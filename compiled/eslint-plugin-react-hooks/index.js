/**
 *
 * eslint-plugin-react-hooks.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @noformat
 * @nolint
 * @lightSyntaxTransform
 * @preventMunge
 * @oncall react_core
 */

"use strict";

if (process.env.NODE_ENV !== "production") {
  (function () {
    "use strict";
    function _readOnlyError(name) {
      throw new TypeError('"' + name + '" is read-only');
    }
    function _regeneratorRuntime() {
      "use strict";
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime =
        function _regeneratorRuntime() {
          return e;
        };
      var t,
        e = {},
        r = Object.prototype,
        n = r.hasOwnProperty,
        o =
          Object.defineProperty ||
          function (t, e, r) {
            t[e] = r.value;
          },
        i = "function" == typeof Symbol ? Symbol : {},
        a = i.iterator || "@@iterator",
        c = i.asyncIterator || "@@asyncIterator",
        u = i.toStringTag || "@@toStringTag";
      function define(t, e, r) {
        return (
          Object.defineProperty(t, e, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
          }),
          t[e]
        );
      }
      try {
        define({}, "");
      } catch (t) {
        define = function define(t, e, r) {
          return (t[e] = r);
        };
      }
      function wrap(t, e, r, n) {
        var i = e && e.prototype instanceof Generator ? e : Generator,
          a = Object.create(i.prototype),
          c = new Context(n || []);
        return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a;
      }
      function tryCatch(t, e, r) {
        try {
          return { type: "normal", arg: t.call(e, r) };
        } catch (t) {
          return { type: "throw", arg: t };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart",
        l = "suspendedYield",
        f = "executing",
        s = "completed",
        y = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var p = {};
      define(p, a, function () {
        return this;
      });
      var d = Object.getPrototypeOf,
        v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g =
        (GeneratorFunctionPrototype.prototype =
        Generator.prototype =
          Object.create(p));
      function defineIteratorMethods(t) {
        ["next", "throw", "return"].forEach(function (e) {
          define(t, e, function (t) {
            return this._invoke(e, t);
          });
        });
      }
      function AsyncIterator(t, e) {
        function invoke(r, o, i, a) {
          var c = tryCatch(t[r], t, o);
          if ("throw" !== c.type) {
            var u = c.arg,
              h = u.value;
            return h && "object" == _typeof(h) && n.call(h, "__await")
              ? e.resolve(h.__await).then(
                  function (t) {
                    invoke("next", t, i, a);
                  },
                  function (t) {
                    invoke("throw", t, i, a);
                  }
                )
              : e.resolve(h).then(
                  function (t) {
                    (u.value = t), i(u);
                  },
                  function (t) {
                    return invoke("throw", t, i, a);
                  }
                );
          }
          a(c.arg);
        }
        var r;
        o(this, "_invoke", {
          value: function value(t, n) {
            function callInvokeWithMethodAndArg() {
              return new e(function (e, r) {
                invoke(t, n, e, r);
              });
            }
            return (r = r
              ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg)
              : callInvokeWithMethodAndArg());
          }
        });
      }
      function makeInvokeMethod(e, r, n) {
        var o = h;
        return function (i, a) {
          if (o === f) throw Error("Generator is already running");
          if (o === s) {
            if ("throw" === i) throw a;
            return { value: t, done: !0 };
          }
          for (n.method = i, n.arg = a; ; ) {
            var c = n.delegate;
            if (c) {
              var u = maybeInvokeDelegate(c, n);
              if (u) {
                if (u === y) continue;
                return u;
              }
            }
            if ("next" === n.method) n.sent = n._sent = n.arg;
            else if ("throw" === n.method) {
              if (o === h) throw ((o = s), n.arg);
              n.dispatchException(n.arg);
            } else "return" === n.method && n.abrupt("return", n.arg);
            o = f;
            var p = tryCatch(e, r, n);
            if ("normal" === p.type) {
              if (((o = n.done ? s : l), p.arg === y)) continue;
              return { value: p.arg, done: n.done };
            }
            "throw" === p.type &&
              ((o = s), (n.method = "throw"), (n.arg = p.arg));
          }
        };
      }
      function maybeInvokeDelegate(e, r) {
        var n = r.method,
          o = e.iterator[n];
        if (o === t)
          return (
            (r.delegate = null),
            ("throw" === n &&
              e.iterator["return"] &&
              ((r.method = "return"),
              (r.arg = t),
              maybeInvokeDelegate(e, r),
              "throw" === r.method)) ||
              ("return" !== n &&
                ((r.method = "throw"),
                (r.arg = new TypeError(
                  "The iterator does not provide a '" + n + "' method"
                )))),
            y
          );
        var i = tryCatch(o, e.iterator, r.arg);
        if ("throw" === i.type)
          return (r.method = "throw"), (r.arg = i.arg), (r.delegate = null), y;
        var a = i.arg;
        return a
          ? a.done
            ? ((r[e.resultName] = a.value),
              (r.next = e.nextLoc),
              "return" !== r.method && ((r.method = "next"), (r.arg = t)),
              (r.delegate = null),
              y)
            : a
          : ((r.method = "throw"),
            (r.arg = new TypeError("iterator result is not an object")),
            (r.delegate = null),
            y);
      }
      function pushTryEntry(t) {
        var e = { tryLoc: t[0] };
        1 in t && (e.catchLoc = t[1]),
          2 in t && ((e.finallyLoc = t[2]), (e.afterLoc = t[3])),
          this.tryEntries.push(e);
      }
      function resetTryEntry(t) {
        var e = t.completion || {};
        (e.type = "normal"), delete e.arg, (t.completion = e);
      }
      function Context(t) {
        (this.tryEntries = [{ tryLoc: "root" }]),
          t.forEach(pushTryEntry, this),
          this.reset(!0);
      }
      function values(e) {
        if (e || "" === e) {
          var r = e[a];
          if (r) return r.call(e);
          if ("function" == typeof e.next) return e;
          if (!isNaN(e.length)) {
            var o = -1,
              i = function next() {
                for (; ++o < e.length; )
                  if (n.call(e, o))
                    return (next.value = e[o]), (next.done = !1), next;
                return (next.value = t), (next.done = !0), next;
              };
            return (i.next = i);
          }
        }
        throw new TypeError(_typeof(e) + " is not iterable");
      }
      return (
        (GeneratorFunction.prototype = GeneratorFunctionPrototype),
        o(g, "constructor", {
          value: GeneratorFunctionPrototype,
          configurable: !0
        }),
        o(GeneratorFunctionPrototype, "constructor", {
          value: GeneratorFunction,
          configurable: !0
        }),
        (GeneratorFunction.displayName = define(
          GeneratorFunctionPrototype,
          u,
          "GeneratorFunction"
        )),
        (e.isGeneratorFunction = function (t) {
          var e = "function" == typeof t && t.constructor;
          return (
            !!e &&
            (e === GeneratorFunction ||
              "GeneratorFunction" === (e.displayName || e.name))
          );
        }),
        (e.mark = function (t) {
          return (
            Object.setPrototypeOf
              ? Object.setPrototypeOf(t, GeneratorFunctionPrototype)
              : ((t.__proto__ = GeneratorFunctionPrototype),
                define(t, u, "GeneratorFunction")),
            (t.prototype = Object.create(g)),
            t
          );
        }),
        (e.awrap = function (t) {
          return { __await: t };
        }),
        defineIteratorMethods(AsyncIterator.prototype),
        define(AsyncIterator.prototype, c, function () {
          return this;
        }),
        (e.AsyncIterator = AsyncIterator),
        (e.async = function (t, r, n, o, i) {
          void 0 === i && (i = Promise);
          var a = new AsyncIterator(wrap(t, r, n, o), i);
          return e.isGeneratorFunction(r)
            ? a
            : a.next().then(function (t) {
                return t.done ? t.value : a.next();
              });
        }),
        defineIteratorMethods(g),
        define(g, u, "Generator"),
        define(g, a, function () {
          return this;
        }),
        define(g, "toString", function () {
          return "[object Generator]";
        }),
        (e.keys = function (t) {
          var e = Object(t),
            r = [];
          for (var n in e) r.push(n);
          return (
            r.reverse(),
            function next() {
              for (; r.length; ) {
                var t = r.pop();
                if (t in e) return (next.value = t), (next.done = !1), next;
              }
              return (next.done = !0), next;
            }
          );
        }),
        (e.values = values),
        (Context.prototype = {
          constructor: Context,
          reset: function reset(e) {
            if (
              ((this.prev = 0),
              (this.next = 0),
              (this.sent = this._sent = t),
              (this.done = !1),
              (this.delegate = null),
              (this.method = "next"),
              (this.arg = t),
              this.tryEntries.forEach(resetTryEntry),
              !e)
            )
              for (var r in this)
                "t" === r.charAt(0) &&
                  n.call(this, r) &&
                  !isNaN(+r.slice(1)) &&
                  (this[r] = t);
          },
          stop: function stop() {
            this.done = !0;
            var t = this.tryEntries[0].completion;
            if ("throw" === t.type) throw t.arg;
            return this.rval;
          },
          dispatchException: function dispatchException(e) {
            if (this.done) throw e;
            var r = this;
            function handle(n, o) {
              return (
                (a.type = "throw"),
                (a.arg = e),
                (r.next = n),
                o && ((r.method = "next"), (r.arg = t)),
                !!o
              );
            }
            for (var o = this.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o],
                a = i.completion;
              if ("root" === i.tryLoc) return handle("end");
              if (i.tryLoc <= this.prev) {
                var c = n.call(i, "catchLoc"),
                  u = n.call(i, "finallyLoc");
                if (c && u) {
                  if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
                  if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
                } else if (c) {
                  if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
                } else {
                  if (!u) throw Error("try statement without catch or finally");
                  if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
                }
              }
            }
          },
          abrupt: function abrupt(t, e) {
            for (var r = this.tryEntries.length - 1; r >= 0; --r) {
              var o = this.tryEntries[r];
              if (
                o.tryLoc <= this.prev &&
                n.call(o, "finallyLoc") &&
                this.prev < o.finallyLoc
              ) {
                var i = o;
                break;
              }
            }
            i &&
              ("break" === t || "continue" === t) &&
              i.tryLoc <= e &&
              e <= i.finallyLoc &&
              (i = null);
            var a = i ? i.completion : {};
            return (
              (a.type = t),
              (a.arg = e),
              i
                ? ((this.method = "next"), (this.next = i.finallyLoc), y)
                : this.complete(a)
            );
          },
          complete: function complete(t, e) {
            if ("throw" === t.type) throw t.arg;
            return (
              "break" === t.type || "continue" === t.type
                ? (this.next = t.arg)
                : "return" === t.type
                  ? ((this.rval = this.arg = t.arg),
                    (this.method = "return"),
                    (this.next = "end"))
                  : "normal" === t.type && e && (this.next = e),
              y
            );
          },
          finish: function finish(t) {
            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
              var r = this.tryEntries[e];
              if (r.finallyLoc === t)
                return (
                  this.complete(r.completion, r.afterLoc), resetTryEntry(r), y
                );
            }
          },
          catch: function _catch(t) {
            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
              var r = this.tryEntries[e];
              if (r.tryLoc === t) {
                var n = r.completion;
                if ("throw" === n.type) {
                  var o = n.arg;
                  resetTryEntry(r);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function delegateYield(e, r, n) {
            return (
              (this.delegate = {
                iterator: values(e),
                resultName: r,
                nextLoc: n
              }),
              "next" === this.method && (this.arg = t),
              y
            );
          }
        }),
        e
      );
    }
    var _marked = /*#__PURE__*/ _regeneratorRuntime().mark(
        eachInstructionLValue
      ),
      _marked2 = /*#__PURE__*/ _regeneratorRuntime().mark(
        eachInstructionValueLValue
      ),
      _marked3 = /*#__PURE__*/ _regeneratorRuntime().mark(
        eachInstructionOperand
      ),
      _marked4 = /*#__PURE__*/ _regeneratorRuntime().mark(
        eachInstructionValueOperand
      ),
      _marked5 = /*#__PURE__*/ _regeneratorRuntime().mark(eachCallArgument),
      _marked6 = /*#__PURE__*/ _regeneratorRuntime().mark(eachPatternOperand),
      _marked7 = /*#__PURE__*/ _regeneratorRuntime().mark(
        eachTerminalSuccessor
      ),
      _marked8 = /*#__PURE__*/ _regeneratorRuntime().mark(eachTerminalOperand),
      _marked9 = /*#__PURE__*/ _regeneratorRuntime().mark(
        eachReactiveValueOperand
      ),
      _marked10 = /*#__PURE__*/ _regeneratorRuntime().mark(generate),
      _marked11 = /*#__PURE__*/ _regeneratorRuntime().mark(
        generateInstructionTypes
      ),
      _marked12 = /*#__PURE__*/ _regeneratorRuntime().mark(eachReachablePlace);
    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get.bind();
      } else {
        _get = function _get(target, property, receiver) {
          var base = _superPropBase(target, property);
          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }
          return desc.value;
        };
      }
      return _get.apply(this, arguments);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }
      return object;
    }
    function _callSuper(t, o, e) {
      return (
        (o = _getPrototypeOf(o)),
        _possibleConstructorReturn(
          t,
          _isNativeReflectConstruct()
            ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor)
            : o.apply(t, e)
        )
      );
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError(
          "Derived constructors may only return object or undefined"
        );
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      }
      return self;
    }
    function _inherits2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError(
          "Super expression must either be null or a function"
        );
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: { value: subClass, writable: true, configurable: true }
      });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;
      _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") {
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);
          _cache.set(Class, Wrapper);
        }
        function Wrapper() {
          return _construct(
            Class,
            arguments,
            _getPrototypeOf(this).constructor
          );
        }
        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(t, e, r) {
      if (_isNativeReflectConstruct())
        return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(
          Reflect.construct(Boolean, [], function () {})
        );
      } catch (t) {}
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
      })();
    }
    function _isNativeFunction(fn) {
      try {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      } catch (e) {
        return typeof fn === "function";
      }
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
          };
      return _setPrototypeOf(o, p);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf
        ? Object.getPrototypeOf.bind()
        : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
          };
      return _getPrototypeOf(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(
          target,
          _toPropertyKey(descriptor.key),
          descriptor
        );
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _defineProperty2(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _toConsumableArray(arr) {
      return (
        _arrayWithoutHoles(arr) ||
        _iterableToArray(arr) ||
        _unsupportedIterableToArray(arr) ||
        _nonIterableSpread()
      );
    }
    function _nonIterableSpread() {
      throw new TypeError(
        "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
      );
    }
    function _iterableToArray(iter) {
      if (
        (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null) ||
        iter["@@iterator"] != null
      )
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return (
        (_typeof =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function (o) {
                return typeof o;
              }
            : function (o) {
                return o &&
                  "function" == typeof Symbol &&
                  o.constructor === Symbol &&
                  o !== Symbol.prototype
                  ? "symbol"
                  : typeof o;
              }),
        _typeof(o)
      );
    }
    function _slicedToArray(arr, i) {
      return (
        _arrayWithHoles(arr) ||
        _iterableToArrayLimit(arr, i) ||
        _unsupportedIterableToArray(arr, i) ||
        _nonIterableRest()
      );
    }
    function _nonIterableRest() {
      throw new TypeError(
        "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
      );
    }
    function _iterableToArrayLimit(r, l) {
      var t =
        null == r
          ? null
          : ("undefined" != typeof Symbol && r[Symbol.iterator]) ||
            r["@@iterator"];
      if (null != t) {
        var e,
          n,
          i,
          u,
          a = [],
          f = !0,
          o = !1;
        try {
          if (((i = (t = t.call(r)).next), 0 === l)) {
            if (Object(t) !== t) return;
            f = !1;
          } else
            for (
              ;
              !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l);
              f = !0
            );
        } catch (r) {
          (o = !0), (n = r);
        } finally {
          try {
            if (
              !f &&
              null != t["return"] &&
              ((u = t["return"]()), Object(u) !== u)
            )
              return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it =
        (typeof Symbol !== "undefined" && o[Symbol.iterator]) ||
        o["@@iterator"];
      if (!it) {
        if (
          Array.isArray(o) ||
          (it = _unsupportedIterableToArray(o)) ||
          (allowArrayLike && o && typeof o.length === "number")
        ) {
          if (it) o = it;
          var i = 0;
          var F = function F() {};
          return {
            s: F,
            n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            },
            e: function e(_e2) {
              throw _e2;
            },
            f: F
          };
        }
        throw new TypeError(
          "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
        );
      }
      var normalCompletion = true,
        didErr = false,
        err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e3) {
          didErr = true;
          err = _e3;
        },
        f: function f() {
          try {
            if (!normalCompletion && it["return"] != null) it["return"]();
          } finally {
            if (didErr) throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (
        n === "Arguments" ||
        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
      )
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    var core$1 = require("@babel/core");
    var PluginProposalPrivateMethods = require("@babel/plugin-transform-private-methods");
    require("@babel/parser");
    var zod = require("zod");
    var zodValidationError = require("zod-validation-error");
    var crypto = require("crypto");
    var HermesParser = require("hermes-parser");
    var rule$2 = {
      meta: {
        type: "suggestion",
        docs: {
          description:
            "verifies the list of dependencies for Hooks like useEffect and similar",
          recommended: true,
          url: "https://github.com/facebook/react/issues/14920"
        },
        fixable: "code",
        hasSuggestions: true,
        schema: [
          {
            type: "object",
            additionalProperties: false,
            enableDangerousAutofixThisMayCauseInfiniteLoops: false,
            properties: {
              additionalHooks: { type: "string" },
              enableDangerousAutofixThisMayCauseInfiniteLoops: {
                type: "boolean"
              }
            }
          }
        ]
      },
      create: function create(context) {
        var additionalHooks =
          context.options &&
          context.options[0] &&
          context.options[0].additionalHooks
            ? new RegExp(context.options[0].additionalHooks)
            : undefined;
        var enableDangerousAutofixThisMayCauseInfiniteLoops =
          (context.options &&
            context.options[0] &&
            context.options[0]
              .enableDangerousAutofixThisMayCauseInfiniteLoops) ||
          false;
        var options = {
          additionalHooks: additionalHooks,
          enableDangerousAutofixThisMayCauseInfiniteLoops:
            enableDangerousAutofixThisMayCauseInfiniteLoops
        };
        function reportProblem(problem) {
          if (enableDangerousAutofixThisMayCauseInfiniteLoops) {
            if (
              Array.isArray(problem.suggest) &&
              problem.suggest.length > 0 &&
              problem.suggest[0]
            ) {
              problem.fix = problem.suggest[0].fix;
            }
          }
          context.report(problem);
        }
        var getSourceCode =
          typeof context.getSourceCode === "function"
            ? function () {
                return context.getSourceCode();
              }
            : function () {
                return context.sourceCode;
              };
        var getScope =
          typeof context.getScope === "function"
            ? function () {
                return context.getScope();
              }
            : function (node) {
                return context.sourceCode.getScope(node);
              };
        var scopeManager = getSourceCode().scopeManager;
        var setStateCallSites = new WeakMap();
        var stateVariables = new WeakSet();
        var stableKnownValueCache = new WeakMap();
        var functionWithoutCapturedValueCache = new WeakMap();
        var useEffectEventVariables = new WeakSet();
        function memoizeWithWeakMap(fn, map) {
          return function (arg) {
            if (map.has(arg)) {
              return map.get(arg);
            }
            var result = fn(arg);
            map.set(arg, result);
            return result;
          };
        }
        function visitFunctionWithDependencies(
          node,
          declaredDependenciesNode,
          reactiveHook,
          reactiveHookName,
          isEffect
        ) {
          if (isEffect && node.async) {
            reportProblem({
              node: node,
              message:
                "Effect callbacks are synchronous to prevent race conditions. " +
                "Put the async function inside:\n\n" +
                "useEffect(() => {\n" +
                "  async function fetchData() {\n" +
                "    // You can await here\n" +
                "    const response = await MyAPI.getData(someId);\n" +
                "    // ...\n" +
                "  }\n" +
                "  fetchData();\n" +
                "}, [someId]); // Or [] if effect doesn't need props or state\n\n" +
                "Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching"
            });
          }
          var scope = scopeManager.acquire(node);
          if (!scope) {
            throw new Error(
              "Unable to acquire scope for the current node. This is a bug in eslint-plugin-react-hooks, please file an issue."
            );
          }
          var pureScopes = new Set();
          var componentScope = null;
          {
            var currentScope = scope.upper;
            while (currentScope) {
              pureScopes.add(currentScope);
              if (currentScope.type === "function") {
                break;
              }
              currentScope = currentScope.upper;
            }
            if (!currentScope) {
              return;
            }
            componentScope = currentScope;
          }
          var isArray = Array.isArray;
          function isStableKnownHookValue(resolved) {
            if (!isArray(resolved.defs)) {
              return false;
            }
            var def = resolved.defs[0];
            if (def == null) {
              return false;
            }
            var defNode = def.node;
            if (defNode.type !== "VariableDeclarator") {
              return false;
            }
            var init = defNode.init;
            if (init == null) {
              return false;
            }
            while (
              init.type === "TSAsExpression" ||
              init.type === "AsExpression"
            ) {
              init = init.expression;
            }
            var declaration = defNode.parent;
            if (declaration == null && componentScope != null) {
              fastFindReferenceWithParent(componentScope.block, def.node.id);
              declaration = def.node.parent;
              if (declaration == null) {
                return false;
              }
            }
            if (
              declaration != null &&
              "kind" in declaration &&
              declaration.kind === "const" &&
              init.type === "Literal" &&
              (typeof init.value === "string" ||
                typeof init.value === "number" ||
                init.value === null)
            ) {
              return true;
            }
            if (init.type !== "CallExpression") {
              return false;
            }
            var callee = init.callee;
            if (
              callee.type === "MemberExpression" &&
              "name" in callee.object &&
              callee.object.name === "React" &&
              callee.property != null &&
              !callee.computed
            ) {
              callee = callee.property;
            }
            if (callee.type !== "Identifier") {
              return false;
            }
            var definitionNode = def.node;
            var id = definitionNode.id;
            var _callee = callee,
              name = _callee.name;
            if (name === "useRef" && id.type === "Identifier") {
              return true;
            } else if (
              isUseEffectEventIdentifier$1(callee) &&
              id.type === "Identifier"
            ) {
              var _iterator = _createForOfIteratorHelper(resolved.references),
                _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var ref = _step.value;
                  if (ref !== id) {
                    useEffectEventVariables.add(ref.identifier);
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              return true;
            } else if (
              name === "useState" ||
              name === "useReducer" ||
              name === "useActionState"
            ) {
              if (
                id.type === "ArrayPattern" &&
                id.elements.length === 2 &&
                isArray(resolved.identifiers)
              ) {
                if (id.elements[1] === resolved.identifiers[0]) {
                  if (name === "useState") {
                    var references = resolved.references;
                    var writeCount = 0;
                    var _iterator2 = _createForOfIteratorHelper(references),
                      _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                        var reference = _step2.value;
                        if (reference.isWrite()) {
                          writeCount++;
                        }
                        if (writeCount > 1) {
                          return false;
                        }
                        setStateCallSites.set(
                          reference.identifier,
                          id.elements[0]
                        );
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                  }
                  return true;
                } else if (id.elements[0] === resolved.identifiers[0]) {
                  if (name === "useState") {
                    var _references = resolved.references;
                    var _iterator3 = _createForOfIteratorHelper(_references),
                      _step3;
                    try {
                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                        var _reference = _step3.value;
                        stateVariables.add(_reference.identifier);
                      }
                    } catch (err) {
                      _iterator3.e(err);
                    } finally {
                      _iterator3.f();
                    }
                  }
                  return false;
                }
              }
            } else if (name === "useTransition") {
              if (
                id.type === "ArrayPattern" &&
                id.elements.length === 2 &&
                Array.isArray(resolved.identifiers)
              ) {
                if (id.elements[1] === resolved.identifiers[0]) {
                  return true;
                }
              }
            }
            return false;
          }
          function isFunctionWithoutCapturedValues(resolved) {
            if (!isArray(resolved.defs)) {
              return false;
            }
            var def = resolved.defs[0];
            if (def == null) {
              return false;
            }
            if (def.node == null || def.node.id == null) {
              return false;
            }
            var fnNode = def.node;
            var childScopes =
              (componentScope === null || componentScope === void 0
                ? void 0
                : componentScope.childScopes) || [];
            var fnScope = null;
            var _iterator4 = _createForOfIteratorHelper(childScopes),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                var childScope = _step4.value;
                var childScopeBlock = childScope.block;
                if (
                  (fnNode.type === "FunctionDeclaration" &&
                    childScopeBlock === fnNode) ||
                  (fnNode.type === "VariableDeclarator" &&
                    childScopeBlock.parent === fnNode)
                ) {
                  fnScope = childScope;
                  break;
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            if (fnScope == null) {
              return false;
            }
            var _iterator5 = _createForOfIteratorHelper(fnScope.through),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                var ref = _step5.value;
                if (ref.resolved == null) {
                  continue;
                }
                if (
                  pureScopes.has(ref.resolved.scope) &&
                  !memoizedIsStableKnownHookValue(ref.resolved)
                ) {
                  return false;
                }
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
            return true;
          }
          var memoizedIsStableKnownHookValue = memoizeWithWeakMap(
            isStableKnownHookValue,
            stableKnownValueCache
          );
          var memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(
            isFunctionWithoutCapturedValues,
            functionWithoutCapturedValueCache
          );
          var currentRefsInEffectCleanup = new Map();
          function isInsideEffectCleanup(reference) {
            var curScope = reference.from;
            var isInReturnedFunction = false;
            while (curScope != null && curScope.block !== node) {
              if (curScope.type === "function") {
                isInReturnedFunction =
                  curScope.block.parent != null &&
                  curScope.block.parent.type === "ReturnStatement";
              }
              curScope = curScope.upper;
            }
            return isInReturnedFunction;
          }
          var dependencies = new Map();
          var optionalChains = new Map();
          gatherDependenciesRecursively(scope);
          function gatherDependenciesRecursively(currentScope) {
            var _a, _b, _c, _d, _e;
            var _iterator6 = _createForOfIteratorHelper(
                currentScope.references
              ),
              _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                var reference = _step6.value;
                if (!reference.resolved) {
                  continue;
                }
                if (!pureScopes.has(reference.resolved.scope)) {
                  continue;
                }
                var referenceNode = fastFindReferenceWithParent(
                  node,
                  reference.identifier
                );
                if (referenceNode == null) {
                  continue;
                }
                var dependencyNode = getDependency(referenceNode);
                var dependency = analyzePropertyChain(
                  dependencyNode,
                  optionalChains
                );
                if (
                  isEffect &&
                  dependencyNode.type === "Identifier" &&
                  (((_a = dependencyNode.parent) === null || _a === void 0
                    ? void 0
                    : _a.type) === "MemberExpression" ||
                    ((_b = dependencyNode.parent) === null || _b === void 0
                      ? void 0
                      : _b.type) === "OptionalMemberExpression") &&
                  !dependencyNode.parent.computed &&
                  dependencyNode.parent.property.type === "Identifier" &&
                  dependencyNode.parent.property.name === "current" &&
                  isInsideEffectCleanup(reference)
                ) {
                  currentRefsInEffectCleanup.set(dependency, {
                    reference: reference,
                    dependencyNode: dependencyNode
                  });
                }
                if (
                  ((_c = dependencyNode.parent) === null || _c === void 0
                    ? void 0
                    : _c.type) === "TSTypeQuery" ||
                  ((_d = dependencyNode.parent) === null || _d === void 0
                    ? void 0
                    : _d.type) === "TSTypeReference"
                ) {
                  continue;
                }
                var def = reference.resolved.defs[0];
                if (def == null) {
                  continue;
                }
                if (def.node != null && def.node.init === node.parent) {
                  continue;
                }
                if (def.type === "TypeParameter") {
                  continue;
                }
                if (!dependencies.has(dependency)) {
                  var resolved = reference.resolved;
                  var isStable =
                    memoizedIsStableKnownHookValue(resolved) ||
                    memoizedIsFunctionWithoutCapturedValues(resolved);
                  dependencies.set(dependency, {
                    isStable: isStable,
                    references: [reference]
                  });
                } else {
                  (_e = dependencies.get(dependency)) === null || _e === void 0
                    ? void 0
                    : _e.references.push(reference);
                }
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
            var _iterator7 = _createForOfIteratorHelper(
                currentScope.childScopes
              ),
              _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                var childScope = _step7.value;
                gatherDependenciesRecursively(childScope);
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
          }
          currentRefsInEffectCleanup.forEach(function (_ref, dependency) {
            var reference = _ref.reference,
              dependencyNode = _ref.dependencyNode;
            var _a, _b;
            var references =
              ((_a = reference.resolved) === null || _a === void 0
                ? void 0
                : _a.references) || [];
            var foundCurrentAssignment = false;
            var _iterator8 = _createForOfIteratorHelper(references),
              _step8;
            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                var ref = _step8.value;
                var _identifier2 = ref.identifier;
                var parent = _identifier2.parent;
                if (
                  parent != null &&
                  parent.type === "MemberExpression" &&
                  !parent.computed &&
                  parent.property.type === "Identifier" &&
                  parent.property.name === "current" &&
                  ((_b = parent.parent) === null || _b === void 0
                    ? void 0
                    : _b.type) === "AssignmentExpression" &&
                  parent.parent.left === parent
                ) {
                  foundCurrentAssignment = true;
                  break;
                }
              }
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }
            if (foundCurrentAssignment) {
              return;
            }
            reportProblem({
              node: dependencyNode.parent.property,
              message:
                "The ref value '".concat(
                  dependency,
                  ".current' will likely have "
                ) +
                "changed by the time this effect cleanup function runs. If " +
                "this ref points to a node rendered by React, copy " +
                "'".concat(
                  dependency,
                  ".current' to a variable inside the effect, and "
                ) +
                "use that variable in the cleanup function."
            });
          });
          var staleAssignments = new Set();
          function reportStaleAssignment(writeExpr, key) {
            if (staleAssignments.has(key)) {
              return;
            }
            staleAssignments.add(key);
            reportProblem({
              node: writeExpr,
              message:
                "Assignments to the '".concat(
                  key,
                  "' variable from inside React Hook "
                ) +
                "".concat(
                  getSourceCode().getText(reactiveHook),
                  " will be lost after each "
                ) +
                "render. To preserve the value over time, store it in a useRef " +
                "Hook and keep the mutable value in the '.current' property. " +
                "Otherwise, you can move this variable directly inside " +
                "".concat(getSourceCode().getText(reactiveHook), ".")
            });
          }
          var stableDependencies = new Set();
          dependencies.forEach(function (_ref2, key) {
            var isStable = _ref2.isStable,
              references = _ref2.references;
            if (isStable) {
              stableDependencies.add(key);
            }
            references.forEach(function (reference) {
              if (reference.writeExpr) {
                reportStaleAssignment(reference.writeExpr, key);
              }
            });
          });
          if (staleAssignments.size > 0) {
            return;
          }
          if (!declaredDependenciesNode) {
            var setStateInsideEffectWithoutDeps = null;
            dependencies.forEach(function (_ref3, key) {
              var references = _ref3.references;
              if (setStateInsideEffectWithoutDeps) {
                return;
              }
              references.forEach(function (reference) {
                if (setStateInsideEffectWithoutDeps) {
                  return;
                }
                var id = reference.identifier;
                var isSetState = setStateCallSites.has(id);
                if (!isSetState) {
                  return;
                }
                var fnScope = reference.from;
                while (fnScope != null && fnScope.type !== "function") {
                  fnScope = fnScope.upper;
                }
                var isDirectlyInsideEffect =
                  (fnScope === null || fnScope === void 0
                    ? void 0
                    : fnScope.block) === node;
                if (isDirectlyInsideEffect) {
                  setStateInsideEffectWithoutDeps = key;
                }
              });
            });
            if (setStateInsideEffectWithoutDeps) {
              var _collectRecommendatio = collectRecommendations({
                  dependencies: dependencies,
                  declaredDependencies: [],
                  stableDependencies: stableDependencies,
                  externalDependencies: new Set(),
                  isEffect: true
                }),
                _suggestedDependencies =
                  _collectRecommendatio.suggestedDependencies;
              reportProblem({
                node: reactiveHook,
                message:
                  "React Hook "
                    .concat(reactiveHookName, " contains a call to '")
                    .concat(setStateInsideEffectWithoutDeps, "'. ") +
                  "Without a list of dependencies, this can lead to an infinite chain of updates. " +
                  "To fix this, pass [" +
                  _suggestedDependencies.join(", ") +
                  "] as a second argument to the ".concat(
                    reactiveHookName,
                    " Hook."
                  ),
                suggest: [
                  {
                    desc: "Add dependencies array: [".concat(
                      _suggestedDependencies.join(", "),
                      "]"
                    ),
                    fix: function fix(fixer) {
                      return fixer.insertTextAfter(
                        node,
                        ", [".concat(_suggestedDependencies.join(", "), "]")
                      );
                    }
                  }
                ]
              });
            }
            return;
          }
          var declaredDependencies = [];
          var externalDependencies = new Set();
          var isArrayExpression =
            declaredDependenciesNode.type === "ArrayExpression";
          var isTSAsArrayExpression =
            declaredDependenciesNode.type === "TSAsExpression" &&
            declaredDependenciesNode.expression.type === "ArrayExpression";
          if (!isArrayExpression && !isTSAsArrayExpression) {
            reportProblem({
              node: declaredDependenciesNode,
              message:
                "React Hook ".concat(
                  getSourceCode().getText(reactiveHook),
                  " was passed a "
                ) +
                "dependency list that is not an array literal. This means we " +
                "can't statically verify whether you've passed the correct " +
                "dependencies."
            });
          } else {
            var _arrayExpression = isTSAsArrayExpression
              ? declaredDependenciesNode.expression
              : declaredDependenciesNode;
            _arrayExpression.elements.forEach(
              function (declaredDependencyNode) {
                if (declaredDependencyNode === null) {
                  return;
                }
                if (declaredDependencyNode.type === "SpreadElement") {
                  reportProblem({
                    node: declaredDependencyNode,
                    message:
                      "React Hook ".concat(
                        getSourceCode().getText(reactiveHook),
                        " has a spread "
                      ) +
                      "element in its dependency array. This means we can't " +
                      "statically verify whether you've passed the " +
                      "correct dependencies."
                  });
                  return;
                }
                if (useEffectEventVariables.has(declaredDependencyNode)) {
                  reportProblem({
                    node: declaredDependencyNode,
                    message:
                      "Functions returned from `useEffectEvent` must not be included in the dependency array. " +
                      "Remove `".concat(
                        getSourceCode().getText(declaredDependencyNode),
                        "` from the list."
                      ),
                    suggest: [
                      {
                        desc: "Remove the dependency `".concat(
                          getSourceCode().getText(declaredDependencyNode),
                          "`"
                        ),
                        fix: function fix(fixer) {
                          return fixer.removeRange(
                            declaredDependencyNode.range
                          );
                        }
                      }
                    ]
                  });
                }
                var declaredDependency;
                try {
                  declaredDependency = analyzePropertyChain(
                    declaredDependencyNode,
                    null
                  );
                } catch (error) {
                  if (
                    error instanceof Error &&
                    /Unsupported node type/.test(error.message)
                  ) {
                    if (declaredDependencyNode.type === "Literal") {
                      if (
                        declaredDependencyNode.value &&
                        dependencies.has(declaredDependencyNode.value)
                      ) {
                        reportProblem({
                          node: declaredDependencyNode,
                          message:
                            "The ".concat(
                              declaredDependencyNode.raw,
                              " literal is not a valid dependency "
                            ) +
                            "because it never changes. " +
                            "Did you mean to include ".concat(
                              declaredDependencyNode.value,
                              " in the array instead?"
                            )
                        });
                      } else {
                        reportProblem({
                          node: declaredDependencyNode,
                          message:
                            "The ".concat(
                              declaredDependencyNode.raw,
                              " literal is not a valid dependency "
                            ) +
                            "because it never changes. You can safely remove it."
                        });
                      }
                    } else {
                      reportProblem({
                        node: declaredDependencyNode,
                        message:
                          "React Hook ".concat(
                            getSourceCode().getText(reactiveHook),
                            " has a "
                          ) +
                          "complex expression in the dependency array. " +
                          "Extract it to a separate variable so it can be statically checked."
                      });
                    }
                    return;
                  } else {
                    throw error;
                  }
                }
                var maybeID = declaredDependencyNode;
                while (
                  maybeID.type === "MemberExpression" ||
                  maybeID.type === "OptionalMemberExpression" ||
                  maybeID.type === "ChainExpression"
                ) {
                  maybeID = maybeID.object || maybeID.expression.object;
                }
                var isDeclaredInComponent = !componentScope.through.some(
                  function (ref) {
                    return ref.identifier === maybeID;
                  }
                );
                declaredDependencies.push({
                  key: declaredDependency,
                  node: declaredDependencyNode
                });
                if (!isDeclaredInComponent) {
                  externalDependencies.add(declaredDependency);
                }
              }
            );
          }
          var _collectRecommendatio2 = collectRecommendations({
              dependencies: dependencies,
              declaredDependencies: declaredDependencies,
              stableDependencies: stableDependencies,
              externalDependencies: externalDependencies,
              isEffect: isEffect
            }),
            suggestedDependencies =
              _collectRecommendatio2.suggestedDependencies,
            unnecessaryDependencies =
              _collectRecommendatio2.unnecessaryDependencies,
            missingDependencies = _collectRecommendatio2.missingDependencies,
            duplicateDependencies =
              _collectRecommendatio2.duplicateDependencies;
          var suggestedDeps = suggestedDependencies;
          var problemCount =
            duplicateDependencies.size +
            missingDependencies.size +
            unnecessaryDependencies.size;
          if (problemCount === 0) {
            var constructions = scanForConstructions({
              declaredDependencies: declaredDependencies,
              declaredDependenciesNode: declaredDependenciesNode,
              componentScope: componentScope,
              scope: scope
            });
            constructions.forEach(function (_ref4) {
              var construction = _ref4.construction,
                isUsedOutsideOfHook = _ref4.isUsedOutsideOfHook,
                depType = _ref4.depType;
              var _a;
              var wrapperHook =
                depType === "function" ? "useCallback" : "useMemo";
              var constructionType =
                depType === "function" ? "definition" : "initialization";
              var defaultAdvice = "wrap the "
                .concat(constructionType, " of '")
                .concat(construction.name.name, "' in its own ")
                .concat(wrapperHook, "() Hook.");
              var advice = isUsedOutsideOfHook
                ? "To fix this, ".concat(defaultAdvice)
                : "Move it inside the "
                    .concat(reactiveHookName, " callback. Alternatively, ")
                    .concat(defaultAdvice);
              var causation =
                depType === "conditional" || depType === "logical expression"
                  ? "could make"
                  : "makes";
              var message =
                "The '"
                  .concat(construction.name.name, "' ")
                  .concat(depType, " ")
                  .concat(causation, " the dependencies of ") +
                ""
                  .concat(reactiveHookName, " Hook (at line ")
                  .concat(
                    (_a = declaredDependenciesNode.loc) === null ||
                      _a === void 0
                      ? void 0
                      : _a.start.line,
                    ") "
                  ) +
                "change on every render. ".concat(advice);
              var suggest;
              if (
                isUsedOutsideOfHook &&
                construction.type === "Variable" &&
                depType === "function"
              ) {
                suggest = [
                  {
                    desc: "Wrap the "
                      .concat(constructionType, " of '")
                      .concat(construction.name.name, "' in its own ")
                      .concat(wrapperHook, "() Hook."),
                    fix: function fix(fixer) {
                      var _ref5 =
                          wrapperHook === "useMemo"
                            ? ["useMemo(() => { return ", "; })"]
                            : ["useCallback(", ")"],
                        _ref6 = _slicedToArray(_ref5, 2),
                        before = _ref6[0],
                        after = _ref6[1];
                      return [
                        fixer.insertTextBefore(construction.node.init, before),
                        fixer.insertTextAfter(construction.node.init, after)
                      ];
                    }
                  }
                ];
              }
              reportProblem({
                node: construction.node,
                message: message,
                suggest: suggest
              });
            });
            return;
          }
          if (!isEffect && missingDependencies.size > 0) {
            suggestedDeps = collectRecommendations({
              dependencies: dependencies,
              declaredDependencies: [],
              stableDependencies: stableDependencies,
              externalDependencies: externalDependencies,
              isEffect: isEffect
            }).suggestedDependencies;
          }
          function areDeclaredDepsAlphabetized() {
            if (declaredDependencies.length === 0) {
              return true;
            }
            var declaredDepKeys = declaredDependencies.map(function (dep) {
              return dep.key;
            });
            var sortedDeclaredDepKeys = declaredDepKeys.slice().sort();
            return (
              declaredDepKeys.join(",") === sortedDeclaredDepKeys.join(",")
            );
          }
          if (areDeclaredDepsAlphabetized()) {
            suggestedDeps.sort();
          }
          function formatDependency(path) {
            var members = path.split(".");
            var finalPath = "";
            for (var i = 0; i < members.length; i++) {
              if (i !== 0) {
                var pathSoFar = members.slice(0, i + 1).join(".");
                var _isOptional = optionalChains.get(pathSoFar) === true;
                finalPath += _isOptional ? "?." : ".";
              }
              finalPath += members[i];
            }
            return finalPath;
          }
          function getWarningMessage(deps, singlePrefix, label, fixVerb) {
            if (deps.size === 0) {
              return null;
            }
            return (
              (deps.size > 1 ? "" : singlePrefix + " ") +
              label +
              " " +
              (deps.size > 1 ? "dependencies" : "dependency") +
              ": " +
              joinEnglish(
                Array.from(deps)
                  .sort()
                  .map(function (name) {
                    return "'" + formatDependency(name) + "'";
                  })
              ) +
              ". Either "
                .concat(fixVerb, " ")
                .concat(
                  deps.size > 1 ? "them" : "it",
                  " or remove the dependency array."
                )
            );
          }
          var extraWarning = "";
          if (unnecessaryDependencies.size > 0) {
            var badRef = null;
            Array.from(unnecessaryDependencies.keys()).forEach(function (key) {
              if (badRef !== null) {
                return;
              }
              if (key.endsWith(".current")) {
                badRef = key;
              }
            });
            if (badRef !== null) {
              extraWarning =
                " Mutable values like '".concat(
                  badRef,
                  "' aren't valid dependencies "
                ) + "because mutating them doesn't re-render the component.";
            } else if (externalDependencies.size > 0) {
              var dep = Array.from(externalDependencies)[0];
              if (!scope.set.has(dep)) {
                extraWarning =
                  " Outer scope values like '".concat(
                    dep,
                    "' aren't valid dependencies "
                  ) + "because mutating them doesn't re-render the component.";
              }
            }
          }
          if (!extraWarning && missingDependencies.has("props")) {
            var propDep = dependencies.get("props");
            if (propDep == null) {
              return;
            }
            var refs = propDep.references;
            if (!Array.isArray(refs)) {
              return;
            }
            var isPropsOnlyUsedInMembers = true;
            var _iterator9 = _createForOfIteratorHelper(refs),
              _step9;
            try {
              for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
                var ref = _step9.value;
                var id = fastFindReferenceWithParent(
                  componentScope.block,
                  ref.identifier
                );
                if (!id) {
                  isPropsOnlyUsedInMembers = false;
                  break;
                }
                var parent = id.parent;
                if (parent == null) {
                  isPropsOnlyUsedInMembers = false;
                  break;
                }
                if (
                  parent.type !== "MemberExpression" &&
                  parent.type !== "OptionalMemberExpression"
                ) {
                  isPropsOnlyUsedInMembers = false;
                  break;
                }
              }
            } catch (err) {
              _iterator9.e(err);
            } finally {
              _iterator9.f();
            }
            if (isPropsOnlyUsedInMembers) {
              extraWarning =
                " However, 'props' will change when *any* prop changes, so the " +
                "preferred fix is to destructure the 'props' object outside of " +
                "the ".concat(
                  reactiveHookName,
                  " call and refer to those specific props "
                ) +
                "inside ".concat(getSourceCode().getText(reactiveHook), ".");
            }
          }
          if (!extraWarning && missingDependencies.size > 0) {
            var missingCallbackDep = null;
            missingDependencies.forEach(function (missingDep) {
              var _a;
              if (missingCallbackDep) {
                return;
              }
              var topScopeRef = componentScope.set.get(missingDep);
              var usedDep = dependencies.get(missingDep);
              if (
                !(usedDep === null || usedDep === void 0
                  ? void 0
                  : usedDep.references) ||
                ((_a =
                  usedDep === null || usedDep === void 0
                    ? void 0
                    : usedDep.references[0]) === null || _a === void 0
                  ? void 0
                  : _a.resolved) !== topScopeRef
              ) {
                return;
              }
              var def =
                topScopeRef === null || topScopeRef === void 0
                  ? void 0
                  : topScopeRef.defs[0];
              if (def == null || def.name == null || def.type !== "Parameter") {
                return;
              }
              var isFunctionCall = false;
              var id;
              var _iterator10 = _createForOfIteratorHelper(usedDep.references),
                _step10;
              try {
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
                  var reference = _step10.value;
                  id = reference.identifier;
                  if (
                    id != null &&
                    id.parent != null &&
                    (id.parent.type === "CallExpression" ||
                      id.parent.type === "OptionalCallExpression") &&
                    id.parent.callee === id
                  ) {
                    isFunctionCall = true;
                    break;
                  }
                }
              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }
              if (!isFunctionCall) {
                return;
              }
              missingCallbackDep = missingDep;
            });
            if (missingCallbackDep !== null) {
              extraWarning =
                " If '".concat(missingCallbackDep, "' changes too often, ") +
                "find the parent component that defines it " +
                "and wrap that definition in useCallback.";
            }
          }
          if (!extraWarning && missingDependencies.size > 0) {
            var setStateRecommendation = null;
            var _iterator11 = _createForOfIteratorHelper(missingDependencies),
              _step11;
            try {
              for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
                var missingDep = _step11.value;
                if (setStateRecommendation !== null) {
                  break;
                }
                var usedDep = dependencies.get(missingDep);
                var references = usedDep.references;
                var _id2 = void 0;
                var maybeCall = void 0;
                var _iterator12 = _createForOfIteratorHelper(references),
                  _step12;
                try {
                  for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
                    var reference = _step12.value;
                    _id2 = reference.identifier;
                    maybeCall = _id2.parent;
                    while (
                      maybeCall != null &&
                      maybeCall !== componentScope.block
                    ) {
                      if (maybeCall.type === "CallExpression") {
                        var correspondingStateVariable = setStateCallSites.get(
                          maybeCall.callee
                        );
                        if (correspondingStateVariable != null) {
                          if (
                            "name" in correspondingStateVariable &&
                            correspondingStateVariable.name === missingDep
                          ) {
                            setStateRecommendation = {
                              missingDep: missingDep,
                              setter:
                                "name" in maybeCall.callee
                                  ? maybeCall.callee.name
                                  : "",
                              form: "updater"
                            };
                          } else if (stateVariables.has(_id2)) {
                            setStateRecommendation = {
                              missingDep: missingDep,
                              setter:
                                "name" in maybeCall.callee
                                  ? maybeCall.callee.name
                                  : "",
                              form: "reducer"
                            };
                          } else {
                            var resolved = reference.resolved;
                            if (resolved != null) {
                              var def = resolved.defs[0];
                              if (def != null && def.type === "Parameter") {
                                setStateRecommendation = {
                                  missingDep: missingDep,
                                  setter:
                                    "name" in maybeCall.callee
                                      ? maybeCall.callee.name
                                      : "",
                                  form: "inlineReducer"
                                };
                              }
                            }
                          }
                          break;
                        }
                      }
                      maybeCall = maybeCall.parent;
                    }
                    if (setStateRecommendation !== null) {
                      break;
                    }
                  }
                } catch (err) {
                  _iterator12.e(err);
                } finally {
                  _iterator12.f();
                }
              }
            } catch (err) {
              _iterator11.e(err);
            } finally {
              _iterator11.f();
            }
            if (setStateRecommendation !== null) {
              switch (setStateRecommendation.form) {
                case "reducer":
                  extraWarning =
                    " You can also replace multiple useState variables with useReducer " +
                    "if '".concat(
                      setStateRecommendation.setter,
                      "' needs the "
                    ) +
                    "current value of '".concat(
                      setStateRecommendation.missingDep,
                      "'."
                    );
                  break;
                case "inlineReducer":
                  extraWarning =
                    " If '".concat(
                      setStateRecommendation.setter,
                      "' needs the "
                    ) +
                    "current value of '".concat(
                      setStateRecommendation.missingDep,
                      "', "
                    ) +
                    "you can also switch to useReducer instead of useState and " +
                    "read '".concat(
                      setStateRecommendation.missingDep,
                      "' in the reducer."
                    );
                  break;
                case "updater":
                  extraWarning =
                    " You can also do a functional update '"
                      .concat(setStateRecommendation.setter, "(")
                      .concat(
                        setStateRecommendation.missingDep.slice(0, 1),
                        " => ...)' if you only need '"
                      )
                      .concat(setStateRecommendation.missingDep, "'") +
                    " in the '".concat(
                      setStateRecommendation.setter,
                      "' call."
                    );
                  break;
                default:
                  throw new Error("Unknown case.");
              }
            }
          }
          reportProblem({
            node: declaredDependenciesNode,
            message:
              "React Hook ".concat(
                getSourceCode().getText(reactiveHook),
                " has "
              ) +
              (getWarningMessage(
                missingDependencies,
                "a",
                "missing",
                "include"
              ) ||
                getWarningMessage(
                  unnecessaryDependencies,
                  "an",
                  "unnecessary",
                  "exclude"
                ) ||
                getWarningMessage(
                  duplicateDependencies,
                  "a",
                  "duplicate",
                  "omit"
                )) +
              extraWarning,
            suggest: [
              {
                desc: "Update the dependencies array to be: [".concat(
                  suggestedDeps.map(formatDependency).join(", "),
                  "]"
                ),
                fix: function fix(fixer) {
                  return fixer.replaceText(
                    declaredDependenciesNode,
                    "[".concat(
                      suggestedDeps.map(formatDependency).join(", "),
                      "]"
                    )
                  );
                }
              }
            ]
          });
        }
        function visitCallExpression(node) {
          var callbackIndex = getReactiveHookCallbackIndex(
            node.callee,
            options
          );
          if (callbackIndex === -1) {
            return;
          }
          var callback = node.arguments[callbackIndex];
          var reactiveHook = node.callee;
          var nodeWithoutNamespace = getNodeWithoutReactNamespace(reactiveHook);
          var reactiveHookName =
            "name" in nodeWithoutNamespace ? nodeWithoutNamespace.name : "";
          var maybeNode = node.arguments[callbackIndex + 1];
          var declaredDependenciesNode =
            maybeNode &&
            !(maybeNode.type === "Identifier" && maybeNode.name === "undefined")
              ? maybeNode
              : undefined;
          var isEffect = /Effect($|[^a-z])/g.test(reactiveHookName);
          if (!callback) {
            reportProblem({
              node: reactiveHook,
              message:
                "React Hook ".concat(
                  reactiveHookName,
                  " requires an effect callback. "
                ) + "Did you forget to pass a callback to the hook?"
            });
            return;
          }
          if (!declaredDependenciesNode && !isEffect) {
            if (
              reactiveHookName === "useMemo" ||
              reactiveHookName === "useCallback"
            ) {
              reportProblem({
                node: reactiveHook,
                message:
                  "React Hook ".concat(
                    reactiveHookName,
                    " does nothing when called with "
                  ) +
                  "only one argument. Did you forget to pass an array of " +
                  "dependencies?"
              });
            }
            return;
          }
          while (
            callback.type === "TSAsExpression" ||
            callback.type === "AsExpression"
          ) {
            callback = callback.expression;
          }
          switch (callback.type) {
            case "FunctionExpression":
            case "ArrowFunctionExpression":
              visitFunctionWithDependencies(
                callback,
                declaredDependenciesNode,
                reactiveHook,
                reactiveHookName,
                isEffect
              );
              return;
            case "Identifier":
              if (!declaredDependenciesNode) {
                return;
              }
              if (
                "elements" in declaredDependenciesNode &&
                declaredDependenciesNode.elements &&
                declaredDependenciesNode.elements.some(function (el) {
                  return (
                    el && el.type === "Identifier" && el.name === callback.name
                  );
                })
              ) {
                return;
              }
              var variable = getScope(callback).set.get(callback.name);
              if (variable == null || variable.defs == null) {
                return;
              }
              var def = variable.defs[0];
              if (!def || !def.node) {
                break;
              }
              if (def.type === "Parameter") {
                reportProblem({
                  node: reactiveHook,
                  message: getUnknownDependenciesMessage(reactiveHookName)
                });
                return;
              }
              if (def.type !== "Variable" && def.type !== "FunctionName") {
                break;
              }
              switch (def.node.type) {
                case "FunctionDeclaration":
                  visitFunctionWithDependencies(
                    def.node,
                    declaredDependenciesNode,
                    reactiveHook,
                    reactiveHookName,
                    isEffect
                  );
                  return;
                case "VariableDeclarator":
                  var init = def.node.init;
                  if (!init) {
                    break;
                  }
                  switch (init.type) {
                    case "ArrowFunctionExpression":
                    case "FunctionExpression":
                      visitFunctionWithDependencies(
                        init,
                        declaredDependenciesNode,
                        reactiveHook,
                        reactiveHookName,
                        isEffect
                      );
                      return;
                  }
                  break;
              }
              break;
            default:
              reportProblem({
                node: reactiveHook,
                message: getUnknownDependenciesMessage(reactiveHookName)
              });
              return;
          }
          reportProblem({
            node: reactiveHook,
            message:
              "React Hook "
                .concat(reactiveHookName, " has a missing dependency: '")
                .concat(callback.name, "'. ") +
              "Either include it or remove the dependency array.",
            suggest: [
              {
                desc: "Update the dependencies array to be: [".concat(
                  callback.name,
                  "]"
                ),
                fix: function fix(fixer) {
                  return fixer.replaceText(
                    declaredDependenciesNode,
                    "[".concat(callback.name, "]")
                  );
                }
              }
            ]
          });
        }
        return { CallExpression: visitCallExpression };
      }
    };
    function collectRecommendations(_ref7) {
      var dependencies = _ref7.dependencies,
        declaredDependencies = _ref7.declaredDependencies,
        stableDependencies = _ref7.stableDependencies,
        externalDependencies = _ref7.externalDependencies,
        isEffect = _ref7.isEffect;
      var depTree = createDepTree();
      function createDepTree() {
        return {
          isUsed: false,
          isSatisfiedRecursively: false,
          isSubtreeUsed: false,
          children: new Map()
        };
      }
      dependencies.forEach(function (_, key) {
        var node = getOrCreateNodeByPath(depTree, key);
        node.isUsed = true;
        markAllParentsByPath(depTree, key, function (parent) {
          parent.isSubtreeUsed = true;
        });
      });
      declaredDependencies.forEach(function (_ref8) {
        var key = _ref8.key;
        var node = getOrCreateNodeByPath(depTree, key);
        node.isSatisfiedRecursively = true;
      });
      stableDependencies.forEach(function (key) {
        var node = getOrCreateNodeByPath(depTree, key);
        node.isSatisfiedRecursively = true;
      });
      function getOrCreateNodeByPath(rootNode, path) {
        var keys = path.split(".");
        var node = rootNode;
        var _iterator13 = _createForOfIteratorHelper(keys),
          _step13;
        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done; ) {
            var _key = _step13.value;
            var child = node.children.get(_key);
            if (!child) {
              child = createDepTree();
              node.children.set(_key, child);
            }
            node = child;
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
        return node;
      }
      function markAllParentsByPath(rootNode, path, fn) {
        var keys = path.split(".");
        var node = rootNode;
        var _iterator14 = _createForOfIteratorHelper(keys),
          _step14;
        try {
          for (_iterator14.s(); !(_step14 = _iterator14.n()).done; ) {
            var _key2 = _step14.value;
            var child = node.children.get(_key2);
            if (!child) {
              return;
            }
            fn(child);
            node = child;
          }
        } catch (err) {
          _iterator14.e(err);
        } finally {
          _iterator14.f();
        }
      }
      var missingDependencies = new Set();
      var satisfyingDependencies = new Set();
      scanTreeRecursively(
        depTree,
        missingDependencies,
        satisfyingDependencies,
        function (key) {
          return key;
        }
      );
      function scanTreeRecursively(
        node,
        missingPaths,
        satisfyingPaths,
        keyToPath
      ) {
        node.children.forEach(function (child, key) {
          var path = keyToPath(key);
          if (child.isSatisfiedRecursively) {
            if (child.isSubtreeUsed) {
              satisfyingPaths.add(path);
            }
            return;
          }
          if (child.isUsed) {
            missingPaths.add(path);
            return;
          }
          scanTreeRecursively(
            child,
            missingPaths,
            satisfyingPaths,
            function (childKey) {
              return path + "." + childKey;
            }
          );
        });
      }
      var suggestedDependencies = [];
      var unnecessaryDependencies = new Set();
      var duplicateDependencies = new Set();
      declaredDependencies.forEach(function (_ref9) {
        var key = _ref9.key;
        if (satisfyingDependencies.has(key)) {
          if (suggestedDependencies.indexOf(key) === -1) {
            suggestedDependencies.push(key);
          } else {
            duplicateDependencies.add(key);
          }
        } else {
          if (
            isEffect &&
            !key.endsWith(".current") &&
            !externalDependencies.has(key)
          ) {
            if (suggestedDependencies.indexOf(key) === -1) {
              suggestedDependencies.push(key);
            }
          } else {
            unnecessaryDependencies.add(key);
          }
        }
      });
      missingDependencies.forEach(function (key) {
        suggestedDependencies.push(key);
      });
      return {
        suggestedDependencies: suggestedDependencies,
        unnecessaryDependencies: unnecessaryDependencies,
        duplicateDependencies: duplicateDependencies,
        missingDependencies: missingDependencies
      };
    }
    function getConstructionExpressionType(node) {
      switch (node.type) {
        case "ObjectExpression":
          return "object";
        case "ArrayExpression":
          return "array";
        case "ArrowFunctionExpression":
        case "FunctionExpression":
          return "function";
        case "ClassExpression":
          return "class";
        case "ConditionalExpression":
          if (
            getConstructionExpressionType(node.consequent) != null ||
            getConstructionExpressionType(node.alternate) != null
          ) {
            return "conditional";
          }
          return null;
        case "LogicalExpression":
          if (
            getConstructionExpressionType(node.left) != null ||
            getConstructionExpressionType(node.right) != null
          ) {
            return "logical expression";
          }
          return null;
        case "JSXFragment":
          return "JSX fragment";
        case "JSXElement":
          return "JSX element";
        case "AssignmentExpression":
          if (getConstructionExpressionType(node.right) != null) {
            return "assignment expression";
          }
          return null;
        case "NewExpression":
          return "object construction";
        case "Literal":
          if (node.value instanceof RegExp) {
            return "regular expression";
          }
          return null;
        case "TypeCastExpression":
        case "AsExpression":
        case "TSAsExpression":
          return getConstructionExpressionType(node.expression);
      }
      return null;
    }
    function scanForConstructions(_ref10) {
      var declaredDependencies = _ref10.declaredDependencies,
        declaredDependenciesNode = _ref10.declaredDependenciesNode,
        componentScope = _ref10.componentScope,
        scope = _ref10.scope;
      var constructions = declaredDependencies
        .map(function (_ref11) {
          var key = _ref11.key;
          var ref = componentScope.variables.find(function (v) {
            return v.name === key;
          });
          if (ref == null) {
            return null;
          }
          var node = ref.defs[0];
          if (node == null) {
            return null;
          }
          if (
            node.type === "Variable" &&
            node.node.type === "VariableDeclarator" &&
            node.node.id.type === "Identifier" &&
            node.node.init != null
          ) {
            var constantExpressionType = getConstructionExpressionType(
              node.node.init
            );
            if (constantExpressionType) {
              return [ref, constantExpressionType];
            }
          }
          if (
            node.type === "FunctionName" &&
            node.node.type === "FunctionDeclaration"
          ) {
            return [ref, "function"];
          }
          if (
            node.type === "ClassName" &&
            node.node.type === "ClassDeclaration"
          ) {
            return [ref, "class"];
          }
          return null;
        })
        .filter(Boolean);
      function isUsedOutsideOfHook(ref) {
        var foundWriteExpr = false;
        var _iterator15 = _createForOfIteratorHelper(ref.references),
          _step15;
        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done; ) {
            var reference = _step15.value;
            if (reference.writeExpr) {
              if (foundWriteExpr) {
                return true;
              } else {
                foundWriteExpr = true;
                continue;
              }
            }
            var currentScope = reference.from;
            while (currentScope !== scope && currentScope != null) {
              currentScope = currentScope.upper;
            }
            if (currentScope !== scope) {
              if (
                !isAncestorNodeOf(
                  declaredDependenciesNode,
                  reference.identifier
                )
              ) {
                return true;
              }
            }
          }
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }
        return false;
      }
      return constructions.map(function (_ref12) {
        var _ref13 = _slicedToArray(_ref12, 2),
          ref = _ref13[0],
          depType = _ref13[1];
        return {
          construction: ref.defs[0],
          depType: depType,
          isUsedOutsideOfHook: isUsedOutsideOfHook(ref)
        };
      });
    }
    function getDependency(node) {
      if (
        node.parent &&
        (node.parent.type === "MemberExpression" ||
          node.parent.type === "OptionalMemberExpression") &&
        node.parent.object === node &&
        "name" in node.parent.property &&
        node.parent.property.name !== "current" &&
        !node.parent.computed &&
        !(
          node.parent.parent != null &&
          (node.parent.parent.type === "CallExpression" ||
            node.parent.parent.type === "OptionalCallExpression") &&
          node.parent.parent.callee === node.parent
        )
      ) {
        return getDependency(node.parent);
      } else if (
        node.type === "MemberExpression" &&
        node.parent &&
        node.parent.type === "AssignmentExpression" &&
        node.parent.left === node
      ) {
        return node.object;
      } else {
        return node;
      }
    }
    function markNode(node, optionalChains, result) {
      if (optionalChains) {
        if ("optional" in node && node.optional) {
          if (!optionalChains.has(result)) {
            optionalChains.set(result, true);
          }
        } else {
          optionalChains.set(result, false);
        }
      }
    }
    function analyzePropertyChain(node, optionalChains) {
      if (node.type === "Identifier" || node.type === "JSXIdentifier") {
        var result = node.name;
        if (optionalChains) {
          optionalChains.set(result, false);
        }
        return result;
      } else if (node.type === "MemberExpression" && !node.computed) {
        var object = analyzePropertyChain(node.object, optionalChains);
        var property = analyzePropertyChain(node.property, null);
        var _result = "".concat(object, ".").concat(property);
        markNode(node, optionalChains, _result);
        return _result;
      } else if (node.type === "OptionalMemberExpression" && !node.computed) {
        var _object = analyzePropertyChain(node.object, optionalChains);
        var _property2 = analyzePropertyChain(node.property, null);
        var _result2 = "".concat(_object, ".").concat(_property2);
        markNode(node, optionalChains, _result2);
        return _result2;
      } else if (
        node.type === "ChainExpression" &&
        (!("computed" in node) || !node.computed)
      ) {
        var expression = node.expression;
        if (expression.type === "CallExpression") {
          throw new Error("Unsupported node type: ".concat(expression.type));
        }
        var _object2 = analyzePropertyChain(expression.object, optionalChains);
        var _property3 = analyzePropertyChain(expression.property, null);
        var _result3 = "".concat(_object2, ".").concat(_property3);
        markNode(expression, optionalChains, _result3);
        return _result3;
      } else {
        throw new Error("Unsupported node type: ".concat(node.type));
      }
    }
    function getNodeWithoutReactNamespace(node) {
      if (
        node.type === "MemberExpression" &&
        node.object.type === "Identifier" &&
        node.object.name === "React" &&
        node.property.type === "Identifier" &&
        !node.computed
      ) {
        return node.property;
      }
      return node;
    }
    function getReactiveHookCallbackIndex(calleeNode, options) {
      var node = getNodeWithoutReactNamespace(calleeNode);
      if (node.type !== "Identifier") {
        return -1;
      }
      switch (node.name) {
        case "useEffect":
        case "useLayoutEffect":
        case "useCallback":
        case "useMemo":
          return 0;
        case "useImperativeHandle":
          return 1;
        default:
          if (node === calleeNode && options && options.additionalHooks) {
            var name;
            try {
              name = analyzePropertyChain(node, null);
            } catch (error) {
              if (
                error instanceof Error &&
                /Unsupported node type/.test(error.message)
              ) {
                return 0;
              } else {
                throw error;
              }
            }
            return options.additionalHooks.test(name) ? 0 : -1;
          } else {
            return -1;
          }
      }
    }
    function fastFindReferenceWithParent(start, target) {
      var queue = [start];
      var item;
      while (queue.length) {
        item = queue.shift();
        if (isSameIdentifier(item, target)) {
          return item;
        }
        if (!isAncestorNodeOf(item, target)) {
          continue;
        }
        for (
          var _i = 0, _Object$entries = Object.entries(item);
          _i < _Object$entries.length;
          _i++
        ) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            _key3 = _Object$entries$_i[0],
            value = _Object$entries$_i[1];
          if (_key3 === "parent") {
            continue;
          }
          if (isNodeLike(value)) {
            value.parent = item;
            queue.push(value);
          } else if (Array.isArray(value)) {
            value.forEach(function (val) {
              if (isNodeLike(val)) {
                val.parent = item;
                queue.push(val);
              }
            });
          }
        }
      }
      return null;
    }
    function joinEnglish(arr) {
      var s = "";
      for (var i = 0; i < arr.length; i++) {
        s += arr[i];
        if (i === 0 && arr.length === 2) {
          s += " and ";
        } else if (i === arr.length - 2 && arr.length > 2) {
          s += ", and ";
        } else if (i < arr.length - 1) {
          s += ", ";
        }
      }
      return s;
    }
    function isNodeLike(val) {
      return (
        _typeof(val) === "object" &&
        val !== null &&
        !Array.isArray(val) &&
        "type" in val &&
        typeof val.type === "string"
      );
    }
    function isSameIdentifier(a, b) {
      return (
        (a.type === "Identifier" || a.type === "JSXIdentifier") &&
        a.type === b.type &&
        a.name === b.name &&
        !!a.range &&
        !!b.range &&
        a.range[0] === b.range[0] &&
        a.range[1] === b.range[1]
      );
    }
    function isAncestorNodeOf(a, b) {
      return (
        !!a.range &&
        !!b.range &&
        a.range[0] <= b.range[0] &&
        a.range[1] >= b.range[1]
      );
    }
    function isUseEffectEventIdentifier$1(node) {
      {
        return node.type === "Identifier" && node.name === "useEffectEvent";
      }
    }
    function getUnknownDependenciesMessage(reactiveHookName) {
      return (
        "React Hook ".concat(
          reactiveHookName,
          " received a function whose dependencies "
        ) + "are unknown. Pass an inline function instead."
      );
    }
    var commonjsGlobal =
      typeof globalThis !== "undefined"
        ? globalThis
        : typeof window !== "undefined"
          ? window
          : typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : {};
    var invariant = function invariant(condition, format, a, b, c, d, e, f) {
      {
        if (format === undefined) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error(
            "Minified exception occurred; use the non-minified dev environment " +
              "for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function () {
              return args[argIndex++];
            })
          );
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1; // we don't care about invariant's own frame
        throw error;
      }
    };
    var invariant_1 = invariant;
    var lib$3 = {};
    var isReactComponent$1 = {};
    var buildMatchMemberExpression$1 = {};
    var matchesPattern$1 = {};
    var generated$3 = {};
    var shallowEqual$1 = {};
    Object.defineProperty(shallowEqual$1, "__esModule", { value: true });
    shallowEqual$1["default"] = shallowEqual;
    function shallowEqual(actual, expected) {
      var keys = Object.keys(expected);
      for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {
        var _key4 = _keys[_i2];
        if (actual[_key4] !== expected[_key4]) {
          return false;
        }
      }
      return true;
    }
    var deprecationWarning$1 = {};
    Object.defineProperty(deprecationWarning$1, "__esModule", { value: true });
    deprecationWarning$1["default"] = deprecationWarning;
    var warnings = new Set();
    function deprecationWarning(oldName, newName) {
      var prefix =
        arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
      if (warnings.has(oldName)) return;
      warnings.add(oldName);
      var _captureShortStackTra = captureShortStackTrace(1, 2),
        internal = _captureShortStackTra.internal,
        trace = _captureShortStackTra.trace;
      if (internal) {
        return;
      }
      console.warn(
        ""
          .concat(prefix, "`")
          .concat(oldName, "` has been deprecated, please migrate to `")
          .concat(newName, "`\n")
          .concat(trace)
      );
    }
    function captureShortStackTrace(skip, length) {
      var stackTraceLimit = Error.stackTraceLimit,
        prepareStackTrace = Error.prepareStackTrace;
      var stackTrace;
      Error.stackTraceLimit = 1 + skip + length;
      Error.prepareStackTrace = function (err, stack) {
        stackTrace = stack;
      };
      Error.stackTraceLimit = stackTraceLimit;
      Error.prepareStackTrace = prepareStackTrace;
      if (!stackTrace) return { internal: false, trace: "" };
      var shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
      return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace
          .map(function (frame) {
            return "    at ".concat(frame);
          })
          .join("\n")
      };
    }
    Object.defineProperty(generated$3, "__esModule", { value: true });
    generated$3.isAccessor = isAccessor;
    generated$3.isAnyTypeAnnotation = isAnyTypeAnnotation;
    generated$3.isArgumentPlaceholder = isArgumentPlaceholder;
    generated$3.isArrayExpression = isArrayExpression;
    generated$3.isArrayPattern = isArrayPattern;
    generated$3.isArrayTypeAnnotation = isArrayTypeAnnotation;
    generated$3.isArrowFunctionExpression = isArrowFunctionExpression;
    generated$3.isAssignmentExpression = isAssignmentExpression;
    generated$3.isAssignmentPattern = isAssignmentPattern;
    generated$3.isAwaitExpression = isAwaitExpression;
    generated$3.isBigIntLiteral = isBigIntLiteral;
    generated$3.isBinary = isBinary;
    generated$3.isBinaryExpression = isBinaryExpression;
    generated$3.isBindExpression = isBindExpression;
    generated$3.isBlock = isBlock;
    generated$3.isBlockParent = isBlockParent;
    generated$3.isBlockStatement = isBlockStatement;
    generated$3.isBooleanLiteral = isBooleanLiteral;
    generated$3.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
    generated$3.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
    generated$3.isBreakStatement = isBreakStatement;
    generated$3.isCallExpression = isCallExpression;
    generated$3.isCatchClause = isCatchClause;
    generated$3.isClass = isClass;
    generated$3.isClassAccessorProperty = isClassAccessorProperty;
    generated$3.isClassBody = isClassBody;
    generated$3.isClassDeclaration = isClassDeclaration;
    generated$3.isClassExpression = isClassExpression;
    generated$3.isClassImplements = isClassImplements;
    generated$3.isClassMethod = isClassMethod;
    generated$3.isClassPrivateMethod = isClassPrivateMethod;
    generated$3.isClassPrivateProperty = isClassPrivateProperty;
    generated$3.isClassProperty = isClassProperty;
    generated$3.isCompletionStatement = isCompletionStatement;
    generated$3.isConditional = isConditional;
    generated$3.isConditionalExpression = isConditionalExpression;
    generated$3.isContinueStatement = isContinueStatement;
    generated$3.isDebuggerStatement = isDebuggerStatement;
    generated$3.isDecimalLiteral = isDecimalLiteral;
    generated$3.isDeclaration = isDeclaration;
    generated$3.isDeclareClass = isDeclareClass;
    generated$3.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
    generated$3.isDeclareExportDeclaration = isDeclareExportDeclaration;
    generated$3.isDeclareFunction = isDeclareFunction;
    generated$3.isDeclareInterface = isDeclareInterface;
    generated$3.isDeclareModule = isDeclareModule;
    generated$3.isDeclareModuleExports = isDeclareModuleExports;
    generated$3.isDeclareOpaqueType = isDeclareOpaqueType;
    generated$3.isDeclareTypeAlias = isDeclareTypeAlias;
    generated$3.isDeclareVariable = isDeclareVariable;
    generated$3.isDeclaredPredicate = isDeclaredPredicate;
    generated$3.isDecorator = isDecorator;
    generated$3.isDirective = isDirective;
    generated$3.isDirectiveLiteral = isDirectiveLiteral;
    generated$3.isDoExpression = isDoExpression;
    generated$3.isDoWhileStatement = isDoWhileStatement;
    generated$3.isEmptyStatement = isEmptyStatement;
    generated$3.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
    generated$3.isEnumBody = isEnumBody;
    generated$3.isEnumBooleanBody = isEnumBooleanBody;
    generated$3.isEnumBooleanMember = isEnumBooleanMember;
    generated$3.isEnumDeclaration = isEnumDeclaration;
    generated$3.isEnumDefaultedMember = isEnumDefaultedMember;
    generated$3.isEnumMember = isEnumMember;
    generated$3.isEnumNumberBody = isEnumNumberBody;
    generated$3.isEnumNumberMember = isEnumNumberMember;
    generated$3.isEnumStringBody = isEnumStringBody;
    generated$3.isEnumStringMember = isEnumStringMember;
    generated$3.isEnumSymbolBody = isEnumSymbolBody;
    generated$3.isExistsTypeAnnotation = isExistsTypeAnnotation;
    generated$3.isExportAllDeclaration = isExportAllDeclaration;
    generated$3.isExportDeclaration = isExportDeclaration;
    generated$3.isExportDefaultDeclaration = isExportDefaultDeclaration;
    generated$3.isExportDefaultSpecifier = isExportDefaultSpecifier;
    generated$3.isExportNamedDeclaration = isExportNamedDeclaration;
    generated$3.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
    generated$3.isExportSpecifier = isExportSpecifier;
    generated$3.isExpression = isExpression;
    generated$3.isExpressionStatement = isExpressionStatement;
    generated$3.isExpressionWrapper = isExpressionWrapper;
    generated$3.isFile = isFile;
    generated$3.isFlow = isFlow;
    generated$3.isFlowBaseAnnotation = isFlowBaseAnnotation;
    generated$3.isFlowDeclaration = isFlowDeclaration;
    generated$3.isFlowPredicate = isFlowPredicate;
    generated$3.isFlowType = isFlowType;
    generated$3.isFor = isFor;
    generated$3.isForInStatement = isForInStatement;
    generated$3.isForOfStatement = isForOfStatement;
    generated$3.isForStatement = isForStatement;
    generated$3.isForXStatement = isForXStatement;
    generated$3.isFunction = isFunction;
    generated$3.isFunctionDeclaration = isFunctionDeclaration;
    generated$3.isFunctionExpression = isFunctionExpression;
    generated$3.isFunctionParent = isFunctionParent;
    generated$3.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
    generated$3.isFunctionTypeParam = isFunctionTypeParam;
    generated$3.isGenericTypeAnnotation = isGenericTypeAnnotation;
    generated$3.isIdentifier = isIdentifier;
    generated$3.isIfStatement = isIfStatement;
    generated$3.isImmutable = isImmutable$2;
    generated$3.isImport = isImport;
    generated$3.isImportAttribute = isImportAttribute;
    generated$3.isImportDeclaration = isImportDeclaration;
    generated$3.isImportDefaultSpecifier = isImportDefaultSpecifier;
    generated$3.isImportExpression = isImportExpression;
    generated$3.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
    generated$3.isImportOrExportDeclaration = isImportOrExportDeclaration;
    generated$3.isImportSpecifier = isImportSpecifier;
    generated$3.isIndexedAccessType = isIndexedAccessType;
    generated$3.isInferredPredicate = isInferredPredicate;
    generated$3.isInterfaceDeclaration = isInterfaceDeclaration;
    generated$3.isInterfaceExtends = isInterfaceExtends;
    generated$3.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
    generated$3.isInterpreterDirective = isInterpreterDirective;
    generated$3.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
    generated$3.isJSX = isJSX;
    generated$3.isJSXAttribute = isJSXAttribute;
    generated$3.isJSXClosingElement = isJSXClosingElement;
    generated$3.isJSXClosingFragment = isJSXClosingFragment;
    generated$3.isJSXElement = isJSXElement;
    generated$3.isJSXEmptyExpression = isJSXEmptyExpression;
    generated$3.isJSXExpressionContainer = isJSXExpressionContainer;
    generated$3.isJSXFragment = isJSXFragment;
    generated$3.isJSXIdentifier = isJSXIdentifier;
    generated$3.isJSXMemberExpression = isJSXMemberExpression;
    generated$3.isJSXNamespacedName = isJSXNamespacedName;
    generated$3.isJSXOpeningElement = isJSXOpeningElement;
    generated$3.isJSXOpeningFragment = isJSXOpeningFragment;
    generated$3.isJSXSpreadAttribute = isJSXSpreadAttribute;
    generated$3.isJSXSpreadChild = isJSXSpreadChild;
    generated$3.isJSXText = isJSXText;
    generated$3.isLVal = isLVal;
    generated$3.isLabeledStatement = isLabeledStatement;
    generated$3.isLiteral = isLiteral;
    generated$3.isLogicalExpression = isLogicalExpression;
    generated$3.isLoop = isLoop;
    generated$3.isMemberExpression = isMemberExpression;
    generated$3.isMetaProperty = isMetaProperty;
    generated$3.isMethod = isMethod;
    generated$3.isMiscellaneous = isMiscellaneous;
    generated$3.isMixedTypeAnnotation = isMixedTypeAnnotation;
    generated$3.isModuleDeclaration = isModuleDeclaration;
    generated$3.isModuleExpression = isModuleExpression;
    generated$3.isModuleSpecifier = isModuleSpecifier;
    generated$3.isNewExpression = isNewExpression;
    generated$3.isNoop = isNoop;
    generated$3.isNullLiteral = isNullLiteral;
    generated$3.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
    generated$3.isNullableTypeAnnotation = isNullableTypeAnnotation;
    generated$3.isNumberLiteral = isNumberLiteral;
    generated$3.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
    generated$3.isNumberTypeAnnotation = isNumberTypeAnnotation;
    generated$3.isNumericLiteral = isNumericLiteral;
    generated$3.isObjectExpression = isObjectExpression;
    generated$3.isObjectMember = isObjectMember;
    generated$3.isObjectMethod = isObjectMethod;
    generated$3.isObjectPattern = isObjectPattern;
    generated$3.isObjectProperty = isObjectProperty;
    generated$3.isObjectTypeAnnotation = isObjectTypeAnnotation;
    generated$3.isObjectTypeCallProperty = isObjectTypeCallProperty;
    generated$3.isObjectTypeIndexer = isObjectTypeIndexer;
    generated$3.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
    generated$3.isObjectTypeProperty = isObjectTypeProperty;
    generated$3.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
    generated$3.isOpaqueType = isOpaqueType;
    generated$3.isOptionalCallExpression = isOptionalCallExpression;
    generated$3.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
    generated$3.isOptionalMemberExpression = isOptionalMemberExpression;
    generated$3.isParenthesizedExpression = isParenthesizedExpression;
    generated$3.isPattern = isPattern;
    generated$3.isPatternLike = isPatternLike;
    generated$3.isPipelineBareFunction = isPipelineBareFunction;
    generated$3.isPipelinePrimaryTopicReference =
      isPipelinePrimaryTopicReference;
    generated$3.isPipelineTopicExpression = isPipelineTopicExpression;
    generated$3.isPlaceholder = isPlaceholder;
    generated$3.isPrivate = isPrivate;
    generated$3.isPrivateName = isPrivateName;
    generated$3.isProgram = isProgram;
    generated$3.isProperty = isProperty;
    generated$3.isPureish = isPureish;
    generated$3.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
    generated$3.isRecordExpression = isRecordExpression;
    generated$3.isRegExpLiteral = isRegExpLiteral;
    generated$3.isRegexLiteral = isRegexLiteral;
    generated$3.isRestElement = isRestElement;
    generated$3.isRestProperty = isRestProperty;
    generated$3.isReturnStatement = isReturnStatement;
    generated$3.isScopable = isScopable;
    generated$3.isSequenceExpression = isSequenceExpression;
    generated$3.isSpreadElement = isSpreadElement;
    generated$3.isSpreadProperty = isSpreadProperty;
    generated$3.isStandardized = isStandardized;
    generated$3.isStatement = isStatement;
    generated$3.isStaticBlock = isStaticBlock;
    generated$3.isStringLiteral = isStringLiteral;
    generated$3.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
    generated$3.isStringTypeAnnotation = isStringTypeAnnotation;
    generated$3.isSuper = isSuper;
    generated$3.isSwitchCase = isSwitchCase;
    generated$3.isSwitchStatement = isSwitchStatement;
    generated$3.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
    generated$3.isTSAnyKeyword = isTSAnyKeyword;
    generated$3.isTSArrayType = isTSArrayType;
    generated$3.isTSAsExpression = isTSAsExpression;
    generated$3.isTSBaseType = isTSBaseType;
    generated$3.isTSBigIntKeyword = isTSBigIntKeyword;
    generated$3.isTSBooleanKeyword = isTSBooleanKeyword;
    generated$3.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
    generated$3.isTSConditionalType = isTSConditionalType;
    generated$3.isTSConstructSignatureDeclaration =
      isTSConstructSignatureDeclaration;
    generated$3.isTSConstructorType = isTSConstructorType;
    generated$3.isTSDeclareFunction = isTSDeclareFunction;
    generated$3.isTSDeclareMethod = isTSDeclareMethod;
    generated$3.isTSEntityName = isTSEntityName;
    generated$3.isTSEnumDeclaration = isTSEnumDeclaration;
    generated$3.isTSEnumMember = isTSEnumMember;
    generated$3.isTSExportAssignment = isTSExportAssignment;
    generated$3.isTSExpressionWithTypeArguments =
      isTSExpressionWithTypeArguments;
    generated$3.isTSExternalModuleReference = isTSExternalModuleReference;
    generated$3.isTSFunctionType = isTSFunctionType;
    generated$3.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
    generated$3.isTSImportType = isTSImportType;
    generated$3.isTSIndexSignature = isTSIndexSignature;
    generated$3.isTSIndexedAccessType = isTSIndexedAccessType;
    generated$3.isTSInferType = isTSInferType;
    generated$3.isTSInstantiationExpression = isTSInstantiationExpression;
    generated$3.isTSInterfaceBody = isTSInterfaceBody;
    generated$3.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
    generated$3.isTSIntersectionType = isTSIntersectionType;
    generated$3.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
    generated$3.isTSLiteralType = isTSLiteralType;
    generated$3.isTSMappedType = isTSMappedType;
    generated$3.isTSMethodSignature = isTSMethodSignature;
    generated$3.isTSModuleBlock = isTSModuleBlock;
    generated$3.isTSModuleDeclaration = isTSModuleDeclaration;
    generated$3.isTSNamedTupleMember = isTSNamedTupleMember;
    generated$3.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
    generated$3.isTSNeverKeyword = isTSNeverKeyword;
    generated$3.isTSNonNullExpression = isTSNonNullExpression;
    generated$3.isTSNullKeyword = isTSNullKeyword;
    generated$3.isTSNumberKeyword = isTSNumberKeyword;
    generated$3.isTSObjectKeyword = isTSObjectKeyword;
    generated$3.isTSOptionalType = isTSOptionalType;
    generated$3.isTSParameterProperty = isTSParameterProperty;
    generated$3.isTSParenthesizedType = isTSParenthesizedType;
    generated$3.isTSPropertySignature = isTSPropertySignature;
    generated$3.isTSQualifiedName = isTSQualifiedName;
    generated$3.isTSRestType = isTSRestType;
    generated$3.isTSSatisfiesExpression = isTSSatisfiesExpression;
    generated$3.isTSStringKeyword = isTSStringKeyword;
    generated$3.isTSSymbolKeyword = isTSSymbolKeyword;
    generated$3.isTSThisType = isTSThisType;
    generated$3.isTSTupleType = isTSTupleType;
    generated$3.isTSType = isTSType;
    generated$3.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
    generated$3.isTSTypeAnnotation = isTSTypeAnnotation;
    generated$3.isTSTypeAssertion = isTSTypeAssertion;
    generated$3.isTSTypeElement = isTSTypeElement;
    generated$3.isTSTypeLiteral = isTSTypeLiteral;
    generated$3.isTSTypeOperator = isTSTypeOperator;
    generated$3.isTSTypeParameter = isTSTypeParameter;
    generated$3.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
    generated$3.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
    generated$3.isTSTypePredicate = isTSTypePredicate;
    generated$3.isTSTypeQuery = isTSTypeQuery;
    generated$3.isTSTypeReference = isTSTypeReference;
    generated$3.isTSUndefinedKeyword = isTSUndefinedKeyword;
    generated$3.isTSUnionType = isTSUnionType;
    generated$3.isTSUnknownKeyword = isTSUnknownKeyword;
    generated$3.isTSVoidKeyword = isTSVoidKeyword;
    generated$3.isTaggedTemplateExpression = isTaggedTemplateExpression;
    generated$3.isTemplateElement = isTemplateElement;
    generated$3.isTemplateLiteral = isTemplateLiteral;
    generated$3.isTerminatorless = isTerminatorless;
    generated$3.isThisExpression = isThisExpression;
    generated$3.isThisTypeAnnotation = isThisTypeAnnotation;
    generated$3.isThrowStatement = isThrowStatement;
    generated$3.isTopicReference = isTopicReference;
    generated$3.isTryStatement = isTryStatement;
    generated$3.isTupleExpression = isTupleExpression;
    generated$3.isTupleTypeAnnotation = isTupleTypeAnnotation;
    generated$3.isTypeAlias = isTypeAlias;
    generated$3.isTypeAnnotation = isTypeAnnotation;
    generated$3.isTypeCastExpression = isTypeCastExpression;
    generated$3.isTypeParameter = isTypeParameter;
    generated$3.isTypeParameterDeclaration = isTypeParameterDeclaration;
    generated$3.isTypeParameterInstantiation = isTypeParameterInstantiation;
    generated$3.isTypeScript = isTypeScript;
    generated$3.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
    generated$3.isUnaryExpression = isUnaryExpression;
    generated$3.isUnaryLike = isUnaryLike;
    generated$3.isUnionTypeAnnotation = isUnionTypeAnnotation;
    generated$3.isUpdateExpression = isUpdateExpression;
    generated$3.isUserWhitespacable = isUserWhitespacable;
    generated$3.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
    generated$3.isVariableDeclaration = isVariableDeclaration;
    generated$3.isVariableDeclarator = isVariableDeclarator;
    generated$3.isVariance = isVariance;
    generated$3.isVoidTypeAnnotation = isVoidTypeAnnotation;
    generated$3.isWhile = isWhile;
    generated$3.isWhileStatement = isWhileStatement;
    generated$3.isWithStatement = isWithStatement;
    generated$3.isYieldExpression = isYieldExpression;
    var _shallowEqual = shallowEqual$1;
    var _deprecationWarning$2 = deprecationWarning$1;
    function isArrayExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ArrayExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isAssignmentExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "AssignmentExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isBinaryExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "BinaryExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isInterpreterDirective(node, opts) {
      if (!node) return false;
      if (node.type !== "InterpreterDirective") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDirective(node, opts) {
      if (!node) return false;
      if (node.type !== "Directive") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDirectiveLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "DirectiveLiteral") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isBlockStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "BlockStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isBreakStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "BreakStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isCallExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "CallExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isCatchClause(node, opts) {
      if (!node) return false;
      if (node.type !== "CatchClause") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isConditionalExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ConditionalExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isContinueStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ContinueStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDebuggerStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "DebuggerStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDoWhileStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "DoWhileStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEmptyStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "EmptyStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isExpressionStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ExpressionStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFile(node, opts) {
      if (!node) return false;
      if (node.type !== "File") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isForInStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ForInStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isForStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ForStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFunctionDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "FunctionDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFunctionExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "FunctionExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isIdentifier(node, opts) {
      if (!node) return false;
      if (node.type !== "Identifier") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isIfStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "IfStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isLabeledStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "LabeledStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isStringLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "StringLiteral") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isNumericLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "NumericLiteral") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isNullLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "NullLiteral") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isBooleanLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "BooleanLiteral") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isRegExpLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "RegExpLiteral") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isLogicalExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "LogicalExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isMemberExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "MemberExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isNewExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "NewExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isProgram(node, opts) {
      if (!node) return false;
      if (node.type !== "Program") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isObjectExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isObjectMethod(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectMethod") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isObjectProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectProperty") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isRestElement(node, opts) {
      if (!node) return false;
      if (node.type !== "RestElement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isReturnStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ReturnStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isSequenceExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "SequenceExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isParenthesizedExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ParenthesizedExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isSwitchCase(node, opts) {
      if (!node) return false;
      if (node.type !== "SwitchCase") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isSwitchStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "SwitchStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isThisExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ThisExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isThrowStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ThrowStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTryStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "TryStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isUnaryExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "UnaryExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isUpdateExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "UpdateExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isVariableDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "VariableDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isVariableDeclarator(node, opts) {
      if (!node) return false;
      if (node.type !== "VariableDeclarator") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isWhileStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "WhileStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isWithStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "WithStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isAssignmentPattern(node, opts) {
      if (!node) return false;
      if (node.type !== "AssignmentPattern") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isArrayPattern(node, opts) {
      if (!node) return false;
      if (node.type !== "ArrayPattern") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isArrowFunctionExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ArrowFunctionExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isClassBody(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassBody") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isClassExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isClassDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isExportAllDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportAllDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isExportDefaultDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportDefaultDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isExportNamedDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportNamedDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isExportSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportSpecifier") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isForOfStatement(node, opts) {
      if (!node) return false;
      if (node.type !== "ForOfStatement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isImportDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isImportDefaultSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportDefaultSpecifier") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isImportNamespaceSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportNamespaceSpecifier") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isImportSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportSpecifier") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isImportExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isMetaProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "MetaProperty") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isClassMethod(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassMethod") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isObjectPattern(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectPattern") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isSpreadElement(node, opts) {
      if (!node) return false;
      if (node.type !== "SpreadElement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isSuper(node, opts) {
      if (!node) return false;
      if (node.type !== "Super") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTaggedTemplateExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TaggedTemplateExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTemplateElement(node, opts) {
      if (!node) return false;
      if (node.type !== "TemplateElement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTemplateLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "TemplateLiteral") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isYieldExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "YieldExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isAwaitExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "AwaitExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isImport(node, opts) {
      if (!node) return false;
      if (node.type !== "Import") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isBigIntLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "BigIntLiteral") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isExportNamespaceSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportNamespaceSpecifier") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isOptionalMemberExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "OptionalMemberExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isOptionalCallExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "OptionalCallExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isClassProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassProperty") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isClassAccessorProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassAccessorProperty") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isClassPrivateProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassPrivateProperty") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isClassPrivateMethod(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassPrivateMethod") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isPrivateName(node, opts) {
      if (!node) return false;
      if (node.type !== "PrivateName") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isStaticBlock(node, opts) {
      if (!node) return false;
      if (node.type !== "StaticBlock") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isAnyTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "AnyTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isArrayTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "ArrayTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isBooleanTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "BooleanTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isBooleanLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "BooleanLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isNullLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "NullLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isClassImplements(node, opts) {
      if (!node) return false;
      if (node.type !== "ClassImplements") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDeclareClass(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareClass") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDeclareFunction(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareFunction") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDeclareInterface(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareInterface") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDeclareModule(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareModule") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDeclareModuleExports(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareModuleExports") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDeclareTypeAlias(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareTypeAlias") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDeclareOpaqueType(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareOpaqueType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDeclareVariable(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareVariable") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDeclareExportDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareExportDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDeclareExportAllDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclareExportAllDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDeclaredPredicate(node, opts) {
      if (!node) return false;
      if (node.type !== "DeclaredPredicate") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isExistsTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "ExistsTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFunctionTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "FunctionTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFunctionTypeParam(node, opts) {
      if (!node) return false;
      if (node.type !== "FunctionTypeParam") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isGenericTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "GenericTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isInferredPredicate(node, opts) {
      if (!node) return false;
      if (node.type !== "InferredPredicate") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isInterfaceExtends(node, opts) {
      if (!node) return false;
      if (node.type !== "InterfaceExtends") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isInterfaceDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "InterfaceDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isInterfaceTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "InterfaceTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isIntersectionTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "IntersectionTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isMixedTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "MixedTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEmptyTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "EmptyTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isNullableTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "NullableTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isNumberLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "NumberLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isNumberTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "NumberTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isObjectTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isObjectTypeInternalSlot(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeInternalSlot") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isObjectTypeCallProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeCallProperty") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isObjectTypeIndexer(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeIndexer") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isObjectTypeProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeProperty") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isObjectTypeSpreadProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "ObjectTypeSpreadProperty") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isOpaqueType(node, opts) {
      if (!node) return false;
      if (node.type !== "OpaqueType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isQualifiedTypeIdentifier(node, opts) {
      if (!node) return false;
      if (node.type !== "QualifiedTypeIdentifier") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isStringLiteralTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "StringLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isStringTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "StringTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isSymbolTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "SymbolTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isThisTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "ThisTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTupleTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "TupleTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTypeofTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeofTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTypeAlias(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeAlias") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTypeCastExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeCastExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTypeParameter(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeParameter") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTypeParameterDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeParameterDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTypeParameterInstantiation(node, opts) {
      if (!node) return false;
      if (node.type !== "TypeParameterInstantiation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isUnionTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "UnionTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isVariance(node, opts) {
      if (!node) return false;
      if (node.type !== "Variance") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isVoidTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "VoidTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEnumDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEnumBooleanBody(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumBooleanBody") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEnumNumberBody(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumNumberBody") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEnumStringBody(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumStringBody") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEnumSymbolBody(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumSymbolBody") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEnumBooleanMember(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumBooleanMember") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEnumNumberMember(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumNumberMember") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEnumStringMember(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumStringMember") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEnumDefaultedMember(node, opts) {
      if (!node) return false;
      if (node.type !== "EnumDefaultedMember") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isIndexedAccessType(node, opts) {
      if (!node) return false;
      if (node.type !== "IndexedAccessType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isOptionalIndexedAccessType(node, opts) {
      if (!node) return false;
      if (node.type !== "OptionalIndexedAccessType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXAttribute(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXAttribute") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXClosingElement(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXClosingElement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXElement(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXElement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXEmptyExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXEmptyExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXExpressionContainer(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXExpressionContainer") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXSpreadChild(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXSpreadChild") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXIdentifier(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXIdentifier") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXMemberExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXMemberExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXNamespacedName(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXNamespacedName") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXOpeningElement(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXOpeningElement") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXSpreadAttribute(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXSpreadAttribute") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXText(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXText") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXFragment(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXFragment") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXOpeningFragment(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXOpeningFragment") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSXClosingFragment(node, opts) {
      if (!node) return false;
      if (node.type !== "JSXClosingFragment") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isNoop(node, opts) {
      if (!node) return false;
      if (node.type !== "Noop") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isPlaceholder(node, opts) {
      if (!node) return false;
      if (node.type !== "Placeholder") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isV8IntrinsicIdentifier(node, opts) {
      if (!node) return false;
      if (node.type !== "V8IntrinsicIdentifier") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isArgumentPlaceholder(node, opts) {
      if (!node) return false;
      if (node.type !== "ArgumentPlaceholder") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isBindExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "BindExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isImportAttribute(node, opts) {
      if (!node) return false;
      if (node.type !== "ImportAttribute") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDecorator(node, opts) {
      if (!node) return false;
      if (node.type !== "Decorator") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDoExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "DoExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isExportDefaultSpecifier(node, opts) {
      if (!node) return false;
      if (node.type !== "ExportDefaultSpecifier") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isRecordExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "RecordExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTupleExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TupleExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDecimalLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "DecimalLiteral") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isModuleExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "ModuleExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTopicReference(node, opts) {
      if (!node) return false;
      if (node.type !== "TopicReference") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isPipelineTopicExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "PipelineTopicExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isPipelineBareFunction(node, opts) {
      if (!node) return false;
      if (node.type !== "PipelineBareFunction") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isPipelinePrimaryTopicReference(node, opts) {
      if (!node) return false;
      if (node.type !== "PipelinePrimaryTopicReference") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSParameterProperty(node, opts) {
      if (!node) return false;
      if (node.type !== "TSParameterProperty") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSDeclareFunction(node, opts) {
      if (!node) return false;
      if (node.type !== "TSDeclareFunction") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSDeclareMethod(node, opts) {
      if (!node) return false;
      if (node.type !== "TSDeclareMethod") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSQualifiedName(node, opts) {
      if (!node) return false;
      if (node.type !== "TSQualifiedName") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSCallSignatureDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSCallSignatureDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSConstructSignatureDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSConstructSignatureDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSPropertySignature(node, opts) {
      if (!node) return false;
      if (node.type !== "TSPropertySignature") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSMethodSignature(node, opts) {
      if (!node) return false;
      if (node.type !== "TSMethodSignature") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSIndexSignature(node, opts) {
      if (!node) return false;
      if (node.type !== "TSIndexSignature") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSAnyKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSAnyKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSBooleanKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSBooleanKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSBigIntKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSBigIntKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSIntrinsicKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSIntrinsicKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSNeverKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNeverKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSNullKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNullKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSNumberKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNumberKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSObjectKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSObjectKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSStringKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSStringKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSSymbolKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSSymbolKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSUndefinedKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSUndefinedKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSUnknownKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSUnknownKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSVoidKeyword(node, opts) {
      if (!node) return false;
      if (node.type !== "TSVoidKeyword") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSThisType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSThisType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSFunctionType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSFunctionType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSConstructorType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSConstructorType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTypeReference(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeReference") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTypePredicate(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypePredicate") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTypeQuery(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeQuery") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTypeLiteral(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeLiteral") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSArrayType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSArrayType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTupleType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTupleType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSOptionalType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSOptionalType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSRestType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSRestType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSNamedTupleMember(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNamedTupleMember") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSUnionType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSUnionType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSIntersectionType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSIntersectionType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSConditionalType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSConditionalType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSInferType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSInferType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSParenthesizedType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSParenthesizedType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTypeOperator(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeOperator") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSIndexedAccessType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSIndexedAccessType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSMappedType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSMappedType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSLiteralType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSLiteralType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSExpressionWithTypeArguments(node, opts) {
      if (!node) return false;
      if (node.type !== "TSExpressionWithTypeArguments") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSInterfaceDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSInterfaceDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSInterfaceBody(node, opts) {
      if (!node) return false;
      if (node.type !== "TSInterfaceBody") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTypeAliasDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeAliasDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSInstantiationExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TSInstantiationExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSAsExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TSAsExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSSatisfiesExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TSSatisfiesExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTypeAssertion(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeAssertion") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSEnumDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSEnumDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSEnumMember(node, opts) {
      if (!node) return false;
      if (node.type !== "TSEnumMember") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSModuleDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSModuleDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSModuleBlock(node, opts) {
      if (!node) return false;
      if (node.type !== "TSModuleBlock") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSImportType(node, opts) {
      if (!node) return false;
      if (node.type !== "TSImportType") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSImportEqualsDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSImportEqualsDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSExternalModuleReference(node, opts) {
      if (!node) return false;
      if (node.type !== "TSExternalModuleReference") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSNonNullExpression(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNonNullExpression") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSExportAssignment(node, opts) {
      if (!node) return false;
      if (node.type !== "TSExportAssignment") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSNamespaceExportDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSNamespaceExportDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTypeAnnotation(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTypeParameterInstantiation(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeParameterInstantiation") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTypeParameterDeclaration(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeParameterDeclaration") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTypeParameter(node, opts) {
      if (!node) return false;
      if (node.type !== "TSTypeParameter") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isStandardized(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "InterpreterDirective":
        case "Directive":
        case "DirectiveLiteral":
        case "BlockStatement":
        case "BreakStatement":
        case "CallExpression":
        case "CatchClause":
        case "ConditionalExpression":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "File":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Identifier":
        case "IfStatement":
        case "LabeledStatement":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "Program":
        case "ObjectExpression":
        case "ObjectMethod":
        case "ObjectProperty":
        case "RestElement":
        case "ReturnStatement":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "SwitchCase":
        case "SwitchStatement":
        case "ThisExpression":
        case "ThrowStatement":
        case "TryStatement":
        case "UnaryExpression":
        case "UpdateExpression":
        case "VariableDeclaration":
        case "VariableDeclarator":
        case "WhileStatement":
        case "WithStatement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ArrowFunctionExpression":
        case "ClassBody":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ExportSpecifier":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ImportExpression":
        case "MetaProperty":
        case "ClassMethod":
        case "ObjectPattern":
        case "SpreadElement":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateElement":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "ExportNamespaceSpecifier":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
        case "StaticBlock":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Identifier":
            case "StringLiteral":
            case "BlockStatement":
            case "ClassBody":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isExpression(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ImportExpression":
        case "MetaProperty":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "TypeCastExpression":
        case "JSXElement":
        case "JSXFragment":
        case "BindExpression":
        case "DoExpression":
        case "RecordExpression":
        case "TupleExpression":
        case "DecimalLiteral":
        case "ModuleExpression":
        case "TopicReference":
        case "PipelineTopicExpression":
        case "PipelineBareFunction":
        case "PipelinePrimaryTopicReference":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Expression":
            case "Identifier":
            case "StringLiteral":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isBinary(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BinaryExpression":
        case "LogicalExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isScopable(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isBlockParent(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isBlock(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BlockStatement":
        case "Program":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isStatement(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Statement":
            case "Declaration":
            case "BlockStatement":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTerminatorless(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "YieldExpression":
        case "AwaitExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isCompletionStatement(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isConditional(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ConditionalExpression":
        case "IfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isLoop(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isWhile(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "DoWhileStatement":
        case "WhileStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isExpressionWrapper(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ExpressionStatement":
        case "ParenthesizedExpression":
        case "TypeCastExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFor(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ForInStatement":
        case "ForStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isForXStatement(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ForInStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFunction(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFunctionParent(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isPureish(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "ArrowFunctionExpression":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isDeclaration(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "FunctionDeclaration":
        case "VariableDeclaration":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
          break;
        case "Placeholder":
          if (node.expectedNode === "Declaration") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isPatternLike(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Identifier":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isLVal(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSParameterProperty":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSEntityName(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Identifier":
        case "TSQualifiedName":
          break;
        case "Placeholder":
          if (node.expectedNode === "Identifier") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isLiteral(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "TemplateLiteral":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isImmutable$2(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "BigIntLiteral":
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXOpeningElement":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isUserWhitespacable(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isMethod(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isObjectMember(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isProperty(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ObjectProperty":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isUnaryLike(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "UnaryExpression":
        case "SpreadElement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isPattern(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
          break;
        case "Placeholder":
          if (node.expectedNode === "Pattern") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isClass(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ClassExpression":
        case "ClassDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isImportOrExportDeclaration(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isExportDeclaration(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isModuleSpecifier(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ExportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isAccessor(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ClassAccessorProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isPrivate(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFlow(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ClassImplements":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "DeclaredPredicate":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "FunctionTypeParam":
        case "GenericTypeAnnotation":
        case "InferredPredicate":
        case "InterfaceExtends":
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
        case "OpaqueType":
        case "QualifiedTypeIdentifier":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "TypeAlias":
        case "TypeAnnotation":
        case "TypeCastExpression":
        case "TypeParameter":
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation":
        case "UnionTypeAnnotation":
        case "Variance":
        case "VoidTypeAnnotation":
        case "EnumDeclaration":
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFlowType(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "GenericTypeAnnotation":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "UnionTypeAnnotation":
        case "VoidTypeAnnotation":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFlowBaseAnnotation(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NumberTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "VoidTypeAnnotation":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFlowDeclaration(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isFlowPredicate(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "DeclaredPredicate":
        case "InferredPredicate":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEnumBody(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isEnumMember(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isJSX(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXEmptyExpression":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXIdentifier":
        case "JSXMemberExpression":
        case "JSXNamespacedName":
        case "JSXOpeningElement":
        case "JSXSpreadAttribute":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isMiscellaneous(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "Noop":
        case "Placeholder":
        case "V8IntrinsicIdentifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTypeScript(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "TSParameterProperty":
        case "TSDeclareFunction":
        case "TSDeclareMethod":
        case "TSQualifiedName":
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSNamedTupleMember":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSInterfaceDeclaration":
        case "TSInterfaceBody":
        case "TSTypeAliasDeclaration":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSEnumDeclaration":
        case "TSEnumMember":
        case "TSModuleDeclaration":
        case "TSModuleBlock":
        case "TSImportType":
        case "TSImportEqualsDeclaration":
        case "TSExternalModuleReference":
        case "TSNonNullExpression":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
        case "TSTypeAnnotation":
        case "TSTypeParameterInstantiation":
        case "TSTypeParameterDeclaration":
        case "TSTypeParameter":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSTypeElement(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSType(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSImportType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isTSBaseType(node, opts) {
      if (!node) return false;
      switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSLiteralType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isNumberLiteral(node, opts) {
      (0, _deprecationWarning$2["default"])(
        "isNumberLiteral",
        "isNumericLiteral"
      );
      if (!node) return false;
      if (node.type !== "NumberLiteral") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isRegexLiteral(node, opts) {
      (0, _deprecationWarning$2["default"])(
        "isRegexLiteral",
        "isRegExpLiteral"
      );
      if (!node) return false;
      if (node.type !== "RegexLiteral") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isRestProperty(node, opts) {
      (0, _deprecationWarning$2["default"])("isRestProperty", "isRestElement");
      if (!node) return false;
      if (node.type !== "RestProperty") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isSpreadProperty(node, opts) {
      (0, _deprecationWarning$2["default"])(
        "isSpreadProperty",
        "isSpreadElement"
      );
      if (!node) return false;
      if (node.type !== "SpreadProperty") return false;
      return opts == null || (0, _shallowEqual["default"])(node, opts);
    }
    function isModuleDeclaration(node, opts) {
      (0, _deprecationWarning$2["default"])(
        "isModuleDeclaration",
        "isImportOrExportDeclaration"
      );
      return isImportOrExportDeclaration(node, opts);
    }
    Object.defineProperty(matchesPattern$1, "__esModule", { value: true });
    matchesPattern$1["default"] = matchesPattern;
    var _index$v = generated$3;
    function matchesPattern(member, match, allowPartial) {
      if (!(0, _index$v.isMemberExpression)(member)) return false;
      var parts = Array.isArray(match) ? match : match.split(".");
      var nodes = [];
      var node;
      for (
        node = member;
        (0, _index$v.isMemberExpression)(node);
        node = node.object
      ) {
        nodes.push(node.property);
      }
      nodes.push(node);
      if (nodes.length < parts.length) return false;
      if (!allowPartial && nodes.length > parts.length) return false;
      for (var i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
        var _node = nodes[j];
        var value = void 0;
        if ((0, _index$v.isIdentifier)(_node)) {
          value = _node.name;
        } else if ((0, _index$v.isStringLiteral)(_node)) {
          value = _node.value;
        } else if ((0, _index$v.isThisExpression)(_node)) {
          value = "this";
        } else {
          return false;
        }
        if (parts[i] !== value) return false;
      }
      return true;
    }
    Object.defineProperty(buildMatchMemberExpression$1, "__esModule", {
      value: true
    });
    buildMatchMemberExpression$1["default"] = buildMatchMemberExpression;
    var _matchesPattern = matchesPattern$1;
    function buildMatchMemberExpression(match, allowPartial) {
      var parts = match.split(".");
      return function (member) {
        return (0, _matchesPattern["default"])(member, parts, allowPartial);
      };
    }
    Object.defineProperty(isReactComponent$1, "__esModule", { value: true });
    isReactComponent$1["default"] = void 0;
    var _buildMatchMemberExpression = buildMatchMemberExpression$1;
    var isReactComponent = (0, _buildMatchMemberExpression["default"])(
      "React.Component"
    );
    isReactComponent$1["default"] = isReactComponent;
    var isCompatTag$1 = {};
    Object.defineProperty(isCompatTag$1, "__esModule", { value: true });
    isCompatTag$1["default"] = isCompatTag;
    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]/.test(tagName);
    }
    var buildChildren = {};
    var cleanJSXElementLiteralChild = {};
    var generated$2 = {};
    var validate$2 = {};
    var definitions = {};
    var core = {};
    var is = {};
    var isType$1 = {};
    var hasRequiredIsType;
    function requireIsType() {
      if (hasRequiredIsType) return isType$1;
      hasRequiredIsType = 1;
      Object.defineProperty(isType$1, "__esModule", { value: true });
      isType$1["default"] = isType;
      var _index = requireDefinitions();
      function isType(nodeType, targetType) {
        if (nodeType === targetType) return true;
        if (nodeType == null) return false;
        if (_index.ALIAS_KEYS[targetType]) return false;
        var aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
        if (aliases) {
          if (aliases[0] === nodeType) return true;
          var _iterator16 = _createForOfIteratorHelper(aliases),
            _step16;
          try {
            for (_iterator16.s(); !(_step16 = _iterator16.n()).done; ) {
              var alias = _step16.value;
              if (nodeType === alias) return true;
            }
          } catch (err) {
            _iterator16.e(err);
          } finally {
            _iterator16.f();
          }
        }
        return false;
      }
      return isType$1;
    }
    var isPlaceholderType = {};
    var hasRequiredIsPlaceholderType;
    function requireIsPlaceholderType() {
      if (hasRequiredIsPlaceholderType) return isPlaceholderType;
      hasRequiredIsPlaceholderType = 1;
      Object.defineProperty(isPlaceholderType, "__esModule", { value: true });
      isPlaceholderType["default"] = isPlaceholderType$1;
      var _index = requireDefinitions();
      function isPlaceholderType$1(placeholderType, targetType) {
        if (placeholderType === targetType) return true;
        var aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
        if (aliases) {
          var _iterator17 = _createForOfIteratorHelper(aliases),
            _step17;
          try {
            for (_iterator17.s(); !(_step17 = _iterator17.n()).done; ) {
              var alias = _step17.value;
              if (targetType === alias) return true;
            }
          } catch (err) {
            _iterator17.e(err);
          } finally {
            _iterator17.f();
          }
        }
        return false;
      }
      return isPlaceholderType;
    }
    var hasRequiredIs;
    function requireIs() {
      if (hasRequiredIs) return is;
      hasRequiredIs = 1;
      Object.defineProperty(is, "__esModule", { value: true });
      is["default"] = is$1;
      var _shallowEqual = shallowEqual$1;
      var _isType = requireIsType();
      var _isPlaceholderType = requireIsPlaceholderType();
      var _index = requireDefinitions();
      function is$1(type, node, opts) {
        if (!node) return false;
        var matches = (0, _isType["default"])(node.type, type);
        if (!matches) {
          if (
            !opts &&
            node.type === "Placeholder" &&
            type in _index.FLIPPED_ALIAS_KEYS
          ) {
            return (0, _isPlaceholderType["default"])(node.expectedNode, type);
          }
          return false;
        }
        if (opts === undefined) {
          return true;
        } else {
          return (0, _shallowEqual["default"])(node, opts);
        }
      }
      return is;
    }
    var isValidIdentifier$1 = {};
    var lib$2 = {};
    var identifier$1 = {};
    Object.defineProperty(identifier$1, "__esModule", { value: true });
    identifier$1.isIdentifierChar = isIdentifierChar;
    identifier$1.isIdentifierName = isIdentifierName;
    identifier$1.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars =
      "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars =
      "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart = new RegExp(
      "[" + nonASCIIidentifierStartChars + "]"
    );
    var nonASCIIidentifier = new RegExp(
      "[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]"
    );
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [
      0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48,
      48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35,
      5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51,
      13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4,
      0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65,
      0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11,
      18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7,
      1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3,
      0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0,
      2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7,
      3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2,
      37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46,
      42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32,
      7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0,
      11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0,
      50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18,
      16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16,
      1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29,
      19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65,
      1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30,
      2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2,
      1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2,
      3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2,
      30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6,
      17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14,
      2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0,
      2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2,
      0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2,
      16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541,
      1507, 4938, 6, 4191
    ];
    var astralIdentifierCodes = [
      509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1,
      574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14,
      32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0,
      13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56,
      1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2,
      4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1,
      83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5,
      2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9,
      0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4,
      0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0,
      49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60,
      6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9,
      519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513,
      54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4,
      101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110,
      6, 6, 9, 4759, 9, 787719, 239
    ];
    function isInAstralSet(code, set) {
      var pos = 0x10000;
      for (var i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65) return code === 36;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 0xffff) {
        return (
          code >= 0xaa &&
          nonASCIIidentifierStart.test(String.fromCharCode(code))
        );
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48) return code === 36;
      if (code < 58) return true;
      if (code < 65) return false;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 0xffff) {
        return (
          code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))
        );
      }
      return (
        isInAstralSet(code, astralIdentifierStartCodes) ||
        isInAstralSet(code, astralIdentifierCodes)
      );
    }
    function isIdentifierName(name) {
      var isFirst = true;
      for (var i = 0; i < name.length; i++) {
        var cp = name.charCodeAt(i);
        if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
          var trail = name.charCodeAt(++i);
          if ((trail & 0xfc00) === 0xdc00) {
            cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
    var keyword = {};
    Object.defineProperty(keyword, "__esModule", { value: true });
    keyword.isKeyword = isKeyword;
    keyword.isReservedWord = isReservedWord;
    keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    keyword.isStrictBindReservedWord = isStrictBindReservedWord;
    keyword.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: [
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
      ],
      strict: [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
      ],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return (inModule && word === "await") || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return (
        isStrictReservedWord(word, inModule) ||
        isStrictBindOnlyReservedWord(word)
      );
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
    (function (exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      Object.defineProperty(exports, "isIdentifierChar", {
        enumerable: true,
        get: function get() {
          return _identifier.isIdentifierChar;
        }
      });
      Object.defineProperty(exports, "isIdentifierName", {
        enumerable: true,
        get: function get() {
          return _identifier.isIdentifierName;
        }
      });
      Object.defineProperty(exports, "isIdentifierStart", {
        enumerable: true,
        get: function get() {
          return _identifier.isIdentifierStart;
        }
      });
      Object.defineProperty(exports, "isKeyword", {
        enumerable: true,
        get: function get() {
          return _keyword.isKeyword;
        }
      });
      Object.defineProperty(exports, "isReservedWord", {
        enumerable: true,
        get: function get() {
          return _keyword.isReservedWord;
        }
      });
      Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
        enumerable: true,
        get: function get() {
          return _keyword.isStrictBindOnlyReservedWord;
        }
      });
      Object.defineProperty(exports, "isStrictBindReservedWord", {
        enumerable: true,
        get: function get() {
          return _keyword.isStrictBindReservedWord;
        }
      });
      Object.defineProperty(exports, "isStrictReservedWord", {
        enumerable: true,
        get: function get() {
          return _keyword.isStrictReservedWord;
        }
      });
      var _identifier = identifier$1;
      var _keyword = keyword;
    })(lib$2);
    Object.defineProperty(isValidIdentifier$1, "__esModule", { value: true });
    isValidIdentifier$1["default"] = isValidIdentifier;
    var _helperValidatorIdentifier$1 = lib$2;
    function isValidIdentifier(name) {
      var reserved =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : true;
      if (typeof name !== "string") return false;
      if (reserved) {
        if (
          (0, _helperValidatorIdentifier$1.isKeyword)(name) ||
          (0, _helperValidatorIdentifier$1.isStrictReservedWord)(name, true)
        ) {
          return false;
        }
      }
      return (0, _helperValidatorIdentifier$1.isIdentifierName)(name);
    }
    var lib$1 = {};
    var hasRequiredLib$1;
    function requireLib$1() {
      if (hasRequiredLib$1) return lib$1;
      hasRequiredLib$1 = 1;
      Object.defineProperty(lib$1, "__esModule", { value: true });
      lib$1.readCodePoint = readCodePoint;
      lib$1.readInt = readInt;
      lib$1.readStringContents = readStringContents;
      var _isDigit = function isDigit(code) {
        return code >= 48 && code <= 57;
      };
      var forbiddenNumericSeparatorSiblings = {
        decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: new Set([46, 88, 95, 120])
      };
      var isAllowedNumericSeparatorSibling = {
        bin: function bin(ch) {
          return ch === 48 || ch === 49;
        },
        oct: function oct(ch) {
          return ch >= 48 && ch <= 55;
        },
        dec: function dec(ch) {
          return ch >= 48 && ch <= 57;
        },
        hex: function hex(ch) {
          return (
            (ch >= 48 && ch <= 57) ||
            (ch >= 65 && ch <= 70) ||
            (ch >= 97 && ch <= 102)
          );
        }
      };
      function readStringContents(
        type,
        input,
        pos,
        lineStart,
        curLine,
        errors
      ) {
        var initialPos = pos;
        var initialLineStart = lineStart;
        var initialCurLine = curLine;
        var out = "";
        var firstInvalidLoc = null;
        var chunkStart = pos;
        var length = input.length;
        for (;;) {
          if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
          }
          var ch = input.charCodeAt(pos);
          if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
          }
          if (ch === 92) {
            out += input.slice(chunkStart, pos);
            var res = readEscapedChar(
              input,
              pos,
              lineStart,
              curLine,
              type === "template",
              errors
            );
            if (res.ch === null && !firstInvalidLoc) {
              firstInvalidLoc = {
                pos: pos,
                lineStart: lineStart,
                curLine: curLine
              };
            } else {
              out += res.ch;
            }
            pos = res.pos;
            lineStart = res.lineStart;
            curLine = res.curLine;
            chunkStart = pos;
          } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
          } else if (ch === 10 || ch === 13) {
            if (type === "template") {
              out += input.slice(chunkStart, pos) + "\n";
              ++pos;
              if (ch === 13 && input.charCodeAt(pos) === 10) {
                ++pos;
              }
              ++curLine;
              chunkStart = lineStart = pos;
            } else {
              errors.unterminated(initialPos, initialLineStart, initialCurLine);
            }
          } else {
            ++pos;
          }
        }
        return {
          pos: pos,
          str: out,
          firstInvalidLoc: firstInvalidLoc,
          lineStart: lineStart,
          curLine: curLine,
          containsInvalid: !!firstInvalidLoc
        };
      }
      function isStringEnd(type, ch, input, pos) {
        if (type === "template") {
          return ch === 96 || (ch === 36 && input.charCodeAt(pos + 1) === 123);
        }
        return ch === (type === "double" ? 34 : 39);
      }
      function readEscapedChar(
        input,
        pos,
        lineStart,
        curLine,
        inTemplate,
        errors
      ) {
        var throwOnInvalid = !inTemplate;
        pos++;
        var res = function res(ch) {
          return { pos: pos, ch: ch, lineStart: lineStart, curLine: curLine };
        };
        var ch = input.charCodeAt(pos++);
        switch (ch) {
          case 110:
            return res("\n");
          case 114:
            return res("\r");
          case 120: {
            var code;
            var _readHexChar = readHexChar(
              input,
              pos,
              lineStart,
              curLine,
              2,
              false,
              throwOnInvalid,
              errors
            );
            code = _readHexChar.code;
            pos = _readHexChar.pos;
            return res(code === null ? null : String.fromCharCode(code));
          }
          case 117: {
            var _code;
            var _readCodePoint = readCodePoint(
              input,
              pos,
              lineStart,
              curLine,
              throwOnInvalid,
              errors
            );
            _code = _readCodePoint.code;
            pos = _readCodePoint.pos;
            return res(_code === null ? null : String.fromCodePoint(_code));
          }
          case 116:
            return res("\t");
          case 98:
            return res("\b");
          case 118:
            return res("\x0B");
          case 102:
            return res("\f");
          case 13:
            if (input.charCodeAt(pos) === 10) {
              ++pos;
            }
          case 10:
            lineStart = pos;
            ++curLine;
          case 8232:
          case 8233:
            return res("");
          case 56:
          case 57:
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(pos - 1, lineStart, curLine);
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var startPos = pos - 1;
              var match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
              var octalStr = match[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              pos += octalStr.length - 1;
              var next = input.charCodeAt(pos);
              if (octalStr !== "0" || next === 56 || next === 57) {
                if (inTemplate) {
                  return res(null);
                } else {
                  errors.strictNumericEscape(startPos, lineStart, curLine);
                }
              }
              return res(String.fromCharCode(octal));
            }
            return res(String.fromCharCode(ch));
        }
      }
      function readHexChar(
        input,
        pos,
        lineStart,
        curLine,
        len,
        forceLen,
        throwOnInvalid,
        errors
      ) {
        var initialPos = pos;
        var n;
        var _readInt = readInt(
          input,
          pos,
          lineStart,
          curLine,
          16,
          len,
          forceLen,
          false,
          errors,
          !throwOnInvalid
        );
        n = _readInt.n;
        pos = _readInt.pos;
        if (n === null) {
          if (throwOnInvalid) {
            errors.invalidEscapeSequence(initialPos, lineStart, curLine);
          } else {
            pos = initialPos - 1;
          }
        }
        return { code: n, pos: pos };
      }
      function readInt(
        input,
        pos,
        lineStart,
        curLine,
        radix,
        len,
        forceLen,
        allowNumSeparator,
        errors,
        bailOnError
      ) {
        var start = pos;
        var forbiddenSiblings =
          radix === 16
            ? forbiddenNumericSeparatorSiblings.hex
            : forbiddenNumericSeparatorSiblings.decBinOct;
        var isAllowedSibling =
          radix === 16
            ? isAllowedNumericSeparatorSibling.hex
            : radix === 10
              ? isAllowedNumericSeparatorSibling.dec
              : radix === 8
                ? isAllowedNumericSeparatorSibling.oct
                : isAllowedNumericSeparatorSibling.bin;
        var invalid = false;
        var total = 0;
        for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          var code = input.charCodeAt(pos);
          var val = void 0;
          if (code === 95 && allowNumSeparator !== "bail") {
            var prev = input.charCodeAt(pos - 1);
            var next = input.charCodeAt(pos + 1);
            if (!allowNumSeparator) {
              if (bailOnError) return { n: null, pos: pos };
              errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (
              Number.isNaN(next) ||
              !isAllowedSibling(next) ||
              forbiddenSiblings.has(prev) ||
              forbiddenSiblings.has(next)
            ) {
              if (bailOnError) return { n: null, pos: pos };
              errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            ++pos;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (_isDigit(code)) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            if (val <= 9 && bailOnError) {
              return { n: null, pos: pos };
            } else if (
              val <= 9 &&
              errors.invalidDigit(pos, lineStart, curLine, radix)
            ) {
              val = 0;
            } else if (forceLen) {
              val = 0;
              invalid = true;
            } else {
              break;
            }
          }
          ++pos;
          total = total * radix + val;
        }
        if (pos === start || (len != null && pos - start !== len) || invalid) {
          return { n: null, pos: pos };
        }
        return { n: total, pos: pos };
      }
      function readCodePoint(
        input,
        pos,
        lineStart,
        curLine,
        throwOnInvalid,
        errors
      ) {
        var ch = input.charCodeAt(pos);
        var code;
        if (ch === 123) {
          ++pos;
          var _readHexChar2 = readHexChar(
            input,
            pos,
            lineStart,
            curLine,
            input.indexOf("}", pos) - pos,
            true,
            throwOnInvalid,
            errors
          );
          code = _readHexChar2.code;
          pos = _readHexChar2.pos;
          ++pos;
          if (code !== null && code > 0x10ffff) {
            if (throwOnInvalid) {
              errors.invalidCodePoint(pos, lineStart, curLine);
            } else {
              return { code: null, pos: pos };
            }
          }
        } else {
          var _readHexChar3 = readHexChar(
            input,
            pos,
            lineStart,
            curLine,
            4,
            false,
            throwOnInvalid,
            errors
          );
          code = _readHexChar3.code;
          pos = _readHexChar3.pos;
        }
        return { code: code, pos: pos };
      }
      return lib$1;
    }
    var constants = {};
    Object.defineProperty(constants, "__esModule", { value: true });
    constants.UPDATE_OPERATORS =
      constants.UNARY_OPERATORS =
      constants.STRING_UNARY_OPERATORS =
      constants.STATEMENT_OR_BLOCK_KEYS =
      constants.NUMBER_UNARY_OPERATORS =
      constants.NUMBER_BINARY_OPERATORS =
      constants.NOT_LOCAL_BINDING =
      constants.LOGICAL_OPERATORS =
      constants.INHERIT_KEYS =
      constants.FOR_INIT_KEYS =
      constants.FLATTENABLE_KEYS =
      constants.EQUALITY_BINARY_OPERATORS =
      constants.COMPARISON_BINARY_OPERATORS =
      constants.COMMENT_KEYS =
      constants.BOOLEAN_UNARY_OPERATORS =
      constants.BOOLEAN_NUMBER_BINARY_OPERATORS =
      constants.BOOLEAN_BINARY_OPERATORS =
      constants.BLOCK_SCOPED_SYMBOL =
      constants.BINARY_OPERATORS =
      constants.ASSIGNMENT_OPERATORS =
        void 0;
    constants.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
    constants.FLATTENABLE_KEYS = ["body", "expressions"];
    constants.FOR_INIT_KEYS = ["left", "init"];
    constants.COMMENT_KEYS = [
      "leadingComments",
      "trailingComments",
      "innerComments"
    ];
    var LOGICAL_OPERATORS = (constants.LOGICAL_OPERATORS = ["||", "&&", "??"]);
    constants.UPDATE_OPERATORS = ["++", "--"];
    var BOOLEAN_NUMBER_BINARY_OPERATORS =
      (constants.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="]);
    var EQUALITY_BINARY_OPERATORS = (constants.EQUALITY_BINARY_OPERATORS = [
      "==",
      "===",
      "!=",
      "!=="
    ]);
    var COMPARISON_BINARY_OPERATORS = (constants.COMPARISON_BINARY_OPERATORS =
      [].concat(EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]));
    var BOOLEAN_BINARY_OPERATORS = (constants.BOOLEAN_BINARY_OPERATORS =
      [].concat(
        _toConsumableArray(COMPARISON_BINARY_OPERATORS),
        BOOLEAN_NUMBER_BINARY_OPERATORS
      ));
    var NUMBER_BINARY_OPERATORS = (constants.NUMBER_BINARY_OPERATORS = [
      "-",
      "/",
      "%",
      "*",
      "**",
      "&",
      "|",
      ">>",
      ">>>",
      "<<",
      "^"
    ]);
    constants.BINARY_OPERATORS = ["+"].concat(
      NUMBER_BINARY_OPERATORS,
      _toConsumableArray(BOOLEAN_BINARY_OPERATORS),
      ["|>"]
    );
    constants.ASSIGNMENT_OPERATORS = ["=", "+="].concat(
      _toConsumableArray(
        NUMBER_BINARY_OPERATORS.map(function (op) {
          return op + "=";
        })
      ),
      _toConsumableArray(
        LOGICAL_OPERATORS.map(function (op) {
          return op + "=";
        })
      )
    );
    var BOOLEAN_UNARY_OPERATORS = (constants.BOOLEAN_UNARY_OPERATORS = [
      "delete",
      "!"
    ]);
    var NUMBER_UNARY_OPERATORS = (constants.NUMBER_UNARY_OPERATORS = [
      "+",
      "-",
      "~"
    ]);
    var STRING_UNARY_OPERATORS = (constants.STRING_UNARY_OPERATORS = [
      "typeof"
    ]);
    constants.UNARY_OPERATORS = ["void", "throw"].concat(
      BOOLEAN_UNARY_OPERATORS,
      NUMBER_UNARY_OPERATORS,
      STRING_UNARY_OPERATORS
    );
    constants.INHERIT_KEYS = {
      optional: ["typeAnnotation", "typeParameters", "returnType"],
      force: ["start", "loc", "end"]
    };
    constants.BLOCK_SCOPED_SYMBOL = Symbol["for"](
      "var used to be block scoped"
    );
    constants.NOT_LOCAL_BINDING = Symbol["for"](
      "should not be considered a local binding"
    );
    var utils$1 = {};
    var hasRequiredUtils;
    function requireUtils() {
      if (hasRequiredUtils) return utils$1;
      hasRequiredUtils = 1;
      Object.defineProperty(utils$1, "__esModule", { value: true });
      utils$1.VISITOR_KEYS =
        utils$1.NODE_PARENT_VALIDATIONS =
        utils$1.NODE_FIELDS =
        utils$1.FLIPPED_ALIAS_KEYS =
        utils$1.DEPRECATED_KEYS =
        utils$1.BUILDER_KEYS =
        utils$1.ALIAS_KEYS =
          void 0;
      utils$1.arrayOf = arrayOf;
      utils$1.arrayOfType = arrayOfType;
      utils$1.assertEach = assertEach;
      utils$1.assertNodeOrValueType = assertNodeOrValueType;
      utils$1.assertNodeType = assertNodeType;
      utils$1.assertOneOf = assertOneOf;
      utils$1.assertOptionalChainStart = assertOptionalChainStart;
      utils$1.assertShape = assertShape;
      utils$1.assertValueType = assertValueType;
      utils$1.chain = chain;
      utils$1["default"] = defineType;
      utils$1.defineAliasedType = defineAliasedType;
      utils$1.validate = validate;
      utils$1.validateArrayOfType = validateArrayOfType;
      utils$1.validateOptional = validateOptional;
      utils$1.validateOptionalType = validateOptionalType;
      utils$1.validateType = validateType;
      var _is = requireIs();
      var _validate = requireValidate();
      var VISITOR_KEYS = (utils$1.VISITOR_KEYS = {});
      var ALIAS_KEYS = (utils$1.ALIAS_KEYS = {});
      var FLIPPED_ALIAS_KEYS = (utils$1.FLIPPED_ALIAS_KEYS = {});
      var NODE_FIELDS = (utils$1.NODE_FIELDS = {});
      var BUILDER_KEYS = (utils$1.BUILDER_KEYS = {});
      var DEPRECATED_KEYS = (utils$1.DEPRECATED_KEYS = {});
      var NODE_PARENT_VALIDATIONS = (utils$1.NODE_PARENT_VALIDATIONS = {});
      function getType(val) {
        if (Array.isArray(val)) {
          return "array";
        } else if (val === null) {
          return "null";
        } else {
          return _typeof(val);
        }
      }
      function validate(validate) {
        return { validate: validate };
      }
      function validateType() {
        return validate(assertNodeType.apply(void 0, arguments));
      }
      function validateOptional(validate) {
        return { validate: validate, optional: true };
      }
      function validateOptionalType() {
        return {
          validate: assertNodeType.apply(void 0, arguments),
          optional: true
        };
      }
      function arrayOf(elementType) {
        return chain(assertValueType("array"), assertEach(elementType));
      }
      function arrayOfType() {
        return arrayOf(assertNodeType.apply(void 0, arguments));
      }
      function validateArrayOfType() {
        return validate(arrayOfType.apply(void 0, arguments));
      }
      function assertEach(callback) {
        var childValidator = process.env.BABEL_TYPES_8_BREAKING
          ? _validate.validateChild
          : function () {};
        function validator(node, key, val) {
          if (!Array.isArray(val)) return;
          for (var i = 0; i < val.length; i++) {
            var subkey = "".concat(key, "[").concat(i, "]");
            var v = val[i];
            callback(node, subkey, v);
            childValidator(node, subkey, v);
          }
        }
        validator.each = callback;
        return validator;
      }
      function assertOneOf() {
        for (
          var _len = arguments.length, values = new Array(_len), _key5 = 0;
          _key5 < _len;
          _key5++
        ) {
          values[_key5] = arguments[_key5];
        }
        function validate(node, key, val) {
          if (!values.includes(val)) {
            throw new TypeError(
              "Property "
                .concat(key, " expected value to be one of ")
                .concat(JSON.stringify(values), " but got ")
                .concat(JSON.stringify(val))
            );
          }
        }
        validate.oneOf = values;
        return validate;
      }
      function assertNodeType() {
        for (
          var _len2 = arguments.length, types = new Array(_len2), _key6 = 0;
          _key6 < _len2;
          _key6++
        ) {
          types[_key6] = arguments[_key6];
        }
        function validate(node, key, val) {
          var _iterator18 = _createForOfIteratorHelper(types),
            _step18;
          try {
            for (_iterator18.s(); !(_step18 = _iterator18.n()).done; ) {
              var type = _step18.value;
              if ((0, _is["default"])(type, val)) {
                (0, _validate.validateChild)(node, key, val);
                return;
              }
            }
          } catch (err) {
            _iterator18.e(err);
          } finally {
            _iterator18.f();
          }
          throw new TypeError(
            "Property "
              .concat(key, " of ")
              .concat(node.type, " expected node to be of a type ")
              .concat(JSON.stringify(types), " but instead got ")
              .concat(JSON.stringify(val == null ? void 0 : val.type))
          );
        }
        validate.oneOfNodeTypes = types;
        return validate;
      }
      function assertNodeOrValueType() {
        for (
          var _len3 = arguments.length, types = new Array(_len3), _key7 = 0;
          _key7 < _len3;
          _key7++
        ) {
          types[_key7] = arguments[_key7];
        }
        function validate(node, key, val) {
          var _iterator19 = _createForOfIteratorHelper(types),
            _step19;
          try {
            for (_iterator19.s(); !(_step19 = _iterator19.n()).done; ) {
              var type = _step19.value;
              if (getType(val) === type || (0, _is["default"])(type, val)) {
                (0, _validate.validateChild)(node, key, val);
                return;
              }
            }
          } catch (err) {
            _iterator19.e(err);
          } finally {
            _iterator19.f();
          }
          throw new TypeError(
            "Property "
              .concat(key, " of ")
              .concat(node.type, " expected node to be of a type ")
              .concat(JSON.stringify(types), " but instead got ")
              .concat(JSON.stringify(val == null ? void 0 : val.type))
          );
        }
        validate.oneOfNodeOrValueTypes = types;
        return validate;
      }
      function assertValueType(type) {
        function validate(node, key, val) {
          var valid = getType(val) === type;
          if (!valid) {
            throw new TypeError(
              "Property "
                .concat(key, " expected type of ")
                .concat(type, " but got ")
                .concat(getType(val))
            );
          }
        }
        validate.type = type;
        return validate;
      }
      function assertShape(shape) {
        function validate(node, key, val) {
          var errors = [];
          for (
            var _i3 = 0, _Object$keys = Object.keys(shape);
            _i3 < _Object$keys.length;
            _i3++
          ) {
            var property = _Object$keys[_i3];
            try {
              (0, _validate.validateField)(
                node,
                property,
                val[property],
                shape[property]
              );
            } catch (error) {
              if (error instanceof TypeError) {
                errors.push(error.message);
                continue;
              }
              throw error;
            }
          }
          if (errors.length) {
            throw new TypeError(
              "Property "
                .concat(key, " of ")
                .concat(node.type, " expected to have the following:\n")
                .concat(errors.join("\n"))
            );
          }
        }
        validate.shapeOf = shape;
        return validate;
      }
      function assertOptionalChainStart() {
        function validate(node) {
          var _current;
          var current = node;
          while (node) {
            var _current2 = current,
              type = _current2.type;
            if (type === "OptionalCallExpression") {
              if (current.optional) return;
              current = current.callee;
              continue;
            }
            if (type === "OptionalMemberExpression") {
              if (current.optional) return;
              current = current.object;
              continue;
            }
            break;
          }
          throw new TypeError(
            "Non-optional "
              .concat(
                node.type,
                " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from "
              )
              .concat((_current = current) == null ? void 0 : _current.type)
          );
        }
        return validate;
      }
      function chain() {
        for (
          var _len4 = arguments.length, fns = new Array(_len4), _key8 = 0;
          _key8 < _len4;
          _key8++
        ) {
          fns[_key8] = arguments[_key8];
        }
        function validate() {
          var _iterator20 = _createForOfIteratorHelper(fns),
            _step20;
          try {
            for (_iterator20.s(); !(_step20 = _iterator20.n()).done; ) {
              var fn = _step20.value;
              fn.apply(void 0, arguments);
            }
          } catch (err) {
            _iterator20.e(err);
          } finally {
            _iterator20.f();
          }
        }
        validate.chainOf = fns;
        if (
          fns.length >= 2 &&
          "type" in fns[0] &&
          fns[0].type === "array" &&
          !("each" in fns[1])
        ) {
          throw new Error(
            'An assertValueType("array") validator can only be followed by an assertEach(...) validator.'
          );
        }
        return validate;
      }
      var validTypeOpts = new Set([
        "aliases",
        "builder",
        "deprecatedAlias",
        "fields",
        "inherits",
        "visitor",
        "validate"
      ]);
      var validFieldKeys = new Set([
        "default",
        "optional",
        "deprecated",
        "validate"
      ]);
      var store = {};
      function defineAliasedType() {
        for (
          var _len5 = arguments.length, aliases = new Array(_len5), _key9 = 0;
          _key9 < _len5;
          _key9++
        ) {
          aliases[_key9] = arguments[_key9];
        }
        return function (type) {
          var _defined2;
          var opts =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {};
          var defined = opts.aliases;
          if (!defined) {
            var _store$opts$inherits$, _defined;
            if (opts.inherits)
              defined =
                (_store$opts$inherits$ = store[opts.inherits].aliases) == null
                  ? void 0
                  : _store$opts$inherits$.slice();
            (_defined = defined) != null ? _defined : (defined = []);
            opts.aliases = defined;
          }
          var additional = aliases.filter(function (a) {
            return !defined.includes(a);
          });
          (_defined2 = defined).unshift.apply(
            _defined2,
            _toConsumableArray(additional)
          );
          defineType(type, opts);
        };
      }
      function defineType(type) {
        var opts =
          arguments.length > 1 && arguments[1] !== undefined
            ? arguments[1]
            : {};
        var inherits = (opts.inherits && store[opts.inherits]) || {};
        var fields = opts.fields;
        if (!fields) {
          fields = {};
          if (inherits.fields) {
            var _keys2 = Object.getOwnPropertyNames(inherits.fields);
            var _iterator21 = _createForOfIteratorHelper(_keys2),
              _step21;
            try {
              for (_iterator21.s(); !(_step21 = _iterator21.n()).done; ) {
                var _key10 = _step21.value;
                var field = inherits.fields[_key10];
                var def = field["default"];
                if (
                  Array.isArray(def)
                    ? def.length > 0
                    : def && _typeof(def) === "object"
                ) {
                  throw new Error(
                    "field defaults can only be primitives or empty arrays currently"
                  );
                }
                fields[_key10] = {
                  default: Array.isArray(def) ? [] : def,
                  optional: field.optional,
                  deprecated: field.deprecated,
                  validate: field.validate
                };
              }
            } catch (err) {
              _iterator21.e(err);
            } finally {
              _iterator21.f();
            }
          }
        }
        var visitor = opts.visitor || inherits.visitor || [];
        var aliases = opts.aliases || inherits.aliases || [];
        var builder = opts.builder || inherits.builder || opts.visitor || [];
        for (
          var _i4 = 0, _Object$keys2 = Object.keys(opts);
          _i4 < _Object$keys2.length;
          _i4++
        ) {
          var k = _Object$keys2[_i4];
          if (!validTypeOpts.has(k)) {
            throw new Error(
              'Unknown type option "'.concat(k, '" on ').concat(type)
            );
          }
        }
        if (opts.deprecatedAlias) {
          DEPRECATED_KEYS[opts.deprecatedAlias] = type;
        }
        var _iterator22 = _createForOfIteratorHelper(visitor.concat(builder)),
          _step22;
        try {
          for (_iterator22.s(); !(_step22 = _iterator22.n()).done; ) {
            var _key12 = _step22.value;
            fields[_key12] = fields[_key12] || {};
          }
        } catch (err) {
          _iterator22.e(err);
        } finally {
          _iterator22.f();
        }
        for (
          var _i5 = 0, _Object$keys3 = Object.keys(fields);
          _i5 < _Object$keys3.length;
          _i5++
        ) {
          var _key11 = _Object$keys3[_i5];
          var _field = fields[_key11];
          if (_field["default"] !== undefined && !builder.includes(_key11)) {
            _field.optional = true;
          }
          if (_field["default"] === undefined) {
            _field["default"] = null;
          } else if (!_field.validate && _field["default"] != null) {
            _field.validate = assertValueType(getType(_field["default"]));
          }
          for (
            var _i6 = 0, _Object$keys4 = Object.keys(_field);
            _i6 < _Object$keys4.length;
            _i6++
          ) {
            var _k2 = _Object$keys4[_i6];
            if (!validFieldKeys.has(_k2)) {
              throw new Error(
                'Unknown field key "'
                  .concat(_k2, '" on ')
                  .concat(type, ".")
                  .concat(_key11)
              );
            }
          }
        }
        VISITOR_KEYS[type] = opts.visitor = visitor;
        BUILDER_KEYS[type] = opts.builder = builder;
        NODE_FIELDS[type] = opts.fields = fields;
        ALIAS_KEYS[type] = opts.aliases = aliases;
        aliases.forEach(function (alias) {
          FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
          FLIPPED_ALIAS_KEYS[alias].push(type);
        });
        if (opts.validate) {
          NODE_PARENT_VALIDATIONS[type] = opts.validate;
        }
        store[type] = opts;
      }
      return utils$1;
    }
    var hasRequiredCore;
    function requireCore() {
      if (hasRequiredCore) return core;
      hasRequiredCore = 1;
      Object.defineProperty(core, "__esModule", { value: true });
      core.patternLikeCommon =
        core.importAttributes =
        core.functionTypeAnnotationCommon =
        core.functionDeclarationCommon =
        core.functionCommon =
        core.classMethodOrPropertyCommon =
        core.classMethodOrDeclareMethodCommon =
          void 0;
      var _is = requireIs();
      var _isValidIdentifier = isValidIdentifier$1;
      var _helperValidatorIdentifier = lib$2;
      var _helperStringParser = requireLib$1();
      var _index = constants;
      var _utils = requireUtils();
      var defineType = (0, _utils.defineAliasedType)("Standardized");
      defineType("ArrayExpression", {
        fields: {
          elements: {
            validate: (0, _utils.arrayOf)(
              (0, _utils.assertNodeOrValueType)(
                "null",
                "Expression",
                "SpreadElement"
              )
            ),
            default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
          }
        },
        visitor: ["elements"],
        aliases: ["Expression"]
      });
      defineType("AssignmentExpression", {
        fields: {
          operator: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.assertValueType)("string")
              : Object.assign(
                  (function () {
                    var identifier = (0, _utils.assertOneOf).apply(
                      void 0,
                      _toConsumableArray(_index.ASSIGNMENT_OPERATORS)
                    );
                    var pattern = (0, _utils.assertOneOf)("=");
                    return function (node, key, val) {
                      var validator = (0, _is["default"])("Pattern", node.left)
                        ? pattern
                        : identifier;
                      validator(node, key, val);
                    };
                  })(),
                  { type: "string" }
                )
          },
          left: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression")
              : (0, _utils.assertNodeType)(
                  "Identifier",
                  "MemberExpression",
                  "OptionalMemberExpression",
                  "ArrayPattern",
                  "ObjectPattern",
                  "TSAsExpression",
                  "TSSatisfiesExpression",
                  "TSTypeAssertion",
                  "TSNonNullExpression"
                )
          },
          right: { validate: (0, _utils.assertNodeType)("Expression") }
        },
        builder: ["operator", "left", "right"],
        visitor: ["left", "right"],
        aliases: ["Expression"]
      });
      defineType("BinaryExpression", {
        builder: ["operator", "left", "right"],
        fields: {
          operator: {
            validate: (0, _utils.assertOneOf).apply(
              void 0,
              _toConsumableArray(_index.BINARY_OPERATORS)
            )
          },
          left: {
            validate: (function () {
              var expression = (0, _utils.assertNodeType)("Expression");
              var inOp = (0, _utils.assertNodeType)(
                "Expression",
                "PrivateName"
              );
              var validator = Object.assign(
                function (node, key, val) {
                  var validator = node.operator === "in" ? inOp : expression;
                  validator(node, key, val);
                },
                { oneOfNodeTypes: ["Expression", "PrivateName"] }
              );
              return validator;
            })()
          },
          right: { validate: (0, _utils.assertNodeType)("Expression") }
        },
        visitor: ["left", "right"],
        aliases: ["Binary", "Expression"]
      });
      defineType("InterpreterDirective", {
        builder: ["value"],
        fields: { value: { validate: (0, _utils.assertValueType)("string") } }
      });
      defineType("Directive", {
        visitor: ["value"],
        fields: {
          value: { validate: (0, _utils.assertNodeType)("DirectiveLiteral") }
        }
      });
      defineType("DirectiveLiteral", {
        builder: ["value"],
        fields: { value: { validate: (0, _utils.assertValueType)("string") } }
      });
      defineType("BlockStatement", {
        builder: ["body", "directives"],
        visitor: ["directives", "body"],
        fields: {
          directives: {
            validate: (0, _utils.arrayOfType)("Directive"),
            default: []
          },
          body: (0, _utils.validateArrayOfType)("Statement")
        },
        aliases: ["Scopable", "BlockParent", "Block", "Statement"]
      });
      defineType("BreakStatement", {
        visitor: ["label"],
        fields: {
          label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          }
        },
        aliases: ["Statement", "Terminatorless", "CompletionStatement"]
      });
      defineType("CallExpression", {
        visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
        builder: ["callee", "arguments"],
        aliases: ["Expression"],
        fields: Object.assign(
          {
            callee: {
              validate: (0, _utils.assertNodeType)(
                "Expression",
                "Super",
                "V8IntrinsicIdentifier"
              )
            },
            arguments: (0, _utils.validateArrayOfType)(
              "Expression",
              "SpreadElement",
              "ArgumentPlaceholder"
            )
          },
          !process.env.BABEL_TYPES_8_BREAKING
            ? {
                optional: {
                  validate: (0, _utils.assertValueType)("boolean"),
                  optional: true
                }
              }
            : {},
          {
            typeArguments: {
              validate: (0, _utils.assertNodeType)(
                "TypeParameterInstantiation"
              ),
              optional: true
            },
            typeParameters: {
              validate: (0, _utils.assertNodeType)(
                "TSTypeParameterInstantiation"
              ),
              optional: true
            }
          }
        )
      });
      defineType("CatchClause", {
        visitor: ["param", "body"],
        fields: {
          param: {
            validate: (0, _utils.assertNodeType)(
              "Identifier",
              "ArrayPattern",
              "ObjectPattern"
            ),
            optional: true
          },
          body: { validate: (0, _utils.assertNodeType)("BlockStatement") }
        },
        aliases: ["Scopable", "BlockParent"]
      });
      defineType("ConditionalExpression", {
        visitor: ["test", "consequent", "alternate"],
        fields: {
          test: { validate: (0, _utils.assertNodeType)("Expression") },
          consequent: { validate: (0, _utils.assertNodeType)("Expression") },
          alternate: { validate: (0, _utils.assertNodeType)("Expression") }
        },
        aliases: ["Expression", "Conditional"]
      });
      defineType("ContinueStatement", {
        visitor: ["label"],
        fields: {
          label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          }
        },
        aliases: ["Statement", "Terminatorless", "CompletionStatement"]
      });
      defineType("DebuggerStatement", { aliases: ["Statement"] });
      defineType("DoWhileStatement", {
        builder: ["test", "body"],
        visitor: ["body", "test"],
        fields: {
          test: { validate: (0, _utils.assertNodeType)("Expression") },
          body: { validate: (0, _utils.assertNodeType)("Statement") }
        },
        aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
      });
      defineType("EmptyStatement", { aliases: ["Statement"] });
      defineType("ExpressionStatement", {
        visitor: ["expression"],
        fields: {
          expression: { validate: (0, _utils.assertNodeType)("Expression") }
        },
        aliases: ["Statement", "ExpressionWrapper"]
      });
      defineType("File", {
        builder: ["program", "comments", "tokens"],
        visitor: ["program"],
        fields: {
          program: { validate: (0, _utils.assertNodeType)("Program") },
          comments: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? Object.assign(function () {}, {
                  each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] }
                })
              : (0, _utils.assertEach)(
                  (0, _utils.assertNodeType)("CommentBlock", "CommentLine")
                ),
            optional: true
          },
          tokens: {
            validate: (0, _utils.assertEach)(
              Object.assign(function () {}, { type: "any" })
            ),
            optional: true
          }
        }
      });
      defineType("ForInStatement", {
        visitor: ["left", "right", "body"],
        aliases: [
          "Scopable",
          "Statement",
          "For",
          "BlockParent",
          "Loop",
          "ForXStatement"
        ],
        fields: {
          left: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
              : (0, _utils.assertNodeType)(
                  "VariableDeclaration",
                  "Identifier",
                  "MemberExpression",
                  "ArrayPattern",
                  "ObjectPattern",
                  "TSAsExpression",
                  "TSSatisfiesExpression",
                  "TSTypeAssertion",
                  "TSNonNullExpression"
                )
          },
          right: { validate: (0, _utils.assertNodeType)("Expression") },
          body: { validate: (0, _utils.assertNodeType)("Statement") }
        }
      });
      defineType("ForStatement", {
        visitor: ["init", "test", "update", "body"],
        aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
        fields: {
          init: {
            validate: (0, _utils.assertNodeType)(
              "VariableDeclaration",
              "Expression"
            ),
            optional: true
          },
          test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          update: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          body: { validate: (0, _utils.assertNodeType)("Statement") }
        }
      });
      var functionCommon = function functionCommon() {
        return {
          params: (0, _utils.validateArrayOfType)(
            "Identifier",
            "Pattern",
            "RestElement"
          ),
          generator: { default: false },
          async: { default: false }
        };
      };
      core.functionCommon = functionCommon;
      var functionTypeAnnotationCommon =
        function functionTypeAnnotationCommon() {
          return {
            returnType: {
              validate: (0, _utils.assertNodeType)(
                "TypeAnnotation",
                "TSTypeAnnotation",
                "Noop"
              ),
              optional: true
            },
            typeParameters: {
              validate: (0, _utils.assertNodeType)(
                "TypeParameterDeclaration",
                "TSTypeParameterDeclaration",
                "Noop"
              ),
              optional: true
            }
          };
        };
      core.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
      var functionDeclarationCommon = function functionDeclarationCommon() {
        return Object.assign({}, functionCommon(), {
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          }
        });
      };
      core.functionDeclarationCommon = functionDeclarationCommon;
      defineType("FunctionDeclaration", {
        builder: ["id", "params", "body", "generator", "async"],
        visitor: ["id", "typeParameters", "params", "returnType", "body"],
        fields: Object.assign(
          {},
          functionDeclarationCommon(),
          functionTypeAnnotationCommon(),
          {
            body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
            predicate: {
              validate: (0, _utils.assertNodeType)(
                "DeclaredPredicate",
                "InferredPredicate"
              ),
              optional: true
            }
          }
        ),
        aliases: [
          "Scopable",
          "Function",
          "BlockParent",
          "FunctionParent",
          "Statement",
          "Pureish",
          "Declaration"
        ],
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? undefined
          : (function () {
              var identifier = (0, _utils.assertNodeType)("Identifier");
              return function (parent, key, node) {
                if (!(0, _is["default"])("ExportDefaultDeclaration", parent)) {
                  identifier(node, "id", node.id);
                }
              };
            })()
      });
      defineType("FunctionExpression", {
        inherits: "FunctionDeclaration",
        aliases: [
          "Scopable",
          "Function",
          "BlockParent",
          "FunctionParent",
          "Expression",
          "Pureish"
        ],
        fields: Object.assign(
          {},
          functionCommon(),
          functionTypeAnnotationCommon(),
          {
            id: {
              validate: (0, _utils.assertNodeType)("Identifier"),
              optional: true
            },
            body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
            predicate: {
              validate: (0, _utils.assertNodeType)(
                "DeclaredPredicate",
                "InferredPredicate"
              ),
              optional: true
            }
          }
        )
      });
      var patternLikeCommon = function patternLikeCommon() {
        return {
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)(
              "TypeAnnotation",
              "TSTypeAnnotation",
              "Noop"
            ),
            optional: true
          },
          optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          decorators: {
            validate: (0, _utils.arrayOfType)("Decorator"),
            optional: true
          }
        };
      };
      core.patternLikeCommon = patternLikeCommon;
      defineType("Identifier", {
        builder: ["name"],
        visitor: ["typeAnnotation", "decorators"],
        aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
        fields: Object.assign({}, patternLikeCommon(), {
          name: {
            validate: process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.chain)(
                  (0, _utils.assertValueType)("string"),
                  Object.assign(
                    function (node, key, val) {
                      if (!(0, _isValidIdentifier["default"])(val, false)) {
                        throw new TypeError(
                          '"'.concat(val, '" is not a valid identifier name')
                        );
                      }
                    },
                    { type: "string" }
                  )
                )
              : (0, _utils.assertValueType)("string")
          }
        }),
        validate: process.env.BABEL_TYPES_8_BREAKING
          ? function (parent, key, node) {
              var match = /\.(\w+)$/.exec(key);
              if (!match) return;
              var _match = _slicedToArray(match, 2),
                parentKey = _match[1];
              var nonComp = { computed: false };
              if (parentKey === "property") {
                if ((0, _is["default"])("MemberExpression", parent, nonComp))
                  return;
                if (
                  (0, _is["default"])(
                    "OptionalMemberExpression",
                    parent,
                    nonComp
                  )
                )
                  return;
              } else if (parentKey === "key") {
                if ((0, _is["default"])("Property", parent, nonComp)) return;
                if ((0, _is["default"])("Method", parent, nonComp)) return;
              } else if (parentKey === "exported") {
                if ((0, _is["default"])("ExportSpecifier", parent)) return;
              } else if (parentKey === "imported") {
                if (
                  (0, _is["default"])("ImportSpecifier", parent, {
                    imported: node
                  })
                )
                  return;
              } else if (parentKey === "meta") {
                if ((0, _is["default"])("MetaProperty", parent, { meta: node }))
                  return;
              }
              if (
                ((0, _helperValidatorIdentifier.isKeyword)(node.name) ||
                  (0, _helperValidatorIdentifier.isReservedWord)(
                    node.name,
                    false
                  )) &&
                node.name !== "this"
              ) {
                throw new TypeError(
                  '"'.concat(node.name, '" is not a valid identifier')
                );
              }
            }
          : undefined
      });
      defineType("IfStatement", {
        visitor: ["test", "consequent", "alternate"],
        aliases: ["Statement", "Conditional"],
        fields: {
          test: { validate: (0, _utils.assertNodeType)("Expression") },
          consequent: { validate: (0, _utils.assertNodeType)("Statement") },
          alternate: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      defineType("LabeledStatement", {
        visitor: ["label", "body"],
        aliases: ["Statement"],
        fields: {
          label: { validate: (0, _utils.assertNodeType)("Identifier") },
          body: { validate: (0, _utils.assertNodeType)("Statement") }
        }
      });
      defineType("StringLiteral", {
        builder: ["value"],
        fields: { value: { validate: (0, _utils.assertValueType)("string") } },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("NumericLiteral", {
        builder: ["value"],
        deprecatedAlias: "NumberLiteral",
        fields: {
          value: {
            validate: (0, _utils.chain)(
              (0, _utils.assertValueType)("number"),
              Object.assign(function (node, key, val) {}, { type: "number" })
            )
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("NullLiteral", {
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("BooleanLiteral", {
        builder: ["value"],
        fields: { value: { validate: (0, _utils.assertValueType)("boolean") } },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("RegExpLiteral", {
        builder: ["pattern", "flags"],
        deprecatedAlias: "RegexLiteral",
        aliases: ["Expression", "Pureish", "Literal"],
        fields: {
          pattern: { validate: (0, _utils.assertValueType)("string") },
          flags: {
            validate: process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.chain)(
                  (0, _utils.assertValueType)("string"),
                  Object.assign(
                    function (node, key, val) {
                      var invalid = /[^gimsuy]/.exec(val);
                      if (invalid) {
                        throw new TypeError(
                          '"'.concat(invalid[0], '" is not a valid RegExp flag')
                        );
                      }
                    },
                    { type: "string" }
                  )
                )
              : (0, _utils.assertValueType)("string"),
            default: ""
          }
        }
      });
      defineType("LogicalExpression", {
        builder: ["operator", "left", "right"],
        visitor: ["left", "right"],
        aliases: ["Binary", "Expression"],
        fields: {
          operator: {
            validate: (0, _utils.assertOneOf).apply(
              void 0,
              _toConsumableArray(_index.LOGICAL_OPERATORS)
            )
          },
          left: { validate: (0, _utils.assertNodeType)("Expression") },
          right: { validate: (0, _utils.assertNodeType)("Expression") }
        }
      });
      defineType("MemberExpression", {
        builder: ["object", "property", "computed"].concat(
          _toConsumableArray(
            !process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []
          )
        ),
        visitor: ["object", "property"],
        aliases: ["Expression", "LVal"],
        fields: Object.assign(
          {
            object: {
              validate: (0, _utils.assertNodeType)("Expression", "Super")
            },
            property: {
              validate: (function () {
                var normal = (0, _utils.assertNodeType)(
                  "Identifier",
                  "PrivateName"
                );
                var computed = (0, _utils.assertNodeType)("Expression");
                var validator = function validator(node, key, val) {
                  var validator = node.computed ? computed : normal;
                  validator(node, key, val);
                };
                validator.oneOfNodeTypes = [
                  "Expression",
                  "Identifier",
                  "PrivateName"
                ];
                return validator;
              })()
            },
            computed: { default: false }
          },
          !process.env.BABEL_TYPES_8_BREAKING
            ? {
                optional: {
                  validate: (0, _utils.assertValueType)("boolean"),
                  optional: true
                }
              }
            : {}
        )
      });
      defineType("NewExpression", { inherits: "CallExpression" });
      defineType("Program", {
        visitor: ["directives", "body"],
        builder: ["body", "directives", "sourceType", "interpreter"],
        fields: {
          sourceType: {
            validate: (0, _utils.assertOneOf)("script", "module"),
            default: "script"
          },
          interpreter: {
            validate: (0, _utils.assertNodeType)("InterpreterDirective"),
            default: null,
            optional: true
          },
          directives: {
            validate: (0, _utils.arrayOfType)("Directive"),
            default: []
          },
          body: (0, _utils.validateArrayOfType)("Statement")
        },
        aliases: ["Scopable", "BlockParent", "Block"]
      });
      defineType("ObjectExpression", {
        visitor: ["properties"],
        aliases: ["Expression"],
        fields: {
          properties: (0, _utils.validateArrayOfType)(
            "ObjectMethod",
            "ObjectProperty",
            "SpreadElement"
          )
        }
      });
      defineType("ObjectMethod", {
        builder: [
          "kind",
          "key",
          "params",
          "body",
          "computed",
          "generator",
          "async"
        ],
        visitor: [
          "decorators",
          "key",
          "typeParameters",
          "params",
          "returnType",
          "body"
        ],
        fields: Object.assign(
          {},
          functionCommon(),
          functionTypeAnnotationCommon(),
          {
            kind: Object.assign(
              { validate: (0, _utils.assertOneOf)("method", "get", "set") },
              !process.env.BABEL_TYPES_8_BREAKING ? { default: "method" } : {}
            ),
            computed: { default: false },
            key: {
              validate: (function () {
                var normal = (0, _utils.assertNodeType)(
                  "Identifier",
                  "StringLiteral",
                  "NumericLiteral",
                  "BigIntLiteral"
                );
                var computed = (0, _utils.assertNodeType)("Expression");
                var validator = function validator(node, key, val) {
                  var validator = node.computed ? computed : normal;
                  validator(node, key, val);
                };
                validator.oneOfNodeTypes = [
                  "Expression",
                  "Identifier",
                  "StringLiteral",
                  "NumericLiteral",
                  "BigIntLiteral"
                ];
                return validator;
              })()
            },
            decorators: {
              validate: (0, _utils.arrayOfType)("Decorator"),
              optional: true
            },
            body: { validate: (0, _utils.assertNodeType)("BlockStatement") }
          }
        ),
        aliases: [
          "UserWhitespacable",
          "Function",
          "Scopable",
          "BlockParent",
          "FunctionParent",
          "Method",
          "ObjectMember"
        ]
      });
      defineType("ObjectProperty", {
        builder: ["key", "value", "computed", "shorthand"].concat(
          _toConsumableArray(
            !process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []
          )
        ),
        fields: {
          computed: { default: false },
          key: {
            validate: (function () {
              var normal = (0, _utils.assertNodeType)(
                "Identifier",
                "StringLiteral",
                "NumericLiteral",
                "BigIntLiteral",
                "DecimalLiteral",
                "PrivateName"
              );
              var computed = (0, _utils.assertNodeType)("Expression");
              var validator = Object.assign(
                function (node, key, val) {
                  var validator = node.computed ? computed : normal;
                  validator(node, key, val);
                },
                {
                  oneOfNodeTypes: [
                    "Expression",
                    "Identifier",
                    "StringLiteral",
                    "NumericLiteral",
                    "BigIntLiteral",
                    "DecimalLiteral",
                    "PrivateName"
                  ]
                }
              );
              return validator;
            })()
          },
          value: {
            validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
          },
          shorthand: {
            validate: process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.chain)(
                  (0, _utils.assertValueType)("boolean"),
                  Object.assign(
                    function (node, key, shorthand) {
                      if (!shorthand) return;
                      if (node.computed) {
                        throw new TypeError(
                          "Property shorthand of ObjectProperty cannot be true if computed is true"
                        );
                      }
                      if (!(0, _is["default"])("Identifier", node.key)) {
                        throw new TypeError(
                          "Property shorthand of ObjectProperty cannot be true if key is not an Identifier"
                        );
                      }
                    },
                    { type: "boolean" }
                  )
                )
              : (0, _utils.assertValueType)("boolean"),
            default: false
          },
          decorators: {
            validate: (0, _utils.arrayOfType)("Decorator"),
            optional: true
          }
        },
        visitor: ["key", "value", "decorators"],
        aliases: ["UserWhitespacable", "Property", "ObjectMember"],
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? undefined
          : (function () {
              var pattern = (0, _utils.assertNodeType)(
                "Identifier",
                "Pattern",
                "TSAsExpression",
                "TSSatisfiesExpression",
                "TSNonNullExpression",
                "TSTypeAssertion"
              );
              var expression = (0, _utils.assertNodeType)("Expression");
              return function (parent, key, node) {
                var validator = (0, _is["default"])("ObjectPattern", parent)
                  ? pattern
                  : expression;
                validator(node, "value", node.value);
              };
            })()
      });
      defineType("RestElement", {
        visitor: ["argument", "typeAnnotation"],
        builder: ["argument"],
        aliases: ["LVal", "PatternLike"],
        deprecatedAlias: "RestProperty",
        fields: Object.assign({}, patternLikeCommon(), {
          argument: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.assertNodeType)("LVal")
              : (0, _utils.assertNodeType)(
                  "Identifier",
                  "ArrayPattern",
                  "ObjectPattern",
                  "MemberExpression",
                  "TSAsExpression",
                  "TSSatisfiesExpression",
                  "TSTypeAssertion",
                  "TSNonNullExpression"
                )
          }
        }),
        validate: process.env.BABEL_TYPES_8_BREAKING
          ? function (parent, key) {
              var match = /(\w+)\[(\d+)\]/.exec(key);
              if (!match)
                throw new Error("Internal Babel error: malformed key.");
              var _match2 = _slicedToArray(match, 3),
                listKey = _match2[1],
                index = _match2[2];
              if (parent[listKey].length > +index + 1) {
                throw new TypeError(
                  "RestElement must be last element of ".concat(listKey)
                );
              }
            }
          : undefined
      });
      defineType("ReturnStatement", {
        visitor: ["argument"],
        aliases: ["Statement", "Terminatorless", "CompletionStatement"],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          }
        }
      });
      defineType("SequenceExpression", {
        visitor: ["expressions"],
        fields: { expressions: (0, _utils.validateArrayOfType)("Expression") },
        aliases: ["Expression"]
      });
      defineType("ParenthesizedExpression", {
        visitor: ["expression"],
        aliases: ["Expression", "ExpressionWrapper"],
        fields: {
          expression: { validate: (0, _utils.assertNodeType)("Expression") }
        }
      });
      defineType("SwitchCase", {
        visitor: ["test", "consequent"],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          consequent: (0, _utils.validateArrayOfType)("Statement")
        }
      });
      defineType("SwitchStatement", {
        visitor: ["discriminant", "cases"],
        aliases: ["Statement", "BlockParent", "Scopable"],
        fields: {
          discriminant: { validate: (0, _utils.assertNodeType)("Expression") },
          cases: (0, _utils.validateArrayOfType)("SwitchCase")
        }
      });
      defineType("ThisExpression", { aliases: ["Expression"] });
      defineType("ThrowStatement", {
        visitor: ["argument"],
        aliases: ["Statement", "Terminatorless", "CompletionStatement"],
        fields: {
          argument: { validate: (0, _utils.assertNodeType)("Expression") }
        }
      });
      defineType("TryStatement", {
        visitor: ["block", "handler", "finalizer"],
        aliases: ["Statement"],
        fields: {
          block: {
            validate: process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.chain)(
                  (0, _utils.assertNodeType)("BlockStatement"),
                  Object.assign(
                    function (node) {
                      if (!node.handler && !node.finalizer) {
                        throw new TypeError(
                          "TryStatement expects either a handler or finalizer, or both"
                        );
                      }
                    },
                    { oneOfNodeTypes: ["BlockStatement"] }
                  )
                )
              : (0, _utils.assertNodeType)("BlockStatement")
          },
          handler: {
            optional: true,
            validate: (0, _utils.assertNodeType)("CatchClause")
          },
          finalizer: {
            optional: true,
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        }
      });
      defineType("UnaryExpression", {
        builder: ["operator", "argument", "prefix"],
        fields: {
          prefix: { default: true },
          argument: { validate: (0, _utils.assertNodeType)("Expression") },
          operator: {
            validate: (0, _utils.assertOneOf).apply(
              void 0,
              _toConsumableArray(_index.UNARY_OPERATORS)
            )
          }
        },
        visitor: ["argument"],
        aliases: ["UnaryLike", "Expression"]
      });
      defineType("UpdateExpression", {
        builder: ["operator", "argument", "prefix"],
        fields: {
          prefix: { default: false },
          argument: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.assertNodeType)("Expression")
              : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
          },
          operator: {
            validate: (0, _utils.assertOneOf).apply(
              void 0,
              _toConsumableArray(_index.UPDATE_OPERATORS)
            )
          }
        },
        visitor: ["argument"],
        aliases: ["Expression"]
      });
      defineType("VariableDeclaration", {
        builder: ["kind", "declarations"],
        visitor: ["declarations"],
        aliases: ["Statement", "Declaration"],
        fields: {
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          kind: {
            validate: (0, _utils.assertOneOf)(
              "var",
              "let",
              "const",
              "using",
              "await using"
            )
          },
          declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")
        },
        validate: process.env.BABEL_TYPES_8_BREAKING
          ? (function () {
              var withoutInit = (0, _utils.assertNodeType)("Identifier");
              return function (parent, key, node) {
                if (
                  (0, _is["default"])("ForXStatement", parent, { left: node })
                ) {
                  if (node.declarations.length !== 1) {
                    throw new TypeError(
                      "Exactly one VariableDeclarator is required in the VariableDeclaration of a ".concat(
                        parent.type
                      )
                    );
                  }
                } else {
                  node.declarations.forEach(function (decl) {
                    if (!decl.init) withoutInit(decl, "id", decl.id);
                  });
                }
              };
            })()
          : undefined
      });
      defineType("VariableDeclarator", {
        visitor: ["id", "init"],
        fields: {
          id: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.assertNodeType)("LVal")
              : (0, _utils.assertNodeType)(
                  "Identifier",
                  "ArrayPattern",
                  "ObjectPattern"
                )
          },
          definite: {
            optional: true,
            validate: (0, _utils.assertValueType)("boolean")
          },
          init: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("WhileStatement", {
        visitor: ["test", "body"],
        aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
        fields: {
          test: { validate: (0, _utils.assertNodeType)("Expression") },
          body: { validate: (0, _utils.assertNodeType)("Statement") }
        }
      });
      defineType("WithStatement", {
        visitor: ["object", "body"],
        aliases: ["Statement"],
        fields: {
          object: { validate: (0, _utils.assertNodeType)("Expression") },
          body: { validate: (0, _utils.assertNodeType)("Statement") }
        }
      });
      defineType("AssignmentPattern", {
        visitor: ["left", "right", "decorators"],
        builder: ["left", "right"],
        aliases: ["Pattern", "PatternLike", "LVal"],
        fields: Object.assign({}, patternLikeCommon(), {
          left: {
            validate: (0, _utils.assertNodeType)(
              "Identifier",
              "ObjectPattern",
              "ArrayPattern",
              "MemberExpression",
              "TSAsExpression",
              "TSSatisfiesExpression",
              "TSTypeAssertion",
              "TSNonNullExpression"
            )
          },
          right: { validate: (0, _utils.assertNodeType)("Expression") },
          decorators: {
            validate: (0, _utils.arrayOfType)("Decorator"),
            optional: true
          }
        })
      });
      defineType("ArrayPattern", {
        visitor: ["elements", "typeAnnotation"],
        builder: ["elements"],
        aliases: ["Pattern", "PatternLike", "LVal"],
        fields: Object.assign({}, patternLikeCommon(), {
          elements: {
            validate: (0, _utils.chain)(
              (0, _utils.assertValueType)("array"),
              (0, _utils.assertEach)(
                (0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")
              )
            )
          }
        })
      });
      defineType("ArrowFunctionExpression", {
        builder: ["params", "body", "async"],
        visitor: ["typeParameters", "params", "returnType", "body"],
        aliases: [
          "Scopable",
          "Function",
          "BlockParent",
          "FunctionParent",
          "Expression",
          "Pureish"
        ],
        fields: Object.assign(
          {},
          functionCommon(),
          functionTypeAnnotationCommon(),
          {
            expression: { validate: (0, _utils.assertValueType)("boolean") },
            body: {
              validate: (0, _utils.assertNodeType)(
                "BlockStatement",
                "Expression"
              )
            },
            predicate: {
              validate: (0, _utils.assertNodeType)(
                "DeclaredPredicate",
                "InferredPredicate"
              ),
              optional: true
            }
          }
        )
      });
      defineType("ClassBody", {
        visitor: ["body"],
        fields: {
          body: (0, _utils.validateArrayOfType)(
            "ClassMethod",
            "ClassPrivateMethod",
            "ClassProperty",
            "ClassPrivateProperty",
            "ClassAccessorProperty",
            "TSDeclareMethod",
            "TSIndexSignature",
            "StaticBlock"
          )
        }
      });
      defineType("ClassExpression", {
        builder: ["id", "superClass", "body", "decorators"],
        visitor: [
          "decorators",
          "id",
          "typeParameters",
          "superClass",
          "superTypeParameters",
          "mixins",
          "implements",
          "body"
        ],
        aliases: ["Scopable", "Class", "Expression"],
        fields: {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)(
              "TypeParameterDeclaration",
              "TSTypeParameterDeclaration",
              "Noop"
            ),
            optional: true
          },
          body: { validate: (0, _utils.assertNodeType)("ClassBody") },
          superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
          },
          superTypeParameters: {
            validate: (0, _utils.assertNodeType)(
              "TypeParameterInstantiation",
              "TSTypeParameterInstantiation"
            ),
            optional: true
          },
          implements: {
            validate: (0, _utils.arrayOfType)(
              "TSExpressionWithTypeArguments",
              "ClassImplements"
            ),
            optional: true
          },
          decorators: {
            validate: (0, _utils.arrayOfType)("Decorator"),
            optional: true
          },
          mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
          }
        }
      });
      defineType("ClassDeclaration", {
        inherits: "ClassExpression",
        aliases: ["Scopable", "Class", "Statement", "Declaration"],
        fields: {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)(
              "TypeParameterDeclaration",
              "TSTypeParameterDeclaration",
              "Noop"
            ),
            optional: true
          },
          body: { validate: (0, _utils.assertNodeType)("ClassBody") },
          superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
          },
          superTypeParameters: {
            validate: (0, _utils.assertNodeType)(
              "TypeParameterInstantiation",
              "TSTypeParameterInstantiation"
            ),
            optional: true
          },
          implements: {
            validate: (0, _utils.arrayOfType)(
              "TSExpressionWithTypeArguments",
              "ClassImplements"
            ),
            optional: true
          },
          decorators: {
            validate: (0, _utils.arrayOfType)("Decorator"),
            optional: true
          },
          mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
          },
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          abstract: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          }
        },
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? undefined
          : (function () {
              var identifier = (0, _utils.assertNodeType)("Identifier");
              return function (parent, key, node) {
                if (!(0, _is["default"])("ExportDefaultDeclaration", parent)) {
                  identifier(node, "id", node.id);
                }
              };
            })()
      });
      var importAttributes = (core.importAttributes = {
        attributes: {
          optional: true,
          validate: (0, _utils.arrayOfType)("ImportAttribute")
        },
        assertions: {
          deprecated: true,
          optional: true,
          validate: (0, _utils.arrayOfType)("ImportAttribute")
        }
      });
      defineType("ExportAllDeclaration", {
        builder: ["source"],
        visitor: ["source", "attributes", "assertions"],
        aliases: [
          "Statement",
          "Declaration",
          "ImportOrExportDeclaration",
          "ExportDeclaration"
        ],
        fields: Object.assign(
          {
            source: { validate: (0, _utils.assertNodeType)("StringLiteral") },
            exportKind: (0, _utils.validateOptional)(
              (0, _utils.assertOneOf)("type", "value")
            )
          },
          importAttributes
        )
      });
      defineType("ExportDefaultDeclaration", {
        visitor: ["declaration"],
        aliases: [
          "Statement",
          "Declaration",
          "ImportOrExportDeclaration",
          "ExportDeclaration"
        ],
        fields: {
          declaration: (0, _utils.validateType)(
            "TSDeclareFunction",
            "FunctionDeclaration",
            "ClassDeclaration",
            "Expression"
          ),
          exportKind: (0, _utils.validateOptional)(
            (0, _utils.assertOneOf)("value")
          )
        }
      });
      defineType("ExportNamedDeclaration", {
        builder: ["declaration", "specifiers", "source"],
        visitor: process.env
          ? ["declaration", "specifiers", "source", "attributes"]
          : ["declaration", "specifiers", "source", "attributes", "assertions"],
        aliases: [
          "Statement",
          "Declaration",
          "ImportOrExportDeclaration",
          "ExportDeclaration"
        ],
        fields: Object.assign(
          {
            declaration: {
              optional: true,
              validate: process.env.BABEL_TYPES_8_BREAKING
                ? (0, _utils.chain)(
                    (0, _utils.assertNodeType)("Declaration"),
                    Object.assign(
                      function (node, key, val) {
                        if (val && node.specifiers.length) {
                          throw new TypeError(
                            "Only declaration or specifiers is allowed on ExportNamedDeclaration"
                          );
                        }
                        if (val && node.source) {
                          throw new TypeError(
                            "Cannot export a declaration from a source"
                          );
                        }
                      },
                      { oneOfNodeTypes: ["Declaration"] }
                    )
                  )
                : (0, _utils.assertNodeType)("Declaration")
            }
          },
          importAttributes,
          {
            specifiers: {
              default: [],
              validate: (0, _utils.arrayOf)(
                (function () {
                  var sourced = (0, _utils.assertNodeType)(
                    "ExportSpecifier",
                    "ExportDefaultSpecifier",
                    "ExportNamespaceSpecifier"
                  );
                  var sourceless = (0, _utils.assertNodeType)(
                    "ExportSpecifier"
                  );
                  if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
                  return Object.assign(
                    function (node, key, val) {
                      var validator = node.source ? sourced : sourceless;
                      validator(node, key, val);
                    },
                    {
                      oneOfNodeTypes: [
                        "ExportSpecifier",
                        "ExportDefaultSpecifier",
                        "ExportNamespaceSpecifier"
                      ]
                    }
                  );
                })()
              )
            },
            source: {
              validate: (0, _utils.assertNodeType)("StringLiteral"),
              optional: true
            },
            exportKind: (0, _utils.validateOptional)(
              (0, _utils.assertOneOf)("type", "value")
            )
          }
        )
      });
      defineType("ExportSpecifier", {
        visitor: ["local", "exported"],
        aliases: ["ModuleSpecifier"],
        fields: {
          local: { validate: (0, _utils.assertNodeType)("Identifier") },
          exported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
          },
          exportKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
          }
        }
      });
      defineType("ForOfStatement", {
        visitor: ["left", "right", "body"],
        builder: ["left", "right", "body", "await"],
        aliases: [
          "Scopable",
          "Statement",
          "For",
          "BlockParent",
          "Loop",
          "ForXStatement"
        ],
        fields: {
          left: {
            validate: (function () {
              if (!process.env.BABEL_TYPES_8_BREAKING) {
                return (0, _utils.assertNodeType)(
                  "VariableDeclaration",
                  "LVal"
                );
              }
              var declaration = (0, _utils.assertNodeType)(
                "VariableDeclaration"
              );
              var lval = (0, _utils.assertNodeType)(
                "Identifier",
                "MemberExpression",
                "ArrayPattern",
                "ObjectPattern",
                "TSAsExpression",
                "TSSatisfiesExpression",
                "TSTypeAssertion",
                "TSNonNullExpression"
              );
              return Object.assign(
                function (node, key, val) {
                  if ((0, _is["default"])("VariableDeclaration", val)) {
                    declaration(node, key, val);
                  } else {
                    lval(node, key, val);
                  }
                },
                {
                  oneOfNodeTypes: [
                    "VariableDeclaration",
                    "Identifier",
                    "MemberExpression",
                    "ArrayPattern",
                    "ObjectPattern",
                    "TSAsExpression",
                    "TSSatisfiesExpression",
                    "TSTypeAssertion",
                    "TSNonNullExpression"
                  ]
                }
              );
            })()
          },
          right: { validate: (0, _utils.assertNodeType)("Expression") },
          body: { validate: (0, _utils.assertNodeType)("Statement") },
          await: { default: false }
        }
      });
      defineType("ImportDeclaration", {
        builder: ["specifiers", "source"],
        visitor: ["specifiers", "source", "attributes", "assertions"],
        aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
        fields: Object.assign({}, importAttributes, {
          module: {
            optional: true,
            validate: (0, _utils.assertValueType)("boolean")
          },
          phase: {
            default: null,
            validate: (0, _utils.assertOneOf)("source", "defer")
          },
          specifiers: (0, _utils.validateArrayOfType)(
            "ImportSpecifier",
            "ImportDefaultSpecifier",
            "ImportNamespaceSpecifier"
          ),
          source: { validate: (0, _utils.assertNodeType)("StringLiteral") },
          importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
          }
        })
      });
      defineType("ImportDefaultSpecifier", {
        visitor: ["local"],
        aliases: ["ModuleSpecifier"],
        fields: {
          local: { validate: (0, _utils.assertNodeType)("Identifier") }
        }
      });
      defineType("ImportNamespaceSpecifier", {
        visitor: ["local"],
        aliases: ["ModuleSpecifier"],
        fields: {
          local: { validate: (0, _utils.assertNodeType)("Identifier") }
        }
      });
      defineType("ImportSpecifier", {
        visitor: ["imported", "local"],
        builder: ["local", "imported"],
        aliases: ["ModuleSpecifier"],
        fields: {
          local: { validate: (0, _utils.assertNodeType)("Identifier") },
          imported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
          },
          importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
          }
        }
      });
      defineType("ImportExpression", {
        visitor: ["source", "options"],
        aliases: ["Expression"],
        fields: {
          phase: {
            default: null,
            validate: (0, _utils.assertOneOf)("source", "defer")
          },
          source: { validate: (0, _utils.assertNodeType)("Expression") },
          options: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          }
        }
      });
      defineType("MetaProperty", {
        visitor: ["meta", "property"],
        aliases: ["Expression"],
        fields: {
          meta: {
            validate: process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.chain)(
                  (0, _utils.assertNodeType)("Identifier"),
                  Object.assign(
                    function (node, key, val) {
                      var property;
                      switch (val.name) {
                        case "function":
                          property = "sent";
                          break;
                        case "new":
                          property = "target";
                          break;
                        case "import":
                          property = "meta";
                          break;
                      }
                      if (
                        !(0, _is["default"])("Identifier", node.property, {
                          name: property
                        })
                      ) {
                        throw new TypeError("Unrecognised MetaProperty");
                      }
                    },
                    { oneOfNodeTypes: ["Identifier"] }
                  )
                )
              : (0, _utils.assertNodeType)("Identifier")
          },
          property: { validate: (0, _utils.assertNodeType)("Identifier") }
        }
      });
      var classMethodOrPropertyCommon = function classMethodOrPropertyCommon() {
        return {
          abstract: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          accessibility: {
            validate: (0, _utils.assertOneOf)("public", "private", "protected"),
            optional: true
          },
          static: { default: false },
          override: { default: false },
          computed: { default: false },
          optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          key: {
            validate: (0, _utils.chain)(
              (function () {
                var normal = (0, _utils.assertNodeType)(
                  "Identifier",
                  "StringLiteral",
                  "NumericLiteral",
                  "BigIntLiteral"
                );
                var computed = (0, _utils.assertNodeType)("Expression");
                return function (node, key, val) {
                  var validator = node.computed ? computed : normal;
                  validator(node, key, val);
                };
              })(),
              (0, _utils.assertNodeType)(
                "Identifier",
                "StringLiteral",
                "NumericLiteral",
                "BigIntLiteral",
                "Expression"
              )
            )
          }
        };
      };
      core.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
      var classMethodOrDeclareMethodCommon =
        function classMethodOrDeclareMethodCommon() {
          return Object.assign(
            {},
            functionCommon(),
            classMethodOrPropertyCommon(),
            {
              params: (0, _utils.validateArrayOfType)(
                "Identifier",
                "Pattern",
                "RestElement",
                "TSParameterProperty"
              ),
              kind: {
                validate: (0, _utils.assertOneOf)(
                  "get",
                  "set",
                  "method",
                  "constructor"
                ),
                default: "method"
              },
              access: {
                validate: (0, _utils.chain)(
                  (0, _utils.assertValueType)("string"),
                  (0, _utils.assertOneOf)("public", "private", "protected")
                ),
                optional: true
              },
              decorators: {
                validate: (0, _utils.arrayOfType)("Decorator"),
                optional: true
              }
            }
          );
        };
      core.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
      defineType("ClassMethod", {
        aliases: [
          "Function",
          "Scopable",
          "BlockParent",
          "FunctionParent",
          "Method"
        ],
        builder: [
          "kind",
          "key",
          "params",
          "body",
          "computed",
          "static",
          "generator",
          "async"
        ],
        visitor: [
          "decorators",
          "key",
          "typeParameters",
          "params",
          "returnType",
          "body"
        ],
        fields: Object.assign(
          {},
          classMethodOrDeclareMethodCommon(),
          functionTypeAnnotationCommon(),
          { body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }
        )
      });
      defineType("ObjectPattern", {
        visitor: ["properties", "typeAnnotation", "decorators"],
        builder: ["properties"],
        aliases: ["Pattern", "PatternLike", "LVal"],
        fields: Object.assign({}, patternLikeCommon(), {
          properties: (0, _utils.validateArrayOfType)(
            "RestElement",
            "ObjectProperty"
          )
        })
      });
      defineType("SpreadElement", {
        visitor: ["argument"],
        aliases: ["UnaryLike"],
        deprecatedAlias: "SpreadProperty",
        fields: {
          argument: { validate: (0, _utils.assertNodeType)("Expression") }
        }
      });
      defineType("Super", { aliases: ["Expression"] });
      defineType("TaggedTemplateExpression", {
        visitor: ["tag", "typeParameters", "quasi"],
        builder: ["tag", "quasi"],
        aliases: ["Expression"],
        fields: {
          tag: { validate: (0, _utils.assertNodeType)("Expression") },
          quasi: { validate: (0, _utils.assertNodeType)("TemplateLiteral") },
          typeParameters: {
            validate: (0, _utils.assertNodeType)(
              "TypeParameterInstantiation",
              "TSTypeParameterInstantiation"
            ),
            optional: true
          }
        }
      });
      defineType("TemplateElement", {
        builder: ["value", "tail"],
        fields: {
          value: {
            validate: (0, _utils.chain)(
              (0, _utils.assertShape)({
                raw: { validate: (0, _utils.assertValueType)("string") },
                cooked: {
                  validate: (0, _utils.assertValueType)("string"),
                  optional: true
                }
              }),
              function templateElementCookedValidator(node) {
                var raw = node.value.raw;
                var unterminatedCalled = false;
                var error = function error() {
                  throw new Error("Internal @babel/types error.");
                };
                var _ref14 = (0, _helperStringParser.readStringContents)(
                    "template",
                    raw,
                    0,
                    0,
                    0,
                    {
                      unterminated: function unterminated() {
                        unterminatedCalled = true;
                      },
                      strictNumericEscape: error,
                      invalidEscapeSequence: error,
                      numericSeparatorInEscapeSequence: error,
                      unexpectedNumericSeparator: error,
                      invalidDigit: error,
                      invalidCodePoint: error
                    }
                  ),
                  str = _ref14.str,
                  firstInvalidLoc = _ref14.firstInvalidLoc;
                if (!unterminatedCalled) throw new Error("Invalid raw");
                node.value.cooked = firstInvalidLoc ? null : str;
              }
            )
          },
          tail: { default: false }
        }
      });
      defineType("TemplateLiteral", {
        visitor: ["quasis", "expressions"],
        aliases: ["Expression", "Literal"],
        fields: {
          quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
          expressions: {
            validate: (0, _utils.chain)(
              (0, _utils.assertValueType)("array"),
              (0, _utils.assertEach)(
                (0, _utils.assertNodeType)("Expression", "TSType")
              ),
              function (node, key, val) {
                if (node.quasis.length !== val.length + 1) {
                  throw new TypeError(
                    "Number of "
                      .concat(
                        node.type,
                        " quasis should be exactly one more than the number of expressions.\nExpected "
                      )
                      .concat(val.length + 1, " quasis but got ")
                      .concat(node.quasis.length)
                  );
                }
              }
            )
          }
        }
      });
      defineType("YieldExpression", {
        builder: ["argument", "delegate"],
        visitor: ["argument"],
        aliases: ["Expression", "Terminatorless"],
        fields: {
          delegate: {
            validate: process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.chain)(
                  (0, _utils.assertValueType)("boolean"),
                  Object.assign(
                    function (node, key, val) {
                      if (val && !node.argument) {
                        throw new TypeError(
                          "Property delegate of YieldExpression cannot be true if there is no argument"
                        );
                      }
                    },
                    { type: "boolean" }
                  )
                )
              : (0, _utils.assertValueType)("boolean"),
            default: false
          },
          argument: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      });
      defineType("AwaitExpression", {
        builder: ["argument"],
        visitor: ["argument"],
        aliases: ["Expression", "Terminatorless"],
        fields: {
          argument: { validate: (0, _utils.assertNodeType)("Expression") }
        }
      });
      defineType("Import", { aliases: ["Expression"] });
      defineType("BigIntLiteral", {
        builder: ["value"],
        fields: { value: { validate: (0, _utils.assertValueType)("string") } },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
      defineType("ExportNamespaceSpecifier", {
        visitor: ["exported"],
        aliases: ["ModuleSpecifier"],
        fields: {
          exported: { validate: (0, _utils.assertNodeType)("Identifier") }
        }
      });
      defineType("OptionalMemberExpression", {
        builder: ["object", "property", "computed", "optional"],
        visitor: ["object", "property"],
        aliases: ["Expression"],
        fields: {
          object: { validate: (0, _utils.assertNodeType)("Expression") },
          property: {
            validate: (function () {
              var normal = (0, _utils.assertNodeType)("Identifier");
              var computed = (0, _utils.assertNodeType)("Expression");
              var validator = Object.assign(
                function (node, key, val) {
                  var validator = node.computed ? computed : normal;
                  validator(node, key, val);
                },
                { oneOfNodeTypes: ["Expression", "Identifier"] }
              );
              return validator;
            })()
          },
          computed: { default: false },
          optional: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.assertValueType)("boolean")
              : (0, _utils.chain)(
                  (0, _utils.assertValueType)("boolean"),
                  (0, _utils.assertOptionalChainStart)()
                )
          }
        }
      });
      defineType("OptionalCallExpression", {
        visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
        builder: ["callee", "arguments", "optional"],
        aliases: ["Expression"],
        fields: {
          callee: { validate: (0, _utils.assertNodeType)("Expression") },
          arguments: (0, _utils.validateArrayOfType)(
            "Expression",
            "SpreadElement",
            "ArgumentPlaceholder"
          ),
          optional: {
            validate: !process.env.BABEL_TYPES_8_BREAKING
              ? (0, _utils.assertValueType)("boolean")
              : (0, _utils.chain)(
                  (0, _utils.assertValueType)("boolean"),
                  (0, _utils.assertOptionalChainStart)()
                )
          },
          typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)(
              "TSTypeParameterInstantiation"
            ),
            optional: true
          }
        }
      });
      defineType("ClassProperty", {
        visitor: ["decorators", "key", "typeAnnotation", "value"],
        builder: [
          "key",
          "value",
          "typeAnnotation",
          "decorators",
          "computed",
          "static"
        ],
        aliases: ["Property"],
        fields: Object.assign({}, classMethodOrPropertyCommon(), {
          value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)(
              "TypeAnnotation",
              "TSTypeAnnotation",
              "Noop"
            ),
            optional: true
          },
          decorators: {
            validate: (0, _utils.arrayOfType)("Decorator"),
            optional: true
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
          }
        })
      });
      defineType("ClassAccessorProperty", {
        visitor: ["decorators", "key", "typeAnnotation", "value"],
        builder: [
          "key",
          "value",
          "typeAnnotation",
          "decorators",
          "computed",
          "static"
        ],
        aliases: ["Property", "Accessor"],
        fields: Object.assign({}, classMethodOrPropertyCommon(), {
          key: {
            validate: (0, _utils.chain)(
              (function () {
                var normal = (0, _utils.assertNodeType)(
                  "Identifier",
                  "StringLiteral",
                  "NumericLiteral",
                  "BigIntLiteral",
                  "PrivateName"
                );
                var computed = (0, _utils.assertNodeType)("Expression");
                return function (node, key, val) {
                  var validator = node.computed ? computed : normal;
                  validator(node, key, val);
                };
              })(),
              (0, _utils.assertNodeType)(
                "Identifier",
                "StringLiteral",
                "NumericLiteral",
                "BigIntLiteral",
                "Expression",
                "PrivateName"
              )
            )
          },
          value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)(
              "TypeAnnotation",
              "TSTypeAnnotation",
              "Noop"
            ),
            optional: true
          },
          decorators: {
            validate: (0, _utils.arrayOfType)("Decorator"),
            optional: true
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
          }
        })
      });
      defineType("ClassPrivateProperty", {
        visitor: ["decorators", "key", "typeAnnotation", "value"],
        builder: ["key", "value", "decorators", "static"],
        aliases: ["Property", "Private"],
        fields: {
          key: { validate: (0, _utils.assertNodeType)("PrivateName") },
          value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          },
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)(
              "TypeAnnotation",
              "TSTypeAnnotation",
              "Noop"
            ),
            optional: true
          },
          decorators: {
            validate: (0, _utils.arrayOfType)("Decorator"),
            optional: true
          },
          static: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
          }
        }
      });
      defineType("ClassPrivateMethod", {
        builder: ["kind", "key", "params", "body", "static"],
        visitor: [
          "decorators",
          "key",
          "typeParameters",
          "params",
          "returnType",
          "body"
        ],
        aliases: [
          "Function",
          "Scopable",
          "BlockParent",
          "FunctionParent",
          "Method",
          "Private"
        ],
        fields: Object.assign(
          {},
          classMethodOrDeclareMethodCommon(),
          functionTypeAnnotationCommon(),
          {
            kind: {
              validate: (0, _utils.assertOneOf)("get", "set", "method"),
              default: "method"
            },
            key: { validate: (0, _utils.assertNodeType)("PrivateName") },
            body: { validate: (0, _utils.assertNodeType)("BlockStatement") }
          }
        )
      });
      defineType("PrivateName", {
        visitor: ["id"],
        aliases: ["Private"],
        fields: { id: { validate: (0, _utils.assertNodeType)("Identifier") } }
      });
      defineType("StaticBlock", {
        visitor: ["body"],
        fields: { body: (0, _utils.validateArrayOfType)("Statement") },
        aliases: ["Scopable", "BlockParent", "FunctionParent"]
      });
      return core;
    }
    var flow$1 = {};
    var hasRequiredFlow;
    function requireFlow() {
      if (hasRequiredFlow) return flow$1;
      hasRequiredFlow = 1;
      var _core = requireCore();
      var _utils = requireUtils();
      var defineType = (0, _utils.defineAliasedType)("Flow");
      var defineInterfaceishType = function defineInterfaceishType(name) {
        var isDeclareClass = name === "DeclareClass";
        defineType(name, {
          builder: ["id", "typeParameters", "extends", "body"],
          visitor: ["id", "typeParameters", "extends"].concat(
            _toConsumableArray(isDeclareClass ? ["mixins", "implements"] : []),
            ["body"]
          ),
          aliases: ["FlowDeclaration", "Statement", "Declaration"],
          fields: Object.assign(
            {
              id: (0, _utils.validateType)("Identifier"),
              typeParameters: (0, _utils.validateOptionalType)(
                "TypeParameterDeclaration"
              ),
              extends: (0, _utils.validateOptional)(
                (0, _utils.arrayOfType)("InterfaceExtends")
              )
            },
            isDeclareClass
              ? {
                  mixins: (0, _utils.validateOptional)(
                    (0, _utils.arrayOfType)("InterfaceExtends")
                  ),
                  implements: (0, _utils.validateOptional)(
                    (0, _utils.arrayOfType)("ClassImplements")
                  )
                }
              : {},
            { body: (0, _utils.validateType)("ObjectTypeAnnotation") }
          )
        });
      };
      defineType("AnyTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("ArrayTypeAnnotation", {
        visitor: ["elementType"],
        aliases: ["FlowType"],
        fields: { elementType: (0, _utils.validateType)("FlowType") }
      });
      defineType("BooleanTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("BooleanLiteralTypeAnnotation", {
        builder: ["value"],
        aliases: ["FlowType"],
        fields: {
          value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("NullLiteralTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("ClassImplements", {
        visitor: ["id", "typeParameters"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TypeParameterInstantiation"
          )
        }
      });
      defineInterfaceishType("DeclareClass");
      defineType("DeclareFunction", {
        visitor: ["id"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
        }
      });
      defineInterfaceishType("DeclareInterface");
      defineType("DeclareModule", {
        builder: ["id", "body", "kind"],
        visitor: ["id", "body"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier", "StringLiteral"),
          body: (0, _utils.validateType)("BlockStatement"),
          kind: (0, _utils.validateOptional)(
            (0, _utils.assertOneOf)("CommonJS", "ES")
          )
        }
      });
      defineType("DeclareModuleExports", {
        visitor: ["typeAnnotation"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: { typeAnnotation: (0, _utils.validateType)("TypeAnnotation") }
      });
      defineType("DeclareTypeAlias", {
        visitor: ["id", "typeParameters", "right"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TypeParameterDeclaration"
          ),
          right: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("DeclareOpaqueType", {
        visitor: ["id", "typeParameters", "supertype"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TypeParameterDeclaration"
          ),
          supertype: (0, _utils.validateOptionalType)("FlowType"),
          impltype: (0, _utils.validateOptionalType)("FlowType")
        }
      });
      defineType("DeclareVariable", {
        visitor: ["id"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: { id: (0, _utils.validateType)("Identifier") }
      });
      defineType("DeclareExportDeclaration", {
        visitor: ["declaration", "specifiers", "source", "attributes"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: Object.assign(
          {
            declaration: (0, _utils.validateOptionalType)("Flow"),
            specifiers: (0, _utils.validateOptional)(
              (0, _utils.arrayOfType)(
                "ExportSpecifier",
                "ExportNamespaceSpecifier"
              )
            ),
            source: (0, _utils.validateOptionalType)("StringLiteral"),
            default: (0, _utils.validateOptional)(
              (0, _utils.assertValueType)("boolean")
            )
          },
          _core.importAttributes
        )
      });
      defineType("DeclareExportAllDeclaration", {
        visitor: ["source", "attributes"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: Object.assign(
          {
            source: (0, _utils.validateType)("StringLiteral"),
            exportKind: (0, _utils.validateOptional)(
              (0, _utils.assertOneOf)("type", "value")
            )
          },
          _core.importAttributes
        )
      });
      defineType("DeclaredPredicate", {
        visitor: ["value"],
        aliases: ["FlowPredicate"],
        fields: { value: (0, _utils.validateType)("Flow") }
      });
      defineType("ExistsTypeAnnotation", { aliases: ["FlowType"] });
      defineType("FunctionTypeAnnotation", {
        visitor: ["typeParameters", "params", "rest", "returnType"],
        aliases: ["FlowType"],
        fields: {
          typeParameters: (0, _utils.validateOptionalType)(
            "TypeParameterDeclaration"
          ),
          params: (0, _utils.validateArrayOfType)("FunctionTypeParam"),
          rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
          this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
          returnType: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("FunctionTypeParam", {
        visitor: ["name", "typeAnnotation"],
        fields: {
          name: (0, _utils.validateOptionalType)("Identifier"),
          typeAnnotation: (0, _utils.validateType)("FlowType"),
          optional: (0, _utils.validateOptional)(
            (0, _utils.assertValueType)("boolean")
          )
        }
      });
      defineType("GenericTypeAnnotation", {
        visitor: ["id", "typeParameters"],
        aliases: ["FlowType"],
        fields: {
          id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TypeParameterInstantiation"
          )
        }
      });
      defineType("InferredPredicate", { aliases: ["FlowPredicate"] });
      defineType("InterfaceExtends", {
        visitor: ["id", "typeParameters"],
        fields: {
          id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TypeParameterInstantiation"
          )
        }
      });
      defineInterfaceishType("InterfaceDeclaration");
      defineType("InterfaceTypeAnnotation", {
        visitor: ["extends", "body"],
        aliases: ["FlowType"],
        fields: {
          extends: (0, _utils.validateOptional)(
            (0, _utils.arrayOfType)("InterfaceExtends")
          ),
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        }
      });
      defineType("IntersectionTypeAnnotation", {
        visitor: ["types"],
        aliases: ["FlowType"],
        fields: {
          types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      });
      defineType("MixedTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("EmptyTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("NullableTypeAnnotation", {
        visitor: ["typeAnnotation"],
        aliases: ["FlowType"],
        fields: { typeAnnotation: (0, _utils.validateType)("FlowType") }
      });
      defineType("NumberLiteralTypeAnnotation", {
        builder: ["value"],
        aliases: ["FlowType"],
        fields: {
          value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
        }
      });
      defineType("NumberTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("ObjectTypeAnnotation", {
        visitor: ["properties", "indexers", "callProperties", "internalSlots"],
        aliases: ["FlowType"],
        builder: [
          "properties",
          "indexers",
          "callProperties",
          "internalSlots",
          "exact"
        ],
        fields: {
          properties: (0, _utils.validate)(
            (0, _utils.arrayOfType)(
              "ObjectTypeProperty",
              "ObjectTypeSpreadProperty"
            )
          ),
          indexers: {
            validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
            optional: true,
            default: []
          },
          callProperties: {
            validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
            optional: true,
            default: []
          },
          internalSlots: {
            validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
            optional: true,
            default: []
          },
          exact: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
          },
          inexact: (0, _utils.validateOptional)(
            (0, _utils.assertValueType)("boolean")
          )
        }
      });
      defineType("ObjectTypeInternalSlot", {
        visitor: ["id", "value"],
        builder: ["id", "value", "optional", "static", "method"],
        aliases: ["UserWhitespacable"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          value: (0, _utils.validateType)("FlowType"),
          optional: (0, _utils.validate)(
            (0, _utils.assertValueType)("boolean")
          ),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("ObjectTypeCallProperty", {
        visitor: ["value"],
        aliases: ["UserWhitespacable"],
        fields: {
          value: (0, _utils.validateType)("FlowType"),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("ObjectTypeIndexer", {
        visitor: ["variance", "id", "key", "value"],
        builder: ["id", "key", "value", "variance"],
        aliases: ["UserWhitespacable"],
        fields: {
          id: (0, _utils.validateOptionalType)("Identifier"),
          key: (0, _utils.validateType)("FlowType"),
          value: (0, _utils.validateType)("FlowType"),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          variance: (0, _utils.validateOptionalType)("Variance")
        }
      });
      defineType("ObjectTypeProperty", {
        visitor: ["key", "value", "variance"],
        aliases: ["UserWhitespacable"],
        fields: {
          key: (0, _utils.validateType)("Identifier", "StringLiteral"),
          value: (0, _utils.validateType)("FlowType"),
          kind: (0, _utils.validate)(
            (0, _utils.assertOneOf)("init", "get", "set")
          ),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          optional: (0, _utils.validate)(
            (0, _utils.assertValueType)("boolean")
          ),
          variance: (0, _utils.validateOptionalType)("Variance"),
          method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      defineType("ObjectTypeSpreadProperty", {
        visitor: ["argument"],
        aliases: ["UserWhitespacable"],
        fields: { argument: (0, _utils.validateType)("FlowType") }
      });
      defineType("OpaqueType", {
        visitor: ["id", "typeParameters", "supertype", "impltype"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TypeParameterDeclaration"
          ),
          supertype: (0, _utils.validateOptionalType)("FlowType"),
          impltype: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("QualifiedTypeIdentifier", {
        visitor: ["qualification", "id"],
        builder: ["id", "qualification"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          qualification: (0, _utils.validateType)(
            "Identifier",
            "QualifiedTypeIdentifier"
          )
        }
      });
      defineType("StringLiteralTypeAnnotation", {
        builder: ["value"],
        aliases: ["FlowType"],
        fields: {
          value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
        }
      });
      defineType("StringTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("SymbolTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("ThisTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("TupleTypeAnnotation", {
        visitor: ["types"],
        aliases: ["FlowType"],
        fields: {
          types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      });
      defineType("TypeofTypeAnnotation", {
        visitor: ["argument"],
        aliases: ["FlowType"],
        fields: { argument: (0, _utils.validateType)("FlowType") }
      });
      defineType("TypeAlias", {
        visitor: ["id", "typeParameters", "right"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TypeParameterDeclaration"
          ),
          right: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("TypeAnnotation", {
        visitor: ["typeAnnotation"],
        fields: { typeAnnotation: (0, _utils.validateType)("FlowType") }
      });
      defineType("TypeCastExpression", {
        visitor: ["expression", "typeAnnotation"],
        aliases: ["ExpressionWrapper", "Expression"],
        fields: {
          expression: (0, _utils.validateType)("Expression"),
          typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
        }
      });
      defineType("TypeParameter", {
        visitor: ["bound", "default", "variance"],
        fields: {
          name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
          bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
          default: (0, _utils.validateOptionalType)("FlowType"),
          variance: (0, _utils.validateOptionalType)("Variance")
        }
      });
      defineType("TypeParameterDeclaration", {
        visitor: ["params"],
        fields: {
          params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
        }
      });
      defineType("TypeParameterInstantiation", {
        visitor: ["params"],
        fields: {
          params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      });
      defineType("UnionTypeAnnotation", {
        visitor: ["types"],
        aliases: ["FlowType"],
        fields: {
          types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      });
      defineType("Variance", {
        builder: ["kind"],
        fields: {
          kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
        }
      });
      defineType("VoidTypeAnnotation", {
        aliases: ["FlowType", "FlowBaseAnnotation"]
      });
      defineType("EnumDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "body"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          body: (0, _utils.validateType)(
            "EnumBooleanBody",
            "EnumNumberBody",
            "EnumStringBody",
            "EnumSymbolBody"
          )
        }
      });
      defineType("EnumBooleanBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
          explicitType: (0, _utils.validate)(
            (0, _utils.assertValueType)("boolean")
          ),
          members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
          hasUnknownMembers: (0, _utils.validate)(
            (0, _utils.assertValueType)("boolean")
          )
        }
      });
      defineType("EnumNumberBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
          explicitType: (0, _utils.validate)(
            (0, _utils.assertValueType)("boolean")
          ),
          members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
          hasUnknownMembers: (0, _utils.validate)(
            (0, _utils.assertValueType)("boolean")
          )
        }
      });
      defineType("EnumStringBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
          explicitType: (0, _utils.validate)(
            (0, _utils.assertValueType)("boolean")
          ),
          members: (0, _utils.validateArrayOfType)(
            "EnumStringMember",
            "EnumDefaultedMember"
          ),
          hasUnknownMembers: (0, _utils.validate)(
            (0, _utils.assertValueType)("boolean")
          )
        }
      });
      defineType("EnumSymbolBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
          members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
          hasUnknownMembers: (0, _utils.validate)(
            (0, _utils.assertValueType)("boolean")
          )
        }
      });
      defineType("EnumBooleanMember", {
        aliases: ["EnumMember"],
        visitor: ["id"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          init: (0, _utils.validateType)("BooleanLiteral")
        }
      });
      defineType("EnumNumberMember", {
        aliases: ["EnumMember"],
        visitor: ["id", "init"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          init: (0, _utils.validateType)("NumericLiteral")
        }
      });
      defineType("EnumStringMember", {
        aliases: ["EnumMember"],
        visitor: ["id", "init"],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          init: (0, _utils.validateType)("StringLiteral")
        }
      });
      defineType("EnumDefaultedMember", {
        aliases: ["EnumMember"],
        visitor: ["id"],
        fields: { id: (0, _utils.validateType)("Identifier") }
      });
      defineType("IndexedAccessType", {
        visitor: ["objectType", "indexType"],
        aliases: ["FlowType"],
        fields: {
          objectType: (0, _utils.validateType)("FlowType"),
          indexType: (0, _utils.validateType)("FlowType")
        }
      });
      defineType("OptionalIndexedAccessType", {
        visitor: ["objectType", "indexType"],
        aliases: ["FlowType"],
        fields: {
          objectType: (0, _utils.validateType)("FlowType"),
          indexType: (0, _utils.validateType)("FlowType"),
          optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
      return flow$1;
    }
    var jsx$1 = {};
    var hasRequiredJsx;
    function requireJsx() {
      if (hasRequiredJsx) return jsx$1;
      hasRequiredJsx = 1;
      var _utils = requireUtils();
      var defineType = (0, _utils.defineAliasedType)("JSX");
      defineType("JSXAttribute", {
        visitor: ["name", "value"],
        aliases: ["Immutable"],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)(
              "JSXIdentifier",
              "JSXNamespacedName"
            )
          },
          value: {
            optional: true,
            validate: (0, _utils.assertNodeType)(
              "JSXElement",
              "JSXFragment",
              "StringLiteral",
              "JSXExpressionContainer"
            )
          }
        }
      });
      defineType("JSXClosingElement", {
        visitor: ["name"],
        aliases: ["Immutable"],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)(
              "JSXIdentifier",
              "JSXMemberExpression",
              "JSXNamespacedName"
            )
          }
        }
      });
      defineType("JSXElement", {
        builder: [
          "openingElement",
          "closingElement",
          "children",
          "selfClosing"
        ],
        visitor: ["openingElement", "children", "closingElement"],
        aliases: ["Immutable", "Expression"],
        fields: Object.assign(
          {
            openingElement: {
              validate: (0, _utils.assertNodeType)("JSXOpeningElement")
            },
            closingElement: {
              optional: true,
              validate: (0, _utils.assertNodeType)("JSXClosingElement")
            },
            children: (0, _utils.validateArrayOfType)(
              "JSXText",
              "JSXExpressionContainer",
              "JSXSpreadChild",
              "JSXElement",
              "JSXFragment"
            )
          },
          {
            selfClosing: {
              validate: (0, _utils.assertValueType)("boolean"),
              optional: true
            }
          }
        )
      });
      defineType("JSXEmptyExpression", {});
      defineType("JSXExpressionContainer", {
        visitor: ["expression"],
        aliases: ["Immutable"],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)(
              "Expression",
              "JSXEmptyExpression"
            )
          }
        }
      });
      defineType("JSXSpreadChild", {
        visitor: ["expression"],
        aliases: ["Immutable"],
        fields: {
          expression: { validate: (0, _utils.assertNodeType)("Expression") }
        }
      });
      defineType("JSXIdentifier", {
        builder: ["name"],
        fields: { name: { validate: (0, _utils.assertValueType)("string") } }
      });
      defineType("JSXMemberExpression", {
        visitor: ["object", "property"],
        fields: {
          object: {
            validate: (0, _utils.assertNodeType)(
              "JSXMemberExpression",
              "JSXIdentifier"
            )
          },
          property: { validate: (0, _utils.assertNodeType)("JSXIdentifier") }
        }
      });
      defineType("JSXNamespacedName", {
        visitor: ["namespace", "name"],
        fields: {
          namespace: { validate: (0, _utils.assertNodeType)("JSXIdentifier") },
          name: { validate: (0, _utils.assertNodeType)("JSXIdentifier") }
        }
      });
      defineType("JSXOpeningElement", {
        builder: ["name", "attributes", "selfClosing"],
        visitor: ["name", "attributes"],
        aliases: ["Immutable"],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)(
              "JSXIdentifier",
              "JSXMemberExpression",
              "JSXNamespacedName"
            )
          },
          selfClosing: { default: false },
          attributes: (0, _utils.validateArrayOfType)(
            "JSXAttribute",
            "JSXSpreadAttribute"
          ),
          typeParameters: {
            validate: (0, _utils.assertNodeType)(
              "TypeParameterInstantiation",
              "TSTypeParameterInstantiation"
            ),
            optional: true
          }
        }
      });
      defineType("JSXSpreadAttribute", {
        visitor: ["argument"],
        fields: {
          argument: { validate: (0, _utils.assertNodeType)("Expression") }
        }
      });
      defineType("JSXText", {
        aliases: ["Immutable"],
        builder: ["value"],
        fields: { value: { validate: (0, _utils.assertValueType)("string") } }
      });
      defineType("JSXFragment", {
        builder: ["openingFragment", "closingFragment", "children"],
        visitor: ["openingFragment", "children", "closingFragment"],
        aliases: ["Immutable", "Expression"],
        fields: {
          openingFragment: {
            validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
          },
          closingFragment: {
            validate: (0, _utils.assertNodeType)("JSXClosingFragment")
          },
          children: (0, _utils.validateArrayOfType)(
            "JSXText",
            "JSXExpressionContainer",
            "JSXSpreadChild",
            "JSXElement",
            "JSXFragment"
          )
        }
      });
      defineType("JSXOpeningFragment", { aliases: ["Immutable"] });
      defineType("JSXClosingFragment", { aliases: ["Immutable"] });
      return jsx$1;
    }
    var misc = {};
    var placeholders = {};
    var hasRequiredPlaceholders;
    function requirePlaceholders() {
      if (hasRequiredPlaceholders) return placeholders;
      hasRequiredPlaceholders = 1;
      Object.defineProperty(placeholders, "__esModule", { value: true });
      placeholders.PLACEHOLDERS_FLIPPED_ALIAS =
        placeholders.PLACEHOLDERS_ALIAS =
        placeholders.PLACEHOLDERS =
          void 0;
      var _utils = requireUtils();
      var PLACEHOLDERS = (placeholders.PLACEHOLDERS = [
        "Identifier",
        "StringLiteral",
        "Expression",
        "Statement",
        "Declaration",
        "BlockStatement",
        "ClassBody",
        "Pattern"
      ]);
      var PLACEHOLDERS_ALIAS = (placeholders.PLACEHOLDERS_ALIAS = {
        Declaration: ["Statement"],
        Pattern: ["PatternLike", "LVal"]
      });
      for (
        var _i7 = 0, _PLACEHOLDERS = PLACEHOLDERS;
        _i7 < _PLACEHOLDERS.length;
        _i7++
      ) {
        var type = _PLACEHOLDERS[_i7];
        var alias = _utils.ALIAS_KEYS[type];
        if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
      }
      var PLACEHOLDERS_FLIPPED_ALIAS =
        (placeholders.PLACEHOLDERS_FLIPPED_ALIAS = {});
      Object.keys(PLACEHOLDERS_ALIAS).forEach(function (type) {
        PLACEHOLDERS_ALIAS[type].forEach(function (alias) {
          if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
            PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
          }
          PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
        });
      });
      return placeholders;
    }
    var hasRequiredMisc;
    function requireMisc() {
      if (hasRequiredMisc) return misc;
      hasRequiredMisc = 1;
      var _utils = requireUtils();
      var _placeholders = requirePlaceholders();
      var _core = requireCore();
      var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
      {
        defineType("Noop", { visitor: [] });
      }
      defineType("Placeholder", {
        visitor: [],
        builder: ["expectedNode", "name"],
        fields: Object.assign(
          {
            name: { validate: (0, _utils.assertNodeType)("Identifier") },
            expectedNode: {
              validate: (0, _utils.assertOneOf).apply(
                void 0,
                _toConsumableArray(_placeholders.PLACEHOLDERS)
              )
            }
          },
          (0, _core.patternLikeCommon)()
        )
      });
      defineType("V8IntrinsicIdentifier", {
        builder: ["name"],
        fields: { name: { validate: (0, _utils.assertValueType)("string") } }
      });
      return misc;
    }
    var experimental = {};
    var hasRequiredExperimental;
    function requireExperimental() {
      if (hasRequiredExperimental) return experimental;
      hasRequiredExperimental = 1;
      var _utils = requireUtils();
      (0, _utils["default"])("ArgumentPlaceholder", {});
      (0, _utils["default"])("BindExpression", {
        visitor: ["object", "callee"],
        aliases: ["Expression"],
        fields: !process.env.BABEL_TYPES_8_BREAKING
          ? {
              object: {
                validate: Object.assign(function () {}, {
                  oneOfNodeTypes: ["Expression"]
                })
              },
              callee: {
                validate: Object.assign(function () {}, {
                  oneOfNodeTypes: ["Expression"]
                })
              }
            }
          : {
              object: { validate: (0, _utils.assertNodeType)("Expression") },
              callee: { validate: (0, _utils.assertNodeType)("Expression") }
            }
      });
      (0, _utils["default"])("ImportAttribute", {
        visitor: ["key", "value"],
        fields: {
          key: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
          },
          value: { validate: (0, _utils.assertNodeType)("StringLiteral") }
        }
      });
      (0, _utils["default"])("Decorator", {
        visitor: ["expression"],
        fields: {
          expression: { validate: (0, _utils.assertNodeType)("Expression") }
        }
      });
      (0, _utils["default"])("DoExpression", {
        visitor: ["body"],
        builder: ["body", "async"],
        aliases: ["Expression"],
        fields: {
          body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
          async: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
          }
        }
      });
      (0, _utils["default"])("ExportDefaultSpecifier", {
        visitor: ["exported"],
        aliases: ["ModuleSpecifier"],
        fields: {
          exported: { validate: (0, _utils.assertNodeType)("Identifier") }
        }
      });
      (0, _utils["default"])("RecordExpression", {
        visitor: ["properties"],
        aliases: ["Expression"],
        fields: {
          properties: (0, _utils.validateArrayOfType)(
            "ObjectProperty",
            "SpreadElement"
          )
        }
      });
      (0, _utils["default"])("TupleExpression", {
        fields: {
          elements: {
            validate: (0, _utils.arrayOfType)("Expression", "SpreadElement"),
            default: []
          }
        },
        visitor: ["elements"],
        aliases: ["Expression"]
      });
      {
        (0, _utils["default"])("DecimalLiteral", {
          builder: ["value"],
          fields: {
            value: { validate: (0, _utils.assertValueType)("string") }
          },
          aliases: ["Expression", "Pureish", "Literal", "Immutable"]
        });
      }
      (0, _utils["default"])("ModuleExpression", {
        visitor: ["body"],
        fields: { body: { validate: (0, _utils.assertNodeType)("Program") } },
        aliases: ["Expression"]
      });
      (0, _utils["default"])("TopicReference", { aliases: ["Expression"] });
      (0, _utils["default"])("PipelineTopicExpression", {
        builder: ["expression"],
        visitor: ["expression"],
        fields: {
          expression: { validate: (0, _utils.assertNodeType)("Expression") }
        },
        aliases: ["Expression"]
      });
      (0, _utils["default"])("PipelineBareFunction", {
        builder: ["callee"],
        visitor: ["callee"],
        fields: {
          callee: { validate: (0, _utils.assertNodeType)("Expression") }
        },
        aliases: ["Expression"]
      });
      (0, _utils["default"])("PipelinePrimaryTopicReference", {
        aliases: ["Expression"]
      });
      return experimental;
    }
    var typescript$1 = {};
    var hasRequiredTypescript;
    function requireTypescript() {
      if (hasRequiredTypescript) return typescript$1;
      hasRequiredTypescript = 1;
      var _utils = requireUtils();
      var _core = requireCore();
      var _is = requireIs();
      var defineType = (0, _utils.defineAliasedType)("TypeScript");
      var bool = (0, _utils.assertValueType)("boolean");
      var tSFunctionTypeAnnotationCommon =
        function tSFunctionTypeAnnotationCommon() {
          return {
            returnType: {
              validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
              optional: true
            },
            typeParameters: {
              validate: (0, _utils.assertNodeType)(
                "TSTypeParameterDeclaration",
                "Noop"
              ),
              optional: true
            }
          };
        };
      defineType("TSParameterProperty", {
        aliases: ["LVal"],
        visitor: ["parameter"],
        fields: {
          accessibility: {
            validate: (0, _utils.assertOneOf)("public", "private", "protected"),
            optional: true
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          parameter: {
            validate: (0, _utils.assertNodeType)(
              "Identifier",
              "AssignmentPattern"
            )
          },
          override: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          decorators: {
            validate: (0, _utils.arrayOfType)("Decorator"),
            optional: true
          }
        }
      });
      defineType("TSDeclareFunction", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "typeParameters", "params", "returnType"],
        fields: Object.assign(
          {},
          (0, _core.functionDeclarationCommon)(),
          tSFunctionTypeAnnotationCommon()
        )
      });
      defineType("TSDeclareMethod", {
        visitor: [
          "decorators",
          "key",
          "typeParameters",
          "params",
          "returnType"
        ],
        fields: Object.assign(
          {},
          (0, _core.classMethodOrDeclareMethodCommon)(),
          tSFunctionTypeAnnotationCommon()
        )
      });
      defineType("TSQualifiedName", {
        aliases: ["TSEntityName"],
        visitor: ["left", "right"],
        fields: {
          left: (0, _utils.validateType)("TSEntityName"),
          right: (0, _utils.validateType)("Identifier")
        }
      });
      var signatureDeclarationCommon = function signatureDeclarationCommon() {
        return _defineProperty2(
          _defineProperty2(
            {
              typeParameters: (0, _utils.validateOptionalType)(
                "TSTypeParameterDeclaration"
              )
            },
            "parameters",
            (0, _utils.validateArrayOfType)(
              "ArrayPattern",
              "Identifier",
              "ObjectPattern",
              "RestElement"
            )
          ),
          "typeAnnotation",
          (0, _utils.validateOptionalType)("TSTypeAnnotation")
        );
      };
      var callConstructSignatureDeclaration = {
        aliases: ["TSTypeElement"],
        visitor: ["typeParameters", "parameters", "typeAnnotation"],
        fields: signatureDeclarationCommon()
      };
      defineType(
        "TSCallSignatureDeclaration",
        callConstructSignatureDeclaration
      );
      defineType(
        "TSConstructSignatureDeclaration",
        callConstructSignatureDeclaration
      );
      var namedTypeElementCommon = function namedTypeElementCommon() {
        return {
          key: (0, _utils.validateType)("Expression"),
          computed: { default: false },
          optional: (0, _utils.validateOptional)(bool)
        };
      };
      defineType("TSPropertySignature", {
        aliases: ["TSTypeElement"],
        visitor: ["key", "typeAnnotation"],
        fields: Object.assign({}, namedTypeElementCommon(), {
          readonly: (0, _utils.validateOptional)(bool),
          typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
          kind: { validate: (0, _utils.assertOneOf)("get", "set") }
        })
      });
      defineType("TSMethodSignature", {
        aliases: ["TSTypeElement"],
        visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
        fields: Object.assign(
          {},
          signatureDeclarationCommon(),
          namedTypeElementCommon(),
          {
            kind: { validate: (0, _utils.assertOneOf)("method", "get", "set") }
          }
        )
      });
      defineType("TSIndexSignature", {
        aliases: ["TSTypeElement"],
        visitor: ["parameters", "typeAnnotation"],
        fields: {
          readonly: (0, _utils.validateOptional)(bool),
          static: (0, _utils.validateOptional)(bool),
          parameters: (0, _utils.validateArrayOfType)("Identifier"),
          typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
        }
      });
      var tsKeywordTypes = [
        "TSAnyKeyword",
        "TSBooleanKeyword",
        "TSBigIntKeyword",
        "TSIntrinsicKeyword",
        "TSNeverKeyword",
        "TSNullKeyword",
        "TSNumberKeyword",
        "TSObjectKeyword",
        "TSStringKeyword",
        "TSSymbolKeyword",
        "TSUndefinedKeyword",
        "TSUnknownKeyword",
        "TSVoidKeyword"
      ];
      for (
        var _i8 = 0, _tsKeywordTypes = tsKeywordTypes;
        _i8 < _tsKeywordTypes.length;
        _i8++
      ) {
        var type = _tsKeywordTypes[_i8];
        defineType(type, {
          aliases: ["TSType", "TSBaseType"],
          visitor: [],
          fields: {}
        });
      }
      defineType("TSThisType", {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
      var fnOrCtrBase = {
        aliases: ["TSType"],
        visitor: ["typeParameters", "parameters", "typeAnnotation"]
      };
      defineType(
        "TSFunctionType",
        Object.assign({}, fnOrCtrBase, { fields: signatureDeclarationCommon() })
      );
      defineType(
        "TSConstructorType",
        Object.assign({}, fnOrCtrBase, {
          fields: Object.assign({}, signatureDeclarationCommon(), {
            abstract: (0, _utils.validateOptional)(bool)
          })
        })
      );
      defineType("TSTypeReference", {
        aliases: ["TSType"],
        visitor: ["typeName", "typeParameters"],
        fields: {
          typeName: (0, _utils.validateType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TSTypeParameterInstantiation"
          )
        }
      });
      defineType("TSTypePredicate", {
        aliases: ["TSType"],
        visitor: ["parameterName", "typeAnnotation"],
        builder: ["parameterName", "typeAnnotation", "asserts"],
        fields: {
          parameterName: (0, _utils.validateType)("Identifier", "TSThisType"),
          typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
          asserts: (0, _utils.validateOptional)(bool)
        }
      });
      defineType("TSTypeQuery", {
        aliases: ["TSType"],
        visitor: ["exprName", "typeParameters"],
        fields: {
          exprName: (0, _utils.validateType)("TSEntityName", "TSImportType"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TSTypeParameterInstantiation"
          )
        }
      });
      defineType("TSTypeLiteral", {
        aliases: ["TSType"],
        visitor: ["members"],
        fields: { members: (0, _utils.validateArrayOfType)("TSTypeElement") }
      });
      defineType("TSArrayType", {
        aliases: ["TSType"],
        visitor: ["elementType"],
        fields: { elementType: (0, _utils.validateType)("TSType") }
      });
      defineType("TSTupleType", {
        aliases: ["TSType"],
        visitor: ["elementTypes"],
        fields: {
          elementTypes: (0, _utils.validateArrayOfType)(
            "TSType",
            "TSNamedTupleMember"
          )
        }
      });
      defineType("TSOptionalType", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: { typeAnnotation: (0, _utils.validateType)("TSType") }
      });
      defineType("TSRestType", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: { typeAnnotation: (0, _utils.validateType)("TSType") }
      });
      defineType("TSNamedTupleMember", {
        visitor: ["label", "elementType"],
        builder: ["label", "elementType", "optional"],
        fields: {
          label: (0, _utils.validateType)("Identifier"),
          optional: { validate: bool, default: false },
          elementType: (0, _utils.validateType)("TSType")
        }
      });
      var unionOrIntersection = {
        aliases: ["TSType"],
        visitor: ["types"],
        fields: { types: (0, _utils.validateArrayOfType)("TSType") }
      };
      defineType("TSUnionType", unionOrIntersection);
      defineType("TSIntersectionType", unionOrIntersection);
      defineType("TSConditionalType", {
        aliases: ["TSType"],
        visitor: ["checkType", "extendsType", "trueType", "falseType"],
        fields: {
          checkType: (0, _utils.validateType)("TSType"),
          extendsType: (0, _utils.validateType)("TSType"),
          trueType: (0, _utils.validateType)("TSType"),
          falseType: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSInferType", {
        aliases: ["TSType"],
        visitor: ["typeParameter"],
        fields: { typeParameter: (0, _utils.validateType)("TSTypeParameter") }
      });
      defineType("TSParenthesizedType", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: { typeAnnotation: (0, _utils.validateType)("TSType") }
      });
      defineType("TSTypeOperator", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {
          operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSIndexedAccessType", {
        aliases: ["TSType"],
        visitor: ["objectType", "indexType"],
        fields: {
          objectType: (0, _utils.validateType)("TSType"),
          indexType: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSMappedType", {
        aliases: ["TSType"],
        visitor: ["typeParameter", "nameType", "typeAnnotation"],
        builder: ["typeParameter", "typeAnnotation", "nameType"],
        fields: Object.assign(
          {},
          { typeParameter: (0, _utils.validateType)("TSTypeParameter") },
          {
            readonly: (0, _utils.validateOptional)(
              (0, _utils.assertOneOf)(true, false, "+", "-")
            ),
            optional: (0, _utils.validateOptional)(
              (0, _utils.assertOneOf)(true, false, "+", "-")
            ),
            typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
            nameType: (0, _utils.validateOptionalType)("TSType")
          }
        )
      });
      defineType("TSLiteralType", {
        aliases: ["TSType", "TSBaseType"],
        visitor: ["literal"],
        fields: {
          literal: {
            validate: (function () {
              var unaryExpression = (0, _utils.assertNodeType)(
                "NumericLiteral",
                "BigIntLiteral"
              );
              var unaryOperator = (0, _utils.assertOneOf)("-");
              var literal = (0, _utils.assertNodeType)(
                "NumericLiteral",
                "StringLiteral",
                "BooleanLiteral",
                "BigIntLiteral",
                "TemplateLiteral"
              );
              function validator(parent, key, node) {
                if ((0, _is["default"])("UnaryExpression", node)) {
                  unaryOperator(node, "operator", node.operator);
                  unaryExpression(node, "argument", node.argument);
                } else {
                  literal(parent, key, node);
                }
              }
              validator.oneOfNodeTypes = [
                "NumericLiteral",
                "StringLiteral",
                "BooleanLiteral",
                "BigIntLiteral",
                "TemplateLiteral",
                "UnaryExpression"
              ];
              return validator;
            })()
          }
        }
      });
      var expressionWithTypeArguments = {
        aliases: ["TSType"],
        visitor: ["expression", "typeParameters"],
        fields: {
          expression: (0, _utils.validateType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TSTypeParameterInstantiation"
          )
        }
      };
      {
        defineType(
          "TSExpressionWithTypeArguments",
          expressionWithTypeArguments
        );
      }
      defineType("TSInterfaceDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "typeParameters", "extends", "body"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TSTypeParameterDeclaration"
          ),
          extends: (0, _utils.validateOptional)(
            (0, _utils.arrayOfType)("TSExpressionWithTypeArguments")
          ),
          body: (0, _utils.validateType)("TSInterfaceBody")
        }
      });
      defineType("TSInterfaceBody", {
        visitor: ["body"],
        fields: { body: (0, _utils.validateArrayOfType)("TSTypeElement") }
      });
      defineType("TSTypeAliasDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "typeParameters", "typeAnnotation"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TSTypeParameterDeclaration"
          ),
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      });
      defineType("TSInstantiationExpression", {
        aliases: ["Expression"],
        visitor: ["expression", "typeParameters"],
        fields: {
          expression: (0, _utils.validateType)("Expression"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TSTypeParameterInstantiation"
          )
        }
      });
      var TSTypeExpression = {
        aliases: ["Expression", "LVal", "PatternLike"],
        visitor: ["expression", "typeAnnotation"],
        fields: {
          expression: (0, _utils.validateType)("Expression"),
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      };
      defineType("TSAsExpression", TSTypeExpression);
      defineType("TSSatisfiesExpression", TSTypeExpression);
      defineType("TSTypeAssertion", {
        aliases: ["Expression", "LVal", "PatternLike"],
        visitor: ["typeAnnotation", "expression"],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType"),
          expression: (0, _utils.validateType)("Expression")
        }
      });
      defineType("TSEnumDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "members"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          const: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          members: (0, _utils.validateArrayOfType)("TSEnumMember"),
          initializer: (0, _utils.validateOptionalType)("Expression")
        }
      });
      defineType("TSEnumMember", {
        visitor: ["id", "initializer"],
        fields: {
          id: (0, _utils.validateType)("Identifier", "StringLiteral"),
          initializer: (0, _utils.validateOptionalType)("Expression")
        }
      });
      defineType("TSModuleDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "body"],
        fields: Object.assign(
          {
            kind: {
              validate: (0, _utils.assertOneOf)("global", "module", "namespace")
            },
            declare: (0, _utils.validateOptional)(bool)
          },
          { global: (0, _utils.validateOptional)(bool) },
          {
            id: (0, _utils.validateType)("Identifier", "StringLiteral"),
            body: (0, _utils.validateType)(
              "TSModuleBlock",
              "TSModuleDeclaration"
            )
          }
        )
      });
      defineType("TSModuleBlock", {
        aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
        visitor: ["body"],
        fields: { body: (0, _utils.validateArrayOfType)("Statement") }
      });
      defineType("TSImportType", {
        aliases: ["TSType"],
        visitor: ["argument", "qualifier", "typeParameters"],
        fields: {
          argument: (0, _utils.validateType)("StringLiteral"),
          qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)(
            "TSTypeParameterInstantiation"
          ),
          options: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
          }
        }
      });
      defineType("TSImportEqualsDeclaration", {
        aliases: ["Statement"],
        visitor: ["id", "moduleReference"],
        fields: {
          isExport: (0, _utils.validate)(bool),
          id: (0, _utils.validateType)("Identifier"),
          moduleReference: (0, _utils.validateType)(
            "TSEntityName",
            "TSExternalModuleReference"
          ),
          importKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
          }
        }
      });
      defineType("TSExternalModuleReference", {
        visitor: ["expression"],
        fields: { expression: (0, _utils.validateType)("StringLiteral") }
      });
      defineType("TSNonNullExpression", {
        aliases: ["Expression", "LVal", "PatternLike"],
        visitor: ["expression"],
        fields: { expression: (0, _utils.validateType)("Expression") }
      });
      defineType("TSExportAssignment", {
        aliases: ["Statement"],
        visitor: ["expression"],
        fields: { expression: (0, _utils.validateType)("Expression") }
      });
      defineType("TSNamespaceExportDeclaration", {
        aliases: ["Statement"],
        visitor: ["id"],
        fields: { id: (0, _utils.validateType)("Identifier") }
      });
      defineType("TSTypeAnnotation", {
        visitor: ["typeAnnotation"],
        fields: {
          typeAnnotation: { validate: (0, _utils.assertNodeType)("TSType") }
        }
      });
      defineType("TSTypeParameterInstantiation", {
        visitor: ["params"],
        fields: { params: (0, _utils.validateArrayOfType)("TSType") }
      });
      defineType("TSTypeParameterDeclaration", {
        visitor: ["params"],
        fields: { params: (0, _utils.validateArrayOfType)("TSTypeParameter") }
      });
      defineType("TSTypeParameter", {
        builder: ["constraint", "default", "name"],
        visitor: ["constraint", "default"],
        fields: {
          name: { validate: (0, _utils.assertValueType)("string") },
          in: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          out: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          const: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
          },
          constraint: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
          },
          default: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
          }
        }
      });
      return typescript$1;
    }
    var deprecatedAliases = {};
    Object.defineProperty(deprecatedAliases, "__esModule", { value: true });
    deprecatedAliases.DEPRECATED_ALIASES = void 0;
    deprecatedAliases.DEPRECATED_ALIASES = {
      ModuleDeclaration: "ImportOrExportDeclaration"
    };
    var hasRequiredDefinitions;
    function requireDefinitions() {
      if (hasRequiredDefinitions) return definitions;
      hasRequiredDefinitions = 1;
      (function (exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        Object.defineProperty(exports, "ALIAS_KEYS", {
          enumerable: true,
          get: function get() {
            return _utils.ALIAS_KEYS;
          }
        });
        Object.defineProperty(exports, "BUILDER_KEYS", {
          enumerable: true,
          get: function get() {
            return _utils.BUILDER_KEYS;
          }
        });
        Object.defineProperty(exports, "DEPRECATED_ALIASES", {
          enumerable: true,
          get: function get() {
            return _deprecatedAliases.DEPRECATED_ALIASES;
          }
        });
        Object.defineProperty(exports, "DEPRECATED_KEYS", {
          enumerable: true,
          get: function get() {
            return _utils.DEPRECATED_KEYS;
          }
        });
        Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
          enumerable: true,
          get: function get() {
            return _utils.FLIPPED_ALIAS_KEYS;
          }
        });
        Object.defineProperty(exports, "NODE_FIELDS", {
          enumerable: true,
          get: function get() {
            return _utils.NODE_FIELDS;
          }
        });
        Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
          enumerable: true,
          get: function get() {
            return _utils.NODE_PARENT_VALIDATIONS;
          }
        });
        Object.defineProperty(exports, "PLACEHOLDERS", {
          enumerable: true,
          get: function get() {
            return _placeholders.PLACEHOLDERS;
          }
        });
        Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
          enumerable: true,
          get: function get() {
            return _placeholders.PLACEHOLDERS_ALIAS;
          }
        });
        Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
          enumerable: true,
          get: function get() {
            return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
          }
        });
        exports.TYPES = void 0;
        Object.defineProperty(exports, "VISITOR_KEYS", {
          enumerable: true,
          get: function get() {
            return _utils.VISITOR_KEYS;
          }
        });
        requireCore();
        requireFlow();
        requireJsx();
        requireMisc();
        requireExperimental();
        requireTypescript();
        var _utils = requireUtils();
        var _placeholders = requirePlaceholders();
        var _deprecatedAliases = deprecatedAliases;
        Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach(
          function (deprecatedAlias) {
            _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] =
              _utils.FLIPPED_ALIAS_KEYS[
                _deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]
              ];
          }
        );
        exports.TYPES = [].concat(
          Object.keys(_utils.VISITOR_KEYS),
          Object.keys(_utils.FLIPPED_ALIAS_KEYS),
          Object.keys(_utils.DEPRECATED_KEYS)
        );
      })(definitions);
      return definitions;
    }
    var hasRequiredValidate;
    function requireValidate() {
      if (hasRequiredValidate) return validate$2;
      hasRequiredValidate = 1;
      Object.defineProperty(validate$2, "__esModule", { value: true });
      validate$2["default"] = validate;
      validate$2.validateChild = validateChild;
      validate$2.validateField = validateField;
      validate$2.validateInternal = validateInternal;
      var _index = requireDefinitions();
      function validate(node, key, val) {
        if (!node) return;
        var fields = _index.NODE_FIELDS[node.type];
        if (!fields) return;
        var field = fields[key];
        validateField(node, key, val, field);
        validateChild(node, key, val);
      }
      function validateInternal(field, node, key, val, maybeNode) {
        if (!(field != null && field.validate)) return;
        if (field.optional && val == null) return;
        field.validate(node, key, val);
        if (maybeNode) {
          var _NODE_PARENT_VALIDATI;
          var type = val.type;
          if (type == null) return;
          (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) ==
            null ||
            _NODE_PARENT_VALIDATI.call(
              _index.NODE_PARENT_VALIDATIONS,
              node,
              key,
              val
            );
        }
      }
      function validateField(node, key, val, field) {
        if (!(field != null && field.validate)) return;
        if (field.optional && val == null) return;
        field.validate(node, key, val);
      }
      function validateChild(node, key, val) {
        var _NODE_PARENT_VALIDATI2;
        var type = val == null ? void 0 : val.type;
        if (type == null) return;
        (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) ==
          null ||
          _NODE_PARENT_VALIDATI2.call(
            _index.NODE_PARENT_VALIDATIONS,
            node,
            key,
            val
          );
      }
      return validate$2;
    }
    Object.defineProperty(generated$2, "__esModule", { value: true });
    generated$2.anyTypeAnnotation = anyTypeAnnotation;
    generated$2.argumentPlaceholder = argumentPlaceholder;
    generated$2.arrayExpression = arrayExpression;
    generated$2.arrayPattern = arrayPattern;
    generated$2.arrayTypeAnnotation = arrayTypeAnnotation;
    generated$2.arrowFunctionExpression = arrowFunctionExpression;
    generated$2.assignmentExpression = assignmentExpression;
    generated$2.assignmentPattern = assignmentPattern;
    generated$2.awaitExpression = awaitExpression;
    generated$2.bigIntLiteral = bigIntLiteral;
    generated$2.binaryExpression = binaryExpression;
    generated$2.bindExpression = bindExpression;
    generated$2.blockStatement = blockStatement;
    generated$2.booleanLiteral = booleanLiteral;
    generated$2.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
    generated$2.booleanTypeAnnotation = booleanTypeAnnotation;
    generated$2.breakStatement = breakStatement;
    generated$2.callExpression = callExpression;
    generated$2.catchClause = catchClause;
    generated$2.classAccessorProperty = classAccessorProperty;
    generated$2.classBody = classBody;
    generated$2.classDeclaration = classDeclaration;
    generated$2.classExpression = classExpression;
    generated$2.classImplements = classImplements;
    generated$2.classMethod = classMethod;
    generated$2.classPrivateMethod = classPrivateMethod;
    generated$2.classPrivateProperty = classPrivateProperty;
    generated$2.classProperty = classProperty;
    generated$2.conditionalExpression = conditionalExpression;
    generated$2.continueStatement = continueStatement;
    generated$2.debuggerStatement = debuggerStatement;
    generated$2.decimalLiteral = decimalLiteral;
    generated$2.declareClass = declareClass;
    generated$2.declareExportAllDeclaration = declareExportAllDeclaration;
    generated$2.declareExportDeclaration = declareExportDeclaration;
    generated$2.declareFunction = declareFunction;
    generated$2.declareInterface = declareInterface;
    generated$2.declareModule = declareModule;
    generated$2.declareModuleExports = declareModuleExports;
    generated$2.declareOpaqueType = declareOpaqueType;
    generated$2.declareTypeAlias = declareTypeAlias;
    generated$2.declareVariable = declareVariable;
    generated$2.declaredPredicate = declaredPredicate;
    generated$2.decorator = decorator;
    generated$2.directive = directive;
    generated$2.directiveLiteral = directiveLiteral;
    generated$2.doExpression = doExpression;
    generated$2.doWhileStatement = doWhileStatement;
    generated$2.emptyStatement = emptyStatement;
    generated$2.emptyTypeAnnotation = emptyTypeAnnotation;
    generated$2.enumBooleanBody = enumBooleanBody;
    generated$2.enumBooleanMember = enumBooleanMember;
    generated$2.enumDeclaration = enumDeclaration;
    generated$2.enumDefaultedMember = enumDefaultedMember;
    generated$2.enumNumberBody = enumNumberBody;
    generated$2.enumNumberMember = enumNumberMember;
    generated$2.enumStringBody = enumStringBody;
    generated$2.enumStringMember = enumStringMember;
    generated$2.enumSymbolBody = enumSymbolBody;
    generated$2.existsTypeAnnotation = existsTypeAnnotation;
    generated$2.exportAllDeclaration = exportAllDeclaration;
    generated$2.exportDefaultDeclaration = exportDefaultDeclaration;
    generated$2.exportDefaultSpecifier = exportDefaultSpecifier;
    generated$2.exportNamedDeclaration = exportNamedDeclaration;
    generated$2.exportNamespaceSpecifier = exportNamespaceSpecifier;
    generated$2.exportSpecifier = exportSpecifier;
    generated$2.expressionStatement = expressionStatement;
    generated$2.file = file;
    generated$2.forInStatement = forInStatement;
    generated$2.forOfStatement = forOfStatement;
    generated$2.forStatement = forStatement;
    generated$2.functionDeclaration = functionDeclaration;
    generated$2.functionExpression = functionExpression;
    generated$2.functionTypeAnnotation = functionTypeAnnotation;
    generated$2.functionTypeParam = functionTypeParam;
    generated$2.genericTypeAnnotation = genericTypeAnnotation;
    generated$2.identifier = identifier;
    generated$2.ifStatement = ifStatement;
    generated$2["import"] = _import;
    generated$2.importAttribute = importAttribute;
    generated$2.importDeclaration = importDeclaration;
    generated$2.importDefaultSpecifier = importDefaultSpecifier;
    generated$2.importExpression = importExpression;
    generated$2.importNamespaceSpecifier = importNamespaceSpecifier;
    generated$2.importSpecifier = importSpecifier;
    generated$2.indexedAccessType = indexedAccessType;
    generated$2.inferredPredicate = inferredPredicate;
    generated$2.interfaceDeclaration = interfaceDeclaration;
    generated$2.interfaceExtends = interfaceExtends;
    generated$2.interfaceTypeAnnotation = interfaceTypeAnnotation;
    generated$2.interpreterDirective = interpreterDirective;
    generated$2.intersectionTypeAnnotation = intersectionTypeAnnotation;
    generated$2.jSXAttribute = generated$2.jsxAttribute = jsxAttribute;
    generated$2.jSXClosingElement = generated$2.jsxClosingElement =
      jsxClosingElement;
    generated$2.jSXClosingFragment = generated$2.jsxClosingFragment =
      jsxClosingFragment;
    generated$2.jSXElement = generated$2.jsxElement = jsxElement;
    generated$2.jSXEmptyExpression = generated$2.jsxEmptyExpression =
      jsxEmptyExpression;
    generated$2.jSXExpressionContainer = generated$2.jsxExpressionContainer =
      jsxExpressionContainer;
    generated$2.jSXFragment = generated$2.jsxFragment = jsxFragment;
    generated$2.jSXIdentifier = generated$2.jsxIdentifier = jsxIdentifier;
    generated$2.jSXMemberExpression = generated$2.jsxMemberExpression =
      jsxMemberExpression;
    generated$2.jSXNamespacedName = generated$2.jsxNamespacedName =
      jsxNamespacedName;
    generated$2.jSXOpeningElement = generated$2.jsxOpeningElement =
      jsxOpeningElement;
    generated$2.jSXOpeningFragment = generated$2.jsxOpeningFragment =
      jsxOpeningFragment;
    generated$2.jSXSpreadAttribute = generated$2.jsxSpreadAttribute =
      jsxSpreadAttribute;
    generated$2.jSXSpreadChild = generated$2.jsxSpreadChild = jsxSpreadChild;
    generated$2.jSXText = generated$2.jsxText = jsxText;
    generated$2.labeledStatement = labeledStatement;
    generated$2.logicalExpression = logicalExpression;
    generated$2.memberExpression = memberExpression;
    generated$2.metaProperty = metaProperty;
    generated$2.mixedTypeAnnotation = mixedTypeAnnotation;
    generated$2.moduleExpression = moduleExpression;
    generated$2.newExpression = newExpression;
    generated$2.noop = noop;
    generated$2.nullLiteral = nullLiteral;
    generated$2.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
    generated$2.nullableTypeAnnotation = nullableTypeAnnotation;
    generated$2.numberLiteral = NumberLiteral;
    generated$2.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
    generated$2.numberTypeAnnotation = numberTypeAnnotation;
    generated$2.numericLiteral = numericLiteral;
    generated$2.objectExpression = objectExpression;
    generated$2.objectMethod = objectMethod;
    generated$2.objectPattern = objectPattern;
    generated$2.objectProperty = objectProperty;
    generated$2.objectTypeAnnotation = objectTypeAnnotation;
    generated$2.objectTypeCallProperty = objectTypeCallProperty;
    generated$2.objectTypeIndexer = objectTypeIndexer;
    generated$2.objectTypeInternalSlot = objectTypeInternalSlot;
    generated$2.objectTypeProperty = objectTypeProperty;
    generated$2.objectTypeSpreadProperty = objectTypeSpreadProperty;
    generated$2.opaqueType = opaqueType;
    generated$2.optionalCallExpression = optionalCallExpression;
    generated$2.optionalIndexedAccessType = optionalIndexedAccessType;
    generated$2.optionalMemberExpression = optionalMemberExpression;
    generated$2.parenthesizedExpression = parenthesizedExpression;
    generated$2.pipelineBareFunction = pipelineBareFunction;
    generated$2.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
    generated$2.pipelineTopicExpression = pipelineTopicExpression;
    generated$2.placeholder = placeholder;
    generated$2.privateName = privateName;
    generated$2.program = program;
    generated$2.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
    generated$2.recordExpression = recordExpression;
    generated$2.regExpLiteral = regExpLiteral;
    generated$2.regexLiteral = RegexLiteral;
    generated$2.restElement = restElement;
    generated$2.restProperty = RestProperty;
    generated$2.returnStatement = returnStatement;
    generated$2.sequenceExpression = sequenceExpression;
    generated$2.spreadElement = spreadElement;
    generated$2.spreadProperty = SpreadProperty;
    generated$2.staticBlock = staticBlock;
    generated$2.stringLiteral = stringLiteral;
    generated$2.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
    generated$2.stringTypeAnnotation = stringTypeAnnotation;
    generated$2["super"] = _super;
    generated$2.switchCase = switchCase;
    generated$2.switchStatement = switchStatement;
    generated$2.symbolTypeAnnotation = symbolTypeAnnotation;
    generated$2.taggedTemplateExpression = taggedTemplateExpression;
    generated$2.templateElement = templateElement;
    generated$2.templateLiteral = templateLiteral;
    generated$2.thisExpression = thisExpression;
    generated$2.thisTypeAnnotation = thisTypeAnnotation;
    generated$2.throwStatement = throwStatement;
    generated$2.topicReference = topicReference;
    generated$2.tryStatement = tryStatement;
    generated$2.tSAnyKeyword = generated$2.tsAnyKeyword = tsAnyKeyword;
    generated$2.tSArrayType = generated$2.tsArrayType = tsArrayType;
    generated$2.tSAsExpression = generated$2.tsAsExpression = tsAsExpression;
    generated$2.tSBigIntKeyword = generated$2.tsBigIntKeyword = tsBigIntKeyword;
    generated$2.tSBooleanKeyword = generated$2.tsBooleanKeyword =
      tsBooleanKeyword;
    generated$2.tSCallSignatureDeclaration =
      generated$2.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
    generated$2.tSConditionalType = generated$2.tsConditionalType =
      tsConditionalType;
    generated$2.tSConstructSignatureDeclaration =
      generated$2.tsConstructSignatureDeclaration =
        tsConstructSignatureDeclaration;
    generated$2.tSConstructorType = generated$2.tsConstructorType =
      tsConstructorType;
    generated$2.tSDeclareFunction = generated$2.tsDeclareFunction =
      tsDeclareFunction;
    generated$2.tSDeclareMethod = generated$2.tsDeclareMethod = tsDeclareMethod;
    generated$2.tSEnumDeclaration = generated$2.tsEnumDeclaration =
      tsEnumDeclaration;
    generated$2.tSEnumMember = generated$2.tsEnumMember = tsEnumMember;
    generated$2.tSExportAssignment = generated$2.tsExportAssignment =
      tsExportAssignment;
    generated$2.tSExpressionWithTypeArguments =
      generated$2.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
    generated$2.tSExternalModuleReference =
      generated$2.tsExternalModuleReference = tsExternalModuleReference;
    generated$2.tSFunctionType = generated$2.tsFunctionType = tsFunctionType;
    generated$2.tSImportEqualsDeclaration =
      generated$2.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
    generated$2.tSImportType = generated$2.tsImportType = tsImportType;
    generated$2.tSIndexSignature = generated$2.tsIndexSignature =
      tsIndexSignature;
    generated$2.tSIndexedAccessType = generated$2.tsIndexedAccessType =
      tsIndexedAccessType;
    generated$2.tSInferType = generated$2.tsInferType = tsInferType;
    generated$2.tSInstantiationExpression =
      generated$2.tsInstantiationExpression = tsInstantiationExpression;
    generated$2.tSInterfaceBody = generated$2.tsInterfaceBody = tsInterfaceBody;
    generated$2.tSInterfaceDeclaration = generated$2.tsInterfaceDeclaration =
      tsInterfaceDeclaration;
    generated$2.tSIntersectionType = generated$2.tsIntersectionType =
      tsIntersectionType;
    generated$2.tSIntrinsicKeyword = generated$2.tsIntrinsicKeyword =
      tsIntrinsicKeyword;
    generated$2.tSLiteralType = generated$2.tsLiteralType = tsLiteralType;
    generated$2.tSMappedType = generated$2.tsMappedType = tsMappedType;
    generated$2.tSMethodSignature = generated$2.tsMethodSignature =
      tsMethodSignature;
    generated$2.tSModuleBlock = generated$2.tsModuleBlock = tsModuleBlock;
    generated$2.tSModuleDeclaration = generated$2.tsModuleDeclaration =
      tsModuleDeclaration;
    generated$2.tSNamedTupleMember = generated$2.tsNamedTupleMember =
      tsNamedTupleMember;
    generated$2.tSNamespaceExportDeclaration =
      generated$2.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
    generated$2.tSNeverKeyword = generated$2.tsNeverKeyword = tsNeverKeyword;
    generated$2.tSNonNullExpression = generated$2.tsNonNullExpression =
      tsNonNullExpression;
    generated$2.tSNullKeyword = generated$2.tsNullKeyword = tsNullKeyword;
    generated$2.tSNumberKeyword = generated$2.tsNumberKeyword = tsNumberKeyword;
    generated$2.tSObjectKeyword = generated$2.tsObjectKeyword = tsObjectKeyword;
    generated$2.tSOptionalType = generated$2.tsOptionalType = tsOptionalType;
    generated$2.tSParameterProperty = generated$2.tsParameterProperty =
      tsParameterProperty;
    generated$2.tSParenthesizedType = generated$2.tsParenthesizedType =
      tsParenthesizedType;
    generated$2.tSPropertySignature = generated$2.tsPropertySignature =
      tsPropertySignature;
    generated$2.tSQualifiedName = generated$2.tsQualifiedName = tsQualifiedName;
    generated$2.tSRestType = generated$2.tsRestType = tsRestType;
    generated$2.tSSatisfiesExpression = generated$2.tsSatisfiesExpression =
      tsSatisfiesExpression;
    generated$2.tSStringKeyword = generated$2.tsStringKeyword = tsStringKeyword;
    generated$2.tSSymbolKeyword = generated$2.tsSymbolKeyword = tsSymbolKeyword;
    generated$2.tSThisType = generated$2.tsThisType = tsThisType;
    generated$2.tSTupleType = generated$2.tsTupleType = tsTupleType;
    generated$2.tSTypeAliasDeclaration = generated$2.tsTypeAliasDeclaration =
      tsTypeAliasDeclaration;
    generated$2.tSTypeAnnotation = generated$2.tsTypeAnnotation =
      tsTypeAnnotation;
    generated$2.tSTypeAssertion = generated$2.tsTypeAssertion = tsTypeAssertion;
    generated$2.tSTypeLiteral = generated$2.tsTypeLiteral = tsTypeLiteral;
    generated$2.tSTypeOperator = generated$2.tsTypeOperator = tsTypeOperator;
    generated$2.tSTypeParameter = generated$2.tsTypeParameter = tsTypeParameter;
    generated$2.tSTypeParameterDeclaration =
      generated$2.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
    generated$2.tSTypeParameterInstantiation =
      generated$2.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
    generated$2.tSTypePredicate = generated$2.tsTypePredicate = tsTypePredicate;
    generated$2.tSTypeQuery = generated$2.tsTypeQuery = tsTypeQuery;
    generated$2.tSTypeReference = generated$2.tsTypeReference = tsTypeReference;
    generated$2.tSUndefinedKeyword = generated$2.tsUndefinedKeyword =
      tsUndefinedKeyword;
    generated$2.tSUnionType = generated$2.tsUnionType = tsUnionType;
    generated$2.tSUnknownKeyword = generated$2.tsUnknownKeyword =
      tsUnknownKeyword;
    generated$2.tSVoidKeyword = generated$2.tsVoidKeyword = tsVoidKeyword;
    generated$2.tupleExpression = tupleExpression;
    generated$2.tupleTypeAnnotation = tupleTypeAnnotation;
    generated$2.typeAlias = typeAlias;
    generated$2.typeAnnotation = typeAnnotation;
    generated$2.typeCastExpression = typeCastExpression;
    generated$2.typeParameter = typeParameter;
    generated$2.typeParameterDeclaration = typeParameterDeclaration;
    generated$2.typeParameterInstantiation = typeParameterInstantiation;
    generated$2.typeofTypeAnnotation = typeofTypeAnnotation;
    generated$2.unaryExpression = unaryExpression;
    generated$2.unionTypeAnnotation = unionTypeAnnotation;
    generated$2.updateExpression = updateExpression;
    generated$2.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
    generated$2.variableDeclaration = variableDeclaration;
    generated$2.variableDeclarator = variableDeclarator;
    generated$2.variance = variance;
    generated$2.voidTypeAnnotation = voidTypeAnnotation;
    generated$2.whileStatement = whileStatement;
    generated$2.withStatement = withStatement;
    generated$2.yieldExpression = yieldExpression;
    var _validate = requireValidate();
    var _deprecationWarning$1 = deprecationWarning$1;
    var utils = requireUtils();
    var validate$1 = _validate.validateInternal;
    var NODE_FIELDS = utils.NODE_FIELDS;
    function arrayExpression() {
      var elements =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var node = { type: "ArrayExpression", elements: elements };
      var defs = NODE_FIELDS.ArrayExpression;
      validate$1(defs.elements, node, "elements", elements, 1);
      return node;
    }
    function assignmentExpression(operator, left, right) {
      var node = {
        type: "AssignmentExpression",
        operator: operator,
        left: left,
        right: right
      };
      var defs = NODE_FIELDS.AssignmentExpression;
      validate$1(defs.operator, node, "operator", operator);
      validate$1(defs.left, node, "left", left, 1);
      validate$1(defs.right, node, "right", right, 1);
      return node;
    }
    function binaryExpression(operator, left, right) {
      var node = {
        type: "BinaryExpression",
        operator: operator,
        left: left,
        right: right
      };
      var defs = NODE_FIELDS.BinaryExpression;
      validate$1(defs.operator, node, "operator", operator);
      validate$1(defs.left, node, "left", left, 1);
      validate$1(defs.right, node, "right", right, 1);
      return node;
    }
    function interpreterDirective(value) {
      var node = { type: "InterpreterDirective", value: value };
      var defs = NODE_FIELDS.InterpreterDirective;
      validate$1(defs.value, node, "value", value);
      return node;
    }
    function directive(value) {
      var node = { type: "Directive", value: value };
      var defs = NODE_FIELDS.Directive;
      validate$1(defs.value, node, "value", value, 1);
      return node;
    }
    function directiveLiteral(value) {
      var node = { type: "DirectiveLiteral", value: value };
      var defs = NODE_FIELDS.DirectiveLiteral;
      validate$1(defs.value, node, "value", value);
      return node;
    }
    function blockStatement(body) {
      var directives =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var node = { type: "BlockStatement", body: body, directives: directives };
      var defs = NODE_FIELDS.BlockStatement;
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs.directives, node, "directives", directives, 1);
      return node;
    }
    function breakStatement() {
      var label =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var node = { type: "BreakStatement", label: label };
      var defs = NODE_FIELDS.BreakStatement;
      validate$1(defs.label, node, "label", label, 1);
      return node;
    }
    function callExpression(callee, _arguments) {
      var node = {
        type: "CallExpression",
        callee: callee,
        arguments: _arguments
      };
      var defs = NODE_FIELDS.CallExpression;
      validate$1(defs.callee, node, "callee", callee, 1);
      validate$1(defs.arguments, node, "arguments", _arguments, 1);
      return node;
    }
    function catchClause() {
      var param =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var body = arguments.length > 1 ? arguments[1] : undefined;
      var node = { type: "CatchClause", param: param, body: body };
      var defs = NODE_FIELDS.CatchClause;
      validate$1(defs.param, node, "param", param, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function conditionalExpression(test, consequent, alternate) {
      var node = {
        type: "ConditionalExpression",
        test: test,
        consequent: consequent,
        alternate: alternate
      };
      var defs = NODE_FIELDS.ConditionalExpression;
      validate$1(defs.test, node, "test", test, 1);
      validate$1(defs.consequent, node, "consequent", consequent, 1);
      validate$1(defs.alternate, node, "alternate", alternate, 1);
      return node;
    }
    function continueStatement() {
      var label =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var node = { type: "ContinueStatement", label: label };
      var defs = NODE_FIELDS.ContinueStatement;
      validate$1(defs.label, node, "label", label, 1);
      return node;
    }
    function debuggerStatement() {
      return { type: "DebuggerStatement" };
    }
    function doWhileStatement(test, body) {
      var node = { type: "DoWhileStatement", test: test, body: body };
      var defs = NODE_FIELDS.DoWhileStatement;
      validate$1(defs.test, node, "test", test, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function emptyStatement() {
      return { type: "EmptyStatement" };
    }
    function expressionStatement(expression) {
      var node = { type: "ExpressionStatement", expression: expression };
      var defs = NODE_FIELDS.ExpressionStatement;
      validate$1(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function file(program) {
      var comments =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var tokens =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "File",
        program: program,
        comments: comments,
        tokens: tokens
      };
      var defs = NODE_FIELDS.File;
      validate$1(defs.program, node, "program", program, 1);
      validate$1(defs.comments, node, "comments", comments, 1);
      validate$1(defs.tokens, node, "tokens", tokens);
      return node;
    }
    function forInStatement(left, right, body) {
      var node = {
        type: "ForInStatement",
        left: left,
        right: right,
        body: body
      };
      var defs = NODE_FIELDS.ForInStatement;
      validate$1(defs.left, node, "left", left, 1);
      validate$1(defs.right, node, "right", right, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function forStatement() {
      var init =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var test =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var update =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var body = arguments.length > 3 ? arguments[3] : undefined;
      var node = {
        type: "ForStatement",
        init: init,
        test: test,
        update: update,
        body: body
      };
      var defs = NODE_FIELDS.ForStatement;
      validate$1(defs.init, node, "init", init, 1);
      validate$1(defs.test, node, "test", test, 1);
      validate$1(defs.update, node, "update", update, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function functionDeclaration() {
      var id =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var params = arguments.length > 1 ? arguments[1] : undefined;
      var body = arguments.length > 2 ? arguments[2] : undefined;
      var generator =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : false;
      var async =
        arguments.length > 4 && arguments[4] !== undefined
          ? arguments[4]
          : false;
      var node = {
        type: "FunctionDeclaration",
        id: id,
        params: params,
        body: body,
        generator: generator,
        async: async
      };
      var defs = NODE_FIELDS.FunctionDeclaration;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.params, node, "params", params, 1);
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs.generator, node, "generator", generator);
      validate$1(defs.async, node, "async", async);
      return node;
    }
    function functionExpression() {
      var id =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var params = arguments.length > 1 ? arguments[1] : undefined;
      var body = arguments.length > 2 ? arguments[2] : undefined;
      var generator =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : false;
      var async =
        arguments.length > 4 && arguments[4] !== undefined
          ? arguments[4]
          : false;
      var node = {
        type: "FunctionExpression",
        id: id,
        params: params,
        body: body,
        generator: generator,
        async: async
      };
      var defs = NODE_FIELDS.FunctionExpression;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.params, node, "params", params, 1);
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs.generator, node, "generator", generator);
      validate$1(defs.async, node, "async", async);
      return node;
    }
    function identifier(name) {
      var node = { type: "Identifier", name: name };
      var defs = NODE_FIELDS.Identifier;
      validate$1(defs.name, node, "name", name);
      return node;
    }
    function ifStatement(test, consequent) {
      var alternate =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "IfStatement",
        test: test,
        consequent: consequent,
        alternate: alternate
      };
      var defs = NODE_FIELDS.IfStatement;
      validate$1(defs.test, node, "test", test, 1);
      validate$1(defs.consequent, node, "consequent", consequent, 1);
      validate$1(defs.alternate, node, "alternate", alternate, 1);
      return node;
    }
    function labeledStatement(label, body) {
      var node = { type: "LabeledStatement", label: label, body: body };
      var defs = NODE_FIELDS.LabeledStatement;
      validate$1(defs.label, node, "label", label, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function stringLiteral(value) {
      var node = { type: "StringLiteral", value: value };
      var defs = NODE_FIELDS.StringLiteral;
      validate$1(defs.value, node, "value", value);
      return node;
    }
    function numericLiteral(value) {
      var node = { type: "NumericLiteral", value: value };
      var defs = NODE_FIELDS.NumericLiteral;
      validate$1(defs.value, node, "value", value);
      return node;
    }
    function nullLiteral() {
      return { type: "NullLiteral" };
    }
    function booleanLiteral(value) {
      var node = { type: "BooleanLiteral", value: value };
      var defs = NODE_FIELDS.BooleanLiteral;
      validate$1(defs.value, node, "value", value);
      return node;
    }
    function regExpLiteral(pattern) {
      var flags =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      var node = { type: "RegExpLiteral", pattern: pattern, flags: flags };
      var defs = NODE_FIELDS.RegExpLiteral;
      validate$1(defs.pattern, node, "pattern", pattern);
      validate$1(defs.flags, node, "flags", flags);
      return node;
    }
    function logicalExpression(operator, left, right) {
      var node = {
        type: "LogicalExpression",
        operator: operator,
        left: left,
        right: right
      };
      var defs = NODE_FIELDS.LogicalExpression;
      validate$1(defs.operator, node, "operator", operator);
      validate$1(defs.left, node, "left", left, 1);
      validate$1(defs.right, node, "right", right, 1);
      return node;
    }
    function memberExpression(object, property) {
      var computed =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : false;
      var optional =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : null;
      var node = {
        type: "MemberExpression",
        object: object,
        property: property,
        computed: computed,
        optional: optional
      };
      var defs = NODE_FIELDS.MemberExpression;
      validate$1(defs.object, node, "object", object, 1);
      validate$1(defs.property, node, "property", property, 1);
      validate$1(defs.computed, node, "computed", computed);
      validate$1(defs.optional, node, "optional", optional);
      return node;
    }
    function newExpression(callee, _arguments) {
      var node = {
        type: "NewExpression",
        callee: callee,
        arguments: _arguments
      };
      var defs = NODE_FIELDS.NewExpression;
      validate$1(defs.callee, node, "callee", callee, 1);
      validate$1(defs.arguments, node, "arguments", _arguments, 1);
      return node;
    }
    function program(body) {
      var directives =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var sourceType =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : "script";
      var interpreter =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : null;
      var node = {
        type: "Program",
        body: body,
        directives: directives,
        sourceType: sourceType,
        interpreter: interpreter
      };
      var defs = NODE_FIELDS.Program;
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs.directives, node, "directives", directives, 1);
      validate$1(defs.sourceType, node, "sourceType", sourceType);
      validate$1(defs.interpreter, node, "interpreter", interpreter, 1);
      return node;
    }
    function objectExpression(properties) {
      var node = { type: "ObjectExpression", properties: properties };
      var defs = NODE_FIELDS.ObjectExpression;
      validate$1(defs.properties, node, "properties", properties, 1);
      return node;
    }
    function objectMethod() {
      var kind =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : "method";
      var key = arguments.length > 1 ? arguments[1] : undefined;
      var params = arguments.length > 2 ? arguments[2] : undefined;
      var body = arguments.length > 3 ? arguments[3] : undefined;
      var computed =
        arguments.length > 4 && arguments[4] !== undefined
          ? arguments[4]
          : false;
      var generator =
        arguments.length > 5 && arguments[5] !== undefined
          ? arguments[5]
          : false;
      var async =
        arguments.length > 6 && arguments[6] !== undefined
          ? arguments[6]
          : false;
      var node = {
        type: "ObjectMethod",
        kind: kind,
        key: key,
        params: params,
        body: body,
        computed: computed,
        generator: generator,
        async: async
      };
      var defs = NODE_FIELDS.ObjectMethod;
      validate$1(defs.kind, node, "kind", kind);
      validate$1(defs.key, node, "key", key, 1);
      validate$1(defs.params, node, "params", params, 1);
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs.computed, node, "computed", computed);
      validate$1(defs.generator, node, "generator", generator);
      validate$1(defs.async, node, "async", async);
      return node;
    }
    function objectProperty(key, value) {
      var computed =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : false;
      var shorthand =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : false;
      var decorators =
        arguments.length > 4 && arguments[4] !== undefined
          ? arguments[4]
          : null;
      var node = {
        type: "ObjectProperty",
        key: key,
        value: value,
        computed: computed,
        shorthand: shorthand,
        decorators: decorators
      };
      var defs = NODE_FIELDS.ObjectProperty;
      validate$1(defs.key, node, "key", key, 1);
      validate$1(defs.value, node, "value", value, 1);
      validate$1(defs.computed, node, "computed", computed);
      validate$1(defs.shorthand, node, "shorthand", shorthand);
      validate$1(defs.decorators, node, "decorators", decorators, 1);
      return node;
    }
    function restElement(argument) {
      var node = { type: "RestElement", argument: argument };
      var defs = NODE_FIELDS.RestElement;
      validate$1(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function returnStatement() {
      var argument =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var node = { type: "ReturnStatement", argument: argument };
      var defs = NODE_FIELDS.ReturnStatement;
      validate$1(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function sequenceExpression(expressions) {
      var node = { type: "SequenceExpression", expressions: expressions };
      var defs = NODE_FIELDS.SequenceExpression;
      validate$1(defs.expressions, node, "expressions", expressions, 1);
      return node;
    }
    function parenthesizedExpression(expression) {
      var node = { type: "ParenthesizedExpression", expression: expression };
      var defs = NODE_FIELDS.ParenthesizedExpression;
      validate$1(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function switchCase() {
      var test =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var consequent = arguments.length > 1 ? arguments[1] : undefined;
      var node = { type: "SwitchCase", test: test, consequent: consequent };
      var defs = NODE_FIELDS.SwitchCase;
      validate$1(defs.test, node, "test", test, 1);
      validate$1(defs.consequent, node, "consequent", consequent, 1);
      return node;
    }
    function switchStatement(discriminant, cases) {
      var node = {
        type: "SwitchStatement",
        discriminant: discriminant,
        cases: cases
      };
      var defs = NODE_FIELDS.SwitchStatement;
      validate$1(defs.discriminant, node, "discriminant", discriminant, 1);
      validate$1(defs.cases, node, "cases", cases, 1);
      return node;
    }
    function thisExpression() {
      return { type: "ThisExpression" };
    }
    function throwStatement(argument) {
      var node = { type: "ThrowStatement", argument: argument };
      var defs = NODE_FIELDS.ThrowStatement;
      validate$1(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function tryStatement(block) {
      var handler =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var finalizer =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "TryStatement",
        block: block,
        handler: handler,
        finalizer: finalizer
      };
      var defs = NODE_FIELDS.TryStatement;
      validate$1(defs.block, node, "block", block, 1);
      validate$1(defs.handler, node, "handler", handler, 1);
      validate$1(defs.finalizer, node, "finalizer", finalizer, 1);
      return node;
    }
    function unaryExpression(operator, argument) {
      var prefix =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : true;
      var node = {
        type: "UnaryExpression",
        operator: operator,
        argument: argument,
        prefix: prefix
      };
      var defs = NODE_FIELDS.UnaryExpression;
      validate$1(defs.operator, node, "operator", operator);
      validate$1(defs.argument, node, "argument", argument, 1);
      validate$1(defs.prefix, node, "prefix", prefix);
      return node;
    }
    function updateExpression(operator, argument) {
      var prefix =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : false;
      var node = {
        type: "UpdateExpression",
        operator: operator,
        argument: argument,
        prefix: prefix
      };
      var defs = NODE_FIELDS.UpdateExpression;
      validate$1(defs.operator, node, "operator", operator);
      validate$1(defs.argument, node, "argument", argument, 1);
      validate$1(defs.prefix, node, "prefix", prefix);
      return node;
    }
    function variableDeclaration(kind, declarations) {
      var node = {
        type: "VariableDeclaration",
        kind: kind,
        declarations: declarations
      };
      var defs = NODE_FIELDS.VariableDeclaration;
      validate$1(defs.kind, node, "kind", kind);
      validate$1(defs.declarations, node, "declarations", declarations, 1);
      return node;
    }
    function variableDeclarator(id) {
      var init =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = { type: "VariableDeclarator", id: id, init: init };
      var defs = NODE_FIELDS.VariableDeclarator;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.init, node, "init", init, 1);
      return node;
    }
    function whileStatement(test, body) {
      var node = { type: "WhileStatement", test: test, body: body };
      var defs = NODE_FIELDS.WhileStatement;
      validate$1(defs.test, node, "test", test, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function withStatement(object, body) {
      var node = { type: "WithStatement", object: object, body: body };
      var defs = NODE_FIELDS.WithStatement;
      validate$1(defs.object, node, "object", object, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function assignmentPattern(left, right) {
      var node = { type: "AssignmentPattern", left: left, right: right };
      var defs = NODE_FIELDS.AssignmentPattern;
      validate$1(defs.left, node, "left", left, 1);
      validate$1(defs.right, node, "right", right, 1);
      return node;
    }
    function arrayPattern(elements) {
      var node = { type: "ArrayPattern", elements: elements };
      var defs = NODE_FIELDS.ArrayPattern;
      validate$1(defs.elements, node, "elements", elements, 1);
      return node;
    }
    function arrowFunctionExpression(params, body) {
      var async =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : false;
      var node = {
        type: "ArrowFunctionExpression",
        params: params,
        body: body,
        async: async,
        expression: null
      };
      var defs = NODE_FIELDS.ArrowFunctionExpression;
      validate$1(defs.params, node, "params", params, 1);
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs.async, node, "async", async);
      return node;
    }
    function classBody(body) {
      var node = { type: "ClassBody", body: body };
      var defs = NODE_FIELDS.ClassBody;
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function classExpression() {
      var id =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var superClass =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var body = arguments.length > 2 ? arguments[2] : undefined;
      var decorators =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : null;
      var node = {
        type: "ClassExpression",
        id: id,
        superClass: superClass,
        body: body,
        decorators: decorators
      };
      var defs = NODE_FIELDS.ClassExpression;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.superClass, node, "superClass", superClass, 1);
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs.decorators, node, "decorators", decorators, 1);
      return node;
    }
    function classDeclaration() {
      var id =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var superClass =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var body = arguments.length > 2 ? arguments[2] : undefined;
      var decorators =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : null;
      var node = {
        type: "ClassDeclaration",
        id: id,
        superClass: superClass,
        body: body,
        decorators: decorators
      };
      var defs = NODE_FIELDS.ClassDeclaration;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.superClass, node, "superClass", superClass, 1);
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs.decorators, node, "decorators", decorators, 1);
      return node;
    }
    function exportAllDeclaration(source) {
      var node = { type: "ExportAllDeclaration", source: source };
      var defs = NODE_FIELDS.ExportAllDeclaration;
      validate$1(defs.source, node, "source", source, 1);
      return node;
    }
    function exportDefaultDeclaration(declaration) {
      var node = { type: "ExportDefaultDeclaration", declaration: declaration };
      var defs = NODE_FIELDS.ExportDefaultDeclaration;
      validate$1(defs.declaration, node, "declaration", declaration, 1);
      return node;
    }
    function exportNamedDeclaration() {
      var declaration =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var specifiers =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var source =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "ExportNamedDeclaration",
        declaration: declaration,
        specifiers: specifiers,
        source: source
      };
      var defs = NODE_FIELDS.ExportNamedDeclaration;
      validate$1(defs.declaration, node, "declaration", declaration, 1);
      validate$1(defs.specifiers, node, "specifiers", specifiers, 1);
      validate$1(defs.source, node, "source", source, 1);
      return node;
    }
    function exportSpecifier(local, exported) {
      var node = { type: "ExportSpecifier", local: local, exported: exported };
      var defs = NODE_FIELDS.ExportSpecifier;
      validate$1(defs.local, node, "local", local, 1);
      validate$1(defs.exported, node, "exported", exported, 1);
      return node;
    }
    function forOfStatement(left, right, body) {
      var _await =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : false;
      var node = {
        type: "ForOfStatement",
        left: left,
        right: right,
        body: body,
        await: _await
      };
      var defs = NODE_FIELDS.ForOfStatement;
      validate$1(defs.left, node, "left", left, 1);
      validate$1(defs.right, node, "right", right, 1);
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs["await"], node, "await", _await);
      return node;
    }
    function importDeclaration(specifiers, source) {
      var node = {
        type: "ImportDeclaration",
        specifiers: specifiers,
        source: source
      };
      var defs = NODE_FIELDS.ImportDeclaration;
      validate$1(defs.specifiers, node, "specifiers", specifiers, 1);
      validate$1(defs.source, node, "source", source, 1);
      return node;
    }
    function importDefaultSpecifier(local) {
      var node = { type: "ImportDefaultSpecifier", local: local };
      var defs = NODE_FIELDS.ImportDefaultSpecifier;
      validate$1(defs.local, node, "local", local, 1);
      return node;
    }
    function importNamespaceSpecifier(local) {
      var node = { type: "ImportNamespaceSpecifier", local: local };
      var defs = NODE_FIELDS.ImportNamespaceSpecifier;
      validate$1(defs.local, node, "local", local, 1);
      return node;
    }
    function importSpecifier(local, imported) {
      var node = { type: "ImportSpecifier", local: local, imported: imported };
      var defs = NODE_FIELDS.ImportSpecifier;
      validate$1(defs.local, node, "local", local, 1);
      validate$1(defs.imported, node, "imported", imported, 1);
      return node;
    }
    function importExpression(source) {
      var options =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = { type: "ImportExpression", source: source, options: options };
      var defs = NODE_FIELDS.ImportExpression;
      validate$1(defs.source, node, "source", source, 1);
      validate$1(defs.options, node, "options", options, 1);
      return node;
    }
    function metaProperty(meta, property) {
      var node = { type: "MetaProperty", meta: meta, property: property };
      var defs = NODE_FIELDS.MetaProperty;
      validate$1(defs.meta, node, "meta", meta, 1);
      validate$1(defs.property, node, "property", property, 1);
      return node;
    }
    function classMethod() {
      var kind =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : "method";
      var key = arguments.length > 1 ? arguments[1] : undefined;
      var params = arguments.length > 2 ? arguments[2] : undefined;
      var body = arguments.length > 3 ? arguments[3] : undefined;
      var computed =
        arguments.length > 4 && arguments[4] !== undefined
          ? arguments[4]
          : false;
      var _static =
        arguments.length > 5 && arguments[5] !== undefined
          ? arguments[5]
          : false;
      var generator =
        arguments.length > 6 && arguments[6] !== undefined
          ? arguments[6]
          : false;
      var async =
        arguments.length > 7 && arguments[7] !== undefined
          ? arguments[7]
          : false;
      var node = {
        type: "ClassMethod",
        kind: kind,
        key: key,
        params: params,
        body: body,
        computed: computed,
        static: _static,
        generator: generator,
        async: async
      };
      var defs = NODE_FIELDS.ClassMethod;
      validate$1(defs.kind, node, "kind", kind);
      validate$1(defs.key, node, "key", key, 1);
      validate$1(defs.params, node, "params", params, 1);
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs.computed, node, "computed", computed);
      validate$1(defs["static"], node, "static", _static);
      validate$1(defs.generator, node, "generator", generator);
      validate$1(defs.async, node, "async", async);
      return node;
    }
    function objectPattern(properties) {
      var node = { type: "ObjectPattern", properties: properties };
      var defs = NODE_FIELDS.ObjectPattern;
      validate$1(defs.properties, node, "properties", properties, 1);
      return node;
    }
    function spreadElement(argument) {
      var node = { type: "SpreadElement", argument: argument };
      var defs = NODE_FIELDS.SpreadElement;
      validate$1(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function _super() {
      return { type: "Super" };
    }
    function taggedTemplateExpression(tag, quasi) {
      var node = { type: "TaggedTemplateExpression", tag: tag, quasi: quasi };
      var defs = NODE_FIELDS.TaggedTemplateExpression;
      validate$1(defs.tag, node, "tag", tag, 1);
      validate$1(defs.quasi, node, "quasi", quasi, 1);
      return node;
    }
    function templateElement(value) {
      var tail =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : false;
      var node = { type: "TemplateElement", value: value, tail: tail };
      var defs = NODE_FIELDS.TemplateElement;
      validate$1(defs.value, node, "value", value);
      validate$1(defs.tail, node, "tail", tail);
      return node;
    }
    function templateLiteral(quasis, expressions) {
      var node = {
        type: "TemplateLiteral",
        quasis: quasis,
        expressions: expressions
      };
      var defs = NODE_FIELDS.TemplateLiteral;
      validate$1(defs.quasis, node, "quasis", quasis, 1);
      validate$1(defs.expressions, node, "expressions", expressions, 1);
      return node;
    }
    function yieldExpression() {
      var argument =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var delegate =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : false;
      var node = {
        type: "YieldExpression",
        argument: argument,
        delegate: delegate
      };
      var defs = NODE_FIELDS.YieldExpression;
      validate$1(defs.argument, node, "argument", argument, 1);
      validate$1(defs.delegate, node, "delegate", delegate);
      return node;
    }
    function awaitExpression(argument) {
      var node = { type: "AwaitExpression", argument: argument };
      var defs = NODE_FIELDS.AwaitExpression;
      validate$1(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function _import() {
      return { type: "Import" };
    }
    function bigIntLiteral(value) {
      var node = { type: "BigIntLiteral", value: value };
      var defs = NODE_FIELDS.BigIntLiteral;
      validate$1(defs.value, node, "value", value);
      return node;
    }
    function exportNamespaceSpecifier(exported) {
      var node = { type: "ExportNamespaceSpecifier", exported: exported };
      var defs = NODE_FIELDS.ExportNamespaceSpecifier;
      validate$1(defs.exported, node, "exported", exported, 1);
      return node;
    }
    function optionalMemberExpression(object, property) {
      var computed =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : false;
      var optional = arguments.length > 3 ? arguments[3] : undefined;
      var node = {
        type: "OptionalMemberExpression",
        object: object,
        property: property,
        computed: computed,
        optional: optional
      };
      var defs = NODE_FIELDS.OptionalMemberExpression;
      validate$1(defs.object, node, "object", object, 1);
      validate$1(defs.property, node, "property", property, 1);
      validate$1(defs.computed, node, "computed", computed);
      validate$1(defs.optional, node, "optional", optional);
      return node;
    }
    function optionalCallExpression(callee, _arguments, optional) {
      var node = {
        type: "OptionalCallExpression",
        callee: callee,
        arguments: _arguments,
        optional: optional
      };
      var defs = NODE_FIELDS.OptionalCallExpression;
      validate$1(defs.callee, node, "callee", callee, 1);
      validate$1(defs.arguments, node, "arguments", _arguments, 1);
      validate$1(defs.optional, node, "optional", optional);
      return node;
    }
    function classProperty(key) {
      var value =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var typeAnnotation =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var decorators =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : null;
      var computed =
        arguments.length > 4 && arguments[4] !== undefined
          ? arguments[4]
          : false;
      var _static =
        arguments.length > 5 && arguments[5] !== undefined
          ? arguments[5]
          : false;
      var node = {
        type: "ClassProperty",
        key: key,
        value: value,
        typeAnnotation: typeAnnotation,
        decorators: decorators,
        computed: computed,
        static: _static
      };
      var defs = NODE_FIELDS.ClassProperty;
      validate$1(defs.key, node, "key", key, 1);
      validate$1(defs.value, node, "value", value, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      validate$1(defs.decorators, node, "decorators", decorators, 1);
      validate$1(defs.computed, node, "computed", computed);
      validate$1(defs["static"], node, "static", _static);
      return node;
    }
    function classAccessorProperty(key) {
      var value =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var typeAnnotation =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var decorators =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : null;
      var computed =
        arguments.length > 4 && arguments[4] !== undefined
          ? arguments[4]
          : false;
      var _static =
        arguments.length > 5 && arguments[5] !== undefined
          ? arguments[5]
          : false;
      var node = {
        type: "ClassAccessorProperty",
        key: key,
        value: value,
        typeAnnotation: typeAnnotation,
        decorators: decorators,
        computed: computed,
        static: _static
      };
      var defs = NODE_FIELDS.ClassAccessorProperty;
      validate$1(defs.key, node, "key", key, 1);
      validate$1(defs.value, node, "value", value, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      validate$1(defs.decorators, node, "decorators", decorators, 1);
      validate$1(defs.computed, node, "computed", computed);
      validate$1(defs["static"], node, "static", _static);
      return node;
    }
    function classPrivateProperty(key) {
      var value =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var decorators =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var _static =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : false;
      var node = {
        type: "ClassPrivateProperty",
        key: key,
        value: value,
        decorators: decorators,
        static: _static
      };
      var defs = NODE_FIELDS.ClassPrivateProperty;
      validate$1(defs.key, node, "key", key, 1);
      validate$1(defs.value, node, "value", value, 1);
      validate$1(defs.decorators, node, "decorators", decorators, 1);
      validate$1(defs["static"], node, "static", _static);
      return node;
    }
    function classPrivateMethod() {
      var kind =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : "method";
      var key = arguments.length > 1 ? arguments[1] : undefined;
      var params = arguments.length > 2 ? arguments[2] : undefined;
      var body = arguments.length > 3 ? arguments[3] : undefined;
      var _static =
        arguments.length > 4 && arguments[4] !== undefined
          ? arguments[4]
          : false;
      var node = {
        type: "ClassPrivateMethod",
        kind: kind,
        key: key,
        params: params,
        body: body,
        static: _static
      };
      var defs = NODE_FIELDS.ClassPrivateMethod;
      validate$1(defs.kind, node, "kind", kind);
      validate$1(defs.key, node, "key", key, 1);
      validate$1(defs.params, node, "params", params, 1);
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs["static"], node, "static", _static);
      return node;
    }
    function privateName(id) {
      var node = { type: "PrivateName", id: id };
      var defs = NODE_FIELDS.PrivateName;
      validate$1(defs.id, node, "id", id, 1);
      return node;
    }
    function staticBlock(body) {
      var node = { type: "StaticBlock", body: body };
      var defs = NODE_FIELDS.StaticBlock;
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function anyTypeAnnotation() {
      return { type: "AnyTypeAnnotation" };
    }
    function arrayTypeAnnotation(elementType) {
      var node = { type: "ArrayTypeAnnotation", elementType: elementType };
      var defs = NODE_FIELDS.ArrayTypeAnnotation;
      validate$1(defs.elementType, node, "elementType", elementType, 1);
      return node;
    }
    function booleanTypeAnnotation() {
      return { type: "BooleanTypeAnnotation" };
    }
    function booleanLiteralTypeAnnotation(value) {
      var node = { type: "BooleanLiteralTypeAnnotation", value: value };
      var defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
      validate$1(defs.value, node, "value", value);
      return node;
    }
    function nullLiteralTypeAnnotation() {
      return { type: "NullLiteralTypeAnnotation" };
    }
    function classImplements(id) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = {
        type: "ClassImplements",
        id: id,
        typeParameters: typeParameters
      };
      var defs = NODE_FIELDS.ClassImplements;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      return node;
    }
    function declareClass(id) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var _extends =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var body = arguments.length > 3 ? arguments[3] : undefined;
      var node = {
        type: "DeclareClass",
        id: id,
        typeParameters: typeParameters,
        extends: _extends,
        body: body
      };
      var defs = NODE_FIELDS.DeclareClass;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs["extends"], node, "extends", _extends, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function declareFunction(id) {
      var node = { type: "DeclareFunction", id: id };
      var defs = NODE_FIELDS.DeclareFunction;
      validate$1(defs.id, node, "id", id, 1);
      return node;
    }
    function declareInterface(id) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var _extends =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var body = arguments.length > 3 ? arguments[3] : undefined;
      var node = {
        type: "DeclareInterface",
        id: id,
        typeParameters: typeParameters,
        extends: _extends,
        body: body
      };
      var defs = NODE_FIELDS.DeclareInterface;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs["extends"], node, "extends", _extends, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function declareModule(id, body) {
      var kind =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = { type: "DeclareModule", id: id, body: body, kind: kind };
      var defs = NODE_FIELDS.DeclareModule;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs.kind, node, "kind", kind);
      return node;
    }
    function declareModuleExports(typeAnnotation) {
      var node = {
        type: "DeclareModuleExports",
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.DeclareModuleExports;
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function declareTypeAlias(id) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var right = arguments.length > 2 ? arguments[2] : undefined;
      var node = {
        type: "DeclareTypeAlias",
        id: id,
        typeParameters: typeParameters,
        right: right
      };
      var defs = NODE_FIELDS.DeclareTypeAlias;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs.right, node, "right", right, 1);
      return node;
    }
    function declareOpaqueType(id) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var supertype =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "DeclareOpaqueType",
        id: id,
        typeParameters: typeParameters,
        supertype: supertype
      };
      var defs = NODE_FIELDS.DeclareOpaqueType;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs.supertype, node, "supertype", supertype, 1);
      return node;
    }
    function declareVariable(id) {
      var node = { type: "DeclareVariable", id: id };
      var defs = NODE_FIELDS.DeclareVariable;
      validate$1(defs.id, node, "id", id, 1);
      return node;
    }
    function declareExportDeclaration() {
      var declaration =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var specifiers =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var source =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var attributes =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : null;
      var node = {
        type: "DeclareExportDeclaration",
        declaration: declaration,
        specifiers: specifiers,
        source: source,
        attributes: attributes
      };
      var defs = NODE_FIELDS.DeclareExportDeclaration;
      validate$1(defs.declaration, node, "declaration", declaration, 1);
      validate$1(defs.specifiers, node, "specifiers", specifiers, 1);
      validate$1(defs.source, node, "source", source, 1);
      validate$1(defs.attributes, node, "attributes", attributes, 1);
      return node;
    }
    function declareExportAllDeclaration(source) {
      var attributes =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = {
        type: "DeclareExportAllDeclaration",
        source: source,
        attributes: attributes
      };
      var defs = NODE_FIELDS.DeclareExportAllDeclaration;
      validate$1(defs.source, node, "source", source, 1);
      validate$1(defs.attributes, node, "attributes", attributes, 1);
      return node;
    }
    function declaredPredicate(value) {
      var node = { type: "DeclaredPredicate", value: value };
      var defs = NODE_FIELDS.DeclaredPredicate;
      validate$1(defs.value, node, "value", value, 1);
      return node;
    }
    function existsTypeAnnotation() {
      return { type: "ExistsTypeAnnotation" };
    }
    function functionTypeAnnotation() {
      var typeParameters =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var params = arguments.length > 1 ? arguments[1] : undefined;
      var rest =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var returnType = arguments.length > 3 ? arguments[3] : undefined;
      var node = {
        type: "FunctionTypeAnnotation",
        typeParameters: typeParameters,
        params: params,
        rest: rest,
        returnType: returnType
      };
      var defs = NODE_FIELDS.FunctionTypeAnnotation;
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs.params, node, "params", params, 1);
      validate$1(defs.rest, node, "rest", rest, 1);
      validate$1(defs.returnType, node, "returnType", returnType, 1);
      return node;
    }
    function functionTypeParam() {
      var name =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var typeAnnotation = arguments.length > 1 ? arguments[1] : undefined;
      var node = {
        type: "FunctionTypeParam",
        name: name,
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.FunctionTypeParam;
      validate$1(defs.name, node, "name", name, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function genericTypeAnnotation(id) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = {
        type: "GenericTypeAnnotation",
        id: id,
        typeParameters: typeParameters
      };
      var defs = NODE_FIELDS.GenericTypeAnnotation;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      return node;
    }
    function inferredPredicate() {
      return { type: "InferredPredicate" };
    }
    function interfaceExtends(id) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = {
        type: "InterfaceExtends",
        id: id,
        typeParameters: typeParameters
      };
      var defs = NODE_FIELDS.InterfaceExtends;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      return node;
    }
    function interfaceDeclaration(id) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var _extends =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var body = arguments.length > 3 ? arguments[3] : undefined;
      var node = {
        type: "InterfaceDeclaration",
        id: id,
        typeParameters: typeParameters,
        extends: _extends,
        body: body
      };
      var defs = NODE_FIELDS.InterfaceDeclaration;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs["extends"], node, "extends", _extends, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function interfaceTypeAnnotation() {
      var _extends =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var body = arguments.length > 1 ? arguments[1] : undefined;
      var node = {
        type: "InterfaceTypeAnnotation",
        extends: _extends,
        body: body
      };
      var defs = NODE_FIELDS.InterfaceTypeAnnotation;
      validate$1(defs["extends"], node, "extends", _extends, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function intersectionTypeAnnotation(types) {
      var node = { type: "IntersectionTypeAnnotation", types: types };
      var defs = NODE_FIELDS.IntersectionTypeAnnotation;
      validate$1(defs.types, node, "types", types, 1);
      return node;
    }
    function mixedTypeAnnotation() {
      return { type: "MixedTypeAnnotation" };
    }
    function emptyTypeAnnotation() {
      return { type: "EmptyTypeAnnotation" };
    }
    function nullableTypeAnnotation(typeAnnotation) {
      var node = {
        type: "NullableTypeAnnotation",
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.NullableTypeAnnotation;
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function numberLiteralTypeAnnotation(value) {
      var node = { type: "NumberLiteralTypeAnnotation", value: value };
      var defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
      validate$1(defs.value, node, "value", value);
      return node;
    }
    function numberTypeAnnotation() {
      return { type: "NumberTypeAnnotation" };
    }
    function objectTypeAnnotation(properties) {
      var indexers =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var callProperties =
        arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var internalSlots =
        arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      var exact =
        arguments.length > 4 && arguments[4] !== undefined
          ? arguments[4]
          : false;
      var node = {
        type: "ObjectTypeAnnotation",
        properties: properties,
        indexers: indexers,
        callProperties: callProperties,
        internalSlots: internalSlots,
        exact: exact
      };
      var defs = NODE_FIELDS.ObjectTypeAnnotation;
      validate$1(defs.properties, node, "properties", properties, 1);
      validate$1(defs.indexers, node, "indexers", indexers, 1);
      validate$1(
        defs.callProperties,
        node,
        "callProperties",
        callProperties,
        1
      );
      validate$1(defs.internalSlots, node, "internalSlots", internalSlots, 1);
      validate$1(defs.exact, node, "exact", exact);
      return node;
    }
    function objectTypeInternalSlot(id, value, optional, _static, method) {
      var node = {
        type: "ObjectTypeInternalSlot",
        id: id,
        value: value,
        optional: optional,
        static: _static,
        method: method
      };
      var defs = NODE_FIELDS.ObjectTypeInternalSlot;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.value, node, "value", value, 1);
      validate$1(defs.optional, node, "optional", optional);
      validate$1(defs["static"], node, "static", _static);
      validate$1(defs.method, node, "method", method);
      return node;
    }
    function objectTypeCallProperty(value) {
      var node = { type: "ObjectTypeCallProperty", value: value, static: null };
      var defs = NODE_FIELDS.ObjectTypeCallProperty;
      validate$1(defs.value, node, "value", value, 1);
      return node;
    }
    function objectTypeIndexer() {
      var id =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var key = arguments.length > 1 ? arguments[1] : undefined;
      var value = arguments.length > 2 ? arguments[2] : undefined;
      var variance =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : null;
      var node = {
        type: "ObjectTypeIndexer",
        id: id,
        key: key,
        value: value,
        variance: variance,
        static: null
      };
      var defs = NODE_FIELDS.ObjectTypeIndexer;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.key, node, "key", key, 1);
      validate$1(defs.value, node, "value", value, 1);
      validate$1(defs.variance, node, "variance", variance, 1);
      return node;
    }
    function objectTypeProperty(key, value) {
      var variance =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "ObjectTypeProperty",
        key: key,
        value: value,
        variance: variance,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null
      };
      var defs = NODE_FIELDS.ObjectTypeProperty;
      validate$1(defs.key, node, "key", key, 1);
      validate$1(defs.value, node, "value", value, 1);
      validate$1(defs.variance, node, "variance", variance, 1);
      return node;
    }
    function objectTypeSpreadProperty(argument) {
      var node = { type: "ObjectTypeSpreadProperty", argument: argument };
      var defs = NODE_FIELDS.ObjectTypeSpreadProperty;
      validate$1(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function opaqueType(id) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var supertype =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var impltype = arguments.length > 3 ? arguments[3] : undefined;
      var node = {
        type: "OpaqueType",
        id: id,
        typeParameters: typeParameters,
        supertype: supertype,
        impltype: impltype
      };
      var defs = NODE_FIELDS.OpaqueType;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs.supertype, node, "supertype", supertype, 1);
      validate$1(defs.impltype, node, "impltype", impltype, 1);
      return node;
    }
    function qualifiedTypeIdentifier(id, qualification) {
      var node = {
        type: "QualifiedTypeIdentifier",
        id: id,
        qualification: qualification
      };
      var defs = NODE_FIELDS.QualifiedTypeIdentifier;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.qualification, node, "qualification", qualification, 1);
      return node;
    }
    function stringLiteralTypeAnnotation(value) {
      var node = { type: "StringLiteralTypeAnnotation", value: value };
      var defs = NODE_FIELDS.StringLiteralTypeAnnotation;
      validate$1(defs.value, node, "value", value);
      return node;
    }
    function stringTypeAnnotation() {
      return { type: "StringTypeAnnotation" };
    }
    function symbolTypeAnnotation() {
      return { type: "SymbolTypeAnnotation" };
    }
    function thisTypeAnnotation() {
      return { type: "ThisTypeAnnotation" };
    }
    function tupleTypeAnnotation(types) {
      var node = { type: "TupleTypeAnnotation", types: types };
      var defs = NODE_FIELDS.TupleTypeAnnotation;
      validate$1(defs.types, node, "types", types, 1);
      return node;
    }
    function typeofTypeAnnotation(argument) {
      var node = { type: "TypeofTypeAnnotation", argument: argument };
      var defs = NODE_FIELDS.TypeofTypeAnnotation;
      validate$1(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function typeAlias(id) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var right = arguments.length > 2 ? arguments[2] : undefined;
      var node = {
        type: "TypeAlias",
        id: id,
        typeParameters: typeParameters,
        right: right
      };
      var defs = NODE_FIELDS.TypeAlias;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs.right, node, "right", right, 1);
      return node;
    }
    function typeAnnotation(typeAnnotation) {
      var node = { type: "TypeAnnotation", typeAnnotation: typeAnnotation };
      var defs = NODE_FIELDS.TypeAnnotation;
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function typeCastExpression(expression, typeAnnotation) {
      var node = {
        type: "TypeCastExpression",
        expression: expression,
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.TypeCastExpression;
      validate$1(defs.expression, node, "expression", expression, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function typeParameter() {
      var bound =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var _default =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var variance =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "TypeParameter",
        bound: bound,
        default: _default,
        variance: variance,
        name: null
      };
      var defs = NODE_FIELDS.TypeParameter;
      validate$1(defs.bound, node, "bound", bound, 1);
      validate$1(defs["default"], node, "default", _default, 1);
      validate$1(defs.variance, node, "variance", variance, 1);
      return node;
    }
    function typeParameterDeclaration(params) {
      var node = { type: "TypeParameterDeclaration", params: params };
      var defs = NODE_FIELDS.TypeParameterDeclaration;
      validate$1(defs.params, node, "params", params, 1);
      return node;
    }
    function typeParameterInstantiation(params) {
      var node = { type: "TypeParameterInstantiation", params: params };
      var defs = NODE_FIELDS.TypeParameterInstantiation;
      validate$1(defs.params, node, "params", params, 1);
      return node;
    }
    function unionTypeAnnotation(types) {
      var node = { type: "UnionTypeAnnotation", types: types };
      var defs = NODE_FIELDS.UnionTypeAnnotation;
      validate$1(defs.types, node, "types", types, 1);
      return node;
    }
    function variance(kind) {
      var node = { type: "Variance", kind: kind };
      var defs = NODE_FIELDS.Variance;
      validate$1(defs.kind, node, "kind", kind);
      return node;
    }
    function voidTypeAnnotation() {
      return { type: "VoidTypeAnnotation" };
    }
    function enumDeclaration(id, body) {
      var node = { type: "EnumDeclaration", id: id, body: body };
      var defs = NODE_FIELDS.EnumDeclaration;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function enumBooleanBody(members) {
      var node = {
        type: "EnumBooleanBody",
        members: members,
        explicitType: null,
        hasUnknownMembers: null
      };
      var defs = NODE_FIELDS.EnumBooleanBody;
      validate$1(defs.members, node, "members", members, 1);
      return node;
    }
    function enumNumberBody(members) {
      var node = {
        type: "EnumNumberBody",
        members: members,
        explicitType: null,
        hasUnknownMembers: null
      };
      var defs = NODE_FIELDS.EnumNumberBody;
      validate$1(defs.members, node, "members", members, 1);
      return node;
    }
    function enumStringBody(members) {
      var node = {
        type: "EnumStringBody",
        members: members,
        explicitType: null,
        hasUnknownMembers: null
      };
      var defs = NODE_FIELDS.EnumStringBody;
      validate$1(defs.members, node, "members", members, 1);
      return node;
    }
    function enumSymbolBody(members) {
      var node = {
        type: "EnumSymbolBody",
        members: members,
        hasUnknownMembers: null
      };
      var defs = NODE_FIELDS.EnumSymbolBody;
      validate$1(defs.members, node, "members", members, 1);
      return node;
    }
    function enumBooleanMember(id) {
      var node = { type: "EnumBooleanMember", id: id, init: null };
      var defs = NODE_FIELDS.EnumBooleanMember;
      validate$1(defs.id, node, "id", id, 1);
      return node;
    }
    function enumNumberMember(id, init) {
      var node = { type: "EnumNumberMember", id: id, init: init };
      var defs = NODE_FIELDS.EnumNumberMember;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.init, node, "init", init, 1);
      return node;
    }
    function enumStringMember(id, init) {
      var node = { type: "EnumStringMember", id: id, init: init };
      var defs = NODE_FIELDS.EnumStringMember;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.init, node, "init", init, 1);
      return node;
    }
    function enumDefaultedMember(id) {
      var node = { type: "EnumDefaultedMember", id: id };
      var defs = NODE_FIELDS.EnumDefaultedMember;
      validate$1(defs.id, node, "id", id, 1);
      return node;
    }
    function indexedAccessType(objectType, indexType) {
      var node = {
        type: "IndexedAccessType",
        objectType: objectType,
        indexType: indexType
      };
      var defs = NODE_FIELDS.IndexedAccessType;
      validate$1(defs.objectType, node, "objectType", objectType, 1);
      validate$1(defs.indexType, node, "indexType", indexType, 1);
      return node;
    }
    function optionalIndexedAccessType(objectType, indexType) {
      var node = {
        type: "OptionalIndexedAccessType",
        objectType: objectType,
        indexType: indexType,
        optional: null
      };
      var defs = NODE_FIELDS.OptionalIndexedAccessType;
      validate$1(defs.objectType, node, "objectType", objectType, 1);
      validate$1(defs.indexType, node, "indexType", indexType, 1);
      return node;
    }
    function jsxAttribute(name) {
      var value =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = { type: "JSXAttribute", name: name, value: value };
      var defs = NODE_FIELDS.JSXAttribute;
      validate$1(defs.name, node, "name", name, 1);
      validate$1(defs.value, node, "value", value, 1);
      return node;
    }
    function jsxClosingElement(name) {
      var node = { type: "JSXClosingElement", name: name };
      var defs = NODE_FIELDS.JSXClosingElement;
      validate$1(defs.name, node, "name", name, 1);
      return node;
    }
    function jsxElement(openingElement) {
      var closingElement =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var children = arguments.length > 2 ? arguments[2] : undefined;
      var selfClosing =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : null;
      var node = {
        type: "JSXElement",
        openingElement: openingElement,
        closingElement: closingElement,
        children: children,
        selfClosing: selfClosing
      };
      var defs = NODE_FIELDS.JSXElement;
      validate$1(
        defs.openingElement,
        node,
        "openingElement",
        openingElement,
        1
      );
      validate$1(
        defs.closingElement,
        node,
        "closingElement",
        closingElement,
        1
      );
      validate$1(defs.children, node, "children", children, 1);
      validate$1(defs.selfClosing, node, "selfClosing", selfClosing);
      return node;
    }
    function jsxEmptyExpression() {
      return { type: "JSXEmptyExpression" };
    }
    function jsxExpressionContainer(expression) {
      var node = { type: "JSXExpressionContainer", expression: expression };
      var defs = NODE_FIELDS.JSXExpressionContainer;
      validate$1(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function jsxSpreadChild(expression) {
      var node = { type: "JSXSpreadChild", expression: expression };
      var defs = NODE_FIELDS.JSXSpreadChild;
      validate$1(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function jsxIdentifier(name) {
      var node = { type: "JSXIdentifier", name: name };
      var defs = NODE_FIELDS.JSXIdentifier;
      validate$1(defs.name, node, "name", name);
      return node;
    }
    function jsxMemberExpression(object, property) {
      var node = {
        type: "JSXMemberExpression",
        object: object,
        property: property
      };
      var defs = NODE_FIELDS.JSXMemberExpression;
      validate$1(defs.object, node, "object", object, 1);
      validate$1(defs.property, node, "property", property, 1);
      return node;
    }
    function jsxNamespacedName(namespace, name) {
      var node = {
        type: "JSXNamespacedName",
        namespace: namespace,
        name: name
      };
      var defs = NODE_FIELDS.JSXNamespacedName;
      validate$1(defs.namespace, node, "namespace", namespace, 1);
      validate$1(defs.name, node, "name", name, 1);
      return node;
    }
    function jsxOpeningElement(name, attributes) {
      var selfClosing =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : false;
      var node = {
        type: "JSXOpeningElement",
        name: name,
        attributes: attributes,
        selfClosing: selfClosing
      };
      var defs = NODE_FIELDS.JSXOpeningElement;
      validate$1(defs.name, node, "name", name, 1);
      validate$1(defs.attributes, node, "attributes", attributes, 1);
      validate$1(defs.selfClosing, node, "selfClosing", selfClosing);
      return node;
    }
    function jsxSpreadAttribute(argument) {
      var node = { type: "JSXSpreadAttribute", argument: argument };
      var defs = NODE_FIELDS.JSXSpreadAttribute;
      validate$1(defs.argument, node, "argument", argument, 1);
      return node;
    }
    function jsxText(value) {
      var node = { type: "JSXText", value: value };
      var defs = NODE_FIELDS.JSXText;
      validate$1(defs.value, node, "value", value);
      return node;
    }
    function jsxFragment(openingFragment, closingFragment, children) {
      var node = {
        type: "JSXFragment",
        openingFragment: openingFragment,
        closingFragment: closingFragment,
        children: children
      };
      var defs = NODE_FIELDS.JSXFragment;
      validate$1(
        defs.openingFragment,
        node,
        "openingFragment",
        openingFragment,
        1
      );
      validate$1(
        defs.closingFragment,
        node,
        "closingFragment",
        closingFragment,
        1
      );
      validate$1(defs.children, node, "children", children, 1);
      return node;
    }
    function jsxOpeningFragment() {
      return { type: "JSXOpeningFragment" };
    }
    function jsxClosingFragment() {
      return { type: "JSXClosingFragment" };
    }
    function noop() {
      return { type: "Noop" };
    }
    function placeholder(expectedNode, name) {
      var node = {
        type: "Placeholder",
        expectedNode: expectedNode,
        name: name
      };
      var defs = NODE_FIELDS.Placeholder;
      validate$1(defs.expectedNode, node, "expectedNode", expectedNode);
      validate$1(defs.name, node, "name", name, 1);
      return node;
    }
    function v8IntrinsicIdentifier(name) {
      var node = { type: "V8IntrinsicIdentifier", name: name };
      var defs = NODE_FIELDS.V8IntrinsicIdentifier;
      validate$1(defs.name, node, "name", name);
      return node;
    }
    function argumentPlaceholder() {
      return { type: "ArgumentPlaceholder" };
    }
    function bindExpression(object, callee) {
      var node = { type: "BindExpression", object: object, callee: callee };
      var defs = NODE_FIELDS.BindExpression;
      validate$1(defs.object, node, "object", object, 1);
      validate$1(defs.callee, node, "callee", callee, 1);
      return node;
    }
    function importAttribute(key, value) {
      var node = { type: "ImportAttribute", key: key, value: value };
      var defs = NODE_FIELDS.ImportAttribute;
      validate$1(defs.key, node, "key", key, 1);
      validate$1(defs.value, node, "value", value, 1);
      return node;
    }
    function decorator(expression) {
      var node = { type: "Decorator", expression: expression };
      var defs = NODE_FIELDS.Decorator;
      validate$1(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function doExpression(body) {
      var async =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : false;
      var node = { type: "DoExpression", body: body, async: async };
      var defs = NODE_FIELDS.DoExpression;
      validate$1(defs.body, node, "body", body, 1);
      validate$1(defs.async, node, "async", async);
      return node;
    }
    function exportDefaultSpecifier(exported) {
      var node = { type: "ExportDefaultSpecifier", exported: exported };
      var defs = NODE_FIELDS.ExportDefaultSpecifier;
      validate$1(defs.exported, node, "exported", exported, 1);
      return node;
    }
    function recordExpression(properties) {
      var node = { type: "RecordExpression", properties: properties };
      var defs = NODE_FIELDS.RecordExpression;
      validate$1(defs.properties, node, "properties", properties, 1);
      return node;
    }
    function tupleExpression() {
      var elements =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var node = { type: "TupleExpression", elements: elements };
      var defs = NODE_FIELDS.TupleExpression;
      validate$1(defs.elements, node, "elements", elements, 1);
      return node;
    }
    function decimalLiteral(value) {
      var node = { type: "DecimalLiteral", value: value };
      var defs = NODE_FIELDS.DecimalLiteral;
      validate$1(defs.value, node, "value", value);
      return node;
    }
    function moduleExpression(body) {
      var node = { type: "ModuleExpression", body: body };
      var defs = NODE_FIELDS.ModuleExpression;
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function topicReference() {
      return { type: "TopicReference" };
    }
    function pipelineTopicExpression(expression) {
      var node = { type: "PipelineTopicExpression", expression: expression };
      var defs = NODE_FIELDS.PipelineTopicExpression;
      validate$1(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function pipelineBareFunction(callee) {
      var node = { type: "PipelineBareFunction", callee: callee };
      var defs = NODE_FIELDS.PipelineBareFunction;
      validate$1(defs.callee, node, "callee", callee, 1);
      return node;
    }
    function pipelinePrimaryTopicReference() {
      return { type: "PipelinePrimaryTopicReference" };
    }
    function tsParameterProperty(parameter) {
      var node = { type: "TSParameterProperty", parameter: parameter };
      var defs = NODE_FIELDS.TSParameterProperty;
      validate$1(defs.parameter, node, "parameter", parameter, 1);
      return node;
    }
    function tsDeclareFunction() {
      var id =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var params = arguments.length > 2 ? arguments[2] : undefined;
      var returnType =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : null;
      var node = {
        type: "TSDeclareFunction",
        id: id,
        typeParameters: typeParameters,
        params: params,
        returnType: returnType
      };
      var defs = NODE_FIELDS.TSDeclareFunction;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs.params, node, "params", params, 1);
      validate$1(defs.returnType, node, "returnType", returnType, 1);
      return node;
    }
    function tsDeclareMethod() {
      var decorators =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var key = arguments.length > 1 ? arguments[1] : undefined;
      var typeParameters =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var params = arguments.length > 3 ? arguments[3] : undefined;
      var returnType =
        arguments.length > 4 && arguments[4] !== undefined
          ? arguments[4]
          : null;
      var node = {
        type: "TSDeclareMethod",
        decorators: decorators,
        key: key,
        typeParameters: typeParameters,
        params: params,
        returnType: returnType
      };
      var defs = NODE_FIELDS.TSDeclareMethod;
      validate$1(defs.decorators, node, "decorators", decorators, 1);
      validate$1(defs.key, node, "key", key, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs.params, node, "params", params, 1);
      validate$1(defs.returnType, node, "returnType", returnType, 1);
      return node;
    }
    function tsQualifiedName(left, right) {
      var node = { type: "TSQualifiedName", left: left, right: right };
      var defs = NODE_FIELDS.TSQualifiedName;
      validate$1(defs.left, node, "left", left, 1);
      validate$1(defs.right, node, "right", right, 1);
      return node;
    }
    function tsCallSignatureDeclaration() {
      var typeParameters =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var parameters = arguments.length > 1 ? arguments[1] : undefined;
      var typeAnnotation =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "TSCallSignatureDeclaration",
        typeParameters: typeParameters,
        parameters: parameters,
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.TSCallSignatureDeclaration;
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs.parameters, node, "parameters", parameters, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsConstructSignatureDeclaration() {
      var typeParameters =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var parameters = arguments.length > 1 ? arguments[1] : undefined;
      var typeAnnotation =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "TSConstructSignatureDeclaration",
        typeParameters: typeParameters,
        parameters: parameters,
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.TSConstructSignatureDeclaration;
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs.parameters, node, "parameters", parameters, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsPropertySignature(key) {
      var typeAnnotation =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = {
        type: "TSPropertySignature",
        key: key,
        typeAnnotation: typeAnnotation,
        kind: null
      };
      var defs = NODE_FIELDS.TSPropertySignature;
      validate$1(defs.key, node, "key", key, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsMethodSignature(key) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var parameters = arguments.length > 2 ? arguments[2] : undefined;
      var typeAnnotation =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : null;
      var node = {
        type: "TSMethodSignature",
        key: key,
        typeParameters: typeParameters,
        parameters: parameters,
        typeAnnotation: typeAnnotation,
        kind: null
      };
      var defs = NODE_FIELDS.TSMethodSignature;
      validate$1(defs.key, node, "key", key, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs.parameters, node, "parameters", parameters, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsIndexSignature(parameters) {
      var typeAnnotation =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = {
        type: "TSIndexSignature",
        parameters: parameters,
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.TSIndexSignature;
      validate$1(defs.parameters, node, "parameters", parameters, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsAnyKeyword() {
      return { type: "TSAnyKeyword" };
    }
    function tsBooleanKeyword() {
      return { type: "TSBooleanKeyword" };
    }
    function tsBigIntKeyword() {
      return { type: "TSBigIntKeyword" };
    }
    function tsIntrinsicKeyword() {
      return { type: "TSIntrinsicKeyword" };
    }
    function tsNeverKeyword() {
      return { type: "TSNeverKeyword" };
    }
    function tsNullKeyword() {
      return { type: "TSNullKeyword" };
    }
    function tsNumberKeyword() {
      return { type: "TSNumberKeyword" };
    }
    function tsObjectKeyword() {
      return { type: "TSObjectKeyword" };
    }
    function tsStringKeyword() {
      return { type: "TSStringKeyword" };
    }
    function tsSymbolKeyword() {
      return { type: "TSSymbolKeyword" };
    }
    function tsUndefinedKeyword() {
      return { type: "TSUndefinedKeyword" };
    }
    function tsUnknownKeyword() {
      return { type: "TSUnknownKeyword" };
    }
    function tsVoidKeyword() {
      return { type: "TSVoidKeyword" };
    }
    function tsThisType() {
      return { type: "TSThisType" };
    }
    function tsFunctionType() {
      var typeParameters =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var parameters = arguments.length > 1 ? arguments[1] : undefined;
      var typeAnnotation =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "TSFunctionType",
        typeParameters: typeParameters,
        parameters: parameters,
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.TSFunctionType;
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs.parameters, node, "parameters", parameters, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsConstructorType() {
      var typeParameters =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var parameters = arguments.length > 1 ? arguments[1] : undefined;
      var typeAnnotation =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "TSConstructorType",
        typeParameters: typeParameters,
        parameters: parameters,
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.TSConstructorType;
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs.parameters, node, "parameters", parameters, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsTypeReference(typeName) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = {
        type: "TSTypeReference",
        typeName: typeName,
        typeParameters: typeParameters
      };
      var defs = NODE_FIELDS.TSTypeReference;
      validate$1(defs.typeName, node, "typeName", typeName, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      return node;
    }
    function tsTypePredicate(parameterName) {
      var typeAnnotation =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var asserts =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "TSTypePredicate",
        parameterName: parameterName,
        typeAnnotation: typeAnnotation,
        asserts: asserts
      };
      var defs = NODE_FIELDS.TSTypePredicate;
      validate$1(defs.parameterName, node, "parameterName", parameterName, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      validate$1(defs.asserts, node, "asserts", asserts);
      return node;
    }
    function tsTypeQuery(exprName) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = {
        type: "TSTypeQuery",
        exprName: exprName,
        typeParameters: typeParameters
      };
      var defs = NODE_FIELDS.TSTypeQuery;
      validate$1(defs.exprName, node, "exprName", exprName, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      return node;
    }
    function tsTypeLiteral(members) {
      var node = { type: "TSTypeLiteral", members: members };
      var defs = NODE_FIELDS.TSTypeLiteral;
      validate$1(defs.members, node, "members", members, 1);
      return node;
    }
    function tsArrayType(elementType) {
      var node = { type: "TSArrayType", elementType: elementType };
      var defs = NODE_FIELDS.TSArrayType;
      validate$1(defs.elementType, node, "elementType", elementType, 1);
      return node;
    }
    function tsTupleType(elementTypes) {
      var node = { type: "TSTupleType", elementTypes: elementTypes };
      var defs = NODE_FIELDS.TSTupleType;
      validate$1(defs.elementTypes, node, "elementTypes", elementTypes, 1);
      return node;
    }
    function tsOptionalType(typeAnnotation) {
      var node = { type: "TSOptionalType", typeAnnotation: typeAnnotation };
      var defs = NODE_FIELDS.TSOptionalType;
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsRestType(typeAnnotation) {
      var node = { type: "TSRestType", typeAnnotation: typeAnnotation };
      var defs = NODE_FIELDS.TSRestType;
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsNamedTupleMember(label, elementType) {
      var optional =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : false;
      var node = {
        type: "TSNamedTupleMember",
        label: label,
        elementType: elementType,
        optional: optional
      };
      var defs = NODE_FIELDS.TSNamedTupleMember;
      validate$1(defs.label, node, "label", label, 1);
      validate$1(defs.elementType, node, "elementType", elementType, 1);
      validate$1(defs.optional, node, "optional", optional);
      return node;
    }
    function tsUnionType(types) {
      var node = { type: "TSUnionType", types: types };
      var defs = NODE_FIELDS.TSUnionType;
      validate$1(defs.types, node, "types", types, 1);
      return node;
    }
    function tsIntersectionType(types) {
      var node = { type: "TSIntersectionType", types: types };
      var defs = NODE_FIELDS.TSIntersectionType;
      validate$1(defs.types, node, "types", types, 1);
      return node;
    }
    function tsConditionalType(checkType, extendsType, trueType, falseType) {
      var node = {
        type: "TSConditionalType",
        checkType: checkType,
        extendsType: extendsType,
        trueType: trueType,
        falseType: falseType
      };
      var defs = NODE_FIELDS.TSConditionalType;
      validate$1(defs.checkType, node, "checkType", checkType, 1);
      validate$1(defs.extendsType, node, "extendsType", extendsType, 1);
      validate$1(defs.trueType, node, "trueType", trueType, 1);
      validate$1(defs.falseType, node, "falseType", falseType, 1);
      return node;
    }
    function tsInferType(typeParameter) {
      var node = { type: "TSInferType", typeParameter: typeParameter };
      var defs = NODE_FIELDS.TSInferType;
      validate$1(defs.typeParameter, node, "typeParameter", typeParameter, 1);
      return node;
    }
    function tsParenthesizedType(typeAnnotation) {
      var node = {
        type: "TSParenthesizedType",
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.TSParenthesizedType;
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsTypeOperator(typeAnnotation) {
      var node = {
        type: "TSTypeOperator",
        typeAnnotation: typeAnnotation,
        operator: null
      };
      var defs = NODE_FIELDS.TSTypeOperator;
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsIndexedAccessType(objectType, indexType) {
      var node = {
        type: "TSIndexedAccessType",
        objectType: objectType,
        indexType: indexType
      };
      var defs = NODE_FIELDS.TSIndexedAccessType;
      validate$1(defs.objectType, node, "objectType", objectType, 1);
      validate$1(defs.indexType, node, "indexType", indexType, 1);
      return node;
    }
    function tsMappedType(typeParameter) {
      var typeAnnotation =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var nameType =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "TSMappedType",
        typeParameter: typeParameter,
        typeAnnotation: typeAnnotation,
        nameType: nameType
      };
      var defs = NODE_FIELDS.TSMappedType;
      validate$1(defs.typeParameter, node, "typeParameter", typeParameter, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      validate$1(defs.nameType, node, "nameType", nameType, 1);
      return node;
    }
    function tsLiteralType(literal) {
      var node = { type: "TSLiteralType", literal: literal };
      var defs = NODE_FIELDS.TSLiteralType;
      validate$1(defs.literal, node, "literal", literal, 1);
      return node;
    }
    function tsExpressionWithTypeArguments(expression) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = {
        type: "TSExpressionWithTypeArguments",
        expression: expression,
        typeParameters: typeParameters
      };
      var defs = NODE_FIELDS.TSExpressionWithTypeArguments;
      validate$1(defs.expression, node, "expression", expression, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      return node;
    }
    function tsInterfaceDeclaration(id) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var _extends =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var body = arguments.length > 3 ? arguments[3] : undefined;
      var node = {
        type: "TSInterfaceDeclaration",
        id: id,
        typeParameters: typeParameters,
        extends: _extends,
        body: body
      };
      var defs = NODE_FIELDS.TSInterfaceDeclaration;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(defs["extends"], node, "extends", _extends, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function tsInterfaceBody(body) {
      var node = { type: "TSInterfaceBody", body: body };
      var defs = NODE_FIELDS.TSInterfaceBody;
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function tsTypeAliasDeclaration(id) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var typeAnnotation = arguments.length > 2 ? arguments[2] : undefined;
      var node = {
        type: "TSTypeAliasDeclaration",
        id: id,
        typeParameters: typeParameters,
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.TSTypeAliasDeclaration;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsInstantiationExpression(expression) {
      var typeParameters =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = {
        type: "TSInstantiationExpression",
        expression: expression,
        typeParameters: typeParameters
      };
      var defs = NODE_FIELDS.TSInstantiationExpression;
      validate$1(defs.expression, node, "expression", expression, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      return node;
    }
    function tsAsExpression(expression, typeAnnotation) {
      var node = {
        type: "TSAsExpression",
        expression: expression,
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.TSAsExpression;
      validate$1(defs.expression, node, "expression", expression, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsSatisfiesExpression(expression, typeAnnotation) {
      var node = {
        type: "TSSatisfiesExpression",
        expression: expression,
        typeAnnotation: typeAnnotation
      };
      var defs = NODE_FIELDS.TSSatisfiesExpression;
      validate$1(defs.expression, node, "expression", expression, 1);
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsTypeAssertion(typeAnnotation, expression) {
      var node = {
        type: "TSTypeAssertion",
        typeAnnotation: typeAnnotation,
        expression: expression
      };
      var defs = NODE_FIELDS.TSTypeAssertion;
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      validate$1(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function tsEnumDeclaration(id, members) {
      var node = { type: "TSEnumDeclaration", id: id, members: members };
      var defs = NODE_FIELDS.TSEnumDeclaration;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.members, node, "members", members, 1);
      return node;
    }
    function tsEnumMember(id) {
      var initializer =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var node = { type: "TSEnumMember", id: id, initializer: initializer };
      var defs = NODE_FIELDS.TSEnumMember;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.initializer, node, "initializer", initializer, 1);
      return node;
    }
    function tsModuleDeclaration(id, body) {
      var node = {
        type: "TSModuleDeclaration",
        id: id,
        body: body,
        kind: null
      };
      var defs = NODE_FIELDS.TSModuleDeclaration;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function tsModuleBlock(body) {
      var node = { type: "TSModuleBlock", body: body };
      var defs = NODE_FIELDS.TSModuleBlock;
      validate$1(defs.body, node, "body", body, 1);
      return node;
    }
    function tsImportType(argument) {
      var qualifier =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var typeParameters =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var node = {
        type: "TSImportType",
        argument: argument,
        qualifier: qualifier,
        typeParameters: typeParameters
      };
      var defs = NODE_FIELDS.TSImportType;
      validate$1(defs.argument, node, "argument", argument, 1);
      validate$1(defs.qualifier, node, "qualifier", qualifier, 1);
      validate$1(
        defs.typeParameters,
        node,
        "typeParameters",
        typeParameters,
        1
      );
      return node;
    }
    function tsImportEqualsDeclaration(id, moduleReference) {
      var node = {
        type: "TSImportEqualsDeclaration",
        id: id,
        moduleReference: moduleReference,
        isExport: null
      };
      var defs = NODE_FIELDS.TSImportEqualsDeclaration;
      validate$1(defs.id, node, "id", id, 1);
      validate$1(
        defs.moduleReference,
        node,
        "moduleReference",
        moduleReference,
        1
      );
      return node;
    }
    function tsExternalModuleReference(expression) {
      var node = { type: "TSExternalModuleReference", expression: expression };
      var defs = NODE_FIELDS.TSExternalModuleReference;
      validate$1(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function tsNonNullExpression(expression) {
      var node = { type: "TSNonNullExpression", expression: expression };
      var defs = NODE_FIELDS.TSNonNullExpression;
      validate$1(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function tsExportAssignment(expression) {
      var node = { type: "TSExportAssignment", expression: expression };
      var defs = NODE_FIELDS.TSExportAssignment;
      validate$1(defs.expression, node, "expression", expression, 1);
      return node;
    }
    function tsNamespaceExportDeclaration(id) {
      var node = { type: "TSNamespaceExportDeclaration", id: id };
      var defs = NODE_FIELDS.TSNamespaceExportDeclaration;
      validate$1(defs.id, node, "id", id, 1);
      return node;
    }
    function tsTypeAnnotation(typeAnnotation) {
      var node = { type: "TSTypeAnnotation", typeAnnotation: typeAnnotation };
      var defs = NODE_FIELDS.TSTypeAnnotation;
      validate$1(
        defs.typeAnnotation,
        node,
        "typeAnnotation",
        typeAnnotation,
        1
      );
      return node;
    }
    function tsTypeParameterInstantiation(params) {
      var node = { type: "TSTypeParameterInstantiation", params: params };
      var defs = NODE_FIELDS.TSTypeParameterInstantiation;
      validate$1(defs.params, node, "params", params, 1);
      return node;
    }
    function tsTypeParameterDeclaration(params) {
      var node = { type: "TSTypeParameterDeclaration", params: params };
      var defs = NODE_FIELDS.TSTypeParameterDeclaration;
      validate$1(defs.params, node, "params", params, 1);
      return node;
    }
    function tsTypeParameter() {
      var constraint =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : null;
      var _default =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var name = arguments.length > 2 ? arguments[2] : undefined;
      var node = {
        type: "TSTypeParameter",
        constraint: constraint,
        default: _default,
        name: name
      };
      var defs = NODE_FIELDS.TSTypeParameter;
      validate$1(defs.constraint, node, "constraint", constraint, 1);
      validate$1(defs["default"], node, "default", _default, 1);
      validate$1(defs.name, node, "name", name);
      return node;
    }
    function NumberLiteral(value) {
      (0, _deprecationWarning$1["default"])(
        "NumberLiteral",
        "NumericLiteral",
        "The node type "
      );
      return numericLiteral(value);
    }
    function RegexLiteral(pattern) {
      var flags =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      (0, _deprecationWarning$1["default"])(
        "RegexLiteral",
        "RegExpLiteral",
        "The node type "
      );
      return regExpLiteral(pattern, flags);
    }
    function RestProperty(argument) {
      (0, _deprecationWarning$1["default"])(
        "RestProperty",
        "RestElement",
        "The node type "
      );
      return restElement(argument);
    }
    function SpreadProperty(argument) {
      (0, _deprecationWarning$1["default"])(
        "SpreadProperty",
        "SpreadElement",
        "The node type "
      );
      return spreadElement(argument);
    }
    var hasRequiredCleanJSXElementLiteralChild;
    function requireCleanJSXElementLiteralChild() {
      if (hasRequiredCleanJSXElementLiteralChild)
        return cleanJSXElementLiteralChild;
      hasRequiredCleanJSXElementLiteralChild = 1;
      Object.defineProperty(cleanJSXElementLiteralChild, "__esModule", {
        value: true
      });
      cleanJSXElementLiteralChild["default"] = cleanJSXElementLiteralChild$1;
      var _index = generated$2;
      var _index2 = requireLib();
      function cleanJSXElementLiteralChild$1(child, args) {
        var lines = child.value.split(/\r\n|\n|\r/);
        var lastNonEmptyLine = 0;
        for (var i = 0; i < lines.length; i++) {
          if (/[^ \t]/.exec(lines[i])) {
            lastNonEmptyLine = i;
          }
        }
        var str = "";
        for (var _i9 = 0; _i9 < lines.length; _i9++) {
          var line = lines[_i9];
          var isFirstLine = _i9 === 0;
          var isLastLine = _i9 === lines.length - 1;
          var isLastNonEmptyLine = _i9 === lastNonEmptyLine;
          var trimmedLine = line.replace(/\t/g, " ");
          if (!isFirstLine) {
            trimmedLine = trimmedLine.replace(/^ +/, "");
          }
          if (!isLastLine) {
            trimmedLine = trimmedLine.replace(/ +$/, "");
          }
          if (trimmedLine) {
            if (!isLastNonEmptyLine) {
              trimmedLine += " ";
            }
            str += trimmedLine;
          }
        }
        if (str)
          args.push(
            (0, _index2.inherits)((0, _index.stringLiteral)(str), child)
          );
      }
      return cleanJSXElementLiteralChild;
    }
    var hasRequiredBuildChildren;
    function requireBuildChildren() {
      if (hasRequiredBuildChildren) return buildChildren;
      hasRequiredBuildChildren = 1;
      Object.defineProperty(buildChildren, "__esModule", { value: true });
      buildChildren["default"] = buildChildren$1;
      var _index = generated$3;
      var _cleanJSXElementLiteralChild = requireCleanJSXElementLiteralChild();
      function buildChildren$1(node) {
        var elements = [];
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          if ((0, _index.isJSXText)(child)) {
            (0, _cleanJSXElementLiteralChild["default"])(child, elements);
            continue;
          }
          if ((0, _index.isJSXExpressionContainer)(child))
            child = child.expression;
          if ((0, _index.isJSXEmptyExpression)(child)) continue;
          elements.push(child);
        }
        return elements;
      }
      return buildChildren;
    }
    var assertNode$1 = {};
    var isNode$1 = {};
    Object.defineProperty(isNode$1, "__esModule", { value: true });
    isNode$1["default"] = isNode;
    var _index$u = requireDefinitions();
    function isNode(node) {
      return !!(node && _index$u.VISITOR_KEYS[node.type]);
    }
    Object.defineProperty(assertNode$1, "__esModule", { value: true });
    assertNode$1["default"] = assertNode;
    var _isNode = isNode$1;
    function assertNode(node) {
      if (!(0, _isNode["default"])(node)) {
        var _node$type;
        var type =
          (_node$type = node == null ? void 0 : node.type) != null
            ? _node$type
            : JSON.stringify(node);
        throw new TypeError('Not a valid node of type "'.concat(type, '"'));
      }
    }
    var generated$1 = {};
    Object.defineProperty(generated$1, "__esModule", { value: true });
    generated$1.assertAccessor = assertAccessor;
    generated$1.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
    generated$1.assertArgumentPlaceholder = assertArgumentPlaceholder;
    generated$1.assertArrayExpression = assertArrayExpression;
    generated$1.assertArrayPattern = assertArrayPattern;
    generated$1.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
    generated$1.assertArrowFunctionExpression = assertArrowFunctionExpression;
    generated$1.assertAssignmentExpression = assertAssignmentExpression;
    generated$1.assertAssignmentPattern = assertAssignmentPattern;
    generated$1.assertAwaitExpression = assertAwaitExpression;
    generated$1.assertBigIntLiteral = assertBigIntLiteral;
    generated$1.assertBinary = assertBinary;
    generated$1.assertBinaryExpression = assertBinaryExpression;
    generated$1.assertBindExpression = assertBindExpression;
    generated$1.assertBlock = assertBlock;
    generated$1.assertBlockParent = assertBlockParent;
    generated$1.assertBlockStatement = assertBlockStatement;
    generated$1.assertBooleanLiteral = assertBooleanLiteral;
    generated$1.assertBooleanLiteralTypeAnnotation =
      assertBooleanLiteralTypeAnnotation;
    generated$1.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
    generated$1.assertBreakStatement = assertBreakStatement;
    generated$1.assertCallExpression = assertCallExpression;
    generated$1.assertCatchClause = assertCatchClause;
    generated$1.assertClass = assertClass;
    generated$1.assertClassAccessorProperty = assertClassAccessorProperty;
    generated$1.assertClassBody = assertClassBody;
    generated$1.assertClassDeclaration = assertClassDeclaration;
    generated$1.assertClassExpression = assertClassExpression;
    generated$1.assertClassImplements = assertClassImplements;
    generated$1.assertClassMethod = assertClassMethod;
    generated$1.assertClassPrivateMethod = assertClassPrivateMethod;
    generated$1.assertClassPrivateProperty = assertClassPrivateProperty;
    generated$1.assertClassProperty = assertClassProperty;
    generated$1.assertCompletionStatement = assertCompletionStatement;
    generated$1.assertConditional = assertConditional;
    generated$1.assertConditionalExpression = assertConditionalExpression;
    generated$1.assertContinueStatement = assertContinueStatement;
    generated$1.assertDebuggerStatement = assertDebuggerStatement;
    generated$1.assertDecimalLiteral = assertDecimalLiteral;
    generated$1.assertDeclaration = assertDeclaration;
    generated$1.assertDeclareClass = assertDeclareClass;
    generated$1.assertDeclareExportAllDeclaration =
      assertDeclareExportAllDeclaration;
    generated$1.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
    generated$1.assertDeclareFunction = assertDeclareFunction;
    generated$1.assertDeclareInterface = assertDeclareInterface;
    generated$1.assertDeclareModule = assertDeclareModule;
    generated$1.assertDeclareModuleExports = assertDeclareModuleExports;
    generated$1.assertDeclareOpaqueType = assertDeclareOpaqueType;
    generated$1.assertDeclareTypeAlias = assertDeclareTypeAlias;
    generated$1.assertDeclareVariable = assertDeclareVariable;
    generated$1.assertDeclaredPredicate = assertDeclaredPredicate;
    generated$1.assertDecorator = assertDecorator;
    generated$1.assertDirective = assertDirective;
    generated$1.assertDirectiveLiteral = assertDirectiveLiteral;
    generated$1.assertDoExpression = assertDoExpression;
    generated$1.assertDoWhileStatement = assertDoWhileStatement;
    generated$1.assertEmptyStatement = assertEmptyStatement;
    generated$1.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
    generated$1.assertEnumBody = assertEnumBody;
    generated$1.assertEnumBooleanBody = assertEnumBooleanBody;
    generated$1.assertEnumBooleanMember = assertEnumBooleanMember;
    generated$1.assertEnumDeclaration = assertEnumDeclaration;
    generated$1.assertEnumDefaultedMember = assertEnumDefaultedMember;
    generated$1.assertEnumMember = assertEnumMember;
    generated$1.assertEnumNumberBody = assertEnumNumberBody;
    generated$1.assertEnumNumberMember = assertEnumNumberMember;
    generated$1.assertEnumStringBody = assertEnumStringBody;
    generated$1.assertEnumStringMember = assertEnumStringMember;
    generated$1.assertEnumSymbolBody = assertEnumSymbolBody;
    generated$1.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
    generated$1.assertExportAllDeclaration = assertExportAllDeclaration;
    generated$1.assertExportDeclaration = assertExportDeclaration;
    generated$1.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
    generated$1.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
    generated$1.assertExportNamedDeclaration = assertExportNamedDeclaration;
    generated$1.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
    generated$1.assertExportSpecifier = assertExportSpecifier;
    generated$1.assertExpression = assertExpression;
    generated$1.assertExpressionStatement = assertExpressionStatement;
    generated$1.assertExpressionWrapper = assertExpressionWrapper;
    generated$1.assertFile = assertFile;
    generated$1.assertFlow = assertFlow;
    generated$1.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
    generated$1.assertFlowDeclaration = assertFlowDeclaration;
    generated$1.assertFlowPredicate = assertFlowPredicate;
    generated$1.assertFlowType = assertFlowType;
    generated$1.assertFor = assertFor;
    generated$1.assertForInStatement = assertForInStatement;
    generated$1.assertForOfStatement = assertForOfStatement;
    generated$1.assertForStatement = assertForStatement;
    generated$1.assertForXStatement = assertForXStatement;
    generated$1.assertFunction = assertFunction;
    generated$1.assertFunctionDeclaration = assertFunctionDeclaration;
    generated$1.assertFunctionExpression = assertFunctionExpression;
    generated$1.assertFunctionParent = assertFunctionParent;
    generated$1.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
    generated$1.assertFunctionTypeParam = assertFunctionTypeParam;
    generated$1.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
    generated$1.assertIdentifier = assertIdentifier;
    generated$1.assertIfStatement = assertIfStatement;
    generated$1.assertImmutable = assertImmutable;
    generated$1.assertImport = assertImport;
    generated$1.assertImportAttribute = assertImportAttribute;
    generated$1.assertImportDeclaration = assertImportDeclaration;
    generated$1.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
    generated$1.assertImportExpression = assertImportExpression;
    generated$1.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
    generated$1.assertImportOrExportDeclaration =
      assertImportOrExportDeclaration;
    generated$1.assertImportSpecifier = assertImportSpecifier;
    generated$1.assertIndexedAccessType = assertIndexedAccessType;
    generated$1.assertInferredPredicate = assertInferredPredicate;
    generated$1.assertInterfaceDeclaration = assertInterfaceDeclaration;
    generated$1.assertInterfaceExtends = assertInterfaceExtends;
    generated$1.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
    generated$1.assertInterpreterDirective = assertInterpreterDirective;
    generated$1.assertIntersectionTypeAnnotation =
      assertIntersectionTypeAnnotation;
    generated$1.assertJSX = assertJSX;
    generated$1.assertJSXAttribute = assertJSXAttribute;
    generated$1.assertJSXClosingElement = assertJSXClosingElement;
    generated$1.assertJSXClosingFragment = assertJSXClosingFragment;
    generated$1.assertJSXElement = assertJSXElement;
    generated$1.assertJSXEmptyExpression = assertJSXEmptyExpression;
    generated$1.assertJSXExpressionContainer = assertJSXExpressionContainer;
    generated$1.assertJSXFragment = assertJSXFragment;
    generated$1.assertJSXIdentifier = assertJSXIdentifier;
    generated$1.assertJSXMemberExpression = assertJSXMemberExpression;
    generated$1.assertJSXNamespacedName = assertJSXNamespacedName;
    generated$1.assertJSXOpeningElement = assertJSXOpeningElement;
    generated$1.assertJSXOpeningFragment = assertJSXOpeningFragment;
    generated$1.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
    generated$1.assertJSXSpreadChild = assertJSXSpreadChild;
    generated$1.assertJSXText = assertJSXText;
    generated$1.assertLVal = assertLVal;
    generated$1.assertLabeledStatement = assertLabeledStatement;
    generated$1.assertLiteral = assertLiteral;
    generated$1.assertLogicalExpression = assertLogicalExpression;
    generated$1.assertLoop = assertLoop;
    generated$1.assertMemberExpression = assertMemberExpression;
    generated$1.assertMetaProperty = assertMetaProperty;
    generated$1.assertMethod = assertMethod;
    generated$1.assertMiscellaneous = assertMiscellaneous;
    generated$1.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
    generated$1.assertModuleDeclaration = assertModuleDeclaration;
    generated$1.assertModuleExpression = assertModuleExpression;
    generated$1.assertModuleSpecifier = assertModuleSpecifier;
    generated$1.assertNewExpression = assertNewExpression;
    generated$1.assertNoop = assertNoop;
    generated$1.assertNullLiteral = assertNullLiteral;
    generated$1.assertNullLiteralTypeAnnotation =
      assertNullLiteralTypeAnnotation;
    generated$1.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
    generated$1.assertNumberLiteral = assertNumberLiteral;
    generated$1.assertNumberLiteralTypeAnnotation =
      assertNumberLiteralTypeAnnotation;
    generated$1.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
    generated$1.assertNumericLiteral = assertNumericLiteral;
    generated$1.assertObjectExpression = assertObjectExpression;
    generated$1.assertObjectMember = assertObjectMember;
    generated$1.assertObjectMethod = assertObjectMethod;
    generated$1.assertObjectPattern = assertObjectPattern;
    generated$1.assertObjectProperty = assertObjectProperty;
    generated$1.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
    generated$1.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
    generated$1.assertObjectTypeIndexer = assertObjectTypeIndexer;
    generated$1.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
    generated$1.assertObjectTypeProperty = assertObjectTypeProperty;
    generated$1.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
    generated$1.assertOpaqueType = assertOpaqueType;
    generated$1.assertOptionalCallExpression = assertOptionalCallExpression;
    generated$1.assertOptionalIndexedAccessType =
      assertOptionalIndexedAccessType;
    generated$1.assertOptionalMemberExpression = assertOptionalMemberExpression;
    generated$1.assertParenthesizedExpression = assertParenthesizedExpression;
    generated$1.assertPattern = assertPattern;
    generated$1.assertPatternLike = assertPatternLike;
    generated$1.assertPipelineBareFunction = assertPipelineBareFunction;
    generated$1.assertPipelinePrimaryTopicReference =
      assertPipelinePrimaryTopicReference;
    generated$1.assertPipelineTopicExpression = assertPipelineTopicExpression;
    generated$1.assertPlaceholder = assertPlaceholder;
    generated$1.assertPrivate = assertPrivate;
    generated$1.assertPrivateName = assertPrivateName;
    generated$1.assertProgram = assertProgram;
    generated$1.assertProperty = assertProperty;
    generated$1.assertPureish = assertPureish;
    generated$1.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
    generated$1.assertRecordExpression = assertRecordExpression;
    generated$1.assertRegExpLiteral = assertRegExpLiteral;
    generated$1.assertRegexLiteral = assertRegexLiteral;
    generated$1.assertRestElement = assertRestElement;
    generated$1.assertRestProperty = assertRestProperty;
    generated$1.assertReturnStatement = assertReturnStatement;
    generated$1.assertScopable = assertScopable;
    generated$1.assertSequenceExpression = assertSequenceExpression;
    generated$1.assertSpreadElement = assertSpreadElement;
    generated$1.assertSpreadProperty = assertSpreadProperty;
    generated$1.assertStandardized = assertStandardized;
    generated$1.assertStatement = assertStatement;
    generated$1.assertStaticBlock = assertStaticBlock;
    generated$1.assertStringLiteral = assertStringLiteral;
    generated$1.assertStringLiteralTypeAnnotation =
      assertStringLiteralTypeAnnotation;
    generated$1.assertStringTypeAnnotation = assertStringTypeAnnotation;
    generated$1.assertSuper = assertSuper;
    generated$1.assertSwitchCase = assertSwitchCase;
    generated$1.assertSwitchStatement = assertSwitchStatement;
    generated$1.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
    generated$1.assertTSAnyKeyword = assertTSAnyKeyword;
    generated$1.assertTSArrayType = assertTSArrayType;
    generated$1.assertTSAsExpression = assertTSAsExpression;
    generated$1.assertTSBaseType = assertTSBaseType;
    generated$1.assertTSBigIntKeyword = assertTSBigIntKeyword;
    generated$1.assertTSBooleanKeyword = assertTSBooleanKeyword;
    generated$1.assertTSCallSignatureDeclaration =
      assertTSCallSignatureDeclaration;
    generated$1.assertTSConditionalType = assertTSConditionalType;
    generated$1.assertTSConstructSignatureDeclaration =
      assertTSConstructSignatureDeclaration;
    generated$1.assertTSConstructorType = assertTSConstructorType;
    generated$1.assertTSDeclareFunction = assertTSDeclareFunction;
    generated$1.assertTSDeclareMethod = assertTSDeclareMethod;
    generated$1.assertTSEntityName = assertTSEntityName;
    generated$1.assertTSEnumDeclaration = assertTSEnumDeclaration;
    generated$1.assertTSEnumMember = assertTSEnumMember;
    generated$1.assertTSExportAssignment = assertTSExportAssignment;
    generated$1.assertTSExpressionWithTypeArguments =
      assertTSExpressionWithTypeArguments;
    generated$1.assertTSExternalModuleReference =
      assertTSExternalModuleReference;
    generated$1.assertTSFunctionType = assertTSFunctionType;
    generated$1.assertTSImportEqualsDeclaration =
      assertTSImportEqualsDeclaration;
    generated$1.assertTSImportType = assertTSImportType;
    generated$1.assertTSIndexSignature = assertTSIndexSignature;
    generated$1.assertTSIndexedAccessType = assertTSIndexedAccessType;
    generated$1.assertTSInferType = assertTSInferType;
    generated$1.assertTSInstantiationExpression =
      assertTSInstantiationExpression;
    generated$1.assertTSInterfaceBody = assertTSInterfaceBody;
    generated$1.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
    generated$1.assertTSIntersectionType = assertTSIntersectionType;
    generated$1.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
    generated$1.assertTSLiteralType = assertTSLiteralType;
    generated$1.assertTSMappedType = assertTSMappedType;
    generated$1.assertTSMethodSignature = assertTSMethodSignature;
    generated$1.assertTSModuleBlock = assertTSModuleBlock;
    generated$1.assertTSModuleDeclaration = assertTSModuleDeclaration;
    generated$1.assertTSNamedTupleMember = assertTSNamedTupleMember;
    generated$1.assertTSNamespaceExportDeclaration =
      assertTSNamespaceExportDeclaration;
    generated$1.assertTSNeverKeyword = assertTSNeverKeyword;
    generated$1.assertTSNonNullExpression = assertTSNonNullExpression;
    generated$1.assertTSNullKeyword = assertTSNullKeyword;
    generated$1.assertTSNumberKeyword = assertTSNumberKeyword;
    generated$1.assertTSObjectKeyword = assertTSObjectKeyword;
    generated$1.assertTSOptionalType = assertTSOptionalType;
    generated$1.assertTSParameterProperty = assertTSParameterProperty;
    generated$1.assertTSParenthesizedType = assertTSParenthesizedType;
    generated$1.assertTSPropertySignature = assertTSPropertySignature;
    generated$1.assertTSQualifiedName = assertTSQualifiedName;
    generated$1.assertTSRestType = assertTSRestType;
    generated$1.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
    generated$1.assertTSStringKeyword = assertTSStringKeyword;
    generated$1.assertTSSymbolKeyword = assertTSSymbolKeyword;
    generated$1.assertTSThisType = assertTSThisType;
    generated$1.assertTSTupleType = assertTSTupleType;
    generated$1.assertTSType = assertTSType;
    generated$1.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
    generated$1.assertTSTypeAnnotation = assertTSTypeAnnotation;
    generated$1.assertTSTypeAssertion = assertTSTypeAssertion;
    generated$1.assertTSTypeElement = assertTSTypeElement;
    generated$1.assertTSTypeLiteral = assertTSTypeLiteral;
    generated$1.assertTSTypeOperator = assertTSTypeOperator;
    generated$1.assertTSTypeParameter = assertTSTypeParameter;
    generated$1.assertTSTypeParameterDeclaration =
      assertTSTypeParameterDeclaration;
    generated$1.assertTSTypeParameterInstantiation =
      assertTSTypeParameterInstantiation;
    generated$1.assertTSTypePredicate = assertTSTypePredicate;
    generated$1.assertTSTypeQuery = assertTSTypeQuery;
    generated$1.assertTSTypeReference = assertTSTypeReference;
    generated$1.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
    generated$1.assertTSUnionType = assertTSUnionType;
    generated$1.assertTSUnknownKeyword = assertTSUnknownKeyword;
    generated$1.assertTSVoidKeyword = assertTSVoidKeyword;
    generated$1.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
    generated$1.assertTemplateElement = assertTemplateElement;
    generated$1.assertTemplateLiteral = assertTemplateLiteral;
    generated$1.assertTerminatorless = assertTerminatorless;
    generated$1.assertThisExpression = assertThisExpression;
    generated$1.assertThisTypeAnnotation = assertThisTypeAnnotation;
    generated$1.assertThrowStatement = assertThrowStatement;
    generated$1.assertTopicReference = assertTopicReference;
    generated$1.assertTryStatement = assertTryStatement;
    generated$1.assertTupleExpression = assertTupleExpression;
    generated$1.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
    generated$1.assertTypeAlias = assertTypeAlias;
    generated$1.assertTypeAnnotation = assertTypeAnnotation;
    generated$1.assertTypeCastExpression = assertTypeCastExpression;
    generated$1.assertTypeParameter = assertTypeParameter;
    generated$1.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
    generated$1.assertTypeParameterInstantiation =
      assertTypeParameterInstantiation;
    generated$1.assertTypeScript = assertTypeScript;
    generated$1.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
    generated$1.assertUnaryExpression = assertUnaryExpression;
    generated$1.assertUnaryLike = assertUnaryLike;
    generated$1.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
    generated$1.assertUpdateExpression = assertUpdateExpression;
    generated$1.assertUserWhitespacable = assertUserWhitespacable;
    generated$1.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
    generated$1.assertVariableDeclaration = assertVariableDeclaration;
    generated$1.assertVariableDeclarator = assertVariableDeclarator;
    generated$1.assertVariance = assertVariance;
    generated$1.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
    generated$1.assertWhile = assertWhile;
    generated$1.assertWhileStatement = assertWhileStatement;
    generated$1.assertWithStatement = assertWithStatement;
    generated$1.assertYieldExpression = assertYieldExpression;
    var _is = requireIs();
    var _deprecationWarning = deprecationWarning$1;
    function assert(type, node, opts) {
      if (!(0, _is["default"])(type, node, opts)) {
        throw new Error(
          'Expected type "'
            .concat(type, '" with option ')
            .concat(JSON.stringify(opts), ", ") +
            'but instead got "'.concat(node.type, '".')
        );
      }
    }
    function assertArrayExpression(node, opts) {
      assert("ArrayExpression", node, opts);
    }
    function assertAssignmentExpression(node, opts) {
      assert("AssignmentExpression", node, opts);
    }
    function assertBinaryExpression(node, opts) {
      assert("BinaryExpression", node, opts);
    }
    function assertInterpreterDirective(node, opts) {
      assert("InterpreterDirective", node, opts);
    }
    function assertDirective(node, opts) {
      assert("Directive", node, opts);
    }
    function assertDirectiveLiteral(node, opts) {
      assert("DirectiveLiteral", node, opts);
    }
    function assertBlockStatement(node, opts) {
      assert("BlockStatement", node, opts);
    }
    function assertBreakStatement(node, opts) {
      assert("BreakStatement", node, opts);
    }
    function assertCallExpression(node, opts) {
      assert("CallExpression", node, opts);
    }
    function assertCatchClause(node, opts) {
      assert("CatchClause", node, opts);
    }
    function assertConditionalExpression(node, opts) {
      assert("ConditionalExpression", node, opts);
    }
    function assertContinueStatement(node, opts) {
      assert("ContinueStatement", node, opts);
    }
    function assertDebuggerStatement(node, opts) {
      assert("DebuggerStatement", node, opts);
    }
    function assertDoWhileStatement(node, opts) {
      assert("DoWhileStatement", node, opts);
    }
    function assertEmptyStatement(node, opts) {
      assert("EmptyStatement", node, opts);
    }
    function assertExpressionStatement(node, opts) {
      assert("ExpressionStatement", node, opts);
    }
    function assertFile(node, opts) {
      assert("File", node, opts);
    }
    function assertForInStatement(node, opts) {
      assert("ForInStatement", node, opts);
    }
    function assertForStatement(node, opts) {
      assert("ForStatement", node, opts);
    }
    function assertFunctionDeclaration(node, opts) {
      assert("FunctionDeclaration", node, opts);
    }
    function assertFunctionExpression(node, opts) {
      assert("FunctionExpression", node, opts);
    }
    function assertIdentifier(node, opts) {
      assert("Identifier", node, opts);
    }
    function assertIfStatement(node, opts) {
      assert("IfStatement", node, opts);
    }
    function assertLabeledStatement(node, opts) {
      assert("LabeledStatement", node, opts);
    }
    function assertStringLiteral(node, opts) {
      assert("StringLiteral", node, opts);
    }
    function assertNumericLiteral(node, opts) {
      assert("NumericLiteral", node, opts);
    }
    function assertNullLiteral(node, opts) {
      assert("NullLiteral", node, opts);
    }
    function assertBooleanLiteral(node, opts) {
      assert("BooleanLiteral", node, opts);
    }
    function assertRegExpLiteral(node, opts) {
      assert("RegExpLiteral", node, opts);
    }
    function assertLogicalExpression(node, opts) {
      assert("LogicalExpression", node, opts);
    }
    function assertMemberExpression(node, opts) {
      assert("MemberExpression", node, opts);
    }
    function assertNewExpression(node, opts) {
      assert("NewExpression", node, opts);
    }
    function assertProgram(node, opts) {
      assert("Program", node, opts);
    }
    function assertObjectExpression(node, opts) {
      assert("ObjectExpression", node, opts);
    }
    function assertObjectMethod(node, opts) {
      assert("ObjectMethod", node, opts);
    }
    function assertObjectProperty(node, opts) {
      assert("ObjectProperty", node, opts);
    }
    function assertRestElement(node, opts) {
      assert("RestElement", node, opts);
    }
    function assertReturnStatement(node, opts) {
      assert("ReturnStatement", node, opts);
    }
    function assertSequenceExpression(node, opts) {
      assert("SequenceExpression", node, opts);
    }
    function assertParenthesizedExpression(node, opts) {
      assert("ParenthesizedExpression", node, opts);
    }
    function assertSwitchCase(node, opts) {
      assert("SwitchCase", node, opts);
    }
    function assertSwitchStatement(node, opts) {
      assert("SwitchStatement", node, opts);
    }
    function assertThisExpression(node, opts) {
      assert("ThisExpression", node, opts);
    }
    function assertThrowStatement(node, opts) {
      assert("ThrowStatement", node, opts);
    }
    function assertTryStatement(node, opts) {
      assert("TryStatement", node, opts);
    }
    function assertUnaryExpression(node, opts) {
      assert("UnaryExpression", node, opts);
    }
    function assertUpdateExpression(node, opts) {
      assert("UpdateExpression", node, opts);
    }
    function assertVariableDeclaration(node, opts) {
      assert("VariableDeclaration", node, opts);
    }
    function assertVariableDeclarator(node, opts) {
      assert("VariableDeclarator", node, opts);
    }
    function assertWhileStatement(node, opts) {
      assert("WhileStatement", node, opts);
    }
    function assertWithStatement(node, opts) {
      assert("WithStatement", node, opts);
    }
    function assertAssignmentPattern(node, opts) {
      assert("AssignmentPattern", node, opts);
    }
    function assertArrayPattern(node, opts) {
      assert("ArrayPattern", node, opts);
    }
    function assertArrowFunctionExpression(node, opts) {
      assert("ArrowFunctionExpression", node, opts);
    }
    function assertClassBody(node, opts) {
      assert("ClassBody", node, opts);
    }
    function assertClassExpression(node, opts) {
      assert("ClassExpression", node, opts);
    }
    function assertClassDeclaration(node, opts) {
      assert("ClassDeclaration", node, opts);
    }
    function assertExportAllDeclaration(node, opts) {
      assert("ExportAllDeclaration", node, opts);
    }
    function assertExportDefaultDeclaration(node, opts) {
      assert("ExportDefaultDeclaration", node, opts);
    }
    function assertExportNamedDeclaration(node, opts) {
      assert("ExportNamedDeclaration", node, opts);
    }
    function assertExportSpecifier(node, opts) {
      assert("ExportSpecifier", node, opts);
    }
    function assertForOfStatement(node, opts) {
      assert("ForOfStatement", node, opts);
    }
    function assertImportDeclaration(node, opts) {
      assert("ImportDeclaration", node, opts);
    }
    function assertImportDefaultSpecifier(node, opts) {
      assert("ImportDefaultSpecifier", node, opts);
    }
    function assertImportNamespaceSpecifier(node, opts) {
      assert("ImportNamespaceSpecifier", node, opts);
    }
    function assertImportSpecifier(node, opts) {
      assert("ImportSpecifier", node, opts);
    }
    function assertImportExpression(node, opts) {
      assert("ImportExpression", node, opts);
    }
    function assertMetaProperty(node, opts) {
      assert("MetaProperty", node, opts);
    }
    function assertClassMethod(node, opts) {
      assert("ClassMethod", node, opts);
    }
    function assertObjectPattern(node, opts) {
      assert("ObjectPattern", node, opts);
    }
    function assertSpreadElement(node, opts) {
      assert("SpreadElement", node, opts);
    }
    function assertSuper(node, opts) {
      assert("Super", node, opts);
    }
    function assertTaggedTemplateExpression(node, opts) {
      assert("TaggedTemplateExpression", node, opts);
    }
    function assertTemplateElement(node, opts) {
      assert("TemplateElement", node, opts);
    }
    function assertTemplateLiteral(node, opts) {
      assert("TemplateLiteral", node, opts);
    }
    function assertYieldExpression(node, opts) {
      assert("YieldExpression", node, opts);
    }
    function assertAwaitExpression(node, opts) {
      assert("AwaitExpression", node, opts);
    }
    function assertImport(node, opts) {
      assert("Import", node, opts);
    }
    function assertBigIntLiteral(node, opts) {
      assert("BigIntLiteral", node, opts);
    }
    function assertExportNamespaceSpecifier(node, opts) {
      assert("ExportNamespaceSpecifier", node, opts);
    }
    function assertOptionalMemberExpression(node, opts) {
      assert("OptionalMemberExpression", node, opts);
    }
    function assertOptionalCallExpression(node, opts) {
      assert("OptionalCallExpression", node, opts);
    }
    function assertClassProperty(node, opts) {
      assert("ClassProperty", node, opts);
    }
    function assertClassAccessorProperty(node, opts) {
      assert("ClassAccessorProperty", node, opts);
    }
    function assertClassPrivateProperty(node, opts) {
      assert("ClassPrivateProperty", node, opts);
    }
    function assertClassPrivateMethod(node, opts) {
      assert("ClassPrivateMethod", node, opts);
    }
    function assertPrivateName(node, opts) {
      assert("PrivateName", node, opts);
    }
    function assertStaticBlock(node, opts) {
      assert("StaticBlock", node, opts);
    }
    function assertAnyTypeAnnotation(node, opts) {
      assert("AnyTypeAnnotation", node, opts);
    }
    function assertArrayTypeAnnotation(node, opts) {
      assert("ArrayTypeAnnotation", node, opts);
    }
    function assertBooleanTypeAnnotation(node, opts) {
      assert("BooleanTypeAnnotation", node, opts);
    }
    function assertBooleanLiteralTypeAnnotation(node, opts) {
      assert("BooleanLiteralTypeAnnotation", node, opts);
    }
    function assertNullLiteralTypeAnnotation(node, opts) {
      assert("NullLiteralTypeAnnotation", node, opts);
    }
    function assertClassImplements(node, opts) {
      assert("ClassImplements", node, opts);
    }
    function assertDeclareClass(node, opts) {
      assert("DeclareClass", node, opts);
    }
    function assertDeclareFunction(node, opts) {
      assert("DeclareFunction", node, opts);
    }
    function assertDeclareInterface(node, opts) {
      assert("DeclareInterface", node, opts);
    }
    function assertDeclareModule(node, opts) {
      assert("DeclareModule", node, opts);
    }
    function assertDeclareModuleExports(node, opts) {
      assert("DeclareModuleExports", node, opts);
    }
    function assertDeclareTypeAlias(node, opts) {
      assert("DeclareTypeAlias", node, opts);
    }
    function assertDeclareOpaqueType(node, opts) {
      assert("DeclareOpaqueType", node, opts);
    }
    function assertDeclareVariable(node, opts) {
      assert("DeclareVariable", node, opts);
    }
    function assertDeclareExportDeclaration(node, opts) {
      assert("DeclareExportDeclaration", node, opts);
    }
    function assertDeclareExportAllDeclaration(node, opts) {
      assert("DeclareExportAllDeclaration", node, opts);
    }
    function assertDeclaredPredicate(node, opts) {
      assert("DeclaredPredicate", node, opts);
    }
    function assertExistsTypeAnnotation(node, opts) {
      assert("ExistsTypeAnnotation", node, opts);
    }
    function assertFunctionTypeAnnotation(node, opts) {
      assert("FunctionTypeAnnotation", node, opts);
    }
    function assertFunctionTypeParam(node, opts) {
      assert("FunctionTypeParam", node, opts);
    }
    function assertGenericTypeAnnotation(node, opts) {
      assert("GenericTypeAnnotation", node, opts);
    }
    function assertInferredPredicate(node, opts) {
      assert("InferredPredicate", node, opts);
    }
    function assertInterfaceExtends(node, opts) {
      assert("InterfaceExtends", node, opts);
    }
    function assertInterfaceDeclaration(node, opts) {
      assert("InterfaceDeclaration", node, opts);
    }
    function assertInterfaceTypeAnnotation(node, opts) {
      assert("InterfaceTypeAnnotation", node, opts);
    }
    function assertIntersectionTypeAnnotation(node, opts) {
      assert("IntersectionTypeAnnotation", node, opts);
    }
    function assertMixedTypeAnnotation(node, opts) {
      assert("MixedTypeAnnotation", node, opts);
    }
    function assertEmptyTypeAnnotation(node, opts) {
      assert("EmptyTypeAnnotation", node, opts);
    }
    function assertNullableTypeAnnotation(node, opts) {
      assert("NullableTypeAnnotation", node, opts);
    }
    function assertNumberLiteralTypeAnnotation(node, opts) {
      assert("NumberLiteralTypeAnnotation", node, opts);
    }
    function assertNumberTypeAnnotation(node, opts) {
      assert("NumberTypeAnnotation", node, opts);
    }
    function assertObjectTypeAnnotation(node, opts) {
      assert("ObjectTypeAnnotation", node, opts);
    }
    function assertObjectTypeInternalSlot(node, opts) {
      assert("ObjectTypeInternalSlot", node, opts);
    }
    function assertObjectTypeCallProperty(node, opts) {
      assert("ObjectTypeCallProperty", node, opts);
    }
    function assertObjectTypeIndexer(node, opts) {
      assert("ObjectTypeIndexer", node, opts);
    }
    function assertObjectTypeProperty(node, opts) {
      assert("ObjectTypeProperty", node, opts);
    }
    function assertObjectTypeSpreadProperty(node, opts) {
      assert("ObjectTypeSpreadProperty", node, opts);
    }
    function assertOpaqueType(node, opts) {
      assert("OpaqueType", node, opts);
    }
    function assertQualifiedTypeIdentifier(node, opts) {
      assert("QualifiedTypeIdentifier", node, opts);
    }
    function assertStringLiteralTypeAnnotation(node, opts) {
      assert("StringLiteralTypeAnnotation", node, opts);
    }
    function assertStringTypeAnnotation(node, opts) {
      assert("StringTypeAnnotation", node, opts);
    }
    function assertSymbolTypeAnnotation(node, opts) {
      assert("SymbolTypeAnnotation", node, opts);
    }
    function assertThisTypeAnnotation(node, opts) {
      assert("ThisTypeAnnotation", node, opts);
    }
    function assertTupleTypeAnnotation(node, opts) {
      assert("TupleTypeAnnotation", node, opts);
    }
    function assertTypeofTypeAnnotation(node, opts) {
      assert("TypeofTypeAnnotation", node, opts);
    }
    function assertTypeAlias(node, opts) {
      assert("TypeAlias", node, opts);
    }
    function assertTypeAnnotation(node, opts) {
      assert("TypeAnnotation", node, opts);
    }
    function assertTypeCastExpression(node, opts) {
      assert("TypeCastExpression", node, opts);
    }
    function assertTypeParameter(node, opts) {
      assert("TypeParameter", node, opts);
    }
    function assertTypeParameterDeclaration(node, opts) {
      assert("TypeParameterDeclaration", node, opts);
    }
    function assertTypeParameterInstantiation(node, opts) {
      assert("TypeParameterInstantiation", node, opts);
    }
    function assertUnionTypeAnnotation(node, opts) {
      assert("UnionTypeAnnotation", node, opts);
    }
    function assertVariance(node, opts) {
      assert("Variance", node, opts);
    }
    function assertVoidTypeAnnotation(node, opts) {
      assert("VoidTypeAnnotation", node, opts);
    }
    function assertEnumDeclaration(node, opts) {
      assert("EnumDeclaration", node, opts);
    }
    function assertEnumBooleanBody(node, opts) {
      assert("EnumBooleanBody", node, opts);
    }
    function assertEnumNumberBody(node, opts) {
      assert("EnumNumberBody", node, opts);
    }
    function assertEnumStringBody(node, opts) {
      assert("EnumStringBody", node, opts);
    }
    function assertEnumSymbolBody(node, opts) {
      assert("EnumSymbolBody", node, opts);
    }
    function assertEnumBooleanMember(node, opts) {
      assert("EnumBooleanMember", node, opts);
    }
    function assertEnumNumberMember(node, opts) {
      assert("EnumNumberMember", node, opts);
    }
    function assertEnumStringMember(node, opts) {
      assert("EnumStringMember", node, opts);
    }
    function assertEnumDefaultedMember(node, opts) {
      assert("EnumDefaultedMember", node, opts);
    }
    function assertIndexedAccessType(node, opts) {
      assert("IndexedAccessType", node, opts);
    }
    function assertOptionalIndexedAccessType(node, opts) {
      assert("OptionalIndexedAccessType", node, opts);
    }
    function assertJSXAttribute(node, opts) {
      assert("JSXAttribute", node, opts);
    }
    function assertJSXClosingElement(node, opts) {
      assert("JSXClosingElement", node, opts);
    }
    function assertJSXElement(node, opts) {
      assert("JSXElement", node, opts);
    }
    function assertJSXEmptyExpression(node, opts) {
      assert("JSXEmptyExpression", node, opts);
    }
    function assertJSXExpressionContainer(node, opts) {
      assert("JSXExpressionContainer", node, opts);
    }
    function assertJSXSpreadChild(node, opts) {
      assert("JSXSpreadChild", node, opts);
    }
    function assertJSXIdentifier(node, opts) {
      assert("JSXIdentifier", node, opts);
    }
    function assertJSXMemberExpression(node, opts) {
      assert("JSXMemberExpression", node, opts);
    }
    function assertJSXNamespacedName(node, opts) {
      assert("JSXNamespacedName", node, opts);
    }
    function assertJSXOpeningElement(node, opts) {
      assert("JSXOpeningElement", node, opts);
    }
    function assertJSXSpreadAttribute(node, opts) {
      assert("JSXSpreadAttribute", node, opts);
    }
    function assertJSXText(node, opts) {
      assert("JSXText", node, opts);
    }
    function assertJSXFragment(node, opts) {
      assert("JSXFragment", node, opts);
    }
    function assertJSXOpeningFragment(node, opts) {
      assert("JSXOpeningFragment", node, opts);
    }
    function assertJSXClosingFragment(node, opts) {
      assert("JSXClosingFragment", node, opts);
    }
    function assertNoop(node, opts) {
      assert("Noop", node, opts);
    }
    function assertPlaceholder(node, opts) {
      assert("Placeholder", node, opts);
    }
    function assertV8IntrinsicIdentifier(node, opts) {
      assert("V8IntrinsicIdentifier", node, opts);
    }
    function assertArgumentPlaceholder(node, opts) {
      assert("ArgumentPlaceholder", node, opts);
    }
    function assertBindExpression(node, opts) {
      assert("BindExpression", node, opts);
    }
    function assertImportAttribute(node, opts) {
      assert("ImportAttribute", node, opts);
    }
    function assertDecorator(node, opts) {
      assert("Decorator", node, opts);
    }
    function assertDoExpression(node, opts) {
      assert("DoExpression", node, opts);
    }
    function assertExportDefaultSpecifier(node, opts) {
      assert("ExportDefaultSpecifier", node, opts);
    }
    function assertRecordExpression(node, opts) {
      assert("RecordExpression", node, opts);
    }
    function assertTupleExpression(node, opts) {
      assert("TupleExpression", node, opts);
    }
    function assertDecimalLiteral(node, opts) {
      assert("DecimalLiteral", node, opts);
    }
    function assertModuleExpression(node, opts) {
      assert("ModuleExpression", node, opts);
    }
    function assertTopicReference(node, opts) {
      assert("TopicReference", node, opts);
    }
    function assertPipelineTopicExpression(node, opts) {
      assert("PipelineTopicExpression", node, opts);
    }
    function assertPipelineBareFunction(node, opts) {
      assert("PipelineBareFunction", node, opts);
    }
    function assertPipelinePrimaryTopicReference(node, opts) {
      assert("PipelinePrimaryTopicReference", node, opts);
    }
    function assertTSParameterProperty(node, opts) {
      assert("TSParameterProperty", node, opts);
    }
    function assertTSDeclareFunction(node, opts) {
      assert("TSDeclareFunction", node, opts);
    }
    function assertTSDeclareMethod(node, opts) {
      assert("TSDeclareMethod", node, opts);
    }
    function assertTSQualifiedName(node, opts) {
      assert("TSQualifiedName", node, opts);
    }
    function assertTSCallSignatureDeclaration(node, opts) {
      assert("TSCallSignatureDeclaration", node, opts);
    }
    function assertTSConstructSignatureDeclaration(node, opts) {
      assert("TSConstructSignatureDeclaration", node, opts);
    }
    function assertTSPropertySignature(node, opts) {
      assert("TSPropertySignature", node, opts);
    }
    function assertTSMethodSignature(node, opts) {
      assert("TSMethodSignature", node, opts);
    }
    function assertTSIndexSignature(node, opts) {
      assert("TSIndexSignature", node, opts);
    }
    function assertTSAnyKeyword(node, opts) {
      assert("TSAnyKeyword", node, opts);
    }
    function assertTSBooleanKeyword(node, opts) {
      assert("TSBooleanKeyword", node, opts);
    }
    function assertTSBigIntKeyword(node, opts) {
      assert("TSBigIntKeyword", node, opts);
    }
    function assertTSIntrinsicKeyword(node, opts) {
      assert("TSIntrinsicKeyword", node, opts);
    }
    function assertTSNeverKeyword(node, opts) {
      assert("TSNeverKeyword", node, opts);
    }
    function assertTSNullKeyword(node, opts) {
      assert("TSNullKeyword", node, opts);
    }
    function assertTSNumberKeyword(node, opts) {
      assert("TSNumberKeyword", node, opts);
    }
    function assertTSObjectKeyword(node, opts) {
      assert("TSObjectKeyword", node, opts);
    }
    function assertTSStringKeyword(node, opts) {
      assert("TSStringKeyword", node, opts);
    }
    function assertTSSymbolKeyword(node, opts) {
      assert("TSSymbolKeyword", node, opts);
    }
    function assertTSUndefinedKeyword(node, opts) {
      assert("TSUndefinedKeyword", node, opts);
    }
    function assertTSUnknownKeyword(node, opts) {
      assert("TSUnknownKeyword", node, opts);
    }
    function assertTSVoidKeyword(node, opts) {
      assert("TSVoidKeyword", node, opts);
    }
    function assertTSThisType(node, opts) {
      assert("TSThisType", node, opts);
    }
    function assertTSFunctionType(node, opts) {
      assert("TSFunctionType", node, opts);
    }
    function assertTSConstructorType(node, opts) {
      assert("TSConstructorType", node, opts);
    }
    function assertTSTypeReference(node, opts) {
      assert("TSTypeReference", node, opts);
    }
    function assertTSTypePredicate(node, opts) {
      assert("TSTypePredicate", node, opts);
    }
    function assertTSTypeQuery(node, opts) {
      assert("TSTypeQuery", node, opts);
    }
    function assertTSTypeLiteral(node, opts) {
      assert("TSTypeLiteral", node, opts);
    }
    function assertTSArrayType(node, opts) {
      assert("TSArrayType", node, opts);
    }
    function assertTSTupleType(node, opts) {
      assert("TSTupleType", node, opts);
    }
    function assertTSOptionalType(node, opts) {
      assert("TSOptionalType", node, opts);
    }
    function assertTSRestType(node, opts) {
      assert("TSRestType", node, opts);
    }
    function assertTSNamedTupleMember(node, opts) {
      assert("TSNamedTupleMember", node, opts);
    }
    function assertTSUnionType(node, opts) {
      assert("TSUnionType", node, opts);
    }
    function assertTSIntersectionType(node, opts) {
      assert("TSIntersectionType", node, opts);
    }
    function assertTSConditionalType(node, opts) {
      assert("TSConditionalType", node, opts);
    }
    function assertTSInferType(node, opts) {
      assert("TSInferType", node, opts);
    }
    function assertTSParenthesizedType(node, opts) {
      assert("TSParenthesizedType", node, opts);
    }
    function assertTSTypeOperator(node, opts) {
      assert("TSTypeOperator", node, opts);
    }
    function assertTSIndexedAccessType(node, opts) {
      assert("TSIndexedAccessType", node, opts);
    }
    function assertTSMappedType(node, opts) {
      assert("TSMappedType", node, opts);
    }
    function assertTSLiteralType(node, opts) {
      assert("TSLiteralType", node, opts);
    }
    function assertTSExpressionWithTypeArguments(node, opts) {
      assert("TSExpressionWithTypeArguments", node, opts);
    }
    function assertTSInterfaceDeclaration(node, opts) {
      assert("TSInterfaceDeclaration", node, opts);
    }
    function assertTSInterfaceBody(node, opts) {
      assert("TSInterfaceBody", node, opts);
    }
    function assertTSTypeAliasDeclaration(node, opts) {
      assert("TSTypeAliasDeclaration", node, opts);
    }
    function assertTSInstantiationExpression(node, opts) {
      assert("TSInstantiationExpression", node, opts);
    }
    function assertTSAsExpression(node, opts) {
      assert("TSAsExpression", node, opts);
    }
    function assertTSSatisfiesExpression(node, opts) {
      assert("TSSatisfiesExpression", node, opts);
    }
    function assertTSTypeAssertion(node, opts) {
      assert("TSTypeAssertion", node, opts);
    }
    function assertTSEnumDeclaration(node, opts) {
      assert("TSEnumDeclaration", node, opts);
    }
    function assertTSEnumMember(node, opts) {
      assert("TSEnumMember", node, opts);
    }
    function assertTSModuleDeclaration(node, opts) {
      assert("TSModuleDeclaration", node, opts);
    }
    function assertTSModuleBlock(node, opts) {
      assert("TSModuleBlock", node, opts);
    }
    function assertTSImportType(node, opts) {
      assert("TSImportType", node, opts);
    }
    function assertTSImportEqualsDeclaration(node, opts) {
      assert("TSImportEqualsDeclaration", node, opts);
    }
    function assertTSExternalModuleReference(node, opts) {
      assert("TSExternalModuleReference", node, opts);
    }
    function assertTSNonNullExpression(node, opts) {
      assert("TSNonNullExpression", node, opts);
    }
    function assertTSExportAssignment(node, opts) {
      assert("TSExportAssignment", node, opts);
    }
    function assertTSNamespaceExportDeclaration(node, opts) {
      assert("TSNamespaceExportDeclaration", node, opts);
    }
    function assertTSTypeAnnotation(node, opts) {
      assert("TSTypeAnnotation", node, opts);
    }
    function assertTSTypeParameterInstantiation(node, opts) {
      assert("TSTypeParameterInstantiation", node, opts);
    }
    function assertTSTypeParameterDeclaration(node, opts) {
      assert("TSTypeParameterDeclaration", node, opts);
    }
    function assertTSTypeParameter(node, opts) {
      assert("TSTypeParameter", node, opts);
    }
    function assertStandardized(node, opts) {
      assert("Standardized", node, opts);
    }
    function assertExpression(node, opts) {
      assert("Expression", node, opts);
    }
    function assertBinary(node, opts) {
      assert("Binary", node, opts);
    }
    function assertScopable(node, opts) {
      assert("Scopable", node, opts);
    }
    function assertBlockParent(node, opts) {
      assert("BlockParent", node, opts);
    }
    function assertBlock(node, opts) {
      assert("Block", node, opts);
    }
    function assertStatement(node, opts) {
      assert("Statement", node, opts);
    }
    function assertTerminatorless(node, opts) {
      assert("Terminatorless", node, opts);
    }
    function assertCompletionStatement(node, opts) {
      assert("CompletionStatement", node, opts);
    }
    function assertConditional(node, opts) {
      assert("Conditional", node, opts);
    }
    function assertLoop(node, opts) {
      assert("Loop", node, opts);
    }
    function assertWhile(node, opts) {
      assert("While", node, opts);
    }
    function assertExpressionWrapper(node, opts) {
      assert("ExpressionWrapper", node, opts);
    }
    function assertFor(node, opts) {
      assert("For", node, opts);
    }
    function assertForXStatement(node, opts) {
      assert("ForXStatement", node, opts);
    }
    function assertFunction(node, opts) {
      assert("Function", node, opts);
    }
    function assertFunctionParent(node, opts) {
      assert("FunctionParent", node, opts);
    }
    function assertPureish(node, opts) {
      assert("Pureish", node, opts);
    }
    function assertDeclaration(node, opts) {
      assert("Declaration", node, opts);
    }
    function assertPatternLike(node, opts) {
      assert("PatternLike", node, opts);
    }
    function assertLVal(node, opts) {
      assert("LVal", node, opts);
    }
    function assertTSEntityName(node, opts) {
      assert("TSEntityName", node, opts);
    }
    function assertLiteral(node, opts) {
      assert("Literal", node, opts);
    }
    function assertImmutable(node, opts) {
      assert("Immutable", node, opts);
    }
    function assertUserWhitespacable(node, opts) {
      assert("UserWhitespacable", node, opts);
    }
    function assertMethod(node, opts) {
      assert("Method", node, opts);
    }
    function assertObjectMember(node, opts) {
      assert("ObjectMember", node, opts);
    }
    function assertProperty(node, opts) {
      assert("Property", node, opts);
    }
    function assertUnaryLike(node, opts) {
      assert("UnaryLike", node, opts);
    }
    function assertPattern(node, opts) {
      assert("Pattern", node, opts);
    }
    function assertClass(node, opts) {
      assert("Class", node, opts);
    }
    function assertImportOrExportDeclaration(node, opts) {
      assert("ImportOrExportDeclaration", node, opts);
    }
    function assertExportDeclaration(node, opts) {
      assert("ExportDeclaration", node, opts);
    }
    function assertModuleSpecifier(node, opts) {
      assert("ModuleSpecifier", node, opts);
    }
    function assertAccessor(node, opts) {
      assert("Accessor", node, opts);
    }
    function assertPrivate(node, opts) {
      assert("Private", node, opts);
    }
    function assertFlow(node, opts) {
      assert("Flow", node, opts);
    }
    function assertFlowType(node, opts) {
      assert("FlowType", node, opts);
    }
    function assertFlowBaseAnnotation(node, opts) {
      assert("FlowBaseAnnotation", node, opts);
    }
    function assertFlowDeclaration(node, opts) {
      assert("FlowDeclaration", node, opts);
    }
    function assertFlowPredicate(node, opts) {
      assert("FlowPredicate", node, opts);
    }
    function assertEnumBody(node, opts) {
      assert("EnumBody", node, opts);
    }
    function assertEnumMember(node, opts) {
      assert("EnumMember", node, opts);
    }
    function assertJSX(node, opts) {
      assert("JSX", node, opts);
    }
    function assertMiscellaneous(node, opts) {
      assert("Miscellaneous", node, opts);
    }
    function assertTypeScript(node, opts) {
      assert("TypeScript", node, opts);
    }
    function assertTSTypeElement(node, opts) {
      assert("TSTypeElement", node, opts);
    }
    function assertTSType(node, opts) {
      assert("TSType", node, opts);
    }
    function assertTSBaseType(node, opts) {
      assert("TSBaseType", node, opts);
    }
    function assertNumberLiteral(node, opts) {
      (0, _deprecationWarning["default"])(
        "assertNumberLiteral",
        "assertNumericLiteral"
      );
      assert("NumberLiteral", node, opts);
    }
    function assertRegexLiteral(node, opts) {
      (0, _deprecationWarning["default"])(
        "assertRegexLiteral",
        "assertRegExpLiteral"
      );
      assert("RegexLiteral", node, opts);
    }
    function assertRestProperty(node, opts) {
      (0, _deprecationWarning["default"])(
        "assertRestProperty",
        "assertRestElement"
      );
      assert("RestProperty", node, opts);
    }
    function assertSpreadProperty(node, opts) {
      (0, _deprecationWarning["default"])(
        "assertSpreadProperty",
        "assertSpreadElement"
      );
      assert("SpreadProperty", node, opts);
    }
    function assertModuleDeclaration(node, opts) {
      (0, _deprecationWarning["default"])(
        "assertModuleDeclaration",
        "assertImportOrExportDeclaration"
      );
      assert("ModuleDeclaration", node, opts);
    }
    var createTypeAnnotationBasedOnTypeof$1 = {};
    Object.defineProperty(createTypeAnnotationBasedOnTypeof$1, "__esModule", {
      value: true
    });
    createTypeAnnotationBasedOnTypeof$1["default"] = void 0;
    var _index$t = generated$2;
    createTypeAnnotationBasedOnTypeof$1["default"] =
      createTypeAnnotationBasedOnTypeof;
    function createTypeAnnotationBasedOnTypeof(type) {
      switch (type) {
        case "string":
          return (0, _index$t.stringTypeAnnotation)();
        case "number":
          return (0, _index$t.numberTypeAnnotation)();
        case "undefined":
          return (0, _index$t.voidTypeAnnotation)();
        case "boolean":
          return (0, _index$t.booleanTypeAnnotation)();
        case "function":
          return (0, _index$t.genericTypeAnnotation)(
            (0, _index$t.identifier)("Function")
          );
        case "object":
          return (0, _index$t.genericTypeAnnotation)(
            (0, _index$t.identifier)("Object")
          );
        case "symbol":
          return (0, _index$t.genericTypeAnnotation)(
            (0, _index$t.identifier)("Symbol")
          );
        case "bigint":
          return (0, _index$t.anyTypeAnnotation)();
      }
      throw new Error("Invalid typeof value: " + type);
    }
    var createFlowUnionType$1 = {};
    var removeTypeDuplicates$3 = {};
    Object.defineProperty(removeTypeDuplicates$3, "__esModule", {
      value: true
    });
    removeTypeDuplicates$3["default"] = removeTypeDuplicates$2;
    var _index$s = generated$3;
    function getQualifiedName$1(node) {
      return (0, _index$s.isIdentifier)(node)
        ? node.name
        : ""
            .concat(node.id.name, ".")
            .concat(getQualifiedName$1(node.qualification));
    }
    function removeTypeDuplicates$2(nodesIn) {
      var nodes = Array.from(nodesIn);
      var generics = new Map();
      var bases = new Map();
      var typeGroups = new Set();
      var types = [];
      for (var i = 0; i < nodes.length; i++) {
        var _node2 = nodes[i];
        if (!_node2) continue;
        if (types.includes(_node2)) {
          continue;
        }
        if ((0, _index$s.isAnyTypeAnnotation)(_node2)) {
          return [_node2];
        }
        if ((0, _index$s.isFlowBaseAnnotation)(_node2)) {
          bases.set(_node2.type, _node2);
          continue;
        }
        if ((0, _index$s.isUnionTypeAnnotation)(_node2)) {
          if (!typeGroups.has(_node2.types)) {
            nodes.push.apply(nodes, _toConsumableArray(_node2.types));
            typeGroups.add(_node2.types);
          }
          continue;
        }
        if ((0, _index$s.isGenericTypeAnnotation)(_node2)) {
          var name = getQualifiedName$1(_node2.id);
          if (generics.has(name)) {
            var existing = generics.get(name);
            if (existing.typeParameters) {
              if (_node2.typeParameters) {
                var _existing$typeParamet;
                (_existing$typeParamet =
                  existing.typeParameters.params).push.apply(
                  _existing$typeParamet,
                  _toConsumableArray(_node2.typeParameters.params)
                );
                existing.typeParameters.params = removeTypeDuplicates$2(
                  existing.typeParameters.params
                );
              }
            } else {
              existing = _node2.typeParameters;
            }
          } else {
            generics.set(name, _node2);
          }
          continue;
        }
        types.push(_node2);
      }
      var _iterator23 = _createForOfIteratorHelper(bases),
        _step23;
      try {
        for (_iterator23.s(); !(_step23 = _iterator23.n()).done; ) {
          var _step23$value = _slicedToArray(_step23.value, 2),
            baseType = _step23$value[1];
          types.push(baseType);
        }
      } catch (err) {
        _iterator23.e(err);
      } finally {
        _iterator23.f();
      }
      var _iterator24 = _createForOfIteratorHelper(generics),
        _step24;
      try {
        for (_iterator24.s(); !(_step24 = _iterator24.n()).done; ) {
          var _step24$value = _slicedToArray(_step24.value, 2),
            genericName = _step24$value[1];
          types.push(genericName);
        }
      } catch (err) {
        _iterator24.e(err);
      } finally {
        _iterator24.f();
      }
      return types;
    }
    Object.defineProperty(createFlowUnionType$1, "__esModule", { value: true });
    createFlowUnionType$1["default"] = createFlowUnionType;
    var _index$r = generated$2;
    var _removeTypeDuplicates$1 = removeTypeDuplicates$3;
    function createFlowUnionType(types) {
      var flattened = (0, _removeTypeDuplicates$1["default"])(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _index$r.unionTypeAnnotation)(flattened);
      }
    }
    var createTSUnionType$1 = {};
    var removeTypeDuplicates$1 = {};
    Object.defineProperty(removeTypeDuplicates$1, "__esModule", {
      value: true
    });
    removeTypeDuplicates$1["default"] = removeTypeDuplicates;
    var _index$q = generated$3;
    function getQualifiedName(node) {
      return (0, _index$q.isIdentifier)(node)
        ? node.name
        : "".concat(node.right.name, ".").concat(getQualifiedName(node.left));
    }
    function removeTypeDuplicates(nodesIn) {
      var nodes = Array.from(nodesIn);
      var generics = new Map();
      var bases = new Map();
      var typeGroups = new Set();
      var types = [];
      for (var i = 0; i < nodes.length; i++) {
        var _node3 = nodes[i];
        if (!_node3) continue;
        if (types.includes(_node3)) {
          continue;
        }
        if ((0, _index$q.isTSAnyKeyword)(_node3)) {
          return [_node3];
        }
        if ((0, _index$q.isTSBaseType)(_node3)) {
          bases.set(_node3.type, _node3);
          continue;
        }
        if ((0, _index$q.isTSUnionType)(_node3)) {
          if (!typeGroups.has(_node3.types)) {
            nodes.push.apply(nodes, _toConsumableArray(_node3.types));
            typeGroups.add(_node3.types);
          }
          continue;
        }
        if ((0, _index$q.isTSTypeReference)(_node3) && _node3.typeParameters) {
          var name = getQualifiedName(_node3.typeName);
          if (generics.has(name)) {
            var existing = generics.get(name);
            if (existing.typeParameters) {
              if (_node3.typeParameters) {
                var _existing$typeParamet2;
                (_existing$typeParamet2 =
                  existing.typeParameters.params).push.apply(
                  _existing$typeParamet2,
                  _toConsumableArray(_node3.typeParameters.params)
                );
                existing.typeParameters.params = removeTypeDuplicates(
                  existing.typeParameters.params
                );
              }
            } else {
              existing = _node3.typeParameters;
            }
          } else {
            generics.set(name, _node3);
          }
          continue;
        }
        types.push(_node3);
      }
      var _iterator25 = _createForOfIteratorHelper(bases),
        _step25;
      try {
        for (_iterator25.s(); !(_step25 = _iterator25.n()).done; ) {
          var _step25$value = _slicedToArray(_step25.value, 2),
            baseType = _step25$value[1];
          types.push(baseType);
        }
      } catch (err) {
        _iterator25.e(err);
      } finally {
        _iterator25.f();
      }
      var _iterator26 = _createForOfIteratorHelper(generics),
        _step26;
      try {
        for (_iterator26.s(); !(_step26 = _iterator26.n()).done; ) {
          var _step26$value = _slicedToArray(_step26.value, 2),
            genericName = _step26$value[1];
          types.push(genericName);
        }
      } catch (err) {
        _iterator26.e(err);
      } finally {
        _iterator26.f();
      }
      return types;
    }
    Object.defineProperty(createTSUnionType$1, "__esModule", { value: true });
    createTSUnionType$1["default"] = createTSUnionType;
    var _index$p = generated$2;
    var _removeTypeDuplicates = removeTypeDuplicates$1;
    var _index2$7 = generated$3;
    function createTSUnionType(typeAnnotations) {
      var types = typeAnnotations.map(function (type) {
        return (0, _index2$7.isTSTypeAnnotation)(type)
          ? type.typeAnnotation
          : type;
      });
      var flattened = (0, _removeTypeDuplicates["default"])(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _index$p.tsUnionType)(flattened);
      }
    }
    var uppercase = {};
    (function (exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      Object.defineProperty(exports, "AnyTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.anyTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ArgumentPlaceholder", {
        enumerable: true,
        get: function get() {
          return _index.argumentPlaceholder;
        }
      });
      Object.defineProperty(exports, "ArrayExpression", {
        enumerable: true,
        get: function get() {
          return _index.arrayExpression;
        }
      });
      Object.defineProperty(exports, "ArrayPattern", {
        enumerable: true,
        get: function get() {
          return _index.arrayPattern;
        }
      });
      Object.defineProperty(exports, "ArrayTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.arrayTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ArrowFunctionExpression", {
        enumerable: true,
        get: function get() {
          return _index.arrowFunctionExpression;
        }
      });
      Object.defineProperty(exports, "AssignmentExpression", {
        enumerable: true,
        get: function get() {
          return _index.assignmentExpression;
        }
      });
      Object.defineProperty(exports, "AssignmentPattern", {
        enumerable: true,
        get: function get() {
          return _index.assignmentPattern;
        }
      });
      Object.defineProperty(exports, "AwaitExpression", {
        enumerable: true,
        get: function get() {
          return _index.awaitExpression;
        }
      });
      Object.defineProperty(exports, "BigIntLiteral", {
        enumerable: true,
        get: function get() {
          return _index.bigIntLiteral;
        }
      });
      Object.defineProperty(exports, "BinaryExpression", {
        enumerable: true,
        get: function get() {
          return _index.binaryExpression;
        }
      });
      Object.defineProperty(exports, "BindExpression", {
        enumerable: true,
        get: function get() {
          return _index.bindExpression;
        }
      });
      Object.defineProperty(exports, "BlockStatement", {
        enumerable: true,
        get: function get() {
          return _index.blockStatement;
        }
      });
      Object.defineProperty(exports, "BooleanLiteral", {
        enumerable: true,
        get: function get() {
          return _index.booleanLiteral;
        }
      });
      Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.booleanLiteralTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "BooleanTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.booleanTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "BreakStatement", {
        enumerable: true,
        get: function get() {
          return _index.breakStatement;
        }
      });
      Object.defineProperty(exports, "CallExpression", {
        enumerable: true,
        get: function get() {
          return _index.callExpression;
        }
      });
      Object.defineProperty(exports, "CatchClause", {
        enumerable: true,
        get: function get() {
          return _index.catchClause;
        }
      });
      Object.defineProperty(exports, "ClassAccessorProperty", {
        enumerable: true,
        get: function get() {
          return _index.classAccessorProperty;
        }
      });
      Object.defineProperty(exports, "ClassBody", {
        enumerable: true,
        get: function get() {
          return _index.classBody;
        }
      });
      Object.defineProperty(exports, "ClassDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.classDeclaration;
        }
      });
      Object.defineProperty(exports, "ClassExpression", {
        enumerable: true,
        get: function get() {
          return _index.classExpression;
        }
      });
      Object.defineProperty(exports, "ClassImplements", {
        enumerable: true,
        get: function get() {
          return _index.classImplements;
        }
      });
      Object.defineProperty(exports, "ClassMethod", {
        enumerable: true,
        get: function get() {
          return _index.classMethod;
        }
      });
      Object.defineProperty(exports, "ClassPrivateMethod", {
        enumerable: true,
        get: function get() {
          return _index.classPrivateMethod;
        }
      });
      Object.defineProperty(exports, "ClassPrivateProperty", {
        enumerable: true,
        get: function get() {
          return _index.classPrivateProperty;
        }
      });
      Object.defineProperty(exports, "ClassProperty", {
        enumerable: true,
        get: function get() {
          return _index.classProperty;
        }
      });
      Object.defineProperty(exports, "ConditionalExpression", {
        enumerable: true,
        get: function get() {
          return _index.conditionalExpression;
        }
      });
      Object.defineProperty(exports, "ContinueStatement", {
        enumerable: true,
        get: function get() {
          return _index.continueStatement;
        }
      });
      Object.defineProperty(exports, "DebuggerStatement", {
        enumerable: true,
        get: function get() {
          return _index.debuggerStatement;
        }
      });
      Object.defineProperty(exports, "DecimalLiteral", {
        enumerable: true,
        get: function get() {
          return _index.decimalLiteral;
        }
      });
      Object.defineProperty(exports, "DeclareClass", {
        enumerable: true,
        get: function get() {
          return _index.declareClass;
        }
      });
      Object.defineProperty(exports, "DeclareExportAllDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.declareExportAllDeclaration;
        }
      });
      Object.defineProperty(exports, "DeclareExportDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.declareExportDeclaration;
        }
      });
      Object.defineProperty(exports, "DeclareFunction", {
        enumerable: true,
        get: function get() {
          return _index.declareFunction;
        }
      });
      Object.defineProperty(exports, "DeclareInterface", {
        enumerable: true,
        get: function get() {
          return _index.declareInterface;
        }
      });
      Object.defineProperty(exports, "DeclareModule", {
        enumerable: true,
        get: function get() {
          return _index.declareModule;
        }
      });
      Object.defineProperty(exports, "DeclareModuleExports", {
        enumerable: true,
        get: function get() {
          return _index.declareModuleExports;
        }
      });
      Object.defineProperty(exports, "DeclareOpaqueType", {
        enumerable: true,
        get: function get() {
          return _index.declareOpaqueType;
        }
      });
      Object.defineProperty(exports, "DeclareTypeAlias", {
        enumerable: true,
        get: function get() {
          return _index.declareTypeAlias;
        }
      });
      Object.defineProperty(exports, "DeclareVariable", {
        enumerable: true,
        get: function get() {
          return _index.declareVariable;
        }
      });
      Object.defineProperty(exports, "DeclaredPredicate", {
        enumerable: true,
        get: function get() {
          return _index.declaredPredicate;
        }
      });
      Object.defineProperty(exports, "Decorator", {
        enumerable: true,
        get: function get() {
          return _index.decorator;
        }
      });
      Object.defineProperty(exports, "Directive", {
        enumerable: true,
        get: function get() {
          return _index.directive;
        }
      });
      Object.defineProperty(exports, "DirectiveLiteral", {
        enumerable: true,
        get: function get() {
          return _index.directiveLiteral;
        }
      });
      Object.defineProperty(exports, "DoExpression", {
        enumerable: true,
        get: function get() {
          return _index.doExpression;
        }
      });
      Object.defineProperty(exports, "DoWhileStatement", {
        enumerable: true,
        get: function get() {
          return _index.doWhileStatement;
        }
      });
      Object.defineProperty(exports, "EmptyStatement", {
        enumerable: true,
        get: function get() {
          return _index.emptyStatement;
        }
      });
      Object.defineProperty(exports, "EmptyTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.emptyTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "EnumBooleanBody", {
        enumerable: true,
        get: function get() {
          return _index.enumBooleanBody;
        }
      });
      Object.defineProperty(exports, "EnumBooleanMember", {
        enumerable: true,
        get: function get() {
          return _index.enumBooleanMember;
        }
      });
      Object.defineProperty(exports, "EnumDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.enumDeclaration;
        }
      });
      Object.defineProperty(exports, "EnumDefaultedMember", {
        enumerable: true,
        get: function get() {
          return _index.enumDefaultedMember;
        }
      });
      Object.defineProperty(exports, "EnumNumberBody", {
        enumerable: true,
        get: function get() {
          return _index.enumNumberBody;
        }
      });
      Object.defineProperty(exports, "EnumNumberMember", {
        enumerable: true,
        get: function get() {
          return _index.enumNumberMember;
        }
      });
      Object.defineProperty(exports, "EnumStringBody", {
        enumerable: true,
        get: function get() {
          return _index.enumStringBody;
        }
      });
      Object.defineProperty(exports, "EnumStringMember", {
        enumerable: true,
        get: function get() {
          return _index.enumStringMember;
        }
      });
      Object.defineProperty(exports, "EnumSymbolBody", {
        enumerable: true,
        get: function get() {
          return _index.enumSymbolBody;
        }
      });
      Object.defineProperty(exports, "ExistsTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.existsTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ExportAllDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.exportAllDeclaration;
        }
      });
      Object.defineProperty(exports, "ExportDefaultDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.exportDefaultDeclaration;
        }
      });
      Object.defineProperty(exports, "ExportDefaultSpecifier", {
        enumerable: true,
        get: function get() {
          return _index.exportDefaultSpecifier;
        }
      });
      Object.defineProperty(exports, "ExportNamedDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.exportNamedDeclaration;
        }
      });
      Object.defineProperty(exports, "ExportNamespaceSpecifier", {
        enumerable: true,
        get: function get() {
          return _index.exportNamespaceSpecifier;
        }
      });
      Object.defineProperty(exports, "ExportSpecifier", {
        enumerable: true,
        get: function get() {
          return _index.exportSpecifier;
        }
      });
      Object.defineProperty(exports, "ExpressionStatement", {
        enumerable: true,
        get: function get() {
          return _index.expressionStatement;
        }
      });
      Object.defineProperty(exports, "File", {
        enumerable: true,
        get: function get() {
          return _index.file;
        }
      });
      Object.defineProperty(exports, "ForInStatement", {
        enumerable: true,
        get: function get() {
          return _index.forInStatement;
        }
      });
      Object.defineProperty(exports, "ForOfStatement", {
        enumerable: true,
        get: function get() {
          return _index.forOfStatement;
        }
      });
      Object.defineProperty(exports, "ForStatement", {
        enumerable: true,
        get: function get() {
          return _index.forStatement;
        }
      });
      Object.defineProperty(exports, "FunctionDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.functionDeclaration;
        }
      });
      Object.defineProperty(exports, "FunctionExpression", {
        enumerable: true,
        get: function get() {
          return _index.functionExpression;
        }
      });
      Object.defineProperty(exports, "FunctionTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.functionTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "FunctionTypeParam", {
        enumerable: true,
        get: function get() {
          return _index.functionTypeParam;
        }
      });
      Object.defineProperty(exports, "GenericTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.genericTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "Identifier", {
        enumerable: true,
        get: function get() {
          return _index.identifier;
        }
      });
      Object.defineProperty(exports, "IfStatement", {
        enumerable: true,
        get: function get() {
          return _index.ifStatement;
        }
      });
      Object.defineProperty(exports, "Import", {
        enumerable: true,
        get: function get() {
          return _index["import"];
        }
      });
      Object.defineProperty(exports, "ImportAttribute", {
        enumerable: true,
        get: function get() {
          return _index.importAttribute;
        }
      });
      Object.defineProperty(exports, "ImportDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.importDeclaration;
        }
      });
      Object.defineProperty(exports, "ImportDefaultSpecifier", {
        enumerable: true,
        get: function get() {
          return _index.importDefaultSpecifier;
        }
      });
      Object.defineProperty(exports, "ImportExpression", {
        enumerable: true,
        get: function get() {
          return _index.importExpression;
        }
      });
      Object.defineProperty(exports, "ImportNamespaceSpecifier", {
        enumerable: true,
        get: function get() {
          return _index.importNamespaceSpecifier;
        }
      });
      Object.defineProperty(exports, "ImportSpecifier", {
        enumerable: true,
        get: function get() {
          return _index.importSpecifier;
        }
      });
      Object.defineProperty(exports, "IndexedAccessType", {
        enumerable: true,
        get: function get() {
          return _index.indexedAccessType;
        }
      });
      Object.defineProperty(exports, "InferredPredicate", {
        enumerable: true,
        get: function get() {
          return _index.inferredPredicate;
        }
      });
      Object.defineProperty(exports, "InterfaceDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.interfaceDeclaration;
        }
      });
      Object.defineProperty(exports, "InterfaceExtends", {
        enumerable: true,
        get: function get() {
          return _index.interfaceExtends;
        }
      });
      Object.defineProperty(exports, "InterfaceTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.interfaceTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "InterpreterDirective", {
        enumerable: true,
        get: function get() {
          return _index.interpreterDirective;
        }
      });
      Object.defineProperty(exports, "IntersectionTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.intersectionTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "JSXAttribute", {
        enumerable: true,
        get: function get() {
          return _index.jsxAttribute;
        }
      });
      Object.defineProperty(exports, "JSXClosingElement", {
        enumerable: true,
        get: function get() {
          return _index.jsxClosingElement;
        }
      });
      Object.defineProperty(exports, "JSXClosingFragment", {
        enumerable: true,
        get: function get() {
          return _index.jsxClosingFragment;
        }
      });
      Object.defineProperty(exports, "JSXElement", {
        enumerable: true,
        get: function get() {
          return _index.jsxElement;
        }
      });
      Object.defineProperty(exports, "JSXEmptyExpression", {
        enumerable: true,
        get: function get() {
          return _index.jsxEmptyExpression;
        }
      });
      Object.defineProperty(exports, "JSXExpressionContainer", {
        enumerable: true,
        get: function get() {
          return _index.jsxExpressionContainer;
        }
      });
      Object.defineProperty(exports, "JSXFragment", {
        enumerable: true,
        get: function get() {
          return _index.jsxFragment;
        }
      });
      Object.defineProperty(exports, "JSXIdentifier", {
        enumerable: true,
        get: function get() {
          return _index.jsxIdentifier;
        }
      });
      Object.defineProperty(exports, "JSXMemberExpression", {
        enumerable: true,
        get: function get() {
          return _index.jsxMemberExpression;
        }
      });
      Object.defineProperty(exports, "JSXNamespacedName", {
        enumerable: true,
        get: function get() {
          return _index.jsxNamespacedName;
        }
      });
      Object.defineProperty(exports, "JSXOpeningElement", {
        enumerable: true,
        get: function get() {
          return _index.jsxOpeningElement;
        }
      });
      Object.defineProperty(exports, "JSXOpeningFragment", {
        enumerable: true,
        get: function get() {
          return _index.jsxOpeningFragment;
        }
      });
      Object.defineProperty(exports, "JSXSpreadAttribute", {
        enumerable: true,
        get: function get() {
          return _index.jsxSpreadAttribute;
        }
      });
      Object.defineProperty(exports, "JSXSpreadChild", {
        enumerable: true,
        get: function get() {
          return _index.jsxSpreadChild;
        }
      });
      Object.defineProperty(exports, "JSXText", {
        enumerable: true,
        get: function get() {
          return _index.jsxText;
        }
      });
      Object.defineProperty(exports, "LabeledStatement", {
        enumerable: true,
        get: function get() {
          return _index.labeledStatement;
        }
      });
      Object.defineProperty(exports, "LogicalExpression", {
        enumerable: true,
        get: function get() {
          return _index.logicalExpression;
        }
      });
      Object.defineProperty(exports, "MemberExpression", {
        enumerable: true,
        get: function get() {
          return _index.memberExpression;
        }
      });
      Object.defineProperty(exports, "MetaProperty", {
        enumerable: true,
        get: function get() {
          return _index.metaProperty;
        }
      });
      Object.defineProperty(exports, "MixedTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.mixedTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ModuleExpression", {
        enumerable: true,
        get: function get() {
          return _index.moduleExpression;
        }
      });
      Object.defineProperty(exports, "NewExpression", {
        enumerable: true,
        get: function get() {
          return _index.newExpression;
        }
      });
      Object.defineProperty(exports, "Noop", {
        enumerable: true,
        get: function get() {
          return _index.noop;
        }
      });
      Object.defineProperty(exports, "NullLiteral", {
        enumerable: true,
        get: function get() {
          return _index.nullLiteral;
        }
      });
      Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.nullLiteralTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "NullableTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.nullableTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "NumberLiteral", {
        enumerable: true,
        get: function get() {
          return _index.numberLiteral;
        }
      });
      Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.numberLiteralTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "NumberTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.numberTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "NumericLiteral", {
        enumerable: true,
        get: function get() {
          return _index.numericLiteral;
        }
      });
      Object.defineProperty(exports, "ObjectExpression", {
        enumerable: true,
        get: function get() {
          return _index.objectExpression;
        }
      });
      Object.defineProperty(exports, "ObjectMethod", {
        enumerable: true,
        get: function get() {
          return _index.objectMethod;
        }
      });
      Object.defineProperty(exports, "ObjectPattern", {
        enumerable: true,
        get: function get() {
          return _index.objectPattern;
        }
      });
      Object.defineProperty(exports, "ObjectProperty", {
        enumerable: true,
        get: function get() {
          return _index.objectProperty;
        }
      });
      Object.defineProperty(exports, "ObjectTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.objectTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ObjectTypeCallProperty", {
        enumerable: true,
        get: function get() {
          return _index.objectTypeCallProperty;
        }
      });
      Object.defineProperty(exports, "ObjectTypeIndexer", {
        enumerable: true,
        get: function get() {
          return _index.objectTypeIndexer;
        }
      });
      Object.defineProperty(exports, "ObjectTypeInternalSlot", {
        enumerable: true,
        get: function get() {
          return _index.objectTypeInternalSlot;
        }
      });
      Object.defineProperty(exports, "ObjectTypeProperty", {
        enumerable: true,
        get: function get() {
          return _index.objectTypeProperty;
        }
      });
      Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
        enumerable: true,
        get: function get() {
          return _index.objectTypeSpreadProperty;
        }
      });
      Object.defineProperty(exports, "OpaqueType", {
        enumerable: true,
        get: function get() {
          return _index.opaqueType;
        }
      });
      Object.defineProperty(exports, "OptionalCallExpression", {
        enumerable: true,
        get: function get() {
          return _index.optionalCallExpression;
        }
      });
      Object.defineProperty(exports, "OptionalIndexedAccessType", {
        enumerable: true,
        get: function get() {
          return _index.optionalIndexedAccessType;
        }
      });
      Object.defineProperty(exports, "OptionalMemberExpression", {
        enumerable: true,
        get: function get() {
          return _index.optionalMemberExpression;
        }
      });
      Object.defineProperty(exports, "ParenthesizedExpression", {
        enumerable: true,
        get: function get() {
          return _index.parenthesizedExpression;
        }
      });
      Object.defineProperty(exports, "PipelineBareFunction", {
        enumerable: true,
        get: function get() {
          return _index.pipelineBareFunction;
        }
      });
      Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
        enumerable: true,
        get: function get() {
          return _index.pipelinePrimaryTopicReference;
        }
      });
      Object.defineProperty(exports, "PipelineTopicExpression", {
        enumerable: true,
        get: function get() {
          return _index.pipelineTopicExpression;
        }
      });
      Object.defineProperty(exports, "Placeholder", {
        enumerable: true,
        get: function get() {
          return _index.placeholder;
        }
      });
      Object.defineProperty(exports, "PrivateName", {
        enumerable: true,
        get: function get() {
          return _index.privateName;
        }
      });
      Object.defineProperty(exports, "Program", {
        enumerable: true,
        get: function get() {
          return _index.program;
        }
      });
      Object.defineProperty(exports, "QualifiedTypeIdentifier", {
        enumerable: true,
        get: function get() {
          return _index.qualifiedTypeIdentifier;
        }
      });
      Object.defineProperty(exports, "RecordExpression", {
        enumerable: true,
        get: function get() {
          return _index.recordExpression;
        }
      });
      Object.defineProperty(exports, "RegExpLiteral", {
        enumerable: true,
        get: function get() {
          return _index.regExpLiteral;
        }
      });
      Object.defineProperty(exports, "RegexLiteral", {
        enumerable: true,
        get: function get() {
          return _index.regexLiteral;
        }
      });
      Object.defineProperty(exports, "RestElement", {
        enumerable: true,
        get: function get() {
          return _index.restElement;
        }
      });
      Object.defineProperty(exports, "RestProperty", {
        enumerable: true,
        get: function get() {
          return _index.restProperty;
        }
      });
      Object.defineProperty(exports, "ReturnStatement", {
        enumerable: true,
        get: function get() {
          return _index.returnStatement;
        }
      });
      Object.defineProperty(exports, "SequenceExpression", {
        enumerable: true,
        get: function get() {
          return _index.sequenceExpression;
        }
      });
      Object.defineProperty(exports, "SpreadElement", {
        enumerable: true,
        get: function get() {
          return _index.spreadElement;
        }
      });
      Object.defineProperty(exports, "SpreadProperty", {
        enumerable: true,
        get: function get() {
          return _index.spreadProperty;
        }
      });
      Object.defineProperty(exports, "StaticBlock", {
        enumerable: true,
        get: function get() {
          return _index.staticBlock;
        }
      });
      Object.defineProperty(exports, "StringLiteral", {
        enumerable: true,
        get: function get() {
          return _index.stringLiteral;
        }
      });
      Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.stringLiteralTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "StringTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.stringTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "Super", {
        enumerable: true,
        get: function get() {
          return _index["super"];
        }
      });
      Object.defineProperty(exports, "SwitchCase", {
        enumerable: true,
        get: function get() {
          return _index.switchCase;
        }
      });
      Object.defineProperty(exports, "SwitchStatement", {
        enumerable: true,
        get: function get() {
          return _index.switchStatement;
        }
      });
      Object.defineProperty(exports, "SymbolTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.symbolTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "TSAnyKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsAnyKeyword;
        }
      });
      Object.defineProperty(exports, "TSArrayType", {
        enumerable: true,
        get: function get() {
          return _index.tsArrayType;
        }
      });
      Object.defineProperty(exports, "TSAsExpression", {
        enumerable: true,
        get: function get() {
          return _index.tsAsExpression;
        }
      });
      Object.defineProperty(exports, "TSBigIntKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsBigIntKeyword;
        }
      });
      Object.defineProperty(exports, "TSBooleanKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsBooleanKeyword;
        }
      });
      Object.defineProperty(exports, "TSCallSignatureDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.tsCallSignatureDeclaration;
        }
      });
      Object.defineProperty(exports, "TSConditionalType", {
        enumerable: true,
        get: function get() {
          return _index.tsConditionalType;
        }
      });
      Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.tsConstructSignatureDeclaration;
        }
      });
      Object.defineProperty(exports, "TSConstructorType", {
        enumerable: true,
        get: function get() {
          return _index.tsConstructorType;
        }
      });
      Object.defineProperty(exports, "TSDeclareFunction", {
        enumerable: true,
        get: function get() {
          return _index.tsDeclareFunction;
        }
      });
      Object.defineProperty(exports, "TSDeclareMethod", {
        enumerable: true,
        get: function get() {
          return _index.tsDeclareMethod;
        }
      });
      Object.defineProperty(exports, "TSEnumDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.tsEnumDeclaration;
        }
      });
      Object.defineProperty(exports, "TSEnumMember", {
        enumerable: true,
        get: function get() {
          return _index.tsEnumMember;
        }
      });
      Object.defineProperty(exports, "TSExportAssignment", {
        enumerable: true,
        get: function get() {
          return _index.tsExportAssignment;
        }
      });
      Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
        enumerable: true,
        get: function get() {
          return _index.tsExpressionWithTypeArguments;
        }
      });
      Object.defineProperty(exports, "TSExternalModuleReference", {
        enumerable: true,
        get: function get() {
          return _index.tsExternalModuleReference;
        }
      });
      Object.defineProperty(exports, "TSFunctionType", {
        enumerable: true,
        get: function get() {
          return _index.tsFunctionType;
        }
      });
      Object.defineProperty(exports, "TSImportEqualsDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.tsImportEqualsDeclaration;
        }
      });
      Object.defineProperty(exports, "TSImportType", {
        enumerable: true,
        get: function get() {
          return _index.tsImportType;
        }
      });
      Object.defineProperty(exports, "TSIndexSignature", {
        enumerable: true,
        get: function get() {
          return _index.tsIndexSignature;
        }
      });
      Object.defineProperty(exports, "TSIndexedAccessType", {
        enumerable: true,
        get: function get() {
          return _index.tsIndexedAccessType;
        }
      });
      Object.defineProperty(exports, "TSInferType", {
        enumerable: true,
        get: function get() {
          return _index.tsInferType;
        }
      });
      Object.defineProperty(exports, "TSInstantiationExpression", {
        enumerable: true,
        get: function get() {
          return _index.tsInstantiationExpression;
        }
      });
      Object.defineProperty(exports, "TSInterfaceBody", {
        enumerable: true,
        get: function get() {
          return _index.tsInterfaceBody;
        }
      });
      Object.defineProperty(exports, "TSInterfaceDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.tsInterfaceDeclaration;
        }
      });
      Object.defineProperty(exports, "TSIntersectionType", {
        enumerable: true,
        get: function get() {
          return _index.tsIntersectionType;
        }
      });
      Object.defineProperty(exports, "TSIntrinsicKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsIntrinsicKeyword;
        }
      });
      Object.defineProperty(exports, "TSLiteralType", {
        enumerable: true,
        get: function get() {
          return _index.tsLiteralType;
        }
      });
      Object.defineProperty(exports, "TSMappedType", {
        enumerable: true,
        get: function get() {
          return _index.tsMappedType;
        }
      });
      Object.defineProperty(exports, "TSMethodSignature", {
        enumerable: true,
        get: function get() {
          return _index.tsMethodSignature;
        }
      });
      Object.defineProperty(exports, "TSModuleBlock", {
        enumerable: true,
        get: function get() {
          return _index.tsModuleBlock;
        }
      });
      Object.defineProperty(exports, "TSModuleDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.tsModuleDeclaration;
        }
      });
      Object.defineProperty(exports, "TSNamedTupleMember", {
        enumerable: true,
        get: function get() {
          return _index.tsNamedTupleMember;
        }
      });
      Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.tsNamespaceExportDeclaration;
        }
      });
      Object.defineProperty(exports, "TSNeverKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsNeverKeyword;
        }
      });
      Object.defineProperty(exports, "TSNonNullExpression", {
        enumerable: true,
        get: function get() {
          return _index.tsNonNullExpression;
        }
      });
      Object.defineProperty(exports, "TSNullKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsNullKeyword;
        }
      });
      Object.defineProperty(exports, "TSNumberKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsNumberKeyword;
        }
      });
      Object.defineProperty(exports, "TSObjectKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsObjectKeyword;
        }
      });
      Object.defineProperty(exports, "TSOptionalType", {
        enumerable: true,
        get: function get() {
          return _index.tsOptionalType;
        }
      });
      Object.defineProperty(exports, "TSParameterProperty", {
        enumerable: true,
        get: function get() {
          return _index.tsParameterProperty;
        }
      });
      Object.defineProperty(exports, "TSParenthesizedType", {
        enumerable: true,
        get: function get() {
          return _index.tsParenthesizedType;
        }
      });
      Object.defineProperty(exports, "TSPropertySignature", {
        enumerable: true,
        get: function get() {
          return _index.tsPropertySignature;
        }
      });
      Object.defineProperty(exports, "TSQualifiedName", {
        enumerable: true,
        get: function get() {
          return _index.tsQualifiedName;
        }
      });
      Object.defineProperty(exports, "TSRestType", {
        enumerable: true,
        get: function get() {
          return _index.tsRestType;
        }
      });
      Object.defineProperty(exports, "TSSatisfiesExpression", {
        enumerable: true,
        get: function get() {
          return _index.tsSatisfiesExpression;
        }
      });
      Object.defineProperty(exports, "TSStringKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsStringKeyword;
        }
      });
      Object.defineProperty(exports, "TSSymbolKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsSymbolKeyword;
        }
      });
      Object.defineProperty(exports, "TSThisType", {
        enumerable: true,
        get: function get() {
          return _index.tsThisType;
        }
      });
      Object.defineProperty(exports, "TSTupleType", {
        enumerable: true,
        get: function get() {
          return _index.tsTupleType;
        }
      });
      Object.defineProperty(exports, "TSTypeAliasDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.tsTypeAliasDeclaration;
        }
      });
      Object.defineProperty(exports, "TSTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.tsTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "TSTypeAssertion", {
        enumerable: true,
        get: function get() {
          return _index.tsTypeAssertion;
        }
      });
      Object.defineProperty(exports, "TSTypeLiteral", {
        enumerable: true,
        get: function get() {
          return _index.tsTypeLiteral;
        }
      });
      Object.defineProperty(exports, "TSTypeOperator", {
        enumerable: true,
        get: function get() {
          return _index.tsTypeOperator;
        }
      });
      Object.defineProperty(exports, "TSTypeParameter", {
        enumerable: true,
        get: function get() {
          return _index.tsTypeParameter;
        }
      });
      Object.defineProperty(exports, "TSTypeParameterDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.tsTypeParameterDeclaration;
        }
      });
      Object.defineProperty(exports, "TSTypeParameterInstantiation", {
        enumerable: true,
        get: function get() {
          return _index.tsTypeParameterInstantiation;
        }
      });
      Object.defineProperty(exports, "TSTypePredicate", {
        enumerable: true,
        get: function get() {
          return _index.tsTypePredicate;
        }
      });
      Object.defineProperty(exports, "TSTypeQuery", {
        enumerable: true,
        get: function get() {
          return _index.tsTypeQuery;
        }
      });
      Object.defineProperty(exports, "TSTypeReference", {
        enumerable: true,
        get: function get() {
          return _index.tsTypeReference;
        }
      });
      Object.defineProperty(exports, "TSUndefinedKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsUndefinedKeyword;
        }
      });
      Object.defineProperty(exports, "TSUnionType", {
        enumerable: true,
        get: function get() {
          return _index.tsUnionType;
        }
      });
      Object.defineProperty(exports, "TSUnknownKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsUnknownKeyword;
        }
      });
      Object.defineProperty(exports, "TSVoidKeyword", {
        enumerable: true,
        get: function get() {
          return _index.tsVoidKeyword;
        }
      });
      Object.defineProperty(exports, "TaggedTemplateExpression", {
        enumerable: true,
        get: function get() {
          return _index.taggedTemplateExpression;
        }
      });
      Object.defineProperty(exports, "TemplateElement", {
        enumerable: true,
        get: function get() {
          return _index.templateElement;
        }
      });
      Object.defineProperty(exports, "TemplateLiteral", {
        enumerable: true,
        get: function get() {
          return _index.templateLiteral;
        }
      });
      Object.defineProperty(exports, "ThisExpression", {
        enumerable: true,
        get: function get() {
          return _index.thisExpression;
        }
      });
      Object.defineProperty(exports, "ThisTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.thisTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "ThrowStatement", {
        enumerable: true,
        get: function get() {
          return _index.throwStatement;
        }
      });
      Object.defineProperty(exports, "TopicReference", {
        enumerable: true,
        get: function get() {
          return _index.topicReference;
        }
      });
      Object.defineProperty(exports, "TryStatement", {
        enumerable: true,
        get: function get() {
          return _index.tryStatement;
        }
      });
      Object.defineProperty(exports, "TupleExpression", {
        enumerable: true,
        get: function get() {
          return _index.tupleExpression;
        }
      });
      Object.defineProperty(exports, "TupleTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.tupleTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "TypeAlias", {
        enumerable: true,
        get: function get() {
          return _index.typeAlias;
        }
      });
      Object.defineProperty(exports, "TypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.typeAnnotation;
        }
      });
      Object.defineProperty(exports, "TypeCastExpression", {
        enumerable: true,
        get: function get() {
          return _index.typeCastExpression;
        }
      });
      Object.defineProperty(exports, "TypeParameter", {
        enumerable: true,
        get: function get() {
          return _index.typeParameter;
        }
      });
      Object.defineProperty(exports, "TypeParameterDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.typeParameterDeclaration;
        }
      });
      Object.defineProperty(exports, "TypeParameterInstantiation", {
        enumerable: true,
        get: function get() {
          return _index.typeParameterInstantiation;
        }
      });
      Object.defineProperty(exports, "TypeofTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.typeofTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "UnaryExpression", {
        enumerable: true,
        get: function get() {
          return _index.unaryExpression;
        }
      });
      Object.defineProperty(exports, "UnionTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.unionTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "UpdateExpression", {
        enumerable: true,
        get: function get() {
          return _index.updateExpression;
        }
      });
      Object.defineProperty(exports, "V8IntrinsicIdentifier", {
        enumerable: true,
        get: function get() {
          return _index.v8IntrinsicIdentifier;
        }
      });
      Object.defineProperty(exports, "VariableDeclaration", {
        enumerable: true,
        get: function get() {
          return _index.variableDeclaration;
        }
      });
      Object.defineProperty(exports, "VariableDeclarator", {
        enumerable: true,
        get: function get() {
          return _index.variableDeclarator;
        }
      });
      Object.defineProperty(exports, "Variance", {
        enumerable: true,
        get: function get() {
          return _index.variance;
        }
      });
      Object.defineProperty(exports, "VoidTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _index.voidTypeAnnotation;
        }
      });
      Object.defineProperty(exports, "WhileStatement", {
        enumerable: true,
        get: function get() {
          return _index.whileStatement;
        }
      });
      Object.defineProperty(exports, "WithStatement", {
        enumerable: true,
        get: function get() {
          return _index.withStatement;
        }
      });
      Object.defineProperty(exports, "YieldExpression", {
        enumerable: true,
        get: function get() {
          return _index.yieldExpression;
        }
      });
      var _index = generated$2;
    })(uppercase);
    var productions = {};
    Object.defineProperty(productions, "__esModule", { value: true });
    productions.buildUndefinedNode = buildUndefinedNode;
    var _index$o = generated$2;
    function buildUndefinedNode() {
      return (0, _index$o.unaryExpression)(
        "void",
        (0, _index$o.numericLiteral)(0),
        true
      );
    }
    var cloneNode$1 = {};
    Object.defineProperty(cloneNode$1, "__esModule", { value: true });
    cloneNode$1["default"] = cloneNode;
    var _index$n = requireDefinitions();
    var _index2$6 = generated$3;
    var _hasOwn = {
        hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
      },
      hasOwn = _hasOwn.hasOwn;
    function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
      if (obj && typeof obj.type === "string") {
        return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
      }
      return obj;
    }
    function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
      if (Array.isArray(obj)) {
        return obj.map(function (node) {
          return cloneIfNode(node, deep, withoutLoc, commentsCache);
        });
      }
      return cloneIfNode(obj, deep, withoutLoc, commentsCache);
    }
    function cloneNode(node) {
      var deep =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : true;
      var withoutLoc =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : false;
      return cloneNodeInternal(node, deep, withoutLoc, new Map());
    }
    function cloneNodeInternal(node) {
      var deep =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : true;
      var withoutLoc =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : false;
      var commentsCache = arguments.length > 3 ? arguments[3] : undefined;
      if (!node) return node;
      var type = node.type;
      var newNode = { type: node.type };
      if ((0, _index2$6.isIdentifier)(node)) {
        newNode.name = node.name;
        if (hasOwn(node, "optional") && typeof node.optional === "boolean") {
          newNode.optional = node.optional;
        }
        if (hasOwn(node, "typeAnnotation")) {
          newNode.typeAnnotation = deep
            ? cloneIfNodeOrArray(
                node.typeAnnotation,
                true,
                withoutLoc,
                commentsCache
              )
            : node.typeAnnotation;
        }
        if (hasOwn(node, "decorators")) {
          newNode.decorators = deep
            ? cloneIfNodeOrArray(
                node.decorators,
                true,
                withoutLoc,
                commentsCache
              )
            : node.decorators;
        }
      } else if (!hasOwn(_index$n.NODE_FIELDS, type)) {
        throw new Error('Unknown node type: "'.concat(type, '"'));
      } else {
        for (
          var _i10 = 0, _Object$keys5 = Object.keys(_index$n.NODE_FIELDS[type]);
          _i10 < _Object$keys5.length;
          _i10++
        ) {
          var field = _Object$keys5[_i10];
          if (hasOwn(node, field)) {
            if (deep) {
              newNode[field] =
                (0, _index2$6.isFile)(node) && field === "comments"
                  ? maybeCloneComments(
                      node.comments,
                      deep,
                      withoutLoc,
                      commentsCache
                    )
                  : cloneIfNodeOrArray(
                      node[field],
                      true,
                      withoutLoc,
                      commentsCache
                    );
            } else {
              newNode[field] = node[field];
            }
          }
        }
      }
      if (hasOwn(node, "loc")) {
        if (withoutLoc) {
          newNode.loc = null;
        } else {
          newNode.loc = node.loc;
        }
      }
      if (hasOwn(node, "leadingComments")) {
        newNode.leadingComments = maybeCloneComments(
          node.leadingComments,
          deep,
          withoutLoc,
          commentsCache
        );
      }
      if (hasOwn(node, "innerComments")) {
        newNode.innerComments = maybeCloneComments(
          node.innerComments,
          deep,
          withoutLoc,
          commentsCache
        );
      }
      if (hasOwn(node, "trailingComments")) {
        newNode.trailingComments = maybeCloneComments(
          node.trailingComments,
          deep,
          withoutLoc,
          commentsCache
        );
      }
      if (hasOwn(node, "extra")) {
        newNode.extra = Object.assign({}, node.extra);
      }
      return newNode;
    }
    function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
      if (!comments || !deep) {
        return comments;
      }
      return comments.map(function (comment) {
        var cache = commentsCache.get(comment);
        if (cache) return cache;
        var type = comment.type,
          value = comment.value,
          loc = comment.loc;
        var ret = { type: type, value: value, loc: loc };
        if (withoutLoc) {
          ret.loc = null;
        }
        commentsCache.set(comment, ret);
        return ret;
      });
    }
    var clone$1 = {};
    Object.defineProperty(clone$1, "__esModule", { value: true });
    clone$1["default"] = clone;
    var _cloneNode$5 = cloneNode$1;
    function clone(node) {
      return (0, _cloneNode$5["default"])(node, false);
    }
    var cloneDeep$1 = {};
    Object.defineProperty(cloneDeep$1, "__esModule", { value: true });
    cloneDeep$1["default"] = cloneDeep;
    var _cloneNode$4 = cloneNode$1;
    function cloneDeep(node) {
      return (0, _cloneNode$4["default"])(node);
    }
    var cloneDeepWithoutLoc$1 = {};
    Object.defineProperty(cloneDeepWithoutLoc$1, "__esModule", { value: true });
    cloneDeepWithoutLoc$1["default"] = cloneDeepWithoutLoc;
    var _cloneNode$3 = cloneNode$1;
    function cloneDeepWithoutLoc(node) {
      return (0, _cloneNode$3["default"])(node, true, true);
    }
    var cloneWithoutLoc$1 = {};
    Object.defineProperty(cloneWithoutLoc$1, "__esModule", { value: true });
    cloneWithoutLoc$1["default"] = cloneWithoutLoc;
    var _cloneNode$2 = cloneNode$1;
    function cloneWithoutLoc(node) {
      return (0, _cloneNode$2["default"])(node, false, true);
    }
    var addComment$1 = {};
    var addComments$1 = {};
    Object.defineProperty(addComments$1, "__esModule", { value: true });
    addComments$1["default"] = addComments;
    function addComments(node, type, comments) {
      if (!comments || !node) return node;
      var key = "".concat(type, "Comments");
      if (node[key]) {
        if (type === "leading") {
          node[key] = comments.concat(node[key]);
        } else {
          var _node$key;
          (_node$key = node[key]).push.apply(
            _node$key,
            _toConsumableArray(comments)
          );
        }
      } else {
        node[key] = comments;
      }
      return node;
    }
    Object.defineProperty(addComment$1, "__esModule", { value: true });
    addComment$1["default"] = addComment;
    var _addComments = addComments$1;
    function addComment(node, type, content, line) {
      return (0, _addComments["default"])(node, type, [
        { type: line ? "CommentLine" : "CommentBlock", value: content }
      ]);
    }
    var inheritInnerComments$1 = {};
    var inherit$1 = {};
    Object.defineProperty(inherit$1, "__esModule", { value: true });
    inherit$1["default"] = inherit;
    function inherit(key, child, parent) {
      if (child && parent) {
        child[key] = Array.from(
          new Set([].concat(child[key], parent[key]).filter(Boolean))
        );
      }
    }
    Object.defineProperty(inheritInnerComments$1, "__esModule", {
      value: true
    });
    inheritInnerComments$1["default"] = inheritInnerComments;
    var _inherit$2 = inherit$1;
    function inheritInnerComments(child, parent) {
      (0, _inherit$2["default"])("innerComments", child, parent);
    }
    var inheritLeadingComments$1 = {};
    Object.defineProperty(inheritLeadingComments$1, "__esModule", {
      value: true
    });
    inheritLeadingComments$1["default"] = inheritLeadingComments;
    var _inherit$1 = inherit$1;
    function inheritLeadingComments(child, parent) {
      (0, _inherit$1["default"])("leadingComments", child, parent);
    }
    var inheritsComments$1 = {};
    var inheritTrailingComments$1 = {};
    Object.defineProperty(inheritTrailingComments$1, "__esModule", {
      value: true
    });
    inheritTrailingComments$1["default"] = inheritTrailingComments;
    var _inherit = inherit$1;
    function inheritTrailingComments(child, parent) {
      (0, _inherit["default"])("trailingComments", child, parent);
    }
    Object.defineProperty(inheritsComments$1, "__esModule", { value: true });
    inheritsComments$1["default"] = inheritsComments;
    var _inheritTrailingComments = inheritTrailingComments$1;
    var _inheritLeadingComments = inheritLeadingComments$1;
    var _inheritInnerComments = inheritInnerComments$1;
    function inheritsComments(child, parent) {
      (0, _inheritTrailingComments["default"])(child, parent);
      (0, _inheritLeadingComments["default"])(child, parent);
      (0, _inheritInnerComments["default"])(child, parent);
      return child;
    }
    var removeComments$1 = {};
    Object.defineProperty(removeComments$1, "__esModule", { value: true });
    removeComments$1["default"] = removeComments;
    var _index$m = constants;
    function removeComments(node) {
      _index$m.COMMENT_KEYS.forEach(function (key) {
        node[key] = null;
      });
      return node;
    }
    var generated = {};
    Object.defineProperty(generated, "__esModule", { value: true });
    generated.WHILE_TYPES =
      generated.USERWHITESPACABLE_TYPES =
      generated.UNARYLIKE_TYPES =
      generated.TYPESCRIPT_TYPES =
      generated.TSTYPE_TYPES =
      generated.TSTYPEELEMENT_TYPES =
      generated.TSENTITYNAME_TYPES =
      generated.TSBASETYPE_TYPES =
      generated.TERMINATORLESS_TYPES =
      generated.STATEMENT_TYPES =
      generated.STANDARDIZED_TYPES =
      generated.SCOPABLE_TYPES =
      generated.PUREISH_TYPES =
      generated.PROPERTY_TYPES =
      generated.PRIVATE_TYPES =
      generated.PATTERN_TYPES =
      generated.PATTERNLIKE_TYPES =
      generated.OBJECTMEMBER_TYPES =
      generated.MODULESPECIFIER_TYPES =
      generated.MODULEDECLARATION_TYPES =
      generated.MISCELLANEOUS_TYPES =
      generated.METHOD_TYPES =
      generated.LVAL_TYPES =
      generated.LOOP_TYPES =
      generated.LITERAL_TYPES =
      generated.JSX_TYPES =
      generated.IMPORTOREXPORTDECLARATION_TYPES =
      generated.IMMUTABLE_TYPES =
      generated.FUNCTION_TYPES =
      generated.FUNCTIONPARENT_TYPES =
      generated.FOR_TYPES =
      generated.FORXSTATEMENT_TYPES =
      generated.FLOW_TYPES =
      generated.FLOWTYPE_TYPES =
      generated.FLOWPREDICATE_TYPES =
      generated.FLOWDECLARATION_TYPES =
      generated.FLOWBASEANNOTATION_TYPES =
      generated.EXPRESSION_TYPES =
      generated.EXPRESSIONWRAPPER_TYPES =
      generated.EXPORTDECLARATION_TYPES =
      generated.ENUMMEMBER_TYPES =
      generated.ENUMBODY_TYPES =
      generated.DECLARATION_TYPES =
      generated.CONDITIONAL_TYPES =
      generated.COMPLETIONSTATEMENT_TYPES =
      generated.CLASS_TYPES =
      generated.BLOCK_TYPES =
      generated.BLOCKPARENT_TYPES =
      generated.BINARY_TYPES =
      generated.ACCESSOR_TYPES =
        void 0;
    var _index$l = requireDefinitions();
    generated.STANDARDIZED_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Standardized"];
    generated.EXPRESSION_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Expression"];
    generated.BINARY_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Binary"];
    generated.SCOPABLE_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Scopable"];
    generated.BLOCKPARENT_TYPES = _index$l.FLIPPED_ALIAS_KEYS["BlockParent"];
    generated.BLOCK_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Block"];
    generated.STATEMENT_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Statement"];
    generated.TERMINATORLESS_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["Terminatorless"];
    generated.COMPLETIONSTATEMENT_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["CompletionStatement"];
    generated.CONDITIONAL_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Conditional"];
    generated.LOOP_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Loop"];
    generated.WHILE_TYPES = _index$l.FLIPPED_ALIAS_KEYS["While"];
    generated.EXPRESSIONWRAPPER_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
    generated.FOR_TYPES = _index$l.FLIPPED_ALIAS_KEYS["For"];
    generated.FORXSTATEMENT_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["ForXStatement"];
    generated.FUNCTION_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Function"];
    generated.FUNCTIONPARENT_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["FunctionParent"];
    generated.PUREISH_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Pureish"];
    generated.DECLARATION_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Declaration"];
    generated.PATTERNLIKE_TYPES = _index$l.FLIPPED_ALIAS_KEYS["PatternLike"];
    generated.LVAL_TYPES = _index$l.FLIPPED_ALIAS_KEYS["LVal"];
    generated.TSENTITYNAME_TYPES = _index$l.FLIPPED_ALIAS_KEYS["TSEntityName"];
    generated.LITERAL_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Literal"];
    generated.IMMUTABLE_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Immutable"];
    generated.USERWHITESPACABLE_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
    generated.METHOD_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Method"];
    generated.OBJECTMEMBER_TYPES = _index$l.FLIPPED_ALIAS_KEYS["ObjectMember"];
    generated.PROPERTY_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Property"];
    generated.UNARYLIKE_TYPES = _index$l.FLIPPED_ALIAS_KEYS["UnaryLike"];
    generated.PATTERN_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Pattern"];
    generated.CLASS_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Class"];
    var IMPORTOREXPORTDECLARATION_TYPES =
      (generated.IMPORTOREXPORTDECLARATION_TYPES =
        _index$l.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"]);
    generated.EXPORTDECLARATION_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
    generated.MODULESPECIFIER_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
    generated.ACCESSOR_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Accessor"];
    generated.PRIVATE_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Private"];
    generated.FLOW_TYPES = _index$l.FLIPPED_ALIAS_KEYS["Flow"];
    generated.FLOWTYPE_TYPES = _index$l.FLIPPED_ALIAS_KEYS["FlowType"];
    generated.FLOWBASEANNOTATION_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
    generated.FLOWDECLARATION_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
    generated.FLOWPREDICATE_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["FlowPredicate"];
    generated.ENUMBODY_TYPES = _index$l.FLIPPED_ALIAS_KEYS["EnumBody"];
    generated.ENUMMEMBER_TYPES = _index$l.FLIPPED_ALIAS_KEYS["EnumMember"];
    generated.JSX_TYPES = _index$l.FLIPPED_ALIAS_KEYS["JSX"];
    generated.MISCELLANEOUS_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["Miscellaneous"];
    generated.TYPESCRIPT_TYPES = _index$l.FLIPPED_ALIAS_KEYS["TypeScript"];
    generated.TSTYPEELEMENT_TYPES =
      _index$l.FLIPPED_ALIAS_KEYS["TSTypeElement"];
    generated.TSTYPE_TYPES = _index$l.FLIPPED_ALIAS_KEYS["TSType"];
    generated.TSBASETYPE_TYPES = _index$l.FLIPPED_ALIAS_KEYS["TSBaseType"];
    generated.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
    var ensureBlock$1 = {};
    var toBlock$1 = {};
    Object.defineProperty(toBlock$1, "__esModule", { value: true });
    toBlock$1["default"] = toBlock;
    var _index$k = generated$3;
    var _index2$5 = generated$2;
    function toBlock(node, parent) {
      if ((0, _index$k.isBlockStatement)(node)) {
        return node;
      }
      var blockNodes = [];
      if ((0, _index$k.isEmptyStatement)(node)) {
        blockNodes = [];
      } else {
        if (!(0, _index$k.isStatement)(node)) {
          if ((0, _index$k.isFunction)(parent)) {
            node = (0, _index2$5.returnStatement)(node);
          } else {
            node = (0, _index2$5.expressionStatement)(node);
          }
        }
        blockNodes = [node];
      }
      return (0, _index2$5.blockStatement)(blockNodes);
    }
    Object.defineProperty(ensureBlock$1, "__esModule", { value: true });
    ensureBlock$1["default"] = ensureBlock;
    var _toBlock = toBlock$1;
    function ensureBlock(node) {
      var key =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : "body";
      var result = (0, _toBlock["default"])(node[key], node);
      node[key] = result;
      return result;
    }
    var toBindingIdentifierName$1 = {};
    var toIdentifier$1 = {};
    Object.defineProperty(toIdentifier$1, "__esModule", { value: true });
    toIdentifier$1["default"] = toIdentifier;
    var _isValidIdentifier$2 = isValidIdentifier$1;
    var _helperValidatorIdentifier = lib$2;
    function toIdentifier(input) {
      input = input + "";
      var name = "";
      var _iterator27 = _createForOfIteratorHelper(input),
        _step27;
      try {
        for (_iterator27.s(); !(_step27 = _iterator27.n()).done; ) {
          var c = _step27.value;
          name += (0, _helperValidatorIdentifier.isIdentifierChar)(
            c.codePointAt(0)
          )
            ? c
            : "-";
        }
      } catch (err) {
        _iterator27.e(err);
      } finally {
        _iterator27.f();
      }
      name = name.replace(/^[-0-9]+/, "");
      name = name.replace(/[-\s]+(.)?/g, function (match, c) {
        return c ? c.toUpperCase() : "";
      });
      if (!(0, _isValidIdentifier$2["default"])(name)) {
        name = "_".concat(name);
      }
      return name || "_";
    }
    Object.defineProperty(toBindingIdentifierName$1, "__esModule", {
      value: true
    });
    toBindingIdentifierName$1["default"] = toBindingIdentifierName;
    var _toIdentifier = toIdentifier$1;
    function toBindingIdentifierName(name) {
      name = (0, _toIdentifier["default"])(name);
      if (name === "eval" || name === "arguments") name = "_" + name;
      return name;
    }
    var toComputedKey$1 = {};
    Object.defineProperty(toComputedKey$1, "__esModule", { value: true });
    toComputedKey$1["default"] = toComputedKey;
    var _index$j = generated$3;
    var _index2$4 = generated$2;
    function toComputedKey(node) {
      var key =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : node.key || node.property;
      if (!node.computed && (0, _index$j.isIdentifier)(key))
        key = (0, _index2$4.stringLiteral)(key.name);
      return key;
    }
    var toExpression$1 = {};
    Object.defineProperty(toExpression$1, "__esModule", { value: true });
    toExpression$1["default"] = void 0;
    var _index$i = generated$3;
    toExpression$1["default"] = toExpression;
    function toExpression(node) {
      if ((0, _index$i.isExpressionStatement)(node)) {
        node = node.expression;
      }
      if ((0, _index$i.isExpression)(node)) {
        return node;
      }
      if ((0, _index$i.isClass)(node)) {
        node.type = "ClassExpression";
      } else if ((0, _index$i.isFunction)(node)) {
        node.type = "FunctionExpression";
      }
      if (!(0, _index$i.isExpression)(node)) {
        throw new Error("cannot turn ".concat(node.type, " to an expression"));
      }
      return node;
    }
    var toKeyAlias$1 = {};
    var removePropertiesDeep$1 = {};
    var traverseFast$1 = {};
    Object.defineProperty(traverseFast$1, "__esModule", { value: true });
    traverseFast$1["default"] = traverseFast;
    var _index$h = requireDefinitions();
    function traverseFast(node, enter, opts) {
      if (!node) return;
      var keys = _index$h.VISITOR_KEYS[node.type];
      if (!keys) return;
      opts = opts || {};
      enter(node, opts);
      var _iterator28 = _createForOfIteratorHelper(keys),
        _step28;
      try {
        for (_iterator28.s(); !(_step28 = _iterator28.n()).done; ) {
          var _key13 = _step28.value;
          var subNode = node[_key13];
          if (Array.isArray(subNode)) {
            var _iterator29 = _createForOfIteratorHelper(subNode),
              _step29;
            try {
              for (_iterator29.s(); !(_step29 = _iterator29.n()).done; ) {
                var _node4 = _step29.value;
                traverseFast(_node4, enter, opts);
              }
            } catch (err) {
              _iterator29.e(err);
            } finally {
              _iterator29.f();
            }
          } else {
            traverseFast(subNode, enter, opts);
          }
        }
      } catch (err) {
        _iterator28.e(err);
      } finally {
        _iterator28.f();
      }
    }
    var removeProperties$1 = {};
    Object.defineProperty(removeProperties$1, "__esModule", { value: true });
    removeProperties$1["default"] = removeProperties;
    var _index$g = constants;
    var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
    var CLEAR_KEYS_PLUS_COMMENTS = [].concat(
      _toConsumableArray(_index$g.COMMENT_KEYS),
      ["comments"],
      CLEAR_KEYS
    );
    function removeProperties(node) {
      var opts =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      var _iterator30 = _createForOfIteratorHelper(map),
        _step30;
      try {
        for (_iterator30.s(); !(_step30 = _iterator30.n()).done; ) {
          var _key15 = _step30.value;
          if (node[_key15] != null) node[_key15] = undefined;
        }
      } catch (err) {
        _iterator30.e(err);
      } finally {
        _iterator30.f();
      }
      for (
        var _i11 = 0, _Object$keys6 = Object.keys(node);
        _i11 < _Object$keys6.length;
        _i11++
      ) {
        var _key14 = _Object$keys6[_i11];
        if (_key14[0] === "_" && node[_key14] != null) node[_key14] = undefined;
      }
      var symbols = Object.getOwnPropertySymbols(node);
      var _iterator31 = _createForOfIteratorHelper(symbols),
        _step31;
      try {
        for (_iterator31.s(); !(_step31 = _iterator31.n()).done; ) {
          var sym = _step31.value;
          node[sym] = null;
        }
      } catch (err) {
        _iterator31.e(err);
      } finally {
        _iterator31.f();
      }
    }
    Object.defineProperty(removePropertiesDeep$1, "__esModule", {
      value: true
    });
    removePropertiesDeep$1["default"] = removePropertiesDeep;
    var _traverseFast = traverseFast$1;
    var _removeProperties = removeProperties$1;
    function removePropertiesDeep(tree, opts) {
      (0, _traverseFast["default"])(tree, _removeProperties["default"], opts);
      return tree;
    }
    Object.defineProperty(toKeyAlias$1, "__esModule", { value: true });
    toKeyAlias$1["default"] = toKeyAlias;
    var _index$f = generated$3;
    var _cloneNode$1 = cloneNode$1;
    var _removePropertiesDeep = removePropertiesDeep$1;
    function toKeyAlias(node) {
      var key =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : node.key;
      var alias;
      if (node.kind === "method") {
        return toKeyAlias.increment() + "";
      } else if ((0, _index$f.isIdentifier)(key)) {
        alias = key.name;
      } else if ((0, _index$f.isStringLiteral)(key)) {
        alias = JSON.stringify(key.value);
      } else {
        alias = JSON.stringify(
          (0, _removePropertiesDeep["default"])(
            (0, _cloneNode$1["default"])(key)
          )
        );
      }
      if (node.computed) {
        alias = "[".concat(alias, "]");
      }
      if (node["static"]) {
        alias = "static:".concat(alias);
      }
      return alias;
    }
    toKeyAlias.uid = 0;
    toKeyAlias.increment = function () {
      if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return (toKeyAlias.uid = 0);
      } else {
        return toKeyAlias.uid++;
      }
    };
    var toStatement$1 = {};
    Object.defineProperty(toStatement$1, "__esModule", { value: true });
    toStatement$1["default"] = void 0;
    var _index$e = generated$3;
    var _index2$3 = generated$2;
    toStatement$1["default"] = toStatement;
    function toStatement(node, ignore) {
      if ((0, _index$e.isStatement)(node)) {
        return node;
      }
      var mustHaveId = false;
      var newType;
      if ((0, _index$e.isClass)(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
      } else if ((0, _index$e.isFunction)(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
      } else if ((0, _index$e.isAssignmentExpression)(node)) {
        return (0, _index2$3.expressionStatement)(node);
      }
      if (mustHaveId && !node.id) {
        newType = false;
      }
      if (!newType) {
        if (ignore) {
          return false;
        } else {
          throw new Error("cannot turn ".concat(node.type, " to a statement"));
        }
      }
      node.type = newType;
      return node;
    }
    var valueToNode$1 = {};
    Object.defineProperty(valueToNode$1, "__esModule", { value: true });
    valueToNode$1["default"] = void 0;
    var _isValidIdentifier$1 = isValidIdentifier$1;
    var _index$d = generated$2;
    valueToNode$1["default"] = valueToNode;
    var objectToString = Function.call.bind(Object.prototype.toString);
    function isRegExp(value) {
      return objectToString(value) === "[object RegExp]";
    }
    function isPlainObject(value) {
      if (
        _typeof(value) !== "object" ||
        value === null ||
        Object.prototype.toString.call(value) !== "[object Object]"
      ) {
        return false;
      }
      var proto = Object.getPrototypeOf(value);
      return proto === null || Object.getPrototypeOf(proto) === null;
    }
    function valueToNode(value) {
      if (value === undefined) {
        return (0, _index$d.identifier)("undefined");
      }
      if (value === true || value === false) {
        return (0, _index$d.booleanLiteral)(value);
      }
      if (value === null) {
        return (0, _index$d.nullLiteral)();
      }
      if (typeof value === "string") {
        return (0, _index$d.stringLiteral)(value);
      }
      if (typeof value === "number") {
        var result;
        if (Number.isFinite(value)) {
          result = (0, _index$d.numericLiteral)(Math.abs(value));
        } else {
          var numerator;
          if (Number.isNaN(value)) {
            numerator = (0, _index$d.numericLiteral)(0);
          } else {
            numerator = (0, _index$d.numericLiteral)(1);
          }
          result = (0, _index$d.binaryExpression)(
            "/",
            numerator,
            (0, _index$d.numericLiteral)(0)
          );
        }
        if (value < 0 || Object.is(value, -0)) {
          result = (0, _index$d.unaryExpression)("-", result);
        }
        return result;
      }
      if (isRegExp(value)) {
        var pattern = value.source;
        var flags = /\/([a-z]*)$/.exec(value.toString())[1];
        return (0, _index$d.regExpLiteral)(pattern, flags);
      }
      if (Array.isArray(value)) {
        return (0, _index$d.arrayExpression)(value.map(valueToNode));
      }
      if (isPlainObject(value)) {
        var props = [];
        for (
          var _i12 = 0, _Object$keys7 = Object.keys(value);
          _i12 < _Object$keys7.length;
          _i12++
        ) {
          var _key16 = _Object$keys7[_i12];
          var nodeKey = void 0;
          if ((0, _isValidIdentifier$1["default"])(_key16)) {
            nodeKey = (0, _index$d.identifier)(_key16);
          } else {
            nodeKey = (0, _index$d.stringLiteral)(_key16);
          }
          props.push(
            (0, _index$d.objectProperty)(nodeKey, valueToNode(value[_key16]))
          );
        }
        return (0, _index$d.objectExpression)(props);
      }
      throw new Error("don't know how to turn this value into a node");
    }
    var appendToMemberExpression$1 = {};
    Object.defineProperty(appendToMemberExpression$1, "__esModule", {
      value: true
    });
    appendToMemberExpression$1["default"] = appendToMemberExpression;
    var _index$c = generated$2;
    function appendToMemberExpression(member, append) {
      var computed =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : false;
      member.object = (0, _index$c.memberExpression)(
        member.object,
        member.property,
        member.computed
      );
      member.property = append;
      member.computed = !!computed;
      return member;
    }
    var inherits$1 = {};
    Object.defineProperty(inherits$1, "__esModule", { value: true });
    inherits$1["default"] = inherits;
    var _index$b = constants;
    var _inheritsComments = inheritsComments$1;
    function inherits(child, parent) {
      if (!child || !parent) return child;
      var _iterator32 = _createForOfIteratorHelper(
          _index$b.INHERIT_KEYS.optional
        ),
        _step32;
      try {
        for (_iterator32.s(); !(_step32 = _iterator32.n()).done; ) {
          var _key18 = _step32.value;
          if (child[_key18] == null) {
            child[_key18] = parent[_key18];
          }
        }
      } catch (err) {
        _iterator32.e(err);
      } finally {
        _iterator32.f();
      }
      for (
        var _i13 = 0, _Object$keys8 = Object.keys(parent);
        _i13 < _Object$keys8.length;
        _i13++
      ) {
        var _key17 = _Object$keys8[_i13];
        if (_key17[0] === "_" && _key17 !== "__clone") {
          child[_key17] = parent[_key17];
        }
      }
      var _iterator33 = _createForOfIteratorHelper(_index$b.INHERIT_KEYS.force),
        _step33;
      try {
        for (_iterator33.s(); !(_step33 = _iterator33.n()).done; ) {
          var _key19 = _step33.value;
          child[_key19] = parent[_key19];
        }
      } catch (err) {
        _iterator33.e(err);
      } finally {
        _iterator33.f();
      }
      (0, _inheritsComments["default"])(child, parent);
      return child;
    }
    var prependToMemberExpression = {};
    var hasRequiredPrependToMemberExpression;
    function requirePrependToMemberExpression() {
      if (hasRequiredPrependToMemberExpression)
        return prependToMemberExpression;
      hasRequiredPrependToMemberExpression = 1;
      Object.defineProperty(prependToMemberExpression, "__esModule", {
        value: true
      });
      prependToMemberExpression["default"] = prependToMemberExpression$1;
      var _index = generated$2;
      var _index2 = requireLib();
      function prependToMemberExpression$1(member, prepend) {
        if ((0, _index2.isSuper)(member.object)) {
          throw new Error(
            "Cannot prepend node to super property access (`super.foo`)."
          );
        }
        member.object = (0, _index.memberExpression)(prepend, member.object);
        return member;
      }
      return prependToMemberExpression;
    }
    var getAssignmentIdentifiers$1 = {};
    Object.defineProperty(getAssignmentIdentifiers$1, "__esModule", {
      value: true
    });
    getAssignmentIdentifiers$1["default"] = getAssignmentIdentifiers;
    function getAssignmentIdentifiers(node) {
      var search = [].concat(node);
      var ids = Object.create(null);
      while (search.length) {
        var id = search.pop();
        if (!id) continue;
        switch (id.type) {
          case "ArrayPattern":
            search.push.apply(search, _toConsumableArray(id.elements));
            break;
          case "AssignmentExpression":
          case "AssignmentPattern":
          case "ForInStatement":
          case "ForOfStatement":
            search.push(id.left);
            break;
          case "ObjectPattern":
            search.push.apply(search, _toConsumableArray(id.properties));
            break;
          case "ObjectProperty":
            search.push(id.value);
            break;
          case "RestElement":
          case "UpdateExpression":
            search.push(id.argument);
            break;
          case "UnaryExpression":
            if (id.operator === "delete") {
              search.push(id.argument);
            }
            break;
          case "Identifier":
            ids[id.name] = id;
            break;
        }
      }
      return ids;
    }
    var getBindingIdentifiers$1 = {};
    Object.defineProperty(getBindingIdentifiers$1, "__esModule", {
      value: true
    });
    getBindingIdentifiers$1["default"] = getBindingIdentifiers;
    var _index$a = generated$3;
    function getBindingIdentifiers(
      node,
      duplicates,
      outerOnly,
      newBindingsOnly
    ) {
      var search = [].concat(node);
      var ids = Object.create(null);
      while (search.length) {
        var id = search.shift();
        if (!id) continue;
        if (
          newBindingsOnly &&
          ((0, _index$a.isAssignmentExpression)(id) ||
            (0, _index$a.isUnaryExpression)(id) ||
            (0, _index$a.isUpdateExpression)(id))
        ) {
          continue;
        }
        if ((0, _index$a.isIdentifier)(id)) {
          if (duplicates) {
            var _ids = (ids[id.name] = ids[id.name] || []);
            _ids.push(id);
          } else {
            ids[id.name] = id;
          }
          continue;
        }
        if (
          (0, _index$a.isExportDeclaration)(id) &&
          !(0, _index$a.isExportAllDeclaration)(id)
        ) {
          if ((0, _index$a.isDeclaration)(id.declaration)) {
            search.push(id.declaration);
          }
          continue;
        }
        if (outerOnly) {
          if ((0, _index$a.isFunctionDeclaration)(id)) {
            search.push(id.id);
            continue;
          }
          if ((0, _index$a.isFunctionExpression)(id)) {
            continue;
          }
        }
        var _keys3 = getBindingIdentifiers.keys[id.type];
        if (_keys3) {
          for (var i = 0; i < _keys3.length; i++) {
            var _key20 = _keys3[i];
            var _nodes = id[_key20];
            if (_nodes) {
              if (Array.isArray(_nodes)) {
                search.push.apply(search, _toConsumableArray(_nodes));
              } else {
                search.push(_nodes);
              }
            }
          }
        }
      }
      return ids;
    }
    var keys = {
      DeclareClass: ["id"],
      DeclareFunction: ["id"],
      DeclareModule: ["id"],
      DeclareVariable: ["id"],
      DeclareInterface: ["id"],
      DeclareTypeAlias: ["id"],
      DeclareOpaqueType: ["id"],
      InterfaceDeclaration: ["id"],
      TypeAlias: ["id"],
      OpaqueType: ["id"],
      CatchClause: ["param"],
      LabeledStatement: ["label"],
      UnaryExpression: ["argument"],
      AssignmentExpression: ["left"],
      ImportSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportDefaultSpecifier: ["local"],
      ImportDeclaration: ["specifiers"],
      ExportSpecifier: ["exported"],
      ExportNamespaceSpecifier: ["exported"],
      ExportDefaultSpecifier: ["exported"],
      FunctionDeclaration: ["id", "params"],
      FunctionExpression: ["id", "params"],
      ArrowFunctionExpression: ["params"],
      ObjectMethod: ["params"],
      ClassMethod: ["params"],
      ClassPrivateMethod: ["params"],
      ForInStatement: ["left"],
      ForOfStatement: ["left"],
      ClassDeclaration: ["id"],
      ClassExpression: ["id"],
      RestElement: ["argument"],
      UpdateExpression: ["argument"],
      ObjectProperty: ["value"],
      AssignmentPattern: ["left"],
      ArrayPattern: ["elements"],
      ObjectPattern: ["properties"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id"]
    };
    getBindingIdentifiers.keys = keys;
    var getOuterBindingIdentifiers$1 = {};
    Object.defineProperty(getOuterBindingIdentifiers$1, "__esModule", {
      value: true
    });
    getOuterBindingIdentifiers$1["default"] = void 0;
    var _getBindingIdentifiers$2 = getBindingIdentifiers$1;
    getOuterBindingIdentifiers$1["default"] = getOuterBindingIdentifiers;
    function getOuterBindingIdentifiers(node, duplicates) {
      return (0, _getBindingIdentifiers$2["default"])(node, duplicates, true);
    }
    var getFunctionName$4 = {};
    Object.defineProperty(getFunctionName$4, "__esModule", { value: true });
    getFunctionName$4["default"] = getFunctionName$3;
    var _index$9 = generated$3;
    function getNameFromLiteralId(id) {
      if ((0, _index$9.isNullLiteral)(id)) {
        return "null";
      }
      if ((0, _index$9.isRegExpLiteral)(id)) {
        return "/".concat(id.pattern, "/").concat(id.flags);
      }
      if ((0, _index$9.isTemplateLiteral)(id)) {
        return id.quasis
          .map(function (quasi) {
            return quasi.value.raw;
          })
          .join("");
      }
      if (id.value !== undefined) {
        return String(id.value);
      }
      return null;
    }
    function getObjectMemberKey(node) {
      if (!node.computed || (0, _index$9.isLiteral)(node.key)) {
        return node.key;
      }
    }
    function getFunctionName$3(node, parent) {
      if ("id" in node && node.id) {
        return { name: node.id.name, originalNode: node.id };
      }
      var prefix = "";
      var id;
      if ((0, _index$9.isObjectProperty)(parent, { value: node })) {
        id = getObjectMemberKey(parent);
      } else if (
        (0, _index$9.isObjectMethod)(node) ||
        (0, _index$9.isClassMethod)(node)
      ) {
        id = getObjectMemberKey(node);
        if (node.kind === "get") prefix = "get ";
        else if (node.kind === "set") prefix = "set ";
      } else if ((0, _index$9.isVariableDeclarator)(parent, { init: node })) {
        id = parent.id;
      } else if (
        (0, _index$9.isAssignmentExpression)(parent, {
          operator: "=",
          right: node
        })
      ) {
        id = parent.left;
      }
      if (!id) return null;
      var name = (0, _index$9.isLiteral)(id)
        ? getNameFromLiteralId(id)
        : (0, _index$9.isIdentifier)(id)
          ? id.name
          : (0, _index$9.isPrivateName)(id)
            ? id.id.name
            : null;
      if (name == null) return null;
      return { name: prefix + name, originalNode: id };
    }
    var traverse$1 = {};
    Object.defineProperty(traverse$1, "__esModule", { value: true });
    traverse$1["default"] = traverse;
    var _index$8 = requireDefinitions();
    function traverse(node, handlers, state) {
      if (typeof handlers === "function") {
        handlers = { enter: handlers };
      }
      var _handlers = handlers,
        enter = _handlers.enter,
        exit = _handlers.exit;
      traverseSimpleImpl(node, enter, exit, state, []);
    }
    function traverseSimpleImpl(node, enter, exit, state, ancestors) {
      var keys = _index$8.VISITOR_KEYS[node.type];
      if (!keys) return;
      if (enter) enter(node, ancestors, state);
      var _iterator34 = _createForOfIteratorHelper(keys),
        _step34;
      try {
        for (_iterator34.s(); !(_step34 = _iterator34.n()).done; ) {
          var _key21 = _step34.value;
          var subNode = node[_key21];
          if (Array.isArray(subNode)) {
            for (var i = 0; i < subNode.length; i++) {
              var child = subNode[i];
              if (!child) continue;
              ancestors.push({ node: node, key: _key21, index: i });
              traverseSimpleImpl(child, enter, exit, state, ancestors);
              ancestors.pop();
            }
          } else if (subNode) {
            ancestors.push({ node: node, key: _key21 });
            traverseSimpleImpl(subNode, enter, exit, state, ancestors);
            ancestors.pop();
          }
        }
      } catch (err) {
        _iterator34.e(err);
      } finally {
        _iterator34.f();
      }
      if (exit) exit(node, ancestors, state);
    }
    var isBinding$1 = {};
    Object.defineProperty(isBinding$1, "__esModule", { value: true });
    isBinding$1["default"] = isBinding;
    var _getBindingIdentifiers$1 = getBindingIdentifiers$1;
    function isBinding(node, parent, grandparent) {
      if (
        grandparent &&
        node.type === "Identifier" &&
        parent.type === "ObjectProperty" &&
        grandparent.type === "ObjectExpression"
      ) {
        return false;
      }
      var keys = _getBindingIdentifiers$1["default"].keys[parent.type];
      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var _key22 = keys[i];
          var val = parent[_key22];
          if (Array.isArray(val)) {
            if (val.includes(node)) return true;
          } else {
            if (val === node) return true;
          }
        }
      }
      return false;
    }
    var isBlockScoped$1 = {};
    var isLet$1 = {};
    Object.defineProperty(isLet$1, "__esModule", { value: true });
    isLet$1["default"] = isLet;
    var _index$7 = generated$3;
    var _index2$2 = constants;
    function isLet(node) {
      return (
        (0, _index$7.isVariableDeclaration)(node) &&
        (node.kind !== "var" || node[_index2$2.BLOCK_SCOPED_SYMBOL])
      );
    }
    Object.defineProperty(isBlockScoped$1, "__esModule", { value: true });
    isBlockScoped$1["default"] = isBlockScoped;
    var _index$6 = generated$3;
    var _isLet = isLet$1;
    function isBlockScoped(node) {
      return (
        (0, _index$6.isFunctionDeclaration)(node) ||
        (0, _index$6.isClassDeclaration)(node) ||
        (0, _isLet["default"])(node)
      );
    }
    var isImmutable$1 = {};
    Object.defineProperty(isImmutable$1, "__esModule", { value: true });
    isImmutable$1["default"] = isImmutable;
    var _isType = requireIsType();
    var _index$5 = generated$3;
    function isImmutable(node) {
      if ((0, _isType["default"])(node.type, "Immutable")) return true;
      if ((0, _index$5.isIdentifier)(node)) {
        if (node.name === "undefined") {
          return true;
        } else {
          return false;
        }
      }
      return false;
    }
    var isNodesEquivalent$1 = {};
    Object.defineProperty(isNodesEquivalent$1, "__esModule", { value: true });
    isNodesEquivalent$1["default"] = isNodesEquivalent;
    var _index$4 = requireDefinitions();
    function isNodesEquivalent(a, b) {
      if (
        _typeof(a) !== "object" ||
        _typeof(b) !== "object" ||
        a == null ||
        b == null
      ) {
        return a === b;
      }
      if (a.type !== b.type) {
        return false;
      }
      var fields = Object.keys(_index$4.NODE_FIELDS[a.type] || a.type);
      var visitorKeys = _index$4.VISITOR_KEYS[a.type];
      for (var _i14 = 0, _fields = fields; _i14 < _fields.length; _i14++) {
        var field = _fields[_i14];
        var val_a = a[field];
        var val_b = b[field];
        if (_typeof(val_a) !== _typeof(val_b)) {
          return false;
        }
        if (val_a == null && val_b == null) {
          continue;
        } else if (val_a == null || val_b == null) {
          return false;
        }
        if (Array.isArray(val_a)) {
          if (!Array.isArray(val_b)) {
            return false;
          }
          if (val_a.length !== val_b.length) {
            return false;
          }
          for (var i = 0; i < val_a.length; i++) {
            if (!isNodesEquivalent(val_a[i], val_b[i])) {
              return false;
            }
          }
          continue;
        }
        if (
          _typeof(val_a) === "object" &&
          !(visitorKeys != null && visitorKeys.includes(field))
        ) {
          for (
            var _i15 = 0, _Object$keys9 = Object.keys(val_a);
            _i15 < _Object$keys9.length;
            _i15++
          ) {
            var _key23 = _Object$keys9[_i15];
            if (val_a[_key23] !== val_b[_key23]) {
              return false;
            }
          }
          continue;
        }
        if (!isNodesEquivalent(val_a, val_b)) {
          return false;
        }
      }
      return true;
    }
    var isReferenced$1 = {};
    Object.defineProperty(isReferenced$1, "__esModule", { value: true });
    isReferenced$1["default"] = isReferenced;
    function isReferenced(node, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          if (parent.property === node) {
            return !!parent.computed;
          }
          return parent.object === node;
        case "JSXMemberExpression":
          return parent.object === node;
        case "VariableDeclarator":
          return parent.init === node;
        case "ArrowFunctionExpression":
          return parent.body === node;
        case "PrivateName":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return false;
        case "ObjectProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
        case "ClassAccessorProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
        case "ClassPrivateProperty":
          return parent.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node;
        case "AssignmentExpression":
          return parent.right === node;
        case "AssignmentPattern":
          return parent.right === node;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return false;
        case "RestElement":
          return false;
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "ExportSpecifier":
          if (grandparent != null && grandparent.source) {
            return false;
          }
          return parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "ImportAttribute":
          return false;
        case "JSXAttribute":
          return false;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
        case "MetaProperty":
          return false;
        case "ObjectTypeProperty":
          return parent.key !== node;
        case "TSEnumMember":
          return parent.id !== node;
        case "TSPropertySignature":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
      }
      return true;
    }
    var isScope$1 = {};
    Object.defineProperty(isScope$1, "__esModule", { value: true });
    isScope$1["default"] = isScope;
    var _index$3 = generated$3;
    function isScope(node, parent) {
      if (
        (0, _index$3.isBlockStatement)(node) &&
        ((0, _index$3.isFunction)(parent) ||
          (0, _index$3.isCatchClause)(parent))
      ) {
        return false;
      }
      if (
        (0, _index$3.isPattern)(node) &&
        ((0, _index$3.isFunction)(parent) ||
          (0, _index$3.isCatchClause)(parent))
      ) {
        return true;
      }
      return (0, _index$3.isScopable)(node);
    }
    var isSpecifierDefault$1 = {};
    Object.defineProperty(isSpecifierDefault$1, "__esModule", { value: true });
    isSpecifierDefault$1["default"] = isSpecifierDefault;
    var _index$2 = generated$3;
    function isSpecifierDefault(specifier) {
      return (
        (0, _index$2.isImportDefaultSpecifier)(specifier) ||
        (0, _index$2.isIdentifier)(specifier.imported || specifier.exported, {
          name: "default"
        })
      );
    }
    var isValidES3Identifier$1 = {};
    Object.defineProperty(isValidES3Identifier$1, "__esModule", {
      value: true
    });
    isValidES3Identifier$1["default"] = isValidES3Identifier;
    var _isValidIdentifier = isValidIdentifier$1;
    var RESERVED_WORDS_ES3_ONLY = new Set([
      "abstract",
      "boolean",
      "byte",
      "char",
      "double",
      "enum",
      "final",
      "float",
      "goto",
      "implements",
      "int",
      "interface",
      "long",
      "native",
      "package",
      "private",
      "protected",
      "public",
      "short",
      "static",
      "synchronized",
      "throws",
      "transient",
      "volatile"
    ]);
    function isValidES3Identifier(name) {
      return (
        (0, _isValidIdentifier["default"])(name) &&
        !RESERVED_WORDS_ES3_ONLY.has(name)
      );
    }
    var isVar$1 = {};
    Object.defineProperty(isVar$1, "__esModule", { value: true });
    isVar$1["default"] = isVar;
    var _index$1 = generated$3;
    var _index2$1 = constants;
    function isVar(node) {
      return (
        (0, _index$1.isVariableDeclaration)(node, { kind: "var" }) &&
        !node[_index2$1.BLOCK_SCOPED_SYMBOL]
      );
    }
    var toSequenceExpression$1 = {};
    var gatherSequenceExpressions$1 = {};
    Object.defineProperty(gatherSequenceExpressions$1, "__esModule", {
      value: true
    });
    gatherSequenceExpressions$1["default"] = gatherSequenceExpressions;
    var _getBindingIdentifiers = getBindingIdentifiers$1;
    var _index = generated$3;
    var _index2 = generated$2;
    var _productions = productions;
    var _cloneNode = cloneNode$1;
    function gatherSequenceExpressions(nodes, declars) {
      var exprs = [];
      var ensureLastUndefined = true;
      var _iterator35 = _createForOfIteratorHelper(nodes),
        _step35;
      try {
        for (_iterator35.s(); !(_step35 = _iterator35.n()).done; ) {
          var _node5 = _step35.value;
          if (!(0, _index.isEmptyStatement)(_node5)) {
            ensureLastUndefined = false;
          }
          if ((0, _index.isExpression)(_node5)) {
            exprs.push(_node5);
          } else if ((0, _index.isExpressionStatement)(_node5)) {
            exprs.push(_node5.expression);
          } else if ((0, _index.isVariableDeclaration)(_node5)) {
            if (_node5.kind !== "var") return;
            var _iterator36 = _createForOfIteratorHelper(_node5.declarations),
              _step36;
            try {
              for (_iterator36.s(); !(_step36 = _iterator36.n()).done; ) {
                var declar = _step36.value;
                var bindings = (0, _getBindingIdentifiers["default"])(declar);
                for (
                  var _i16 = 0, _Object$keys10 = Object.keys(bindings);
                  _i16 < _Object$keys10.length;
                  _i16++
                ) {
                  var _key24 = _Object$keys10[_i16];
                  declars.push({
                    kind: _node5.kind,
                    id: (0, _cloneNode["default"])(bindings[_key24])
                  });
                }
                if (declar.init) {
                  exprs.push(
                    (0, _index2.assignmentExpression)(
                      "=",
                      declar.id,
                      declar.init
                    )
                  );
                }
              }
            } catch (err) {
              _iterator36.e(err);
            } finally {
              _iterator36.f();
            }
            ensureLastUndefined = true;
          } else if ((0, _index.isIfStatement)(_node5)) {
            var consequent = _node5.consequent
              ? gatherSequenceExpressions([_node5.consequent], declars)
              : (0, _productions.buildUndefinedNode)();
            var alternate = _node5.alternate
              ? gatherSequenceExpressions([_node5.alternate], declars)
              : (0, _productions.buildUndefinedNode)();
            if (!consequent || !alternate) return;
            exprs.push(
              (0, _index2.conditionalExpression)(
                _node5.test,
                consequent,
                alternate
              )
            );
          } else if ((0, _index.isBlockStatement)(_node5)) {
            var body = gatherSequenceExpressions(_node5.body, declars);
            if (!body) return;
            exprs.push(body);
          } else if ((0, _index.isEmptyStatement)(_node5)) {
            if (nodes.indexOf(_node5) === 0) {
              ensureLastUndefined = true;
            }
          } else {
            return;
          }
        }
      } catch (err) {
        _iterator35.e(err);
      } finally {
        _iterator35.f();
      }
      if (ensureLastUndefined) {
        exprs.push((0, _productions.buildUndefinedNode)());
      }
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return (0, _index2.sequenceExpression)(exprs);
      }
    }
    Object.defineProperty(toSequenceExpression$1, "__esModule", {
      value: true
    });
    toSequenceExpression$1["default"] = toSequenceExpression;
    var _gatherSequenceExpressions = gatherSequenceExpressions$1;
    function toSequenceExpression(nodes, scope) {
      if (!(nodes != null && nodes.length)) return;
      var declars = [];
      var result = (0, _gatherSequenceExpressions["default"])(nodes, declars);
      if (!result) return;
      for (var _i17 = 0, _declars = declars; _i17 < _declars.length; _i17++) {
        var declar = _declars[_i17];
        scope.push(declar);
      }
      return result;
    }
    var hasRequiredLib;
    function requireLib() {
      if (hasRequiredLib) return lib$3;
      hasRequiredLib = 1;
      (function (exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        var _exportNames = {
          react: true,
          assertNode: true,
          createTypeAnnotationBasedOnTypeof: true,
          createUnionTypeAnnotation: true,
          createFlowUnionType: true,
          createTSUnionType: true,
          cloneNode: true,
          clone: true,
          cloneDeep: true,
          cloneDeepWithoutLoc: true,
          cloneWithoutLoc: true,
          addComment: true,
          addComments: true,
          inheritInnerComments: true,
          inheritLeadingComments: true,
          inheritsComments: true,
          inheritTrailingComments: true,
          removeComments: true,
          ensureBlock: true,
          toBindingIdentifierName: true,
          toBlock: true,
          toComputedKey: true,
          toExpression: true,
          toIdentifier: true,
          toKeyAlias: true,
          toStatement: true,
          valueToNode: true,
          appendToMemberExpression: true,
          inherits: true,
          prependToMemberExpression: true,
          removeProperties: true,
          removePropertiesDeep: true,
          removeTypeDuplicates: true,
          getAssignmentIdentifiers: true,
          getBindingIdentifiers: true,
          getOuterBindingIdentifiers: true,
          getFunctionName: true,
          traverse: true,
          traverseFast: true,
          shallowEqual: true,
          is: true,
          isBinding: true,
          isBlockScoped: true,
          isImmutable: true,
          isLet: true,
          isNode: true,
          isNodesEquivalent: true,
          isPlaceholderType: true,
          isReferenced: true,
          isScope: true,
          isSpecifierDefault: true,
          isType: true,
          isValidES3Identifier: true,
          isValidIdentifier: true,
          isVar: true,
          matchesPattern: true,
          validate: true,
          buildMatchMemberExpression: true,
          __internal__deprecationWarning: true
        };
        Object.defineProperty(exports, "__internal__deprecationWarning", {
          enumerable: true,
          get: function get() {
            return _deprecationWarning["default"];
          }
        });
        Object.defineProperty(exports, "addComment", {
          enumerable: true,
          get: function get() {
            return _addComment["default"];
          }
        });
        Object.defineProperty(exports, "addComments", {
          enumerable: true,
          get: function get() {
            return _addComments["default"];
          }
        });
        Object.defineProperty(exports, "appendToMemberExpression", {
          enumerable: true,
          get: function get() {
            return _appendToMemberExpression["default"];
          }
        });
        Object.defineProperty(exports, "assertNode", {
          enumerable: true,
          get: function get() {
            return _assertNode["default"];
          }
        });
        Object.defineProperty(exports, "buildMatchMemberExpression", {
          enumerable: true,
          get: function get() {
            return _buildMatchMemberExpression["default"];
          }
        });
        Object.defineProperty(exports, "clone", {
          enumerable: true,
          get: function get() {
            return _clone["default"];
          }
        });
        Object.defineProperty(exports, "cloneDeep", {
          enumerable: true,
          get: function get() {
            return _cloneDeep["default"];
          }
        });
        Object.defineProperty(exports, "cloneDeepWithoutLoc", {
          enumerable: true,
          get: function get() {
            return _cloneDeepWithoutLoc["default"];
          }
        });
        Object.defineProperty(exports, "cloneNode", {
          enumerable: true,
          get: function get() {
            return _cloneNode["default"];
          }
        });
        Object.defineProperty(exports, "cloneWithoutLoc", {
          enumerable: true,
          get: function get() {
            return _cloneWithoutLoc["default"];
          }
        });
        Object.defineProperty(exports, "createFlowUnionType", {
          enumerable: true,
          get: function get() {
            return _createFlowUnionType["default"];
          }
        });
        Object.defineProperty(exports, "createTSUnionType", {
          enumerable: true,
          get: function get() {
            return _createTSUnionType["default"];
          }
        });
        Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
          enumerable: true,
          get: function get() {
            return _createTypeAnnotationBasedOnTypeof["default"];
          }
        });
        Object.defineProperty(exports, "createUnionTypeAnnotation", {
          enumerable: true,
          get: function get() {
            return _createFlowUnionType["default"];
          }
        });
        Object.defineProperty(exports, "ensureBlock", {
          enumerable: true,
          get: function get() {
            return _ensureBlock["default"];
          }
        });
        Object.defineProperty(exports, "getAssignmentIdentifiers", {
          enumerable: true,
          get: function get() {
            return _getAssignmentIdentifiers["default"];
          }
        });
        Object.defineProperty(exports, "getBindingIdentifiers", {
          enumerable: true,
          get: function get() {
            return _getBindingIdentifiers["default"];
          }
        });
        Object.defineProperty(exports, "getFunctionName", {
          enumerable: true,
          get: function get() {
            return _getFunctionName["default"];
          }
        });
        Object.defineProperty(exports, "getOuterBindingIdentifiers", {
          enumerable: true,
          get: function get() {
            return _getOuterBindingIdentifiers["default"];
          }
        });
        Object.defineProperty(exports, "inheritInnerComments", {
          enumerable: true,
          get: function get() {
            return _inheritInnerComments["default"];
          }
        });
        Object.defineProperty(exports, "inheritLeadingComments", {
          enumerable: true,
          get: function get() {
            return _inheritLeadingComments["default"];
          }
        });
        Object.defineProperty(exports, "inheritTrailingComments", {
          enumerable: true,
          get: function get() {
            return _inheritTrailingComments["default"];
          }
        });
        Object.defineProperty(exports, "inherits", {
          enumerable: true,
          get: function get() {
            return _inherits["default"];
          }
        });
        Object.defineProperty(exports, "inheritsComments", {
          enumerable: true,
          get: function get() {
            return _inheritsComments["default"];
          }
        });
        Object.defineProperty(exports, "is", {
          enumerable: true,
          get: function get() {
            return _is["default"];
          }
        });
        Object.defineProperty(exports, "isBinding", {
          enumerable: true,
          get: function get() {
            return _isBinding["default"];
          }
        });
        Object.defineProperty(exports, "isBlockScoped", {
          enumerable: true,
          get: function get() {
            return _isBlockScoped["default"];
          }
        });
        Object.defineProperty(exports, "isImmutable", {
          enumerable: true,
          get: function get() {
            return _isImmutable["default"];
          }
        });
        Object.defineProperty(exports, "isLet", {
          enumerable: true,
          get: function get() {
            return _isLet["default"];
          }
        });
        Object.defineProperty(exports, "isNode", {
          enumerable: true,
          get: function get() {
            return _isNode["default"];
          }
        });
        Object.defineProperty(exports, "isNodesEquivalent", {
          enumerable: true,
          get: function get() {
            return _isNodesEquivalent["default"];
          }
        });
        Object.defineProperty(exports, "isPlaceholderType", {
          enumerable: true,
          get: function get() {
            return _isPlaceholderType["default"];
          }
        });
        Object.defineProperty(exports, "isReferenced", {
          enumerable: true,
          get: function get() {
            return _isReferenced["default"];
          }
        });
        Object.defineProperty(exports, "isScope", {
          enumerable: true,
          get: function get() {
            return _isScope["default"];
          }
        });
        Object.defineProperty(exports, "isSpecifierDefault", {
          enumerable: true,
          get: function get() {
            return _isSpecifierDefault["default"];
          }
        });
        Object.defineProperty(exports, "isType", {
          enumerable: true,
          get: function get() {
            return _isType["default"];
          }
        });
        Object.defineProperty(exports, "isValidES3Identifier", {
          enumerable: true,
          get: function get() {
            return _isValidES3Identifier["default"];
          }
        });
        Object.defineProperty(exports, "isValidIdentifier", {
          enumerable: true,
          get: function get() {
            return _isValidIdentifier["default"];
          }
        });
        Object.defineProperty(exports, "isVar", {
          enumerable: true,
          get: function get() {
            return _isVar["default"];
          }
        });
        Object.defineProperty(exports, "matchesPattern", {
          enumerable: true,
          get: function get() {
            return _matchesPattern["default"];
          }
        });
        Object.defineProperty(exports, "prependToMemberExpression", {
          enumerable: true,
          get: function get() {
            return _prependToMemberExpression["default"];
          }
        });
        exports.react = void 0;
        Object.defineProperty(exports, "removeComments", {
          enumerable: true,
          get: function get() {
            return _removeComments["default"];
          }
        });
        Object.defineProperty(exports, "removeProperties", {
          enumerable: true,
          get: function get() {
            return _removeProperties["default"];
          }
        });
        Object.defineProperty(exports, "removePropertiesDeep", {
          enumerable: true,
          get: function get() {
            return _removePropertiesDeep["default"];
          }
        });
        Object.defineProperty(exports, "removeTypeDuplicates", {
          enumerable: true,
          get: function get() {
            return _removeTypeDuplicates["default"];
          }
        });
        Object.defineProperty(exports, "shallowEqual", {
          enumerable: true,
          get: function get() {
            return _shallowEqual["default"];
          }
        });
        Object.defineProperty(exports, "toBindingIdentifierName", {
          enumerable: true,
          get: function get() {
            return _toBindingIdentifierName["default"];
          }
        });
        Object.defineProperty(exports, "toBlock", {
          enumerable: true,
          get: function get() {
            return _toBlock["default"];
          }
        });
        Object.defineProperty(exports, "toComputedKey", {
          enumerable: true,
          get: function get() {
            return _toComputedKey["default"];
          }
        });
        Object.defineProperty(exports, "toExpression", {
          enumerable: true,
          get: function get() {
            return _toExpression["default"];
          }
        });
        Object.defineProperty(exports, "toIdentifier", {
          enumerable: true,
          get: function get() {
            return _toIdentifier["default"];
          }
        });
        Object.defineProperty(exports, "toKeyAlias", {
          enumerable: true,
          get: function get() {
            return _toKeyAlias["default"];
          }
        });
        Object.defineProperty(exports, "toStatement", {
          enumerable: true,
          get: function get() {
            return _toStatement["default"];
          }
        });
        Object.defineProperty(exports, "traverse", {
          enumerable: true,
          get: function get() {
            return _traverse["default"];
          }
        });
        Object.defineProperty(exports, "traverseFast", {
          enumerable: true,
          get: function get() {
            return _traverseFast["default"];
          }
        });
        Object.defineProperty(exports, "validate", {
          enumerable: true,
          get: function get() {
            return _validate["default"];
          }
        });
        Object.defineProperty(exports, "valueToNode", {
          enumerable: true,
          get: function get() {
            return _valueToNode["default"];
          }
        });
        var _isReactComponent = isReactComponent$1;
        var _isCompatTag = isCompatTag$1;
        var _buildChildren = requireBuildChildren();
        var _assertNode = assertNode$1;
        var _index = generated$1;
        Object.keys(_index).forEach(function (key) {
          if (key === "default" || key === "__esModule") return;
          if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
          if (key in exports && exports[key] === _index[key]) return;
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: function get() {
              return _index[key];
            }
          });
        });
        var _createTypeAnnotationBasedOnTypeof =
          createTypeAnnotationBasedOnTypeof$1;
        var _createFlowUnionType = createFlowUnionType$1;
        var _createTSUnionType = createTSUnionType$1;
        var _index2 = generated$2;
        Object.keys(_index2).forEach(function (key) {
          if (key === "default" || key === "__esModule") return;
          if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
          if (key in exports && exports[key] === _index2[key]) return;
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: function get() {
              return _index2[key];
            }
          });
        });
        var _uppercase = uppercase;
        Object.keys(_uppercase).forEach(function (key) {
          if (key === "default" || key === "__esModule") return;
          if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
          if (key in exports && exports[key] === _uppercase[key]) return;
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: function get() {
              return _uppercase[key];
            }
          });
        });
        var _productions = productions;
        Object.keys(_productions).forEach(function (key) {
          if (key === "default" || key === "__esModule") return;
          if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
          if (key in exports && exports[key] === _productions[key]) return;
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: function get() {
              return _productions[key];
            }
          });
        });
        var _cloneNode = cloneNode$1;
        var _clone = clone$1;
        var _cloneDeep = cloneDeep$1;
        var _cloneDeepWithoutLoc = cloneDeepWithoutLoc$1;
        var _cloneWithoutLoc = cloneWithoutLoc$1;
        var _addComment = addComment$1;
        var _addComments = addComments$1;
        var _inheritInnerComments = inheritInnerComments$1;
        var _inheritLeadingComments = inheritLeadingComments$1;
        var _inheritsComments = inheritsComments$1;
        var _inheritTrailingComments = inheritTrailingComments$1;
        var _removeComments = removeComments$1;
        var _index3 = generated;
        Object.keys(_index3).forEach(function (key) {
          if (key === "default" || key === "__esModule") return;
          if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
          if (key in exports && exports[key] === _index3[key]) return;
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: function get() {
              return _index3[key];
            }
          });
        });
        var _index4 = constants;
        Object.keys(_index4).forEach(function (key) {
          if (key === "default" || key === "__esModule") return;
          if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
          if (key in exports && exports[key] === _index4[key]) return;
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: function get() {
              return _index4[key];
            }
          });
        });
        var _ensureBlock = ensureBlock$1;
        var _toBindingIdentifierName = toBindingIdentifierName$1;
        var _toBlock = toBlock$1;
        var _toComputedKey = toComputedKey$1;
        var _toExpression = toExpression$1;
        var _toIdentifier = toIdentifier$1;
        var _toKeyAlias = toKeyAlias$1;
        var _toStatement = toStatement$1;
        var _valueToNode = valueToNode$1;
        var _index5 = requireDefinitions();
        Object.keys(_index5).forEach(function (key) {
          if (key === "default" || key === "__esModule") return;
          if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
          if (key in exports && exports[key] === _index5[key]) return;
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: function get() {
              return _index5[key];
            }
          });
        });
        var _appendToMemberExpression = appendToMemberExpression$1;
        var _inherits = inherits$1;
        var _prependToMemberExpression = requirePrependToMemberExpression();
        var _removeProperties = removeProperties$1;
        var _removePropertiesDeep = removePropertiesDeep$1;
        var _removeTypeDuplicates = removeTypeDuplicates$3;
        var _getAssignmentIdentifiers = getAssignmentIdentifiers$1;
        var _getBindingIdentifiers = getBindingIdentifiers$1;
        var _getOuterBindingIdentifiers = getOuterBindingIdentifiers$1;
        var _getFunctionName = getFunctionName$4;
        var _traverse = traverse$1;
        Object.keys(_traverse).forEach(function (key) {
          if (key === "default" || key === "__esModule") return;
          if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
          if (key in exports && exports[key] === _traverse[key]) return;
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: function get() {
              return _traverse[key];
            }
          });
        });
        var _traverseFast = traverseFast$1;
        var _shallowEqual = shallowEqual$1;
        var _is = requireIs();
        var _isBinding = isBinding$1;
        var _isBlockScoped = isBlockScoped$1;
        var _isImmutable = isImmutable$1;
        var _isLet = isLet$1;
        var _isNode = isNode$1;
        var _isNodesEquivalent = isNodesEquivalent$1;
        var _isPlaceholderType = requireIsPlaceholderType();
        var _isReferenced = isReferenced$1;
        var _isScope = isScope$1;
        var _isSpecifierDefault = isSpecifierDefault$1;
        var _isType = requireIsType();
        var _isValidES3Identifier = isValidES3Identifier$1;
        var _isValidIdentifier = isValidIdentifier$1;
        var _isVar = isVar$1;
        var _matchesPattern = matchesPattern$1;
        var _validate = requireValidate();
        var _buildMatchMemberExpression = buildMatchMemberExpression$1;
        var _index6 = generated$3;
        Object.keys(_index6).forEach(function (key) {
          if (key === "default" || key === "__esModule") return;
          if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
          if (key in exports && exports[key] === _index6[key]) return;
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: function get() {
              return _index6[key];
            }
          });
        });
        var _deprecationWarning = deprecationWarning$1;
        exports.react = {
          isReactComponent: _isReactComponent["default"],
          isCompatTag: _isCompatTag["default"],
          buildChildren: _buildChildren["default"]
        };
        {
          exports.toSequenceExpression = toSequenceExpression$1["default"];
        }
        if (process.env.BABEL_TYPES_8_BREAKING) {
          console.warn(
            "BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!"
          );
        }
      })(lib$3);
      return lib$3;
    }
    var libExports = requireLib();
    function assertExhaustive$1(_, errorMsg) {
      throw new Error(errorMsg);
    }
    function retainWhere(array, predicate) {
      var writeIndex = 0;
      for (var readIndex = 0; readIndex < array.length; readIndex++) {
        var item = array[readIndex];
        if (predicate(item) === true) {
          array[writeIndex++] = item;
        }
      }
      array.length = writeIndex;
    }
    function retainWhere_Set(items, predicate) {
      var _iterator37 = _createForOfIteratorHelper(items),
        _step37;
      try {
        for (_iterator37.s(); !(_step37 = _iterator37.n()).done; ) {
          var item = _step37.value;
          if (!predicate(item)) {
            items["delete"](item);
          }
        }
      } catch (err) {
        _iterator37.e(err);
      } finally {
        _iterator37.f();
      }
    }
    function getOrInsertWith(m, key, makeDefault) {
      if (m.has(key)) {
        return m.get(key);
      } else {
        var defaultValue = makeDefault();
        m.set(key, defaultValue);
        return defaultValue;
      }
    }
    function getOrInsertDefault(m, key, defaultValue) {
      if (m.has(key)) {
        return m.get(key);
      } else {
        m.set(key, defaultValue);
        return defaultValue;
      }
    }
    function Set_equal(a, b) {
      if (a.size !== b.size) {
        return false;
      }
      var _iterator38 = _createForOfIteratorHelper(a),
        _step38;
      try {
        for (_iterator38.s(); !(_step38 = _iterator38.n()).done; ) {
          var item = _step38.value;
          if (!b.has(item)) {
            return false;
          }
        }
      } catch (err) {
        _iterator38.e(err);
      } finally {
        _iterator38.f();
      }
      return true;
    }
    function Set_union(a, b) {
      var union = new Set(a);
      var _iterator39 = _createForOfIteratorHelper(b),
        _step39;
      try {
        for (_iterator39.s(); !(_step39 = _iterator39.n()).done; ) {
          var item = _step39.value;
          union.add(item);
        }
      } catch (err) {
        _iterator39.e(err);
      } finally {
        _iterator39.f();
      }
      return union;
    }
    function Set_intersect(sets) {
      if (
        sets.length === 0 ||
        sets.some(function (s) {
          return s.size === 0;
        })
      ) {
        return new Set();
      } else if (sets.length === 1) {
        return new Set(sets[0]);
      }
      var result = new Set();
      var first = sets[0];
      var _iterator40 = _createForOfIteratorHelper(first),
        _step40;
      try {
        outer: for (_iterator40.s(); !(_step40 = _iterator40.n()).done; ) {
          var e = _step40.value;
          for (var i = 1; i < sets.length; i++) {
            if (!sets[i].has(e)) {
              continue outer;
            }
          }
          result.add(e);
        }
      } catch (err) {
        _iterator40.e(err);
      } finally {
        _iterator40.f();
      }
      return result;
    }
    function Iterable_some(iter, pred) {
      var _iterator41 = _createForOfIteratorHelper(iter),
        _step41;
      try {
        for (_iterator41.s(); !(_step41 = _iterator41.n()).done; ) {
          var item = _step41.value;
          if (pred(item)) {
            return true;
          }
        }
      } catch (err) {
        _iterator41.e(err);
      } finally {
        _iterator41.f();
      }
      return false;
    }
    function Set_filter(source, fn) {
      var result = new Set();
      var _iterator42 = _createForOfIteratorHelper(source),
        _step42;
      try {
        for (_iterator42.s(); !(_step42 = _iterator42.n()).done; ) {
          var entry = _step42.value;
          if (fn(entry)) {
            result.add(entry);
          }
        }
      } catch (err) {
        _iterator42.e(err);
      } finally {
        _iterator42.f();
      }
      return result;
    }
    function hasNode(input) {
      return input.node != null;
    }
    function hasOwnProperty$1(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    var ErrorSeverity;
    (function (ErrorSeverity) {
      ErrorSeverity["InvalidJS"] = "InvalidJS";
      ErrorSeverity["InvalidReact"] = "InvalidReact";
      ErrorSeverity["InvalidConfig"] = "InvalidConfig";
      ErrorSeverity["CannotPreserveMemoization"] = "CannotPreserveMemoization";
      ErrorSeverity["Todo"] = "Todo";
      ErrorSeverity["Invariant"] = "Invariant";
    })(ErrorSeverity || (ErrorSeverity = {}));
    var CompilerSuggestionOperation;
    (function (CompilerSuggestionOperation) {
      CompilerSuggestionOperation[
        (CompilerSuggestionOperation["InsertBefore"] = 0)
      ] = "InsertBefore";
      CompilerSuggestionOperation[
        (CompilerSuggestionOperation["InsertAfter"] = 1)
      ] = "InsertAfter";
      CompilerSuggestionOperation[(CompilerSuggestionOperation["Remove"] = 2)] =
        "Remove";
      CompilerSuggestionOperation[
        (CompilerSuggestionOperation["Replace"] = 3)
      ] = "Replace";
    })(CompilerSuggestionOperation || (CompilerSuggestionOperation = {}));
    var CompilerErrorDetail = /*#__PURE__*/ (function () {
      function CompilerErrorDetail(options) {
        _classCallCheck(this, CompilerErrorDetail);
        this.options = options;
      }
      return _createClass(CompilerErrorDetail, [
        {
          key: "reason",
          get: function get() {
            return this.options.reason;
          }
        },
        {
          key: "description",
          get: function get() {
            return this.options.description;
          }
        },
        {
          key: "severity",
          get: function get() {
            return this.options.severity;
          }
        },
        {
          key: "loc",
          get: function get() {
            return this.options.loc;
          }
        },
        {
          key: "suggestions",
          get: function get() {
            return this.options.suggestions;
          }
        },
        {
          key: "printErrorMessage",
          value: function printErrorMessage() {
            var buffer = ["".concat(this.severity, ": ").concat(this.reason)];
            if (this.description != null) {
              buffer.push(". ".concat(this.description));
            }
            if (this.loc != null && _typeof(this.loc) !== "symbol") {
              buffer.push(
                " ("
                  .concat(this.loc.start.line, ":")
                  .concat(this.loc.end.line, ")")
              );
            }
            return buffer.join("");
          }
        },
        {
          key: "toString",
          value: function toString() {
            return this.printErrorMessage();
          }
        }
      ]);
    })();
    var CompilerError = /*#__PURE__*/ (function (_Error) {
      function CompilerError() {
        var _this;
        _classCallCheck(this, CompilerError);
        for (
          var _len6 = arguments.length, args = new Array(_len6), _key25 = 0;
          _key25 < _len6;
          _key25++
        ) {
          args[_key25] = arguments[_key25];
        }
        _this = _callSuper(this, CompilerError, [].concat(args));
        _this.details = [];
        _this.name = "ReactCompilerError";
        _this.details = [];
        return _this;
      }
      _inherits2(CompilerError, _Error);
      return _createClass(
        CompilerError,
        [
          {
            key: "message",
            get: function get() {
              return this.toString();
            },
            set: function set(_message) {}
          },
          {
            key: "toString",
            value: function toString() {
              if (Array.isArray(this.details)) {
                return this.details
                  .map(function (detail) {
                    return detail.toString();
                  })
                  .join("\n\n");
              }
              return this.name;
            }
          },
          {
            key: "push",
            value: function push(options) {
              var _a;
              var detail = new CompilerErrorDetail({
                reason: options.reason,
                description:
                  (_a = options.description) !== null && _a !== void 0
                    ? _a
                    : null,
                severity: options.severity,
                suggestions: options.suggestions,
                loc: _typeof(options.loc) === "symbol" ? null : options.loc
              });
              return this.pushErrorDetail(detail);
            }
          },
          {
            key: "pushErrorDetail",
            value: function pushErrorDetail(detail) {
              this.details.push(detail);
              return detail;
            }
          },
          {
            key: "hasErrors",
            value: function hasErrors() {
              return this.details.length > 0;
            }
          },
          {
            key: "isCritical",
            value: function isCritical() {
              return this.details.some(function (detail) {
                switch (detail.severity) {
                  case ErrorSeverity.Invariant:
                  case ErrorSeverity.InvalidJS:
                  case ErrorSeverity.InvalidReact:
                  case ErrorSeverity.InvalidConfig:
                    return true;
                  case ErrorSeverity.CannotPreserveMemoization:
                  case ErrorSeverity.Todo:
                    return false;
                  default:
                    assertExhaustive$1(
                      detail.severity,
                      "Unhandled error severity"
                    );
                }
              });
            }
          }
        ],
        [
          {
            key: "invariant",
            value: function invariant(condition, options) {
              if (!condition) {
                var errors = new CompilerError();
                errors.pushErrorDetail(
                  new CompilerErrorDetail(
                    Object.assign(Object.assign({}, options), {
                      severity: ErrorSeverity.Invariant
                    })
                  )
                );
                throw errors;
              }
            }
          },
          {
            key: "throwTodo",
            value: function throwTodo(options) {
              var errors = new CompilerError();
              errors.pushErrorDetail(
                new CompilerErrorDetail(
                  Object.assign(Object.assign({}, options), {
                    severity: ErrorSeverity.Todo
                  })
                )
              );
              throw errors;
            }
          },
          {
            key: "throwInvalidJS",
            value: function throwInvalidJS(options) {
              var errors = new CompilerError();
              errors.pushErrorDetail(
                new CompilerErrorDetail(
                  Object.assign(Object.assign({}, options), {
                    severity: ErrorSeverity.InvalidJS
                  })
                )
              );
              throw errors;
            }
          },
          {
            key: "throwInvalidReact",
            value: function throwInvalidReact(options) {
              var errors = new CompilerError();
              errors.pushErrorDetail(
                new CompilerErrorDetail(
                  Object.assign(Object.assign({}, options), {
                    severity: ErrorSeverity.InvalidReact
                  })
                )
              );
              throw errors;
            }
          },
          {
            key: "throwInvalidConfig",
            value: function throwInvalidConfig(options) {
              var errors = new CompilerError();
              errors.pushErrorDetail(
                new CompilerErrorDetail(
                  Object.assign(Object.assign({}, options), {
                    severity: ErrorSeverity.InvalidConfig
                  })
                )
              );
              throw errors;
            }
          },
          {
            key: "throw",
            value: function _throw(options) {
              var errors = new CompilerError();
              errors.pushErrorDetail(new CompilerErrorDetail(options));
              throw errors;
            }
          }
        ]
      );
    })(/*#__PURE__*/ _wrapNativeSuper(Error));
    function insertAdditionalFunctionDeclaration(fnPath, compiled, gating) {
      var _a, _b;
      var originalFnName = fnPath.node.id;
      var originalFnParams = fnPath.node.params;
      var compiledParams = fnPath.node.params;
      CompilerError.invariant(originalFnName != null && compiled.id != null, {
        reason:
          "Expected function declarations that are referenced elsewhere to have a named identifier",
        loc: (_a = fnPath.node.loc) !== null && _a !== void 0 ? _a : null
      });
      CompilerError.invariant(
        originalFnParams.length === compiledParams.length,
        {
          reason:
            "Expected React Compiler optimized function declarations to have the same number of parameters as source",
          loc: (_b = fnPath.node.loc) !== null && _b !== void 0 ? _b : null
        }
      );
      var gatingCondition = fnPath.scope.generateUidIdentifier(
        "".concat(gating.importSpecifierName, "_result")
      );
      var unoptimizedFnName = fnPath.scope.generateUidIdentifier(
        "".concat(originalFnName.name, "_unoptimized")
      );
      var optimizedFnName = fnPath.scope.generateUidIdentifier(
        "".concat(originalFnName.name, "_optimized")
      );
      compiled.id.name = optimizedFnName.name;
      fnPath.get("id").replaceInline(unoptimizedFnName);
      var newParams = [];
      var genNewArgs = [];
      var _loop = function _loop() {
        var argName = "arg".concat(i);
        if (originalFnParams[i].type === "RestElement") {
          newParams.push(
            libExports.restElement(libExports.identifier(argName))
          );
          genNewArgs.push(function () {
            return libExports.spreadElement(libExports.identifier(argName));
          });
        } else {
          newParams.push(libExports.identifier(argName));
          genNewArgs.push(function () {
            return libExports.identifier(argName);
          });
        }
      };
      for (var i = 0; i < originalFnParams.length; i++) {
        _loop();
      }
      fnPath.insertAfter(
        libExports.functionDeclaration(
          originalFnName,
          newParams,
          libExports.blockStatement([
            libExports.ifStatement(
              gatingCondition,
              libExports.returnStatement(
                libExports.callExpression(
                  compiled.id,
                  genNewArgs.map(function (fn) {
                    return fn();
                  })
                )
              ),
              libExports.returnStatement(
                libExports.callExpression(
                  unoptimizedFnName,
                  genNewArgs.map(function (fn) {
                    return fn();
                  })
                )
              )
            )
          ])
        )
      );
      fnPath.insertBefore(
        libExports.variableDeclaration("const", [
          libExports.variableDeclarator(
            gatingCondition,
            libExports.callExpression(
              libExports.identifier(gating.importSpecifierName),
              []
            )
          )
        ])
      );
      fnPath.insertBefore(compiled);
    }
    function insertGatedFunctionDeclaration(
      fnPath,
      compiled,
      gating,
      referencedBeforeDeclaration
    ) {
      var _a;
      if (referencedBeforeDeclaration && fnPath.isFunctionDeclaration()) {
        CompilerError.invariant(compiled.type === "FunctionDeclaration", {
          reason: "Expected compiled node type to match input type",
          description: "Got ".concat(
            compiled.type,
            " but expected FunctionDeclaration"
          ),
          loc: (_a = fnPath.node.loc) !== null && _a !== void 0 ? _a : null
        });
        insertAdditionalFunctionDeclaration(fnPath, compiled, gating);
      } else {
        var gatingExpression = libExports.conditionalExpression(
          libExports.callExpression(
            libExports.identifier(gating.importSpecifierName),
            []
          ),
          buildFunctionExpression(compiled),
          buildFunctionExpression(fnPath.node)
        );
        if (
          fnPath.parentPath.node.type !== "ExportDefaultDeclaration" &&
          fnPath.node.type === "FunctionDeclaration" &&
          fnPath.node.id != null
        ) {
          fnPath.replaceWith(
            libExports.variableDeclaration("const", [
              libExports.variableDeclarator(fnPath.node.id, gatingExpression)
            ])
          );
        } else if (
          fnPath.parentPath.node.type === "ExportDefaultDeclaration" &&
          fnPath.node.type !== "ArrowFunctionExpression" &&
          fnPath.node.id != null
        ) {
          fnPath.insertAfter(
            libExports.exportDefaultDeclaration(
              libExports.identifier(fnPath.node.id.name)
            )
          );
          fnPath.parentPath.replaceWith(
            libExports.variableDeclaration("const", [
              libExports.variableDeclarator(
                libExports.identifier(fnPath.node.id.name),
                gatingExpression
              )
            ])
          );
        } else {
          fnPath.replaceWith(gatingExpression);
        }
      }
    }
    function buildFunctionExpression(node) {
      var _a, _b;
      if (
        node.type === "ArrowFunctionExpression" ||
        node.type === "FunctionExpression"
      ) {
        return node;
      } else {
        var fn = {
          type: "FunctionExpression",
          async: node.async,
          generator: node.generator,
          loc: (_a = node.loc) !== null && _a !== void 0 ? _a : null,
          id: (_b = node.id) !== null && _b !== void 0 ? _b : null,
          params: node.params,
          body: node.body
        };
        return fn;
      }
    }
    function makeTypeId(id) {
      CompilerError.invariant(id >= 0 && Number.isInteger(id), {
        reason: "Expected instruction id to be a non-negative integer",
        description: null,
        loc: null,
        suggestions: null
      });
      return id;
    }
    var typeCounter = 0;
    function makeType() {
      return { kind: "Type", id: makeTypeId(typeCounter++) };
    }
    function typeEquals(tA, tB) {
      if (tA.kind !== tB.kind) return false;
      return (
        typeVarEquals(tA, tB) ||
        funcTypeEquals(tA, tB) ||
        objectTypeEquals(tA, tB) ||
        primitiveTypeEquals(tA, tB) ||
        polyTypeEquals(tA, tB) ||
        phiTypeEquals(tA, tB) ||
        propTypeEquals(tA, tB) ||
        objectMethodTypeEquals(tA, tB)
      );
    }
    function typeVarEquals(tA, tB) {
      if (tA.kind === "Type" && tB.kind === "Type") {
        return tA.id === tB.id;
      }
      return false;
    }
    function typeKindCheck(tA, tb, type) {
      return tA.kind === type && tb.kind === type;
    }
    function objectMethodTypeEquals(tA, tB) {
      return typeKindCheck(tA, tB, "ObjectMethod");
    }
    function propTypeEquals(tA, tB) {
      if (tA.kind === "Property" && tB.kind === "Property") {
        if (!typeEquals(tA.objectType, tB.objectType)) {
          return false;
        }
        return (
          tA.propertyName === tB.propertyName && tA.objectName === tB.objectName
        );
      }
      return false;
    }
    function primitiveTypeEquals(tA, tB) {
      return typeKindCheck(tA, tB, "Primitive");
    }
    function polyTypeEquals(tA, tB) {
      return typeKindCheck(tA, tB, "Poly");
    }
    function objectTypeEquals(tA, tB) {
      if (tA.kind === "Object" && tB.kind == "Object") {
        return tA.shapeId === tB.shapeId;
      }
      return false;
    }
    function funcTypeEquals(tA, tB) {
      if (tA.kind !== "Function" || tB.kind !== "Function") {
        return false;
      }
      return typeEquals(tA["return"], tB["return"]);
    }
    function phiTypeEquals(tA, tB) {
      if (tA.kind === "Phi" && tB.kind === "Phi") {
        if (tA.operands.length !== tB.operands.length) {
          return false;
        }
        var operands = new Set(tA.operands);
        for (var i = 0; i < tB.operands.length; i++) {
          if (!operands.has(tB.operands[i])) {
            return false;
          }
        }
      }
      return false;
    }
    var GeneratedSource = Symbol();
    function isStatementBlockKind(kind) {
      return kind === "block" || kind === "catch";
    }
    function isExpressionBlockKind(kind) {
      return !isStatementBlockKind(kind);
    }
    var GotoVariant;
    (function (GotoVariant) {
      GotoVariant["Break"] = "Break";
      GotoVariant["Continue"] = "Continue";
      GotoVariant["Try"] = "Try";
    })(GotoVariant || (GotoVariant = {}));
    var InstructionKind;
    (function (InstructionKind) {
      InstructionKind["Const"] = "Const";
      InstructionKind["Let"] = "Let";
      InstructionKind["Reassign"] = "Reassign";
      InstructionKind["Catch"] = "Catch";
      InstructionKind["HoistedConst"] = "HoistedConst";
      InstructionKind["HoistedLet"] = "HoistedLet";
      InstructionKind["HoistedFunction"] = "HoistedFunction";
      InstructionKind["Function"] = "Function";
    })(InstructionKind || (InstructionKind = {}));
    function makeTemporaryIdentifier(id, loc) {
      return {
        id: id,
        name: null,
        declarationId: makeDeclarationId(id),
        mutableRange: {
          start: makeInstructionId(0),
          end: makeInstructionId(0)
        },
        scope: null,
        type: makeType(),
        loc: loc
      };
    }
    function forkTemporaryIdentifier(id, source) {
      return Object.assign(Object.assign({}, source), {
        mutableRange: {
          start: makeInstructionId(0),
          end: makeInstructionId(0)
        },
        id: id
      });
    }
    function makeIdentifierName(name) {
      CompilerError.invariant(libExports.isValidIdentifier(name), {
        reason: "Expected a valid identifier name",
        loc: GeneratedSource,
        description: "`".concat(name, "` is not a valid JavaScript identifier"),
        suggestions: null
      });
      return { kind: "named", value: name };
    }
    function promoteTemporary(identifier) {
      CompilerError.invariant(identifier.name === null, {
        reason: "Expected a temporary (unnamed) identifier",
        loc: GeneratedSource,
        description: "Identifier already has a name, `".concat(
          identifier.name,
          "`"
        ),
        suggestions: null
      });
      identifier.name = {
        kind: "promoted",
        value: "#t".concat(identifier.declarationId)
      };
    }
    function isPromotedTemporary(name) {
      return name.startsWith("#t");
    }
    function promoteTemporaryJsxTag(identifier) {
      CompilerError.invariant(identifier.name === null, {
        reason: "Expected a temporary (unnamed) identifier",
        loc: GeneratedSource,
        description: "Identifier already has a name, `".concat(
          identifier.name,
          "`"
        ),
        suggestions: null
      });
      identifier.name = {
        kind: "promoted",
        value: "#T".concat(identifier.declarationId)
      };
    }
    function isPromotedJsxTemporary(name) {
      return name.startsWith("#T");
    }
    var ValueReason;
    (function (ValueReason) {
      ValueReason["Global"] = "global";
      ValueReason["JsxCaptured"] = "jsx-captured";
      ValueReason["KnownReturnSignature"] = "known-return-signature";
      ValueReason["Context"] = "context";
      ValueReason["State"] = "state";
      ValueReason["ReducerState"] = "reducer-state";
      ValueReason["ReactiveFunctionArgument"] = "reactive-function-argument";
      ValueReason["Other"] = "other";
    })(ValueReason || (ValueReason = {}));
    var ValueKind;
    (function (ValueKind) {
      ValueKind["MaybeFrozen"] = "maybefrozen";
      ValueKind["Frozen"] = "frozen";
      ValueKind["Primitive"] = "primitive";
      ValueKind["Global"] = "global";
      ValueKind["Mutable"] = "mutable";
      ValueKind["Context"] = "context";
    })(ValueKind || (ValueKind = {}));
    var ValueKindSchema = zod.z["enum"]([
      ValueKind.MaybeFrozen,
      ValueKind.Frozen,
      ValueKind.Primitive,
      ValueKind.Global,
      ValueKind.Mutable,
      ValueKind.Context
    ]);
    var Effect;
    (function (Effect) {
      Effect["Unknown"] = "<unknown>";
      Effect["Freeze"] = "freeze";
      Effect["Read"] = "read";
      Effect["Capture"] = "capture";
      Effect["ConditionallyMutate"] = "mutate?";
      Effect["Mutate"] = "mutate";
      Effect["Store"] = "store";
    })(Effect || (Effect = {}));
    var EffectSchema = zod.z["enum"]([
      Effect.Read,
      Effect.Mutate,
      Effect.ConditionallyMutate,
      Effect.Capture,
      Effect.Store,
      Effect.Freeze
    ]);
    function isMutableEffect(effect, location) {
      switch (effect) {
        case Effect.Capture:
        case Effect.Store:
        case Effect.ConditionallyMutate:
        case Effect.Mutate: {
          return true;
        }
        case Effect.Unknown: {
          CompilerError.invariant(false, {
            reason: "Unexpected unknown effect",
            description: null,
            loc: location,
            suggestions: null
          });
        }
        case Effect.Read:
        case Effect.Freeze: {
          return false;
        }
        default: {
          assertExhaustive$1(effect, "Unexpected effect `".concat(effect, "`"));
        }
      }
    }
    function makePropertyLiteral(value) {
      return value;
    }
    function areEqualPaths(a, b) {
      return (
        a.length === b.length &&
        a.every(function (item, ix) {
          return (
            item.property === b[ix].property && item.optional === b[ix].optional
          );
        })
      );
    }
    function getPlaceScope(id, place) {
      var scope = place.identifier.scope;
      if (scope !== null && isScopeActive(scope, id)) {
        return scope;
      }
      return null;
    }
    function isScopeActive(scope, id) {
      return id >= scope.range.start && id < scope.range.end;
    }
    function makeBlockId(id) {
      CompilerError.invariant(id >= 0 && Number.isInteger(id), {
        reason: "Expected block id to be a non-negative integer",
        description: null,
        loc: null,
        suggestions: null
      });
      return id;
    }
    function makeScopeId(id) {
      CompilerError.invariant(id >= 0 && Number.isInteger(id), {
        reason: "Expected block id to be a non-negative integer",
        description: null,
        loc: null,
        suggestions: null
      });
      return id;
    }
    function makeIdentifierId(id) {
      CompilerError.invariant(id >= 0 && Number.isInteger(id), {
        reason: "Expected identifier id to be a non-negative integer",
        description: null,
        loc: null,
        suggestions: null
      });
      return id;
    }
    function makeDeclarationId(id) {
      CompilerError.invariant(id >= 0 && Number.isInteger(id), {
        reason: "Expected declaration id to be a non-negative integer",
        description: null,
        loc: null,
        suggestions: null
      });
      return id;
    }
    function makeInstructionId(id) {
      CompilerError.invariant(id >= 0 && Number.isInteger(id), {
        reason: "Expected instruction id to be a non-negative integer",
        description: null,
        loc: null,
        suggestions: null
      });
      return id;
    }
    function isObjectMethodType(id) {
      return id.type.kind == "ObjectMethod";
    }
    function isObjectType(id) {
      return id.type.kind === "Object";
    }
    function isPrimitiveType(id) {
      return id.type.kind === "Primitive";
    }
    function isArrayType(id) {
      return id.type.kind === "Object" && id.type.shapeId === "BuiltInArray";
    }
    function isPropsType(id) {
      return id.type.kind === "Object" && id.type.shapeId === "BuiltInProps";
    }
    function isRefValueType(id) {
      return id.type.kind === "Object" && id.type.shapeId === "BuiltInRefValue";
    }
    function isUseRefType(id) {
      return id.type.kind === "Object" && id.type.shapeId === "BuiltInUseRefId";
    }
    function isUseStateType(id) {
      return id.type.kind === "Object" && id.type.shapeId === "BuiltInUseState";
    }
    function isRefOrRefValue(id) {
      return isUseRefType(id) || isRefValueType(id);
    }
    function isSetStateType(id) {
      return (
        id.type.kind === "Function" && id.type.shapeId === "BuiltInSetState"
      );
    }
    function isStartTransitionType(id) {
      return (
        id.type.kind === "Function" &&
        id.type.shapeId === "BuiltInStartTransition"
      );
    }
    function isSetActionStateType(id) {
      return (
        id.type.kind === "Function" &&
        id.type.shapeId === "BuiltInSetActionState"
      );
    }
    function isDispatcherType(id) {
      return (
        id.type.kind === "Function" && id.type.shapeId === "BuiltInDispatch"
      );
    }
    function isStableType(id) {
      return (
        isSetStateType(id) ||
        isSetActionStateType(id) ||
        isDispatcherType(id) ||
        isUseRefType(id) ||
        isStartTransitionType(id)
      );
    }
    function isUseEffectHookType(id) {
      return (
        id.type.kind === "Function" &&
        id.type.shapeId === "BuiltInUseEffectHook"
      );
    }
    function isUseLayoutEffectHookType(id) {
      return (
        id.type.kind === "Function" &&
        id.type.shapeId === "BuiltInUseLayoutEffectHook"
      );
    }
    function isUseInsertionEffectHookType(id) {
      return (
        id.type.kind === "Function" &&
        id.type.shapeId === "BuiltInUseInsertionEffectHook"
      );
    }
    function isUseContextHookType(id) {
      return (
        id.type.kind === "Function" &&
        id.type.shapeId === "BuiltInUseContextHook"
      );
    }
    function getHookKind(env, id) {
      return getHookKindForType(env, id.type);
    }
    function isUseOperator(id) {
      return (
        id.type.kind === "Function" && id.type.shapeId === "BuiltInUseOperator"
      );
    }
    function getHookKindForType(env, type) {
      var _a;
      if (type.kind === "Function") {
        var signature = env.getFunctionSignature(type);
        return (_a =
          signature === null || signature === void 0
            ? void 0
            : signature.hookKind) !== null && _a !== void 0
          ? _a
          : null;
      }
      return null;
    }
    var lib = {};
    var sourceMap$1 = {};
    var sourceMap = {};
    var sourceMapGenerator = {};
    var base64Vlq = {};
    var base64 = {};
    var hasRequiredBase64;
    function requireBase64() {
      if (hasRequiredBase64) return base64;
      hasRequiredBase64 = 1;
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */ var intToCharMap =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
          ""
        );
      /**
       * Encode an integer in the range of 0 to 63 to a single base 64 digit.
       */ base64.encode = function (number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + number);
      };
      /**
       * Decode a single base 64 character code digit to an integer. Returns -1 on
       * failure.
       */ base64.decode = function (charCode) {
        var bigA = 65; // 'A'
        var bigZ = 90; // 'Z'
        var littleA = 97; // 'a'
        var littleZ = 122; // 'z'
        var zero = 48; // '0'
        var nine = 57; // '9'
        var plus = 43; // '+'
        var slash = 47; // '/'
        var littleOffset = 26;
        var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        } // 26 - 51: abcdefghijklmnopqrstuvwxyz
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        } // 52 - 61: 0123456789
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        } // 62: +
        if (charCode == plus) {
          return 62;
        } // 63: /
        if (charCode == slash) {
          return 63;
        } // Invalid base64 digit.
        return -1;
      };
      return base64;
    }
    var hasRequiredBase64Vlq;
    function requireBase64Vlq() {
      if (hasRequiredBase64Vlq) return base64Vlq;
      hasRequiredBase64Vlq = 1;
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       *
       * Based on the Base 64 VLQ implementation in Closure Compiler:
       * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
       *
       * Copyright 2011 The Closure Compiler Authors. All rights reserved.
       * Redistribution and use in source and binary forms, with or without
       * modification, are permitted provided that the following conditions are
       * met:
       *
       *  * Redistributions of source code must retain the above copyright
       *    notice, this list of conditions and the following disclaimer.
       *  * Redistributions in binary form must reproduce the above
       *    copyright notice, this list of conditions and the following
       *    disclaimer in the documentation and/or other materials provided
       *    with the distribution.
       *  * Neither the name of Google Inc. nor the names of its
       *    contributors may be used to endorse or promote products derived
       *    from this software without specific prior written permission.
       *
       * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
       * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
       * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
       * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
       * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
       * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
       * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
       * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
       * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
       * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
       * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
       */ var base64 = requireBase64(); // A single base 64 digit can contain 6 bits of data. For the base 64 variable
      // length quantities we use in the source map spec, the first bit is the sign,
      // the next four bits are the actual value, and the 6th bit is the
      // continuation bit. The continuation bit tells us whether there are more
      // digits in this value following this digit.
      //
      //   Continuation
      //   |    Sign
      //   |    |
      //   V    V
      //   101011
      var VLQ_BASE_SHIFT = 5; // binary: 100000
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111
      var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      /**
       * Converts from a two-complement value to a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
       */ function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      /**
       * Converts to a two-complement value from a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
       */ function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      /**
       * Returns the base 64 VLQ encoded value.
       */ base64Vlq.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      /**
       * Decodes the next base 64 VLQ value from the given string and returns the
       * value and the rest of the string via the out parameter.
       */ base64Vlq.decode = function base64VLQ_decode(
        aStr,
        aIndex,
        aOutParam
      ) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
      return base64Vlq;
    }
    var util = {};
    var hasRequiredUtil;
    function requireUtil() {
      if (hasRequiredUtil) return util;
      hasRequiredUtil = 1;
      (function (exports) {
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */ /**
         * This is a helper function for getting values from parameter/options
         * objects.
         *
         * @param args The object we are extracting values from
         * @param name The name of the property we are getting.
         * @param defaultValue An optional value to return if the property is missing
         * from the object. If this is not specified and the property is missing, an
         * error will be thrown.
         */ function getArg(aArgs, aName, aDefaultValue) {
          if (aName in aArgs) {
            return aArgs[aName];
          } else if (arguments.length === 3) {
            return aDefaultValue;
          } else {
            throw new Error('"' + aName + '" is a required argument.');
          }
        }
        exports.getArg = getArg;
        var urlRegexp =
          /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
        var dataUrlRegexp = /^data:.+\,.+$/;
        function urlParse(aUrl) {
          var match = aUrl.match(urlRegexp);
          if (!match) {
            return null;
          }
          return {
            scheme: match[1],
            auth: match[2],
            host: match[3],
            port: match[4],
            path: match[5]
          };
        }
        exports.urlParse = urlParse;
        function urlGenerate(aParsedUrl) {
          var url = "";
          if (aParsedUrl.scheme) {
            url += aParsedUrl.scheme + ":";
          }
          url += "//";
          if (aParsedUrl.auth) {
            url += aParsedUrl.auth + "@";
          }
          if (aParsedUrl.host) {
            url += aParsedUrl.host;
          }
          if (aParsedUrl.port) {
            url += ":" + aParsedUrl.port;
          }
          if (aParsedUrl.path) {
            url += aParsedUrl.path;
          }
          return url;
        }
        exports.urlGenerate = urlGenerate;
        /**
         * Normalizes a path, or the path portion of a URL:
         *
         * - Replaces consecutive slashes with one slash.
         * - Removes unnecessary '.' parts.
         * - Removes unnecessary '<dir>/..' parts.
         *
         * Based on code in the Node.js 'path' core module.
         *
         * @param aPath The path or url to normalize.
         */ function normalize(aPath) {
          var path = aPath;
          var url = urlParse(aPath);
          if (url) {
            if (!url.path) {
              return aPath;
            }
            path = url.path;
          }
          var isAbsolute = exports.isAbsolute(path);
          var parts = path.split(/\/+/);
          for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
            part = parts[i];
            if (part === ".") {
              parts.splice(i, 1);
            } else if (part === "..") {
              up++;
            } else if (up > 0) {
              if (part === "") {
                // The first part is blank if the path is absolute. Trying to go
                // above the root is a no-op. Therefore we can remove all '..' parts
                // directly after the root.
                parts.splice(i + 1, up);
                up = 0;
              } else {
                parts.splice(i, 2);
                up--;
              }
            }
          }
          path = parts.join("/");
          if (path === "") {
            path = isAbsolute ? "/" : ".";
          }
          if (url) {
            url.path = path;
            return urlGenerate(url);
          }
          return path;
        }
        exports.normalize = normalize;
        /**
         * Joins two paths/URLs.
         *
         * @param aRoot The root path or URL.
         * @param aPath The path or URL to be joined with the root.
         *
         * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
         *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
         *   first.
         * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
         *   is updated with the result and aRoot is returned. Otherwise the result
         *   is returned.
         *   - If aPath is absolute, the result is aPath.
         *   - Otherwise the two paths are joined with a slash.
         * - Joining for example 'http://' and 'www.example.com' is also supported.
         */ function join(aRoot, aPath) {
          if (aRoot === "") {
            aRoot = ".";
          }
          if (aPath === "") {
            aPath = ".";
          }
          var aPathUrl = urlParse(aPath);
          var aRootUrl = urlParse(aRoot);
          if (aRootUrl) {
            aRoot = aRootUrl.path || "/";
          } // `join(foo, '//www.example.org')`
          if (aPathUrl && !aPathUrl.scheme) {
            if (aRootUrl) {
              aPathUrl.scheme = aRootUrl.scheme;
            }
            return urlGenerate(aPathUrl);
          }
          if (aPathUrl || aPath.match(dataUrlRegexp)) {
            return aPath;
          } // `join('http://', 'www.example.com')`
          if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
            aRootUrl.host = aPath;
            return urlGenerate(aRootUrl);
          }
          var joined =
            aPath.charAt(0) === "/"
              ? aPath
              : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
          if (aRootUrl) {
            aRootUrl.path = joined;
            return urlGenerate(aRootUrl);
          }
          return joined;
        }
        exports.join = join;
        exports.isAbsolute = function (aPath) {
          return aPath.charAt(0) === "/" || !!aPath.match(urlRegexp);
        };
        /**
         * Make a path relative to a URL or another path.
         *
         * @param aRoot The root path or URL.
         * @param aPath The path or URL to be made relative to aRoot.
         */ function relative(aRoot, aPath) {
          if (aRoot === "") {
            aRoot = ".";
          }
          aRoot = aRoot.replace(/\/$/, ""); // It is possible for the path to be above the root. In this case, simply
          // checking whether the root is a prefix of the path won't work. Instead, we
          // need to remove components from the root one by one, until either we find
          // a prefix that fits, or we run out of components to remove.
          var level = 0;
          while (aPath.indexOf(aRoot + "/") !== 0) {
            var index = aRoot.lastIndexOf("/");
            if (index < 0) {
              return aPath;
            } // If the only part of the root that is left is the scheme (i.e. http://,
            // file:///, etc.), one or more slashes (/), or simply nothing at all, we
            // have exhausted all components, so the path is not relative to the root.
            aRoot = aRoot.slice(0, index);
            if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
              return aPath;
            }
            ++level;
          } // Make sure we add a "../" for each component we removed from the root.
          return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
        }
        exports.relative = relative;
        var supportsNullProto = (function () {
          var obj = Object.create(null);
          return !("__proto__" in obj);
        })();
        function identity(s) {
          return s;
        }
        /**
         * Because behavior goes wacky when you set `__proto__` on objects, we
         * have to prefix all the strings in our set with an arbitrary character.
         *
         * See https://github.com/mozilla/source-map/pull/31 and
         * https://github.com/mozilla/source-map/issues/30
         *
         * @param String aStr
         */ function toSetString(aStr) {
          if (isProtoString(aStr)) {
            return "$" + aStr;
          }
          return aStr;
        }
        exports.toSetString = supportsNullProto ? identity : toSetString;
        function fromSetString(aStr) {
          if (isProtoString(aStr)) {
            return aStr.slice(1);
          }
          return aStr;
        }
        exports.fromSetString = supportsNullProto ? identity : fromSetString;
        function isProtoString(s) {
          if (!s) {
            return false;
          }
          var length = s.length;
          if (length < 9 /* "__proto__".length */) {
            return false;
          }
          if (
            s.charCodeAt(length - 1) !== 95 /* '_' */ ||
            s.charCodeAt(length - 2) !== 95 /* '_' */ ||
            s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
            s.charCodeAt(length - 4) !== 116 /* 't' */ ||
            s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
            s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
            s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
            s.charCodeAt(length - 8) !== 95 /* '_' */ ||
            s.charCodeAt(length - 9) !== 95 /* '_' */
          ) {
            return false;
          }
          for (var i = length - 10; i >= 0; i--) {
            if (s.charCodeAt(i) !== 36 /* '$' */) {
              return false;
            }
          }
          return true;
        }
        /**
         * Comparator between two mappings where the original positions are compared.
         *
         * Optionally pass in `true` as `onlyCompareGenerated` to consider two
         * mappings with the same original source/line/column, but different generated
         * line and column the same. Useful when searching for a mapping with a
         * stubbed out mapping.
         */ function compareByOriginalPositions(
          mappingA,
          mappingB,
          onlyCompareOriginal
        ) {
          var cmp = mappingA.source - mappingB.source;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalLine - mappingB.originalLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalColumn - mappingB.originalColumn;
          if (cmp !== 0 || onlyCompareOriginal) {
            return cmp;
          }
          cmp = mappingA.generatedColumn - mappingB.generatedColumn;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.generatedLine - mappingB.generatedLine;
          if (cmp !== 0) {
            return cmp;
          }
          return mappingA.name - mappingB.name;
        }
        exports.compareByOriginalPositions = compareByOriginalPositions;
        /**
         * Comparator between two mappings with deflated source and name indices where
         * the generated positions are compared.
         *
         * Optionally pass in `true` as `onlyCompareGenerated` to consider two
         * mappings with the same generated line and column, but different
         * source/name/original line and column the same. Useful when searching for a
         * mapping with a stubbed out mapping.
         */ function compareByGeneratedPositionsDeflated(
          mappingA,
          mappingB,
          onlyCompareGenerated
        ) {
          var cmp = mappingA.generatedLine - mappingB.generatedLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.generatedColumn - mappingB.generatedColumn;
          if (cmp !== 0 || onlyCompareGenerated) {
            return cmp;
          }
          cmp = mappingA.source - mappingB.source;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalLine - mappingB.originalLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalColumn - mappingB.originalColumn;
          if (cmp !== 0) {
            return cmp;
          }
          return mappingA.name - mappingB.name;
        }
        exports.compareByGeneratedPositionsDeflated =
          compareByGeneratedPositionsDeflated;
        function strcmp(aStr1, aStr2) {
          if (aStr1 === aStr2) {
            return 0;
          }
          if (aStr1 > aStr2) {
            return 1;
          }
          return -1;
        }
        /**
         * Comparator between two mappings with inflated source and name strings where
         * the generated positions are compared.
         */ function compareByGeneratedPositionsInflated(mappingA, mappingB) {
          var cmp = mappingA.generatedLine - mappingB.generatedLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.generatedColumn - mappingB.generatedColumn;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = strcmp(mappingA.source, mappingB.source);
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalLine - mappingB.originalLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalColumn - mappingB.originalColumn;
          if (cmp !== 0) {
            return cmp;
          }
          return strcmp(mappingA.name, mappingB.name);
        }
        exports.compareByGeneratedPositionsInflated =
          compareByGeneratedPositionsInflated;
      })(util);
      return util;
    }
    var arraySet = {};
    var hasRequiredArraySet;
    function requireArraySet() {
      if (hasRequiredArraySet) return arraySet;
      hasRequiredArraySet = 1;
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */ var util = requireUtil();
      var has = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      /**
       * A data structure which is a combination of an array and a set. Adding a new
       * member is O(1), testing for membership is O(1), and finding the index of an
       * element is O(1). Removing elements from the set is not supported. Only
       * strings are supported for membership.
       */ function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? new Map() : Object.create(null);
      }
      /**
       * Static method for creating ArraySet instances from an existing array.
       */ ArraySet.fromArray = function ArraySet_fromArray(
        aArray,
        aAllowDuplicates
      ) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
      /**
       * Return how many unique items are in this ArraySet. If duplicates have been
       * added, than those do not count towards the size.
       *
       * @returns Number
       */ ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap
          ? this._set.size
          : Object.getOwnPropertyNames(this._set).length;
      };
      /**
       * Add the given string to this set.
       *
       * @param String aStr
       */ ArraySet.prototype.add = function ArraySet_add(
        aStr,
        aAllowDuplicates
      ) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap
          ? this.has(aStr)
          : has.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      /**
       * Is the given string a member of this set?
       *
       * @param String aStr
       */ ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has.call(this._set, sStr);
        }
      };
      /**
       * What is the index of the given string in the array?
       *
       * @param String aStr
       */ ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      /**
       * What is the element at the given index?
       *
       * @param Number aIdx
       */ ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      /**
       * Returns the array representation of this set (which has the proper indices
       * indicated by indexOf). Note that this is a copy of the internal array used
       * for storing the members so that no one can mess with internal state.
       */ ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      arraySet.ArraySet = ArraySet;
      return arraySet;
    }
    var mappingList = {};
    var hasRequiredMappingList;
    function requireMappingList() {
      if (hasRequiredMappingList) return mappingList;
      hasRequiredMappingList = 1;
      /*
       * Copyright 2014 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */ var util = requireUtil();
      /**
       * Determine whether mappingB is after mappingA with respect to generated
       * position.
       */ function generatedPositionAfter(mappingA, mappingB) {
        // Optimized for most common case
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return (
          lineB > lineA ||
          (lineB == lineA && columnB >= columnA) ||
          util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
        );
      }
      /**
       * A data structure to provide a sorted view of accumulated mappings in a
       * performance conscious manner. It trades a neglibable overhead in general
       * case for a large speedup in case of mappings being added in order.
       */ function MappingList() {
        this._array = [];
        this._sorted = true; // Serves as infimum
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      /**
       * Iterate through internal items. This method takes the same arguments that
       * `Array.prototype.forEach` takes.
       *
       * NOTE: The order of the mappings is NOT guaranteed.
       */ MappingList.prototype.unsortedForEach = function MappingList_forEach(
        aCallback,
        aThisArg
      ) {
        this._array.forEach(aCallback, aThisArg);
      };
      /**
       * Add the given source mapping.
       *
       * @param Object aMapping
       */ MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      /**
       * Returns the flat, sorted array of mappings. The mappings are sorted by
       * generated position.
       *
       * WARNING: This method returns internal data without copying, for
       * performance. The return value must NOT be mutated, and should be treated as
       * an immutable borrow. If you want to take ownership, you must make your own
       * copy.
       */ MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      mappingList.MappingList = MappingList;
      return mappingList;
    }
    var hasRequiredSourceMapGenerator;
    function requireSourceMapGenerator() {
      if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
      hasRequiredSourceMapGenerator = 1;
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */ var base64VLQ = requireBase64Vlq();
      var util = requireUtil();
      var ArraySet = requireArraySet().ArraySet;
      var MappingList = requireMappingList().MappingList;
      /**
       * An instance of the SourceMapGenerator represents a source map which is
       * being built incrementally. You may pass an object with the following
       * properties:
       *
       *   - file: The filename of the generated source.
       *   - sourceRoot: A root for all relative URLs in this source map.
       */ function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      /**
       * Creates a new SourceMapGenerator based on a SourceMapConsumer
       *
       * @param aSourceMapConsumer The SourceMap.
       */ SourceMapGenerator.fromSourceMap =
        function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
          var sourceRoot = aSourceMapConsumer.sourceRoot;
          var generator = new SourceMapGenerator({
            file: aSourceMapConsumer.file,
            sourceRoot: sourceRoot
          });
          aSourceMapConsumer.eachMapping(function (mapping) {
            var newMapping = {
              generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
              }
            };
            if (mapping.source != null) {
              newMapping.source = mapping.source;
              if (sourceRoot != null) {
                newMapping.source = util.relative(
                  sourceRoot,
                  newMapping.source
                );
              }
              newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn
              };
              if (mapping.name != null) {
                newMapping.name = mapping.name;
              }
            }
            generator.addMapping(newMapping);
          });
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              generator.setSourceContent(sourceFile, content);
            }
          });
          return generator;
        };
      /**
       * Add a single mapping from original source line and column to the generated
       * source's line and column for this source map being created. The mapping
       * object should have the following properties:
       *
       *   - generated: An object with the generated line and column positions.
       *   - original: An object with the original line and column positions.
       *   - source: The original source file (relative to the sourceRoot).
       *   - name: An optional original token name for this mapping.
       */ SourceMapGenerator.prototype.addMapping =
        function SourceMapGenerator_addMapping(aArgs) {
          var generated = util.getArg(aArgs, "generated");
          var original = util.getArg(aArgs, "original", null);
          var source = util.getArg(aArgs, "source", null);
          var name = util.getArg(aArgs, "name", null);
          if (!this._skipValidation) {
            this._validateMapping(generated, original, source, name);
          }
          if (source != null) {
            source = String(source);
            if (!this._sources.has(source)) {
              this._sources.add(source);
            }
          }
          if (name != null) {
            name = String(name);
            if (!this._names.has(name)) {
              this._names.add(name);
            }
          }
          this._mappings.add({
            generatedLine: generated.line,
            generatedColumn: generated.column,
            originalLine: original != null && original.line,
            originalColumn: original != null && original.column,
            source: source,
            name: name
          });
        };
      /**
       * Set the source content for a source file.
       */ SourceMapGenerator.prototype.setSourceContent =
        function SourceMapGenerator_setSourceContent(
          aSourceFile,
          aSourceContent
        ) {
          var source = aSourceFile;
          if (this._sourceRoot != null) {
            source = util.relative(this._sourceRoot, source);
          }
          if (aSourceContent != null) {
            // Add the source content to the _sourcesContents map.
            // Create a new _sourcesContents map if the property is null.
            if (!this._sourcesContents) {
              this._sourcesContents = Object.create(null);
            }
            this._sourcesContents[util.toSetString(source)] = aSourceContent;
          } else if (this._sourcesContents) {
            // Remove the source file from the _sourcesContents map.
            // If the _sourcesContents map is empty, set the property to null.
            delete this._sourcesContents[util.toSetString(source)];
            if (Object.keys(this._sourcesContents).length === 0) {
              this._sourcesContents = null;
            }
          }
        };
      /**
       * Applies the mappings of a sub-source-map for a specific source file to the
       * source map being generated. Each mapping to the supplied source file is
       * rewritten using the supplied source map. Note: The resolution for the
       * resulting mappings is the minimium of this map and the supplied map.
       *
       * @param aSourceMapConsumer The source map to be applied.
       * @param aSourceFile Optional. The filename of the source file.
       *        If omitted, SourceMapConsumer's file property will be used.
       * @param aSourceMapPath Optional. The dirname of the path to the source map
       *        to be applied. If relative, it is relative to the SourceMapConsumer.
       *        This parameter is needed when the two source maps aren't in the same
       *        directory, and the source map to be applied contains relative source
       *        paths. If so, those relative source paths need to be rewritten
       *        relative to the SourceMapGenerator.
       */ SourceMapGenerator.prototype.applySourceMap =
        function SourceMapGenerator_applySourceMap(
          aSourceMapConsumer,
          aSourceFile,
          aSourceMapPath
        ) {
          var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap
          if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null) {
              throw new Error(
                "SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " +
                  'or the source map\'s "file" property. Both were omitted.'
              );
            }
            sourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot; // Make "sourceFile" relative if an absolute Url is passed.
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          } // Applying the SourceMap can add and remove items from the sources and
          // the names array.
          var newSources = new ArraySet();
          var newNames = new ArraySet(); // Find mappings for the "sourceFile"
          this._mappings.unsortedForEach(function (mapping) {
            if (mapping.source === sourceFile && mapping.originalLine != null) {
              // Check if it can be mapped by the source map, then update the mapping.
              var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
              });
              if (original.source != null) {
                // Copy mapping
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                  mapping.source = util.join(aSourceMapPath, mapping.source);
                }
                if (sourceRoot != null) {
                  mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                  mapping.name = original.name;
                }
              }
            }
            var source = mapping.source;
            if (source != null && !newSources.has(source)) {
              newSources.add(source);
            }
            var name = mapping.name;
            if (name != null && !newNames.has(name)) {
              newNames.add(name);
            }
          }, this);
          this._sources = newSources;
          this._names = newNames; // Copy sourcesContents of applied map.
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
              }
              if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
              }
              this.setSourceContent(sourceFile, content);
            }
          }, this);
        };
      /**
       * A mapping can have one of the three levels of data:
       *
       *   1. Just the generated position.
       *   2. The Generated position, original position, and original source.
       *   3. Generated and original position, original source, as well as a name
       *      token.
       *
       * To maintain consistency, we validate that any new mapping being added falls
       * in to one of these categories.
       */ SourceMapGenerator.prototype._validateMapping =
        function SourceMapGenerator_validateMapping(
          aGenerated,
          aOriginal,
          aSource,
          aName
        ) {
          // When aOriginal is truthy but has empty values for .line and .column,
          // it is most likely a programmer error. In this case we throw a very
          // specific error message to try to guide them the right way.
          // For example: https://github.com/Polymer/polymer-bundler/pull/519
          if (
            aOriginal &&
            typeof aOriginal.line !== "number" &&
            typeof aOriginal.column !== "number"
          ) {
            throw new Error(
              "original.line and original.column are not numbers -- you probably meant to omit " +
                "the original mapping entirely and only map the generated position. If so, pass " +
                "null for the original mapping instead of an object with empty or null values."
            );
          }
          if (
            aGenerated &&
            "line" in aGenerated &&
            "column" in aGenerated &&
            aGenerated.line > 0 &&
            aGenerated.column >= 0 &&
            !aOriginal &&
            !aSource &&
            !aName
          ) {
            // Case 1.
            return;
          } else if (
            aGenerated &&
            "line" in aGenerated &&
            "column" in aGenerated &&
            aOriginal &&
            "line" in aOriginal &&
            "column" in aOriginal &&
            aGenerated.line > 0 &&
            aGenerated.column >= 0 &&
            aOriginal.line > 0 &&
            aOriginal.column >= 0 &&
            aSource
          ) {
            // Cases 2 and 3.
            return;
          } else {
            throw new Error(
              "Invalid mapping: " +
                JSON.stringify({
                  generated: aGenerated,
                  source: aSource,
                  original: aOriginal,
                  name: aName
                })
            );
          }
        };
      /**
       * Serialize the accumulated mappings in to the stream of base 64 VLQs
       * specified by the source map format.
       */ SourceMapGenerator.prototype._serializeMappings =
        function SourceMapGenerator_serializeMappings() {
          var previousGeneratedColumn = 0;
          var previousGeneratedLine = 1;
          var previousOriginalColumn = 0;
          var previousOriginalLine = 0;
          var previousName = 0;
          var previousSource = 0;
          var result = "";
          var next;
          var mapping;
          var nameIdx;
          var sourceIdx;
          var mappings = this._mappings.toArray();
          for (var i = 0, len = mappings.length; i < len; i++) {
            mapping = mappings[i];
            next = "";
            if (mapping.generatedLine !== previousGeneratedLine) {
              previousGeneratedColumn = 0;
              while (mapping.generatedLine !== previousGeneratedLine) {
                next += ";";
                previousGeneratedLine++;
              }
            } else {
              if (i > 0) {
                if (
                  !util.compareByGeneratedPositionsInflated(
                    mapping,
                    mappings[i - 1]
                  )
                ) {
                  continue;
                }
                next += ",";
              }
            }
            next += base64VLQ.encode(
              mapping.generatedColumn - previousGeneratedColumn
            );
            previousGeneratedColumn = mapping.generatedColumn;
            if (mapping.source != null) {
              sourceIdx = this._sources.indexOf(mapping.source);
              next += base64VLQ.encode(sourceIdx - previousSource);
              previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3
              next += base64VLQ.encode(
                mapping.originalLine - 1 - previousOriginalLine
              );
              previousOriginalLine = mapping.originalLine - 1;
              next += base64VLQ.encode(
                mapping.originalColumn - previousOriginalColumn
              );
              previousOriginalColumn = mapping.originalColumn;
              if (mapping.name != null) {
                nameIdx = this._names.indexOf(mapping.name);
                next += base64VLQ.encode(nameIdx - previousName);
                previousName = nameIdx;
              }
            }
            result += next;
          }
          return result;
        };
      SourceMapGenerator.prototype._generateSourcesContent =
        function SourceMapGenerator_generateSourcesContent(
          aSources,
          aSourceRoot
        ) {
          return aSources.map(function (source) {
            if (!this._sourcesContents) {
              return null;
            }
            if (aSourceRoot != null) {
              source = util.relative(aSourceRoot, source);
            }
            var key = util.toSetString(source);
            return Object.prototype.hasOwnProperty.call(
              this._sourcesContents,
              key
            )
              ? this._sourcesContents[key]
              : null;
          }, this);
        };
      /**
       * Externalize the source map.
       */ SourceMapGenerator.prototype.toJSON =
        function SourceMapGenerator_toJSON() {
          var map = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings()
          };
          if (this._file != null) {
            map.file = this._file;
          }
          if (this._sourceRoot != null) {
            map.sourceRoot = this._sourceRoot;
          }
          if (this._sourcesContents) {
            map.sourcesContent = this._generateSourcesContent(
              map.sources,
              map.sourceRoot
            );
          }
          return map;
        };
      /**
       * Render the source map being generated to a string.
       */ SourceMapGenerator.prototype.toString =
        function SourceMapGenerator_toString() {
          return JSON.stringify(this.toJSON());
        };
      sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
      return sourceMapGenerator;
    }
    var sourceMapConsumer = {};
    var binarySearch = {};
    var hasRequiredBinarySearch;
    function requireBinarySearch() {
      if (hasRequiredBinarySearch) return binarySearch;
      hasRequiredBinarySearch = 1;
      (function (exports) {
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */ exports.GREATEST_LOWER_BOUND = 1;
        exports.LEAST_UPPER_BOUND = 2;
        /**
         * Recursive implementation of binary search.
         *
         * @param aLow Indices here and lower do not contain the needle.
         * @param aHigh Indices here and higher do not contain the needle.
         * @param aNeedle The element being searched for.
         * @param aHaystack The non-empty array being searched.
         * @param aCompare Function which takes two elements and returns -1, 0, or 1.
         * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
         *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
         *     closest element that is smaller than or greater than the one we are
         *     searching for, respectively, if the exact element cannot be found.
         */ function recursiveSearch(
          aLow,
          aHigh,
          aNeedle,
          aHaystack,
          aCompare,
          aBias
        ) {
          // This function terminates when one of the following is true:
          //
          //   1. We find the exact element we are looking for.
          //
          //   2. We did not find the exact element, but we can return the index of
          //      the next-closest element.
          //
          //   3. We did not find the exact element, and there is no next-closest
          //      element than the one we are searching for, so we return -1.
          var mid = Math.floor((aHigh - aLow) / 2) + aLow;
          var cmp = aCompare(aNeedle, aHaystack[mid], true);
          if (cmp === 0) {
            // Found the element we are looking for.
            return mid;
          } else if (cmp > 0) {
            // Our needle is greater than aHaystack[mid].
            if (aHigh - mid > 1) {
              // The element is in the upper half.
              return recursiveSearch(
                mid,
                aHigh,
                aNeedle,
                aHaystack,
                aCompare,
                aBias
              );
            } // The exact needle element was not found in this haystack. Determine if
            // we are in termination case (3) or (2) and return the appropriate thing.
            if (aBias == exports.LEAST_UPPER_BOUND) {
              return aHigh < aHaystack.length ? aHigh : -1;
            } else {
              return mid;
            }
          } else {
            // Our needle is less than aHaystack[mid].
            if (mid - aLow > 1) {
              // The element is in the lower half.
              return recursiveSearch(
                aLow,
                mid,
                aNeedle,
                aHaystack,
                aCompare,
                aBias
              );
            } // we are in termination case (3) or (2) and return the appropriate thing.
            if (aBias == exports.LEAST_UPPER_BOUND) {
              return mid;
            } else {
              return aLow < 0 ? -1 : aLow;
            }
          }
        }
        /**
         * This is an implementation of binary search which will always try and return
         * the index of the closest element if there is no exact hit. This is because
         * mappings between original and generated line/col pairs are single points,
         * and there is an implicit region between each of them, so a miss just means
         * that you aren't on the very start of a region.
         *
         * @param aNeedle The element you are looking for.
         * @param aHaystack The array that is being searched.
         * @param aCompare A function which takes the needle and an element in the
         *     array and returns -1, 0, or 1 depending on whether the needle is less
         *     than, equal to, or greater than the element, respectively.
         * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
         *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
         *     closest element that is smaller than or greater than the one we are
         *     searching for, respectively, if the exact element cannot be found.
         *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
         */ exports.search = function search(
          aNeedle,
          aHaystack,
          aCompare,
          aBias
        ) {
          if (aHaystack.length === 0) {
            return -1;
          }
          var index = recursiveSearch(
            -1,
            aHaystack.length,
            aNeedle,
            aHaystack,
            aCompare,
            aBias || exports.GREATEST_LOWER_BOUND
          );
          if (index < 0) {
            return -1;
          } // We have found either the exact element, or the next-closest element than
          // the one we are searching for. However, there may be more than one such
          // element. Make sure we always return the smallest of these.
          while (index - 1 >= 0) {
            if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
              break;
            }
            --index;
          }
          return index;
        };
      })(binarySearch);
      return binarySearch;
    }
    var quickSort = {};
    var hasRequiredQuickSort;
    function requireQuickSort() {
      if (hasRequiredQuickSort) return quickSort;
      hasRequiredQuickSort = 1; /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */ // It turns out that some (most?) JavaScript engines don't self-host
      // `Array.prototype.sort`. This makes sense because C++ will likely remain
      // faster than JS when doing raw CPU-intensive sorting. However, when using a
      // custom comparator function, calling back and forth between the VM's C++ and
      // JIT'd JS is rather slow *and* loses JIT type information, resulting in
      // worse generated code for the comparator function than would be optimal. In
      // fact, when sorting with a comparator, these costs outweigh the benefits of
      // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
      // a ~3500ms mean speed-up in `bench/bench.html`.
      /**
       * Swap the elements indexed by `x` and `y` in the array `ary`.
       *
       * @param {Array} ary
       *        The array.
       * @param {Number} x
       *        The index of the first item.
       * @param {Number} y
       *        The index of the second item.
       */ function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }
      /**
       * Returns a random integer within the range `low .. high` inclusive.
       *
       * @param {Number} low
       *        The lower bound on the range.
       * @param {Number} high
       *        The upper bound on the range.
       */ function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      /**
       * The Quick Sort algorithm.
       *
       * @param {Array} ary
       *        An array to sort.
       * @param {function} comparator
       *        Function to use to compare two items.
       * @param {Number} p
       *        Start index of the array
       * @param {Number} r
       *        End index of the array
       */ function doQuickSort(ary, comparator, p, r) {
        // If our lower bound is less than our upper bound, we (1) partition the
        // array into two pieces and (2) recurse on each half. If it is not, this is
        // the empty array and our base case.
        if (p < r) {
          // (1) Partitioning.
          //
          // The partitioning chooses a pivot between `p` and `r` and moves all
          // elements that are less than or equal to the pivot to the before it, and
          // all the elements that are greater than it after it. The effect is that
          // once partition is done, the pivot is in the exact place it will be when
          // the array is put in sorted order, and it will not need to be moved
          // again. This runs in O(n) time.
          // Always choose a random pivot so that an input array which is reverse
          // sorted does not cause O(n^2) running time.
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;
          swap(ary, pivotIndex, r);
          var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold
          // true:
          //
          //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
          //
          //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
          for (var j = p; j < r; j++) {
            if (comparator(ary[j], pivot) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }
          swap(ary, i + 1, j);
          var q = i + 1; // (2) Recurse on each half.
          doQuickSort(ary, comparator, p, q - 1);
          doQuickSort(ary, comparator, q + 1, r);
        }
      }
      /**
       * Sort the given array in-place with the given comparator function.
       *
       * @param {Array} ary
       *        An array to sort.
       * @param {function} comparator
       *        Function to use to compare two items.
       */ quickSort.quickSort = function (ary, comparator) {
        doQuickSort(ary, comparator, 0, ary.length - 1);
      };
      return quickSort;
    }
    var hasRequiredSourceMapConsumer;
    function requireSourceMapConsumer() {
      if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
      hasRequiredSourceMapConsumer = 1;
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */ var util = requireUtil();
      var binarySearch = requireBinarySearch();
      var ArraySet = requireArraySet().ArraySet;
      var base64VLQ = requireBase64Vlq();
      var quickSort = requireQuickSort().quickSort;
      function SourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
        }
        return sourceMap.sections != null
          ? new IndexedSourceMapConsumer(sourceMap)
          : new BasicSourceMapConsumer(sourceMap);
      }
      SourceMapConsumer.fromSourceMap = function (aSourceMap) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
      };
      /**
       * The version of the source mapping spec that we are consuming.
       */ SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the
      // parsed mapping coordinates from the source map's "mappings" attribute. They
      // are lazily instantiated, accessed via the `_generatedMappings` and
      // `_originalMappings` getters respectively, and we only parse the mappings
      // and create these arrays once queried for a source location. We jump through
      // these hoops because there can be many thousands of mappings, and parsing
      // them is expensive, so we only want to do it if we must.
      //
      // Each object in the arrays is of the form:
      //
      //     {
      //       generatedLine: The line number in the generated code,
      //       generatedColumn: The column number in the generated code,
      //       source: The path to the original source file that generated this
      //               chunk of code,
      //       originalLine: The line number in the original source that
      //                     corresponds to this chunk of generated code,
      //       originalColumn: The column number in the original source that
      //                       corresponds to this chunk of generated code,
      //       name: The name of the original symbol which generated this chunk of
      //             code.
      //     }
      //
      // All properties except for `generatedLine` and `generatedColumn` can be
      // `null`.
      //
      // `_generatedMappings` is ordered by the generated positions.
      //
      // `_originalMappings` is ordered by the original positions.
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
        get: function get() {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }
      });
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
        get: function get() {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }
      });
      SourceMapConsumer.prototype._charIsMappingSeparator =
        function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
          var c = aStr.charAt(index);
          return c === ";" || c === ",";
        };
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */ SourceMapConsumer.prototype._parseMappings =
        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          throw new Error("Subclasses must implement _parseMappings");
        };
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;
      /**
       * Iterate over each mapping between an original source/line/column and a
       * generated line/column in this source map.
       *
       * @param Function aCallback
       *        The function that is called with each mapping.
       * @param Object aContext
       *        Optional. If specified, this object will be the value of `this` every
       *        time that `aCallback` is called.
       * @param aOrder
       *        Either `SourceMapConsumer.GENERATED_ORDER` or
       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       *        iterate over the mappings sorted by the generated file's line/column
       *        order or the original's source/line/column order, respectively. Defaults to
       *        `SourceMapConsumer.GENERATED_ORDER`.
       */ SourceMapConsumer.prototype.eachMapping =
        function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
          var context = aContext || null;
          var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
          var mappings;
          switch (order) {
            case SourceMapConsumer.GENERATED_ORDER:
              mappings = this._generatedMappings;
              break;
            case SourceMapConsumer.ORIGINAL_ORDER:
              mappings = this._originalMappings;
              break;
            default:
              throw new Error("Unknown order of iteration.");
          }
          var sourceRoot = this.sourceRoot;
          mappings
            .map(function (mapping) {
              var source =
                mapping.source === null
                  ? null
                  : this._sources.at(mapping.source);
              if (source != null && sourceRoot != null) {
                source = util.join(sourceRoot, source);
              }
              return {
                source: source,
                generatedLine: mapping.generatedLine,
                generatedColumn: mapping.generatedColumn,
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name:
                  mapping.name === null ? null : this._names.at(mapping.name)
              };
            }, this)
            .forEach(aCallback, context);
        };
      /**
       * Returns all generated line and column information for the original source,
       * line, and column provided. If no column is provided, returns all mappings
       * corresponding to a either the line we are searching for or the next
       * closest line that has any mappings. Otherwise, returns all mappings
       * corresponding to the given line and either the column we are searching for
       * or the next closest column that has any offsets.
       *
       * The only argument is an object with the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: Optional. the column number in the original source.
       *
       * and an array of objects is returned, each with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */ SourceMapConsumer.prototype.allGeneratedPositionsFor =
        function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
          var line = util.getArg(aArgs, "line"); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
          // returns the index of the closest mapping less than the needle. By
          // setting needle.originalColumn to 0, we thus find the last mapping for
          // the given line, provided such a mapping exists.
          var needle = {
            source: util.getArg(aArgs, "source"),
            originalLine: line,
            originalColumn: util.getArg(aArgs, "column", 0)
          };
          if (this.sourceRoot != null) {
            needle.source = util.relative(this.sourceRoot, needle.source);
          }
          if (!this._sources.has(needle.source)) {
            return [];
          }
          needle.source = this._sources.indexOf(needle.source);
          var mappings = [];
          var index = this._findMapping(
            needle,
            this._originalMappings,
            "originalLine",
            "originalColumn",
            util.compareByOriginalPositions,
            binarySearch.LEAST_UPPER_BOUND
          );
          if (index >= 0) {
            var mapping = this._originalMappings[index];
            if (aArgs.column === undefined) {
              var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into
              // a mapping for a different line than the one we found. Since
              // mappings are sorted, this is guaranteed to find all mappings for
              // the line we found.
              while (mapping && mapping.originalLine === originalLine) {
                mappings.push({
                  line: util.getArg(mapping, "generatedLine", null),
                  column: util.getArg(mapping, "generatedColumn", null),
                  lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
                });
                mapping = this._originalMappings[++index];
              }
            } else {
              var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into
              // a mapping for a different line than the one we were searching for.
              // Since mappings are sorted, this is guaranteed to find all mappings for
              // the line we are searching for.
              while (
                mapping &&
                mapping.originalLine === line &&
                mapping.originalColumn == originalColumn
              ) {
                mappings.push({
                  line: util.getArg(mapping, "generatedLine", null),
                  column: util.getArg(mapping, "generatedColumn", null),
                  lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
                });
                mapping = this._originalMappings[++index];
              }
            }
          }
          return mappings;
        };
      sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;
      /**
       * A BasicSourceMapConsumer instance represents a parsed source map which we can
       * query for information about the original file positions by giving it a file
       * position in the generated source.
       *
       * The only parameter is the raw source map (either as a JSON string, or
       * already parsed to an object). According to the spec, source maps have the
       * following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - sources: An array of URLs to the original source files.
       *   - names: An array of identifiers which can be referrenced by individual mappings.
       *   - sourceRoot: Optional. The URL root from which all sources are relative.
       *   - sourcesContent: Optional. An array of contents of the original source files.
       *   - mappings: A string of base64 VLQs which contain the actual mappings.
       *   - file: Optional. The generated file this source map is associated with.
       *
       * Here is an example source map, taken from the source map spec[0]:
       *
       *     {
       *       version : 3,
       *       file: "out.js",
       *       sourceRoot : "",
       *       sources: ["foo.js", "bar.js"],
       *       names: ["src", "maps", "are", "fun"],
       *       mappings: "AA,AB;;ABCDE;"
       *     }
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
       */ function BasicSourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
        }
        var version = util.getArg(sourceMap, "version");
        var sources = util.getArg(sourceMap, "sources"); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
        // requires the array) to play nice here.
        var names = util.getArg(sourceMap, "names", []);
        var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
        var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
        var mappings = util.getArg(sourceMap, "mappings");
        var file = util.getArg(sourceMap, "file", null); // Once again, Sass deviates from the spec and supplies the version as a
        // string rather than a number, so we use loose equality checking here.
        if (version != this._version) {
          throw new Error("Unsupported version: " + version);
        }
        sources = sources
          .map(String) // Some source maps produce relative source paths like "./foo.js" instead of
          // "foo.js".  Normalize these first so that future comparisons will succeed.
          // See bugzil.la/1090768.
          .map(util.normalize) // Always ensure that absolute sources are internally stored relative to
          // the source root, if the source root is absolute. Not doing this would
          // be particularly problematic when the source root is a prefix of the
          // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
          .map(function (source) {
            return sourceRoot &&
              util.isAbsolute(sourceRoot) &&
              util.isAbsolute(source)
              ? util.relative(sourceRoot, source)
              : source;
          }); // Pass `true` below to allow duplicate names and sources. While source maps
        // are intended to be compressed and deduplicated, the TypeScript compiler
        // sometimes generates source maps with duplicates in them. See Github issue
        // #72 and bugzil.la/889492.
        this._names = ArraySet.fromArray(names.map(String), true);
        this._sources = ArraySet.fromArray(sources, true);
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this.file = file;
      }
      BasicSourceMapConsumer.prototype = Object.create(
        SourceMapConsumer.prototype
      );
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
      /**
       * Create a BasicSourceMapConsumer from a SourceMapGenerator.
       *
       * @param SourceMapGenerator aSourceMap
       *        The source map that will be consumed.
       * @returns BasicSourceMapConsumer
       */ BasicSourceMapConsumer.fromSourceMap =
        function SourceMapConsumer_fromSourceMap(aSourceMap) {
          var smc = Object.create(BasicSourceMapConsumer.prototype);
          var names = (smc._names = ArraySet.fromArray(
            aSourceMap._names.toArray(),
            true
          ));
          var sources = (smc._sources = ArraySet.fromArray(
            aSourceMap._sources.toArray(),
            true
          ));
          smc.sourceRoot = aSourceMap._sourceRoot;
          smc.sourcesContent = aSourceMap._generateSourcesContent(
            smc._sources.toArray(),
            smc.sourceRoot
          );
          smc.file = aSourceMap._file; // Because we are modifying the entries (by converting string sources and
          // names to indices into the sources and names ArraySets), we have to make
          // a copy of the entry or else bad things happen. Shared mutable state
          // strikes again! See github issue #191.
          var generatedMappings = aSourceMap._mappings.toArray().slice();
          var destGeneratedMappings = (smc.__generatedMappings = []);
          var destOriginalMappings = (smc.__originalMappings = []);
          for (var i = 0, length = generatedMappings.length; i < length; i++) {
            var srcMapping = generatedMappings[i];
            var destMapping = new Mapping();
            destMapping.generatedLine = srcMapping.generatedLine;
            destMapping.generatedColumn = srcMapping.generatedColumn;
            if (srcMapping.source) {
              destMapping.source = sources.indexOf(srcMapping.source);
              destMapping.originalLine = srcMapping.originalLine;
              destMapping.originalColumn = srcMapping.originalColumn;
              if (srcMapping.name) {
                destMapping.name = names.indexOf(srcMapping.name);
              }
              destOriginalMappings.push(destMapping);
            }
            destGeneratedMappings.push(destMapping);
          }
          quickSort(smc.__originalMappings, util.compareByOriginalPositions);
          return smc;
        };
      /**
       * The version of the source mapping spec that we are consuming.
       */ BasicSourceMapConsumer.prototype._version = 3;
      /**
       * The list of original sources.
       */ Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
        get: function get() {
          return this._sources.toArray().map(function (s) {
            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
          }, this);
        }
      });
      /**
       * Provide the JIT with a nice shape / hidden class.
       */ function Mapping() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */ BasicSourceMapConsumer.prototype._parseMappings =
        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          var generatedLine = 1;
          var previousGeneratedColumn = 0;
          var previousOriginalLine = 0;
          var previousOriginalColumn = 0;
          var previousSource = 0;
          var previousName = 0;
          var length = aStr.length;
          var index = 0;
          var cachedSegments = {};
          var temp = {};
          var originalMappings = [];
          var generatedMappings = [];
          var mapping, str, segment, end, value;
          while (index < length) {
            if (aStr.charAt(index) === ";") {
              generatedLine++;
              index++;
              previousGeneratedColumn = 0;
            } else if (aStr.charAt(index) === ",") {
              index++;
            } else {
              mapping = new Mapping();
              mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,
              // many segments often have the same encoding. We can exploit this
              // fact by caching the parsed variable length fields of each segment,
              // allowing us to avoid a second parse if we encounter the same
              // segment again.
              for (end = index; end < length; end++) {
                if (this._charIsMappingSeparator(aStr, end)) {
                  break;
                }
              }
              str = aStr.slice(index, end);
              segment = cachedSegments[str];
              if (segment) {
                index += str.length;
              } else {
                segment = [];
                while (index < end) {
                  base64VLQ.decode(aStr, index, temp);
                  value = temp.value;
                  index = temp.rest;
                  segment.push(value);
                }
                if (segment.length === 2) {
                  throw new Error("Found a source, but no line and column");
                }
                if (segment.length === 3) {
                  throw new Error("Found a source and line, but no column");
                }
                cachedSegments[str] = segment;
              } // Generated column.
              mapping.generatedColumn = previousGeneratedColumn + segment[0];
              previousGeneratedColumn = mapping.generatedColumn;
              if (segment.length > 1) {
                // Original source.
                mapping.source = previousSource + segment[1];
                previousSource += segment[1]; // Original line.
                mapping.originalLine = previousOriginalLine + segment[2];
                previousOriginalLine = mapping.originalLine; // Lines are stored 0-based
                mapping.originalLine += 1; // Original column.
                mapping.originalColumn = previousOriginalColumn + segment[3];
                previousOriginalColumn = mapping.originalColumn;
                if (segment.length > 4) {
                  // Original name.
                  mapping.name = previousName + segment[4];
                  previousName += segment[4];
                }
              }
              generatedMappings.push(mapping);
              if (typeof mapping.originalLine === "number") {
                originalMappings.push(mapping);
              }
            }
          }
          quickSort(
            generatedMappings,
            util.compareByGeneratedPositionsDeflated
          );
          this.__generatedMappings = generatedMappings;
          quickSort(originalMappings, util.compareByOriginalPositions);
          this.__originalMappings = originalMappings;
        };
      /**
       * Find the mapping that best matches the hypothetical "needle" mapping that
       * we are searching for in the given "haystack" of mappings.
       */ BasicSourceMapConsumer.prototype._findMapping =
        function SourceMapConsumer_findMapping(
          aNeedle,
          aMappings,
          aLineName,
          aColumnName,
          aComparator,
          aBias
        ) {
          // To return the position we are searching for, we must first find the
          // mapping for the given position and then return the opposite position it
          // points to. Because the mappings are sorted, we can use binary search to
          // find the best mapping.
          if (aNeedle[aLineName] <= 0) {
            throw new TypeError(
              "Line must be greater than or equal to 1, got " +
                aNeedle[aLineName]
            );
          }
          if (aNeedle[aColumnName] < 0) {
            throw new TypeError(
              "Column must be greater than or equal to 0, got " +
                aNeedle[aColumnName]
            );
          }
          return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
        };
      /**
       * Compute the last column for each generated mapping. The last column is
       * inclusive.
       */ BasicSourceMapConsumer.prototype.computeColumnSpans =
        function SourceMapConsumer_computeColumnSpans() {
          for (var index = 0; index < this._generatedMappings.length; ++index) {
            var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We
            // can come up with an optimistic estimate, however, by assuming that
            // mappings are contiguous (i.e. given two consecutive mappings, the
            // first mapping ends where the second one starts).
            if (index + 1 < this._generatedMappings.length) {
              var nextMapping = this._generatedMappings[index + 1];
              if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
              }
            } // The last mapping for each line spans the entire line.
            mapping.lastGeneratedColumn = Infinity;
          }
        };
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.
       *   - column: The column number in the generated source.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.
       *   - column: The column number in the original source, or null.
       *   - name: The original identifier, or null.
       */ BasicSourceMapConsumer.prototype.originalPositionFor =
        function SourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {
            generatedLine: util.getArg(aArgs, "line"),
            generatedColumn: util.getArg(aArgs, "column")
          };
          var index = this._findMapping(
            needle,
            this._generatedMappings,
            "generatedLine",
            "generatedColumn",
            util.compareByGeneratedPositionsDeflated,
            util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
          );
          if (index >= 0) {
            var mapping = this._generatedMappings[index];
            if (mapping.generatedLine === needle.generatedLine) {
              var source = util.getArg(mapping, "source", null);
              if (source !== null) {
                source = this._sources.at(source);
                if (this.sourceRoot != null) {
                  source = util.join(this.sourceRoot, source);
                }
              }
              var name = util.getArg(mapping, "name", null);
              if (name !== null) {
                name = this._names.at(name);
              }
              return {
                source: source,
                line: util.getArg(mapping, "originalLine", null),
                column: util.getArg(mapping, "originalColumn", null),
                name: name
              };
            }
          }
          return { source: null, line: null, column: null, name: null };
        };
      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */ BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
        function BasicSourceMapConsumer_hasContentsOfAllSources() {
          if (!this.sourcesContent) {
            return false;
          }
          return (
            this.sourcesContent.length >= this._sources.size() &&
            !this.sourcesContent.some(function (sc) {
              return sc == null;
            })
          );
        };
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */ BasicSourceMapConsumer.prototype.sourceContentFor =
        function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          if (!this.sourcesContent) {
            return null;
          }
          if (this.sourceRoot != null) {
            aSource = util.relative(this.sourceRoot, aSource);
          }
          if (this._sources.has(aSource)) {
            return this.sourcesContent[this._sources.indexOf(aSource)];
          }
          var url;
          if (
            this.sourceRoot != null &&
            (url = util.urlParse(this.sourceRoot))
          ) {
            // XXX: file:// URIs and absolute paths lead to unexpected behavior for
            // many users. We can help them out when they expect file:// URIs to
            // behave like it would if they were running a local HTTP server. See
            // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
            var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
            if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
              return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
            }
            if (
              (!url.path || url.path == "/") &&
              this._sources.has("/" + aSource)
            ) {
              return this.sourcesContent[this._sources.indexOf("/" + aSource)];
            }
          } // This function is used recursively from
          // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
          // don't want to throw if we can't find the source - we just want to
          // return null, so we provide a flag to exit gracefully.
          if (nullOnMissing) {
            return null;
          } else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
          }
        };
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: The column number in the original source.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */ BasicSourceMapConsumer.prototype.generatedPositionFor =
        function SourceMapConsumer_generatedPositionFor(aArgs) {
          var source = util.getArg(aArgs, "source");
          if (this.sourceRoot != null) {
            source = util.relative(this.sourceRoot, source);
          }
          if (!this._sources.has(source)) {
            return { line: null, column: null, lastColumn: null };
          }
          source = this._sources.indexOf(source);
          var needle = {
            source: source,
            originalLine: util.getArg(aArgs, "line"),
            originalColumn: util.getArg(aArgs, "column")
          };
          var index = this._findMapping(
            needle,
            this._originalMappings,
            "originalLine",
            "originalColumn",
            util.compareByOriginalPositions,
            util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
          );
          if (index >= 0) {
            var mapping = this._originalMappings[index];
            if (mapping.source === needle.source) {
              return {
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              };
            }
          }
          return { line: null, column: null, lastColumn: null };
        };
      sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
      /**
       * An IndexedSourceMapConsumer instance represents a parsed source map which
       * we can query for information. It differs from BasicSourceMapConsumer in
       * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
       * input.
       *
       * The only parameter is a raw source map (either as a JSON string, or already
       * parsed to an object). According to the spec for indexed source maps, they
       * have the following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - file: Optional. The generated file this source map is associated with.
       *   - sections: A list of section definitions.
       *
       * Each value under the "sections" field has two fields:
       *   - offset: The offset into the original specified at which this section
       *       begins to apply, defined as an object with a "line" and "column"
       *       field.
       *   - map: A source map definition. This source map could also be indexed,
       *       but doesn't have to be.
       *
       * Instead of the "map" field, it's also possible to have a "url" field
       * specifying a URL to retrieve a source map from, but that's currently
       * unsupported.
       *
       * Here's an example source map, taken from the source map spec[0], but
       * modified to omit a section which uses the "url" field.
       *
       *  {
       *    version : 3,
       *    file: "app.js",
       *    sections: [{
       *      offset: {line:100, column:10},
       *      map: {
       *        version : 3,
       *        file: "section.js",
       *        sources: ["foo.js", "bar.js"],
       *        names: ["src", "maps", "are", "fun"],
       *        mappings: "AAAA,E;;ABCDE;"
       *      }
       *    }],
       *  }
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
       */ function IndexedSourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
        }
        var version = util.getArg(sourceMap, "version");
        var sections = util.getArg(sourceMap, "sections");
        if (version != this._version) {
          throw new Error("Unsupported version: " + version);
        }
        this._sources = new ArraySet();
        this._names = new ArraySet();
        var lastOffset = { line: -1, column: 0 };
        this._sections = sections.map(function (s) {
          if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error(
              "Support for url field in sections not implemented."
            );
          }
          var offset = util.getArg(s, "offset");
          var offsetLine = util.getArg(offset, "line");
          var offsetColumn = util.getArg(offset, "column");
          if (
            offsetLine < lastOffset.line ||
            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
          ) {
            throw new Error(
              "Section offsets must be ordered and non-overlapping."
            );
          }
          lastOffset = offset;
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, "map"))
          };
        });
      }
      IndexedSourceMapConsumer.prototype = Object.create(
        SourceMapConsumer.prototype
      );
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
      /**
       * The version of the source mapping spec that we are consuming.
       */ IndexedSourceMapConsumer.prototype._version = 3;
      /**
       * The list of original sources.
       */ Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
        get: function get() {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (
              var j = 0;
              j < this._sections[i].consumer.sources.length;
              j++
            ) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          }
          return sources;
        }
      });
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.
       *   - column: The column number in the generated source.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.
       *   - column: The column number in the original source, or null.
       *   - name: The original identifier, or null.
       */ IndexedSourceMapConsumer.prototype.originalPositionFor =
        function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {
            generatedLine: util.getArg(aArgs, "line"),
            generatedColumn: util.getArg(aArgs, "column")
          }; // Find the section containing the generated position we're trying to map
          // to an original position.
          var sectionIndex = binarySearch.search(
            needle,
            this._sections,
            function (needle, section) {
              var cmp =
                needle.generatedLine - section.generatedOffset.generatedLine;
              if (cmp) {
                return cmp;
              }
              return (
                needle.generatedColumn - section.generatedOffset.generatedColumn
              );
            }
          );
          var section = this._sections[sectionIndex];
          if (!section) {
            return { source: null, line: null, column: null, name: null };
          }
          return section.consumer.originalPositionFor({
            line:
              needle.generatedLine -
              (section.generatedOffset.generatedLine - 1),
            column:
              needle.generatedColumn -
              (section.generatedOffset.generatedLine === needle.generatedLine
                ? section.generatedOffset.generatedColumn - 1
                : 0),
            bias: aArgs.bias
          });
        };
      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */ IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
        function IndexedSourceMapConsumer_hasContentsOfAllSources() {
          return this._sections.every(function (s) {
            return s.consumer.hasContentsOfAllSources();
          });
        };
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */ IndexedSourceMapConsumer.prototype.sourceContentFor =
        function IndexedSourceMapConsumer_sourceContentFor(
          aSource,
          nullOnMissing
        ) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            var content = section.consumer.sourceContentFor(aSource, true);
            if (content) {
              return content;
            }
          }
          if (nullOnMissing) {
            return null;
          } else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
          }
        };
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: The column number in the original source.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */ IndexedSourceMapConsumer.prototype.generatedPositionFor =
        function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i]; // Only consider this section if the requested source is in the list of
            // sources of the consumer.
            if (
              section.consumer.sources.indexOf(util.getArg(aArgs, "source")) ===
              -1
            ) {
              continue;
            }
            var generatedPosition =
              section.consumer.generatedPositionFor(aArgs);
            if (generatedPosition) {
              var ret = {
                line:
                  generatedPosition.line +
                  (section.generatedOffset.generatedLine - 1),
                column:
                  generatedPosition.column +
                  (section.generatedOffset.generatedLine ===
                  generatedPosition.line
                    ? section.generatedOffset.generatedColumn - 1
                    : 0)
              };
              return ret;
            }
          }
          return { line: null, column: null };
        };
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */ IndexedSourceMapConsumer.prototype._parseMappings =
        function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          this.__generatedMappings = [];
          this.__originalMappings = [];
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            var sectionMappings = section.consumer._generatedMappings;
            for (var j = 0; j < sectionMappings.length; j++) {
              var mapping = sectionMappings[j];
              var source = section.consumer._sources.at(mapping.source);
              if (section.consumer.sourceRoot !== null) {
                source = util.join(section.consumer.sourceRoot, source);
              }
              this._sources.add(source);
              source = this._sources.indexOf(source);
              var name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name); // The mappings coming from the consumer for the section have
              // generated positions relative to the start of the section, so we
              // need to offset them to be relative to the start of the concatenated
              // generated file.
              var adjustedMapping = {
                source: source,
                generatedLine:
                  mapping.generatedLine +
                  (section.generatedOffset.generatedLine - 1),
                generatedColumn:
                  mapping.generatedColumn +
                  (section.generatedOffset.generatedLine ===
                  mapping.generatedLine
                    ? section.generatedOffset.generatedColumn - 1
                    : 0),
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name: name
              };
              this.__generatedMappings.push(adjustedMapping);
              if (typeof adjustedMapping.originalLine === "number") {
                this.__originalMappings.push(adjustedMapping);
              }
            }
          }
          quickSort(
            this.__generatedMappings,
            util.compareByGeneratedPositionsDeflated
          );
          quickSort(this.__originalMappings, util.compareByOriginalPositions);
        };
      sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
      return sourceMapConsumer;
    }
    var sourceNode = {};
    var hasRequiredSourceNode;
    function requireSourceNode() {
      if (hasRequiredSourceNode) return sourceNode;
      hasRequiredSourceNode = 1;
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */ var SourceMapGenerator =
        requireSourceMapGenerator().SourceMapGenerator;
      var util = requireUtil(); // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
      // operating systems these days (capturing the result).
      var REGEX_NEWLINE = /(\r?\n)/; // Newline character code for charCodeAt() comparisons
      var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of
      // the source-map library are loaded. This MUST NOT CHANGE across
      // versions!
      var isSourceNode = "$$$isSourceNode$$$";
      /**
       * SourceNodes provide a way to abstract over interpolating/concatenating
       * snippets of generated JavaScript source code while maintaining the line and
       * column information associated with the original source code.
       *
       * @param aLine The original line number.
       * @param aColumn The original column number.
       * @param aSource The original source's filename.
       * @param aChunks Optional. An array of strings which are snippets of
       *        generated JS, or other SourceNodes.
       * @param aName The original identifier.
       */ function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null) this.add(aChunks);
      }
      /**
       * Creates a SourceNode from generated code and a SourceMapConsumer.
       *
       * @param aGeneratedCode The generated code
       * @param aSourceMapConsumer The SourceMap for the generated code
       * @param aRelativePath Optional. The path that relative sources in the
       *        SourceMapConsumer should be relative to.
       */ SourceNode.fromStringWithSourceMap =
        function SourceNode_fromStringWithSourceMap(
          aGeneratedCode,
          aSourceMapConsumer,
          aRelativePath
        ) {
          // The SourceNode we want to fill with the generated code
          // and the SourceMap
          var node = new SourceNode(); // All even indices of this array are one line of the generated code,
          // while all odd indices are the newlines between two adjacent lines
          // (since `REGEX_NEWLINE` captures its match).
          // Processed fragments are accessed by calling `shiftNextLine`.
          var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
          var remainingLinesIndex = 0;
          var shiftNextLine = function shiftNextLine() {
            var lineContents = getNextLine(); // The last line of a file might not have a newline.
            var newLine = getNextLine() || "";
            return lineContents + newLine;
            function getNextLine() {
              return remainingLinesIndex < remainingLines.length
                ? remainingLines[remainingLinesIndex++]
                : undefined;
            }
          }; // We need to remember the position of "remainingLines"
          var lastGeneratedLine = 1,
            lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.
          // To extract it current and last mapping is used.
          // Here we store the last mapping.
          var lastMapping = null;
          aSourceMapConsumer.eachMapping(function (mapping) {
            if (lastMapping !== null) {
              // We add the code from "lastMapping" to "mapping":
              // First check if there is a new line in between.
              if (lastGeneratedLine < mapping.generatedLine) {
                // Associate first line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = 0; // The remaining code is added without mapping
              } else {
                // There is no new line in between.
                // Associate the code between "lastGeneratedColumn" and
                // "mapping.generatedColumn" with "lastMapping"
                var nextLine = remainingLines[remainingLinesIndex];
                var code = nextLine.substr(
                  0,
                  mapping.generatedColumn - lastGeneratedColumn
                );
                remainingLines[remainingLinesIndex] = nextLine.substr(
                  mapping.generatedColumn - lastGeneratedColumn
                );
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code); // No more remaining code, continue
                lastMapping = mapping;
                return;
              }
            } // We add the generated code until the first mapping
            // to the SourceNode without any mapping.
            // Each line is added as separate string.
            while (lastGeneratedLine < mapping.generatedLine) {
              node.add(shiftNextLine());
              lastGeneratedLine++;
            }
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[remainingLinesIndex];
              node.add(nextLine.substr(0, mapping.generatedColumn));
              remainingLines[remainingLinesIndex] = nextLine.substr(
                mapping.generatedColumn
              );
              lastGeneratedColumn = mapping.generatedColumn;
            }
            lastMapping = mapping;
          }, this); // We have processed all mappings.
          if (remainingLinesIndex < remainingLines.length) {
            if (lastMapping) {
              // Associate the remaining code in the current line with "lastMapping"
              addMappingWithCode(lastMapping, shiftNextLine());
            } // and add the remaining lines without any mapping
            node.add(remainingLines.splice(remainingLinesIndex).join(""));
          } // Copy sourcesContent into SourceNode
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aRelativePath != null) {
                sourceFile = util.join(aRelativePath, sourceFile);
              }
              node.setSourceContent(sourceFile, content);
            }
          });
          return node;
          function addMappingWithCode(mapping, code) {
            if (mapping === null || mapping.source === undefined) {
              node.add(code);
            } else {
              var source = aRelativePath
                ? util.join(aRelativePath, mapping.source)
                : mapping.source;
              node.add(
                new SourceNode(
                  mapping.originalLine,
                  mapping.originalColumn,
                  source,
                  code,
                  mapping.name
                )
              );
            }
          }
        };
      /**
       * Add a chunk of generated JS to this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */ SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function (chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
              aChunk
          );
        }
        return this;
      };
      /**
       * Add a chunk of generated JS to the beginning of this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */ SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
              aChunk
          );
        }
        return this;
      };
      /**
       * Walk over the tree of JS snippets in this node and its children. The
       * walking function is called once for each snippet of JS and is passed that
       * snippet and the its original associated source's line/column location.
       *
       * @param aFn The traversal function.
       */ SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else {
            if (chunk !== "") {
              aFn(chunk, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name
              });
            }
          }
        }
      };
      /**
       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
       * each of `this.children`.
       *
       * @param aSep The separator.
       */ SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
      /**
       * Call String.prototype.replace on the very right-most source snippet. Useful
       * for trimming whitespace from the end of a source node, etc.
       *
       * @param aPattern The pattern to replace.
       * @param aReplacement The thing to replace the pattern with.
       */ SourceNode.prototype.replaceRight = function SourceNode_replaceRight(
        aPattern,
        aReplacement
      ) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(
            aPattern,
            aReplacement
          );
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      };
      /**
       * Set the source content for a source file. This will be added to the SourceMapGenerator
       * in the sourcesContent field.
       *
       * @param aSourceFile The filename of the source file
       * @param aSourceContent The content of the source file
       */ SourceNode.prototype.setSourceContent =
        function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
          this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
        };
      /**
       * Walk over the tree of SourceNodes. The walking function is called for each
       * source file content and is passed the filename and source content.
       *
       * @param aFn The traversal function.
       */ SourceNode.prototype.walkSourceContents =
        function SourceNode_walkSourceContents(aFn) {
          for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i][isSourceNode]) {
              this.children[i].walkSourceContents(aFn);
            }
          }
          var sources = Object.keys(this.sourceContents);
          for (var i = 0, len = sources.length; i < len; i++) {
            aFn(
              util.fromSetString(sources[i]),
              this.sourceContents[sources[i]]
            );
          }
        };
      /**
       * Return the string representation of this source node. Walks over the tree
       * and concatenates all the various snippets together to one string.
       */ SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function (chunk) {
          str += chunk;
        });
        return str;
      };
      /**
       * Returns the string representation of this source node along with a source
       * map.
       */ SourceNode.prototype.toStringWithSourceMap =
        function SourceNode_toStringWithSourceMap(aArgs) {
          var generated = { code: "", line: 1, column: 0 };
          var map = new SourceMapGenerator(aArgs);
          var sourceMappingActive = false;
          var lastOriginalSource = null;
          var lastOriginalLine = null;
          var lastOriginalColumn = null;
          var lastOriginalName = null;
          this.walk(function (chunk, original) {
            generated.code += chunk;
            if (
              original.source !== null &&
              original.line !== null &&
              original.column !== null
            ) {
              if (
                lastOriginalSource !== original.source ||
                lastOriginalLine !== original.line ||
                lastOriginalColumn !== original.column ||
                lastOriginalName !== original.name
              ) {
                map.addMapping({
                  source: original.source,
                  original: { line: original.line, column: original.column },
                  generated: { line: generated.line, column: generated.column },
                  name: original.name
                });
              }
              lastOriginalSource = original.source;
              lastOriginalLine = original.line;
              lastOriginalColumn = original.column;
              lastOriginalName = original.name;
              sourceMappingActive = true;
            } else if (sourceMappingActive) {
              map.addMapping({
                generated: { line: generated.line, column: generated.column }
              });
              lastOriginalSource = null;
              sourceMappingActive = false;
            }
            for (var idx = 0, length = chunk.length; idx < length; idx++) {
              if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                generated.line++;
                generated.column = 0; // Mappings end at eol
                if (idx + 1 === length) {
                  lastOriginalSource = null;
                  sourceMappingActive = false;
                } else if (sourceMappingActive) {
                  map.addMapping({
                    source: original.source,
                    original: { line: original.line, column: original.column },
                    generated: {
                      line: generated.line,
                      column: generated.column
                    },
                    name: original.name
                  });
                }
              } else {
                generated.column++;
              }
            }
          });
          this.walkSourceContents(function (sourceFile, sourceContent) {
            map.setSourceContent(sourceFile, sourceContent);
          });
          return { code: generated.code, map: map };
        };
      sourceNode.SourceNode = SourceNode;
      return sourceNode;
    }
    var hasRequiredSourceMap;
    function requireSourceMap() {
      if (hasRequiredSourceMap) return sourceMap;
      hasRequiredSourceMap = 1;
      sourceMap.SourceMapGenerator =
        requireSourceMapGenerator().SourceMapGenerator;
      sourceMap.SourceMapConsumer =
        requireSourceMapConsumer().SourceMapConsumer;
      sourceMap.SourceNode = requireSourceNode().SourceNode;
      return sourceMap;
    }
    Object.defineProperty(sourceMap$1, "__esModule", { value: true });
    sourceMap$1["default"] = void 0;
    function _sourceMap$1() {
      var data = _interopRequireDefault$7(requireSourceMap());
      _sourceMap$1 = function _sourceMap$1() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault$7(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SourceMap = /*#__PURE__*/ (function () {
      function SourceMap(opts, code) {
        _classCallCheck(this, SourceMap);
        this._cachedMap = null;
        this._code = code;
        this._opts = opts;
        this._rawMappings = [];
      }
      return _createClass(SourceMap, [
        {
          key: "get",
          value: function get() {
            if (!this._cachedMap) {
              var map = (this._cachedMap = new (_sourceMap$1()[
                "default"
              ].SourceMapGenerator)({ sourceRoot: this._opts.sourceRoot }));
              var code = this._code;
              if (typeof code === "string") {
                map.setSourceContent(this._opts.sourceFileName, code);
              } else if (_typeof(code) === "object") {
                Object.keys(code).forEach(function (sourceFileName) {
                  map.setSourceContent(sourceFileName, code[sourceFileName]);
                });
              }
              this._rawMappings.forEach(map.addMapping, map);
            }
            return this._cachedMap.toJSON();
          }
        },
        {
          key: "getRawMappings",
          value: function getRawMappings() {
            return this._rawMappings.slice();
          }
        },
        {
          key: "mark",
          value: function mark(
            generatedLine,
            generatedColumn,
            line,
            column,
            identifierName,
            filename,
            force
          ) {
            if (this._lastGenLine !== generatedLine && line === null) return;
            if (
              !force &&
              this._lastGenLine === generatedLine &&
              this._lastSourceLine === line &&
              this._lastSourceColumn === column
            ) {
              return;
            }
            this._cachedMap = null;
            this._lastGenLine = generatedLine;
            this._lastSourceLine = line;
            this._lastSourceColumn = column;
            this._rawMappings.push({
              name: identifierName || undefined,
              generated: { line: generatedLine, column: generatedColumn },
              source:
                line == null
                  ? undefined
                  : filename || this._opts.sourceFileName,
              original:
                line == null ? undefined : { line: line, column: column }
            });
          }
        }
      ]);
    })();
    sourceMap$1["default"] = SourceMap;
    var printer$1 = {};
    var _trimmedEndIndex;
    var hasRequired_trimmedEndIndex;
    function require_trimmedEndIndex() {
      if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
      hasRequired_trimmedEndIndex = 1;
      var reWhitespace = /\s/;
      /**
       * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
       * character of `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the index of the last non-whitespace character.
       */ function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {}
        return index;
      }
      _trimmedEndIndex = trimmedEndIndex;
      return _trimmedEndIndex;
    }
    var _baseTrim;
    var hasRequired_baseTrim;
    function require_baseTrim() {
      if (hasRequired_baseTrim) return _baseTrim;
      hasRequired_baseTrim = 1;
      var trimmedEndIndex = require_trimmedEndIndex();
      /** Used to match leading whitespace. */ var reTrimStart = /^\s+/;
      /**
       * The base implementation of `_.trim`.
       *
       * @private
       * @param {string} string The string to trim.
       * @returns {string} Returns the trimmed string.
       */ function baseTrim(string) {
        return string
          ? string
              .slice(0, trimmedEndIndex(string) + 1)
              .replace(reTrimStart, "")
          : string;
      }
      _baseTrim = baseTrim;
      return _baseTrim;
    }
    var isObject_1;
    var hasRequiredIsObject;
    function requireIsObject() {
      if (hasRequiredIsObject) return isObject_1;
      hasRequiredIsObject = 1;
      function isObject(value) {
        var type = _typeof(value);
        return value != null && (type == "object" || type == "function");
      }
      isObject_1 = isObject;
      return isObject_1;
    }
    var _freeGlobal;
    var hasRequired_freeGlobal;
    function require_freeGlobal() {
      if (hasRequired_freeGlobal) return _freeGlobal;
      hasRequired_freeGlobal = 1;
      var freeGlobal =
        _typeof(commonjsGlobal) == "object" &&
        commonjsGlobal &&
        commonjsGlobal.Object === Object &&
        commonjsGlobal;
      _freeGlobal = freeGlobal;
      return _freeGlobal;
    }
    var _root;
    var hasRequired_root;
    function require_root() {
      if (hasRequired_root) return _root;
      hasRequired_root = 1;
      var freeGlobal = require_freeGlobal();
      /** Detect free variable `self`. */ var freeSelf =
        (typeof self === "undefined" ? "undefined" : _typeof(self)) ==
          "object" &&
        self &&
        self.Object === Object &&
        self;
      /** Used as a reference to the global object. */ var root =
        freeGlobal || freeSelf || Function("return this")();
      _root = root;
      return _root;
    }
    var _Symbol;
    var hasRequired_Symbol;
    function require_Symbol() {
      if (hasRequired_Symbol) return _Symbol;
      hasRequired_Symbol = 1;
      var root = require_root();
      /** Built-in value references. */ var _Symbol2 = root.Symbol;
      _Symbol = _Symbol2;
      return _Symbol;
    }
    var _getRawTag;
    var hasRequired_getRawTag;
    function require_getRawTag() {
      if (hasRequired_getRawTag) return _getRawTag;
      hasRequired_getRawTag = 1;
      var _Symbol3 = require_Symbol();
      /** Used for built-in method references. */ var objectProto =
        Object.prototype;
      /** Used to check objects for own properties. */ var hasOwnProperty =
        objectProto.hasOwnProperty;
      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */ var nativeObjectToString = objectProto.toString;
      /** Built-in value references. */ var symToStringTag = _Symbol3
        ? _Symbol3.toStringTag
        : undefined;
      /**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */ function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined;
          var unmasked = true;
        } catch (e) {}
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      _getRawTag = getRawTag;
      return _getRawTag;
    }
    var _objectToString;
    var hasRequired_objectToString;
    function require_objectToString() {
      if (hasRequired_objectToString) return _objectToString;
      hasRequired_objectToString = 1;
      var objectProto = Object.prototype;
      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */ var nativeObjectToString = objectProto.toString;
      /**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */ function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      _objectToString = objectToString;
      return _objectToString;
    }
    var _baseGetTag;
    var hasRequired_baseGetTag;
    function require_baseGetTag() {
      if (hasRequired_baseGetTag) return _baseGetTag;
      hasRequired_baseGetTag = 1;
      var _Symbol4 = require_Symbol(),
        getRawTag = require_getRawTag(),
        objectToString = require_objectToString();
      /** `Object#toString` result references. */ var nullTag = "[object Null]",
        undefinedTag = "[object Undefined]";
      /** Built-in value references. */ var symToStringTag = _Symbol4
        ? _Symbol4.toStringTag
        : undefined;
      /**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */ function baseGetTag(value) {
        if (value == null) {
          return value === undefined ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value)
          ? getRawTag(value)
          : objectToString(value);
      }
      _baseGetTag = baseGetTag;
      return _baseGetTag;
    }
    var isObjectLike_1;
    var hasRequiredIsObjectLike;
    function requireIsObjectLike() {
      if (hasRequiredIsObjectLike) return isObjectLike_1;
      hasRequiredIsObjectLike = 1;
      function isObjectLike(value) {
        return value != null && _typeof(value) == "object";
      }
      isObjectLike_1 = isObjectLike;
      return isObjectLike_1;
    }
    var isSymbol_1;
    var hasRequiredIsSymbol;
    function requireIsSymbol() {
      if (hasRequiredIsSymbol) return isSymbol_1;
      hasRequiredIsSymbol = 1;
      var baseGetTag = require_baseGetTag(),
        isObjectLike = requireIsObjectLike();
      /** `Object#toString` result references. */ var symbolTag =
        "[object Symbol]";
      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */ function isSymbol(value) {
        return (
          _typeof(value) == "symbol" ||
          (isObjectLike(value) && baseGetTag(value) == symbolTag)
        );
      }
      isSymbol_1 = isSymbol;
      return isSymbol_1;
    }
    var toNumber_1;
    var hasRequiredToNumber;
    function requireToNumber() {
      if (hasRequiredToNumber) return toNumber_1;
      hasRequiredToNumber = 1;
      var baseTrim = require_baseTrim(),
        isObject = requireIsObject(),
        isSymbol = requireIsSymbol();
      /** Used as references for various `Number` constants. */ var NAN = 0 / 0;
      /** Used to detect bad signed hexadecimal string values. */ var reIsBadHex =
        /^[-+]0x[0-9a-f]+$/i;
      /** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
      /** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
      /** Built-in method references without a dependency on `root`. */ var freeParseInt =
        parseInt;
      /**
       * Converts `value` to a number.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       * @example
       *
       * _.toNumber(3.2);
       * // => 3.2
       *
       * _.toNumber(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toNumber(Infinity);
       * // => Infinity
       *
       * _.toNumber('3.2');
       * // => 3.2
       */ function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other =
            typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value)
          ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
          : reIsBadHex.test(value)
            ? NAN
            : +value;
      }
      toNumber_1 = toNumber;
      return toNumber_1;
    }
    var toFinite_1;
    var hasRequiredToFinite;
    function requireToFinite() {
      if (hasRequiredToFinite) return toFinite_1;
      hasRequiredToFinite = 1;
      var toNumber = requireToNumber();
      /** Used as references for various `Number` constants. */ var INFINITY =
          1 / 0,
        MAX_INTEGER = 1.7976931348623157e308;
      /**
       * Converts `value` to a finite number.
       *
       * @static
       * @memberOf _
       * @since 4.12.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted number.
       * @example
       *
       * _.toFinite(3.2);
       * // => 3.2
       *
       * _.toFinite(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toFinite(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toFinite('3.2');
       * // => 3.2
       */ function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      toFinite_1 = toFinite;
      return toFinite_1;
    }
    var toInteger_1;
    var hasRequiredToInteger;
    function requireToInteger() {
      if (hasRequiredToInteger) return toInteger_1;
      hasRequiredToInteger = 1;
      var toFinite = requireToFinite();
      /**
       * Converts `value` to an integer.
       *
       * **Note:** This method is loosely based on
       * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toInteger(3.2);
       * // => 3
       *
       * _.toInteger(Number.MIN_VALUE);
       * // => 0
       *
       * _.toInteger(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toInteger('3.2');
       * // => 3
       */ function toInteger(value) {
        var result = toFinite(value),
          remainder = result % 1;
        return result === result
          ? remainder
            ? result - remainder
            : result
          : 0;
      }
      toInteger_1 = toInteger;
      return toInteger_1;
    }
    var isInteger_1;
    var hasRequiredIsInteger;
    function requireIsInteger() {
      if (hasRequiredIsInteger) return isInteger_1;
      hasRequiredIsInteger = 1;
      var toInteger = requireToInteger();
      /**
       * Checks if `value` is an integer.
       *
       * **Note:** This method is based on
       * [`Number.isInteger`](https://mdn.io/Number/isInteger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
       * @example
       *
       * _.isInteger(3);
       * // => true
       *
       * _.isInteger(Number.MIN_VALUE);
       * // => false
       *
       * _.isInteger(Infinity);
       * // => false
       *
       * _.isInteger('3');
       * // => false
       */ function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      isInteger_1 = isInteger;
      return isInteger_1;
    }
    var _baseRepeat;
    var hasRequired_baseRepeat;
    function require_baseRepeat() {
      if (hasRequired_baseRepeat) return _baseRepeat;
      hasRequired_baseRepeat = 1;
      var MAX_SAFE_INTEGER = 9007199254740991;
      /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeFloor =
        Math.floor;
      /**
       * The base implementation of `_.repeat` which doesn't coerce arguments.
       *
       * @private
       * @param {string} string The string to repeat.
       * @param {number} n The number of times to repeat the string.
       * @returns {string} Returns the repeated string.
       */ function baseRepeat(string, n) {
        var result = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result;
        } // Leverage the exponentiation by squaring algorithm for a faster repeat.
        // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
        do {
          if (n % 2) {
            result += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result;
      }
      _baseRepeat = baseRepeat;
      return _baseRepeat;
    }
    var eq_1;
    var hasRequiredEq;
    function requireEq() {
      if (hasRequiredEq) return eq_1;
      hasRequiredEq = 1;
      function eq(value, other) {
        return value === other || (value !== value && other !== other);
      }
      eq_1 = eq;
      return eq_1;
    }
    var isFunction_1;
    var hasRequiredIsFunction;
    function requireIsFunction() {
      if (hasRequiredIsFunction) return isFunction_1;
      hasRequiredIsFunction = 1;
      var baseGetTag = require_baseGetTag(),
        isObject = requireIsObject();
      /** `Object#toString` result references. */ var asyncTag =
          "[object AsyncFunction]",
        funcTag = "[object Function]",
        genTag = "[object GeneratorFunction]",
        proxyTag = "[object Proxy]";
      /**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a function, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */ function isFunction(value) {
        if (!isObject(value)) {
          return false;
        } // The use of `Object#toString` avoids issues with the `typeof` operator
        // in Safari 9 which returns 'object' for typed arrays and other constructors.
        var tag = baseGetTag(value);
        return (
          tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag
        );
      }
      isFunction_1 = isFunction;
      return isFunction_1;
    }
    var isLength_1;
    var hasRequiredIsLength;
    function requireIsLength() {
      if (hasRequiredIsLength) return isLength_1;
      hasRequiredIsLength = 1;
      var MAX_SAFE_INTEGER = 9007199254740991;
      /**
       * Checks if `value` is a valid array-like length.
       *
       * **Note:** This method is loosely based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
       * @example
       *
       * _.isLength(3);
       * // => true
       *
       * _.isLength(Number.MIN_VALUE);
       * // => false
       *
       * _.isLength(Infinity);
       * // => false
       *
       * _.isLength('3');
       * // => false
       */ function isLength(value) {
        return (
          typeof value == "number" &&
          value > -1 &&
          value % 1 == 0 &&
          value <= MAX_SAFE_INTEGER
        );
      }
      isLength_1 = isLength;
      return isLength_1;
    }
    var isArrayLike_1;
    var hasRequiredIsArrayLike;
    function requireIsArrayLike() {
      if (hasRequiredIsArrayLike) return isArrayLike_1;
      hasRequiredIsArrayLike = 1;
      var isFunction = requireIsFunction(),
        isLength = requireIsLength();
      /**
       * Checks if `value` is array-like. A value is considered array-like if it's
       * not a function and has a `value.length` that's an integer greater than or
       * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
       * @example
       *
       * _.isArrayLike([1, 2, 3]);
       * // => true
       *
       * _.isArrayLike(document.body.children);
       * // => true
       *
       * _.isArrayLike('abc');
       * // => true
       *
       * _.isArrayLike(_.noop);
       * // => false
       */ function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      isArrayLike_1 = isArrayLike;
      return isArrayLike_1;
    }
    var _isIndex;
    var hasRequired_isIndex;
    function require_isIndex() {
      if (hasRequired_isIndex) return _isIndex;
      hasRequired_isIndex = 1;
      var MAX_SAFE_INTEGER = 9007199254740991;
      /** Used to detect unsigned integer values. */ var reIsUint =
        /^(?:0|[1-9]\d*)$/;
      /**
       * Checks if `value` is a valid array-like index.
       *
       * @private
       * @param {*} value The value to check.
       * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
       * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
       */ function isIndex(value, length) {
        var type = _typeof(value);
        length = length == null ? MAX_SAFE_INTEGER : length;
        return (
          !!length &&
          (type == "number" || (type != "symbol" && reIsUint.test(value))) &&
          value > -1 &&
          value % 1 == 0 &&
          value < length
        );
      }
      _isIndex = isIndex;
      return _isIndex;
    }
    var _isIterateeCall;
    var hasRequired_isIterateeCall;
    function require_isIterateeCall() {
      if (hasRequired_isIterateeCall) return _isIterateeCall;
      hasRequired_isIterateeCall = 1;
      var eq = requireEq(),
        isArrayLike = requireIsArrayLike(),
        isIndex = require_isIndex(),
        isObject = requireIsObject();
      /**
       * Checks if the given arguments are from an iteratee call.
       *
       * @private
       * @param {*} value The potential iteratee value argument.
       * @param {*} index The potential iteratee index or key argument.
       * @param {*} object The potential iteratee object argument.
       * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
       *  else `false`.
       */ function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = _typeof(index);
        if (
          type == "number"
            ? isArrayLike(object) && isIndex(index, object.length)
            : type == "string" && index in object
        ) {
          return eq(object[index], value);
        }
        return false;
      }
      _isIterateeCall = isIterateeCall;
      return _isIterateeCall;
    }
    var _arrayMap;
    var hasRequired_arrayMap;
    function require_arrayMap() {
      if (hasRequired_arrayMap) return _arrayMap;
      hasRequired_arrayMap = 1;
      function arrayMap(array, iteratee) {
        var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      _arrayMap = arrayMap;
      return _arrayMap;
    }
    var isArray_1;
    var hasRequiredIsArray;
    function requireIsArray() {
      if (hasRequiredIsArray) return isArray_1;
      hasRequiredIsArray = 1;
      var isArray = Array.isArray;
      isArray_1 = isArray;
      return isArray_1;
    }
    var _baseToString;
    var hasRequired_baseToString;
    function require_baseToString() {
      if (hasRequired_baseToString) return _baseToString;
      hasRequired_baseToString = 1;
      var _Symbol5 = require_Symbol(),
        arrayMap = require_arrayMap(),
        isArray = requireIsArray(),
        isSymbol = requireIsSymbol();
      /** Used as references for various `Number` constants. */ var INFINITY =
        1 / 0;
      /** Used to convert symbols to primitives and strings. */ var symbolProto =
          _Symbol5 ? _Symbol5.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;
      /**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */ function baseToString(value) {
        // Exit early for strings to avoid a performance hit in some environments.
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          // Recursively convert values (susceptible to call stack limits).
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      _baseToString = baseToString;
      return _baseToString;
    }
    var toString_1;
    var hasRequiredToString;
    function requireToString() {
      if (hasRequiredToString) return toString_1;
      hasRequiredToString = 1;
      var baseToString = require_baseToString();
      /**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */ function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      toString_1 = toString;
      return toString_1;
    }
    var repeat_1;
    var hasRequiredRepeat;
    function requireRepeat() {
      if (hasRequiredRepeat) return repeat_1;
      hasRequiredRepeat = 1;
      var baseRepeat = require_baseRepeat(),
        isIterateeCall = require_isIterateeCall(),
        toInteger = requireToInteger(),
        toString = requireToString();
      /**
       * Repeats the given string `n` times.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to repeat.
       * @param {number} [n=1] The number of times to repeat the string.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the repeated string.
       * @example
       *
       * _.repeat('*', 3);
       * // => '***'
       *
       * _.repeat('abc', 2);
       * // => 'abcabc'
       *
       * _.repeat('abc', 0);
       * // => ''
       */ function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string), n);
      }
      repeat_1 = repeat;
      return repeat_1;
    }
    var buffer = {};
    var trimRight;
    var hasRequiredTrimRight;
    function requireTrimRight() {
      if (hasRequiredTrimRight) return trimRight;
      hasRequiredTrimRight = 1;
      trimRight = function trimRight(str) {
        var tail = str.length;
        while (/[\s\uFEFF\u00A0]/.test(str[tail - 1])) {
          tail--;
        }
        return str.slice(0, tail);
      };
      return trimRight;
    }
    Object.defineProperty(buffer, "__esModule", { value: true });
    buffer["default"] = void 0;
    function _trimRight() {
      var data = _interopRequireDefault$6(requireTrimRight());
      _trimRight = function _trimRight() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault$6(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SPACES_RE = /^[ \t]+$/;
    var Buffer$1 = /*#__PURE__*/ (function () {
      function Buffer(map) {
        _classCallCheck(this, Buffer);
        this._map = null;
        this._buf = [];
        this._last = "";
        this._queue = [];
        this._position = { line: 1, column: 0 };
        this._sourcePosition = {
          identifierName: null,
          line: null,
          column: null,
          filename: null
        };
        this._disallowedPop = null;
        this._map = map;
      }
      return _createClass(Buffer, [
        {
          key: "get",
          value: function get() {
            this._flush();
            var map = this._map;
            var result = {
              code: (0, _trimRight()["default"])(this._buf.join("")),
              map: null,
              rawMappings: map && map.getRawMappings()
            };
            if (map) {
              Object.defineProperty(result, "map", {
                configurable: true,
                enumerable: true,
                get: function get() {
                  return (this.map = map.get());
                },
                set: function set(value) {
                  Object.defineProperty(this, "map", {
                    value: value,
                    writable: true
                  });
                }
              });
            }
            return result;
          }
        },
        {
          key: "append",
          value: function append(str) {
            this._flush();
            var _this$_sourcePosition = this._sourcePosition,
              line = _this$_sourcePosition.line,
              column = _this$_sourcePosition.column,
              filename = _this$_sourcePosition.filename,
              identifierName = _this$_sourcePosition.identifierName,
              force = _this$_sourcePosition.force;
            this._append(str, line, column, identifierName, filename, force);
          }
        },
        {
          key: "queue",
          value: function queue(str) {
            if (str === "\n") {
              while (
                this._queue.length > 0 &&
                SPACES_RE.test(this._queue[0][0])
              ) {
                this._queue.shift();
              }
            }
            var _this$_sourcePosition2 = this._sourcePosition,
              line = _this$_sourcePosition2.line,
              column = _this$_sourcePosition2.column,
              filename = _this$_sourcePosition2.filename,
              identifierName = _this$_sourcePosition2.identifierName,
              force = _this$_sourcePosition2.force;
            this._queue.unshift([
              str,
              line,
              column,
              identifierName,
              filename,
              force
            ]);
          }
        },
        {
          key: "_flush",
          value: function _flush() {
            var item;
            while ((item = this._queue.pop()))
              this._append.apply(this, _toConsumableArray(item));
          }
        },
        {
          key: "_append",
          value: function _append(
            str,
            line,
            column,
            identifierName,
            filename,
            force
          ) {
            if (this._map && str[0] !== "\n") {
              this._map.mark(
                this._position.line,
                this._position.column,
                line,
                column,
                identifierName,
                filename,
                force
              );
            }
            this._buf.push(str);
            this._last = str[str.length - 1];
            for (var i = 0; i < str.length; i++) {
              if (str[i] === "\n") {
                this._position.line++;
                this._position.column = 0;
              } else {
                this._position.column++;
              }
            }
          }
        },
        {
          key: "removeTrailingNewline",
          value: function removeTrailingNewline() {
            if (this._queue.length > 0 && this._queue[0][0] === "\n") {
              this._queue.shift();
            }
          }
        },
        {
          key: "removeLastSemicolon",
          value: function removeLastSemicolon() {
            if (this._queue.length > 0 && this._queue[0][0] === ";") {
              this._queue.shift();
            }
          }
        },
        {
          key: "endsWith",
          value: function endsWith(suffix) {
            if (suffix.length === 1) {
              var _last;
              if (this._queue.length > 0) {
                var str = this._queue[0][0];
                _last = str[str.length - 1];
              } else {
                _last = this._last;
              }
              return _last === suffix;
            }
            var end =
              this._last +
              this._queue.reduce(function (acc, item) {
                return item[0] + acc;
              }, "");
            if (suffix.length <= end.length) {
              return end.slice(-suffix.length) === suffix;
            }
            return false;
          }
        },
        {
          key: "hasContent",
          value: function hasContent() {
            return this._queue.length > 0 || !!this._last;
          }
        },
        {
          key: "exactSource",
          value: function exactSource(loc, cb) {
            this.source("start", loc, true);
            cb();
            this.source("end", loc);
            this._disallowPop("start", loc);
          }
        },
        {
          key: "source",
          value: function source(prop, loc, force) {
            if (prop && !loc) return;
            this._normalizePosition(prop, loc, this._sourcePosition, force);
          }
        },
        {
          key: "withSource",
          value: function withSource(prop, loc, cb) {
            if (!this._map) return cb();
            var originalLine = this._sourcePosition.line;
            var originalColumn = this._sourcePosition.column;
            var originalFilename = this._sourcePosition.filename;
            var originalIdentifierName = this._sourcePosition.identifierName;
            this.source(prop, loc);
            cb();
            if (
              (!this._sourcePosition.force ||
                this._sourcePosition.line !== originalLine ||
                this._sourcePosition.column !== originalColumn ||
                this._sourcePosition.filename !== originalFilename) &&
              (!this._disallowedPop ||
                this._disallowedPop.line !== originalLine ||
                this._disallowedPop.column !== originalColumn ||
                this._disallowedPop.filename !== originalFilename)
            ) {
              this._sourcePosition.line = originalLine;
              this._sourcePosition.column = originalColumn;
              this._sourcePosition.filename = originalFilename;
              this._sourcePosition.identifierName = originalIdentifierName;
              this._sourcePosition.force = false;
              this._disallowedPop = null;
            }
          }
        },
        {
          key: "_disallowPop",
          value: function _disallowPop(prop, loc) {
            if (prop && !loc) return;
            this._disallowedPop = this._normalizePosition(prop, loc);
          }
        },
        {
          key: "_normalizePosition",
          value: function _normalizePosition(prop, loc, targetObj, force) {
            var pos = loc ? loc[prop] : null;
            if (targetObj === undefined) {
              targetObj = {
                identifierName: null,
                line: null,
                column: null,
                filename: null,
                force: false
              };
            }
            var origLine = targetObj.line;
            var origColumn = targetObj.column;
            var origFilename = targetObj.filename;
            targetObj.identifierName =
              (prop === "start" && loc && loc.identifierName) || null;
            targetObj.line = pos ? pos.line : null;
            targetObj.column = pos ? pos.column : null;
            targetObj.filename = (loc && loc.filename) || null;
            if (
              force ||
              targetObj.line !== origLine ||
              targetObj.column !== origColumn ||
              targetObj.filename !== origFilename
            ) {
              targetObj.force = force;
            }
            return targetObj;
          }
        },
        {
          key: "getCurrentColumn",
          value: function getCurrentColumn() {
            var extra = this._queue.reduce(function (acc, item) {
              return item[0] + acc;
            }, "");
            var lastIndex = extra.lastIndexOf("\n");
            return lastIndex === -1
              ? this._position.column + extra.length
              : extra.length - 1 - lastIndex;
          }
        },
        {
          key: "getCurrentLine",
          value: function getCurrentLine() {
            var extra = this._queue.reduce(function (acc, item) {
              return item[0] + acc;
            }, "");
            var count = 0;
            for (var i = 0; i < extra.length; i++) {
              if (extra[i] === "\n") count++;
            }
            return this._position.line + count;
          }
        }
      ]);
    })();
    buffer["default"] = Buffer$1;
    var node = {};
    var whitespace$1 = {};
    Object.defineProperty(whitespace$1, "__esModule", { value: true });
    whitespace$1.list = whitespace$1.nodes = void 0;
    function t$9() {
      var data = _interopRequireWildcard$a(requireLib());
      t$9 = function t$9() {
        return data;
      };
      return data;
    }
    function _interopRequireWildcard$a(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function crawl(node) {
      var state =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (t$9().isMemberExpression(node)) {
        crawl(node.object, state);
        if (node.computed) crawl(node.property, state);
      } else if (t$9().isBinary(node) || t$9().isAssignmentExpression(node)) {
        crawl(node.left, state);
        crawl(node.right, state);
      } else if (t$9().isCallExpression(node)) {
        state.hasCall = true;
        crawl(node.callee, state);
      } else if (t$9().isFunction(node)) {
        state.hasFunction = true;
      } else if (t$9().isIdentifier(node)) {
        state.hasHelper = state.hasHelper || isHelper(node.callee);
      }
      return state;
    }
    function isHelper(node) {
      if (t$9().isMemberExpression(node)) {
        return isHelper(node.object) || isHelper(node.property);
      } else if (t$9().isIdentifier(node)) {
        return node.name === "require" || node.name[0] === "_";
      } else if (t$9().isCallExpression(node)) {
        return isHelper(node.callee);
      } else if (t$9().isBinary(node) || t$9().isAssignmentExpression(node)) {
        return (
          (t$9().isIdentifier(node.left) && isHelper(node.left)) ||
          isHelper(node.right)
        );
      } else {
        return false;
      }
    }
    function isType(node) {
      return (
        t$9().isLiteral(node) ||
        t$9().isObjectExpression(node) ||
        t$9().isArrayExpression(node) ||
        t$9().isIdentifier(node) ||
        t$9().isMemberExpression(node)
      );
    }
    var nodes = {
      AssignmentExpression: function AssignmentExpression(node) {
        var state = crawl(node.right);
        if ((state.hasCall && state.hasHelper) || state.hasFunction) {
          return { before: state.hasFunction, after: true };
        }
      },
      SwitchCase: function SwitchCase(node, parent) {
        return {
          before: node.consequent.length || parent.cases[0] === node,
          after:
            !node.consequent.length &&
            parent.cases[parent.cases.length - 1] === node
        };
      },
      LogicalExpression: function LogicalExpression(node) {
        if (t$9().isFunction(node.left) || t$9().isFunction(node.right)) {
          return { after: true };
        }
      },
      Literal: function Literal(node) {
        if (node.value === "use strict") {
          return { after: true };
        }
      },
      CallExpression: function CallExpression(node) {
        if (t$9().isFunction(node.callee) || isHelper(node)) {
          return { before: true, after: true };
        }
      },
      VariableDeclaration: function VariableDeclaration(node) {
        for (var i = 0; i < node.declarations.length; i++) {
          var declar = node.declarations[i];
          var enabled = isHelper(declar.id) && !isType(declar.init);
          if (!enabled) {
            var state = crawl(declar.init);
            enabled =
              (isHelper(declar.init) && state.hasCall) || state.hasFunction;
          }
          if (enabled) {
            return { before: true, after: true };
          }
        }
      },
      IfStatement: function IfStatement(node) {
        if (t$9().isBlockStatement(node.consequent)) {
          return { before: true, after: true };
        }
      }
    };
    whitespace$1.nodes = nodes;
    nodes.ObjectProperty =
      nodes.ObjectTypeProperty =
      nodes.ObjectMethod =
        function (node, parent) {
          if (parent.properties[0] === node) {
            return { before: true };
          }
        };
    nodes.ObjectTypeCallProperty = function (node, parent) {
      if (
        parent.callProperties[0] === node &&
        (!parent.properties || !parent.properties.length)
      ) {
        return { before: true };
      }
    };
    nodes.ObjectTypeIndexer = function (node, parent) {
      if (
        parent.indexers[0] === node &&
        (!parent.properties || !parent.properties.length) &&
        (!parent.callProperties || !parent.callProperties.length)
      ) {
        return { before: true };
      }
    };
    nodes.ObjectTypeInternalSlot = function (node, parent) {
      if (
        parent.internalSlots[0] === node &&
        (!parent.properties || !parent.properties.length) &&
        (!parent.callProperties || !parent.callProperties.length) &&
        (!parent.indexers || !parent.indexers.length)
      ) {
        return { before: true };
      }
    };
    var list = {
      VariableDeclaration: function VariableDeclaration(node) {
        return node.declarations.map(function (decl) {
          return decl.init;
        });
      },
      ArrayExpression: function ArrayExpression(node) {
        return node.elements;
      },
      ObjectExpression: function ObjectExpression(node) {
        return node.properties;
      }
    };
    whitespace$1.list = list;
    [
      ["Function", true],
      ["Class", true],
      ["Loop", true],
      ["LabeledStatement", true],
      ["SwitchStatement", true],
      ["TryStatement", true]
    ].forEach(function (_ref15) {
      var _ref16 = _slicedToArray(_ref15, 2),
        type = _ref16[0],
        amounts = _ref16[1];
      if (typeof amounts === "boolean") {
        amounts = { after: amounts, before: amounts };
      }
      [type]
        .concat(t$9().FLIPPED_ALIAS_KEYS[type] || [])
        .forEach(function (type) {
          nodes[type] = function () {
            return amounts;
          };
        });
    });
    var parentheses = {};
    Object.defineProperty(parentheses, "__esModule", { value: true });
    parentheses.FunctionTypeAnnotation = parentheses.NullableTypeAnnotation =
      NullableTypeAnnotation;
    parentheses.UpdateExpression = UpdateExpression$1;
    parentheses.ObjectExpression = ObjectExpression$1;
    parentheses.DoExpression = DoExpression$1;
    parentheses.Binary = Binary;
    parentheses.IntersectionTypeAnnotation = parentheses.UnionTypeAnnotation =
      UnionTypeAnnotation;
    parentheses.TSAsExpression = TSAsExpression$1;
    parentheses.TSTypeAssertion = TSTypeAssertion$1;
    parentheses.BinaryExpression = BinaryExpression;
    parentheses.SequenceExpression = SequenceExpression$1;
    parentheses.AwaitExpression = parentheses.YieldExpression =
      YieldExpression$1;
    parentheses.ClassExpression = ClassExpression;
    parentheses.UnaryLike = UnaryLike;
    parentheses.FunctionExpression = FunctionExpression$1;
    parentheses.ArrowFunctionExpression = ArrowFunctionExpression$1;
    parentheses.ConditionalExpression = ConditionalExpression$1;
    parentheses.OptionalMemberExpression = OptionalMemberExpression$1;
    parentheses.AssignmentExpression = AssignmentExpression$1;
    parentheses.NewExpression = NewExpression$1;
    function t$8() {
      var data = _interopRequireWildcard$9(requireLib());
      t$8 = function t$8() {
        return data;
      };
      return data;
    }
    function _interopRequireWildcard$9(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    var PRECEDENCE = {
      "||": 0,
      "&&": 1,
      "|": 2,
      "^": 3,
      "&": 4,
      "==": 5,
      "===": 5,
      "!=": 5,
      "!==": 5,
      "<": 6,
      ">": 6,
      "<=": 6,
      ">=": 6,
      in: 6,
      instanceof: 6,
      ">>": 7,
      "<<": 7,
      ">>>": 7,
      "+": 8,
      "-": 8,
      "*": 9,
      "/": 9,
      "%": 9,
      "**": 10
    };
    var isClassExtendsClause = function isClassExtendsClause(node, parent) {
      return (
        (t$8().isClassDeclaration(parent) || t$8().isClassExpression(parent)) &&
        parent.superClass === node
      );
    };
    function NullableTypeAnnotation(node, parent) {
      return t$8().isArrayTypeAnnotation(parent);
    }
    function UpdateExpression$1(node, parent) {
      return (
        t$8().isMemberExpression(parent, { object: node }) ||
        t$8().isCallExpression(parent, { callee: node }) ||
        t$8().isNewExpression(parent, { callee: node }) ||
        isClassExtendsClause(node, parent)
      );
    }
    function ObjectExpression$1(node, parent, printStack) {
      return isFirstInStatement(printStack, { considerArrow: true });
    }
    function DoExpression$1(node, parent, printStack) {
      return isFirstInStatement(printStack);
    }
    function Binary(node, parent) {
      if (
        node.operator === "**" &&
        t$8().isBinaryExpression(parent, { operator: "**" })
      ) {
        return parent.left === node;
      }
      if (isClassExtendsClause(node, parent)) {
        return true;
      }
      if (
        ((t$8().isCallExpression(parent) || t$8().isNewExpression(parent)) &&
          parent.callee === node) ||
        t$8().isUnaryLike(parent) ||
        (t$8().isMemberExpression(parent) && parent.object === node) ||
        t$8().isAwaitExpression(parent)
      ) {
        return true;
      }
      if (t$8().isBinary(parent)) {
        var parentOp = parent.operator;
        var parentPos = PRECEDENCE[parentOp];
        var nodeOp = node.operator;
        var nodePos = PRECEDENCE[nodeOp];
        if (
          (parentPos === nodePos &&
            parent.right === node &&
            !t$8().isLogicalExpression(parent)) ||
          parentPos > nodePos
        ) {
          return true;
        }
      }
      return false;
    }
    function UnionTypeAnnotation(node, parent) {
      return (
        t$8().isArrayTypeAnnotation(parent) ||
        t$8().isNullableTypeAnnotation(parent) ||
        t$8().isIntersectionTypeAnnotation(parent) ||
        t$8().isUnionTypeAnnotation(parent)
      );
    }
    function TSAsExpression$1() {
      return true;
    }
    function TSTypeAssertion$1() {
      return true;
    }
    function BinaryExpression(node, parent) {
      return (
        node.operator === "in" &&
        (t$8().isVariableDeclarator(parent) || t$8().isFor(parent))
      );
    }
    function SequenceExpression$1(node, parent) {
      if (
        t$8().isForStatement(parent) ||
        t$8().isThrowStatement(parent) ||
        t$8().isReturnStatement(parent) ||
        (t$8().isIfStatement(parent) && parent.test === node) ||
        (t$8().isWhileStatement(parent) && parent.test === node) ||
        (t$8().isForInStatement(parent) && parent.right === node) ||
        (t$8().isSwitchStatement(parent) && parent.discriminant === node) ||
        (t$8().isExpressionStatement(parent) && parent.expression === node)
      ) {
        return false;
      }
      return true;
    }
    function YieldExpression$1(node, parent) {
      return (
        t$8().isBinary(parent) ||
        t$8().isUnaryLike(parent) ||
        t$8().isCallExpression(parent) ||
        t$8().isMemberExpression(parent) ||
        t$8().isNewExpression(parent) ||
        (t$8().isAwaitExpression(parent) && t$8().isYieldExpression(node)) ||
        (t$8().isConditionalExpression(parent) && node === parent.test) ||
        isClassExtendsClause(node, parent)
      );
    }
    function ClassExpression(node, parent, printStack) {
      return isFirstInStatement(printStack, { considerDefaultExports: true });
    }
    function UnaryLike(node, parent) {
      return (
        t$8().isMemberExpression(parent, { object: node }) ||
        t$8().isCallExpression(parent, { callee: node }) ||
        t$8().isNewExpression(parent, { callee: node }) ||
        t$8().isBinaryExpression(parent, { operator: "**", left: node }) ||
        isClassExtendsClause(node, parent)
      );
    }
    function FunctionExpression$1(node, parent, printStack) {
      return isFirstInStatement(printStack, { considerDefaultExports: true });
    }
    function ArrowFunctionExpression$1(node, parent) {
      return (
        t$8().isExportDeclaration(parent) ||
        ConditionalExpression$1(node, parent)
      );
    }
    function ConditionalExpression$1(node, parent) {
      if (
        t$8().isUnaryLike(parent) ||
        t$8().isBinary(parent) ||
        t$8().isConditionalExpression(parent, { test: node }) ||
        t$8().isAwaitExpression(parent) ||
        t$8().isOptionalMemberExpression(parent) ||
        t$8().isTaggedTemplateExpression(parent) ||
        t$8().isTSTypeAssertion(parent) ||
        t$8().isTSAsExpression(parent)
      ) {
        return true;
      }
      return UnaryLike(node, parent);
    }
    function OptionalMemberExpression$1(node, parent) {
      return t$8().isCallExpression(parent) || t$8().isMemberExpression(parent);
    }
    function AssignmentExpression$1(node) {
      if (t$8().isObjectPattern(node.left)) {
        return true;
      } else {
        return ConditionalExpression$1.apply(void 0, arguments);
      }
    }
    function NewExpression$1(node, parent) {
      return isClassExtendsClause(node, parent);
    }
    function isFirstInStatement(printStack) {
      var _ref17 =
          arguments.length > 1 && arguments[1] !== undefined
            ? arguments[1]
            : {},
        _ref17$considerArrow = _ref17.considerArrow,
        considerArrow =
          _ref17$considerArrow === void 0 ? false : _ref17$considerArrow,
        _ref17$considerDefaul = _ref17.considerDefaultExports,
        considerDefaultExports =
          _ref17$considerDefaul === void 0 ? false : _ref17$considerDefaul;
      var i = printStack.length - 1;
      var node = printStack[i];
      i--;
      var parent = printStack[i];
      while (i > 0) {
        if (
          t$8().isExpressionStatement(parent, { expression: node }) ||
          t$8().isTaggedTemplateExpression(parent) ||
          (considerDefaultExports &&
            t$8().isExportDefaultDeclaration(parent, { declaration: node })) ||
          (considerArrow &&
            t$8().isArrowFunctionExpression(parent, { body: node }))
        ) {
          return true;
        }
        if (
          t$8().isCallExpression(parent, { callee: node }) ||
          (t$8().isSequenceExpression(parent) &&
            parent.expressions[0] === node) ||
          t$8().isMemberExpression(parent, { object: node }) ||
          t$8().isConditional(parent, { test: node }) ||
          t$8().isBinary(parent, { left: node }) ||
          t$8().isAssignmentExpression(parent, { left: node })
        ) {
          node = parent;
          i--;
          parent = printStack[i];
        } else {
          return false;
        }
      }
      return false;
    }
    Object.defineProperty(node, "__esModule", { value: true });
    node.needsWhitespace = needsWhitespace;
    node.needsWhitespaceBefore = needsWhitespaceBefore;
    node.needsWhitespaceAfter = needsWhitespaceAfter;
    node.needsParens = needsParens;
    var whitespace = _interopRequireWildcard$8(whitespace$1);
    var parens = _interopRequireWildcard$8(parentheses);
    function t$7() {
      var data = _interopRequireWildcard$8(requireLib());
      t$7 = function t$7() {
        return data;
      };
      return data;
    }
    function _interopRequireWildcard$8(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function expandAliases(obj) {
      var newObj = {};
      function add(type, func) {
        var fn = newObj[type];
        newObj[type] = fn
          ? function (node, parent, stack) {
              var result = fn(node, parent, stack);
              return result == null ? func(node, parent, stack) : result;
            }
          : func;
      }
      for (
        var _i18 = 0, _Object$keys11 = Object.keys(obj);
        _i18 < _Object$keys11.length;
        _i18++
      ) {
        var type = _Object$keys11[_i18];
        var aliases = t$7().FLIPPED_ALIAS_KEYS[type];
        if (aliases) {
          var _iterator43 = _createForOfIteratorHelper(aliases),
            _step43;
          try {
            for (_iterator43.s(); !(_step43 = _iterator43.n()).done; ) {
              var alias = _step43.value;
              add(alias, obj[type]);
            }
          } catch (err) {
            _iterator43.e(err);
          } finally {
            _iterator43.f();
          }
        } else {
          add(type, obj[type]);
        }
      }
      return newObj;
    }
    var expandedParens = expandAliases(parens);
    var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
    var expandedWhitespaceList = expandAliases(whitespace.list);
    function find(obj, node, parent, printStack) {
      var fn = obj[node.type];
      return fn ? fn(node, parent, printStack) : null;
    }
    function isOrHasCallExpression(node) {
      if (t$7().isCallExpression(node)) {
        return true;
      }
      if (t$7().isMemberExpression(node)) {
        return (
          isOrHasCallExpression(node.object) ||
          (!node.computed && isOrHasCallExpression(node.property))
        );
      } else {
        return false;
      }
    }
    function needsWhitespace(node, parent, type) {
      if (!node) return 0;
      if (t$7().isExpressionStatement(node)) {
        node = node.expression;
      }
      var linesInfo = find(expandedWhitespaceNodes, node, parent);
      if (!linesInfo) {
        var items = find(expandedWhitespaceList, node, parent);
        if (items) {
          for (var i = 0; i < items.length; i++) {
            linesInfo = needsWhitespace(items[i], node, type);
            if (linesInfo) break;
          }
        }
      }
      if (_typeof(linesInfo) === "object" && linesInfo !== null) {
        return linesInfo[type] || 0;
      }
      return 0;
    }
    function needsWhitespaceBefore(node, parent) {
      return needsWhitespace(node, parent, "before");
    }
    function needsWhitespaceAfter(node, parent) {
      return needsWhitespace(node, parent, "after");
    }
    function needsParens(node, parent, printStack) {
      if (!parent) return false;
      if (t$7().isNewExpression(parent) && parent.callee === node) {
        if (isOrHasCallExpression(node)) return true;
      }
      return find(expandedParens, node, parent, printStack);
    }
    var generators = {};
    var templateLiterals = {};
    Object.defineProperty(templateLiterals, "__esModule", { value: true });
    templateLiterals.TaggedTemplateExpression = TaggedTemplateExpression;
    templateLiterals.TemplateElement = TemplateElement;
    templateLiterals.TemplateLiteral = TemplateLiteral;
    function TaggedTemplateExpression(node) {
      this.print(node.tag, node);
      this.print(node.typeParameters, node);
      this.print(node.quasi, node);
    }
    function TemplateElement(node, parent) {
      var isFirst = parent.quasis[0] === node;
      var isLast = parent.quasis[parent.quasis.length - 1] === node;
      var value =
        (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
      this.token(value);
    }
    function TemplateLiteral(node) {
      var quasis = node.quasis;
      for (var i = 0; i < quasis.length; i++) {
        this.print(quasis[i], node);
        if (i + 1 < quasis.length) {
          this.print(node.expressions[i], node);
        }
      }
    }
    var expressions = {};
    Object.defineProperty(expressions, "__esModule", { value: true });
    expressions.UnaryExpression = UnaryExpression;
    expressions.DoExpression = DoExpression;
    expressions.ParenthesizedExpression = ParenthesizedExpression;
    expressions.UpdateExpression = UpdateExpression;
    expressions.ConditionalExpression = ConditionalExpression;
    expressions.NewExpression = NewExpression;
    expressions.SequenceExpression = SequenceExpression;
    expressions.ThisExpression = ThisExpression;
    expressions.Super = Super;
    expressions.Decorator = Decorator;
    expressions.OptionalMemberExpression = OptionalMemberExpression;
    expressions.OptionalCallExpression = OptionalCallExpression;
    expressions.CallExpression = CallExpression;
    expressions.Import = Import;
    expressions.EmptyStatement = EmptyStatement;
    expressions.ExpressionStatement = ExpressionStatement;
    expressions.AssignmentPattern = AssignmentPattern;
    expressions.LogicalExpression =
      expressions.BinaryExpression =
      expressions.AssignmentExpression =
        AssignmentExpression;
    expressions.BindExpression = BindExpression;
    expressions.MemberExpression = MemberExpression;
    expressions.MetaProperty = MetaProperty;
    expressions.PrivateName = PrivateName;
    expressions.AwaitExpression = expressions.YieldExpression = void 0;
    function t$6() {
      var data = _interopRequireWildcard$7(requireLib());
      t$6 = function t$6() {
        return data;
      };
      return data;
    }
    var n$1 = _interopRequireWildcard$7(node);
    function _interopRequireWildcard$7(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function UnaryExpression(node) {
      if (
        node.operator === "void" ||
        node.operator === "delete" ||
        node.operator === "typeof" ||
        node.operator === "throw"
      ) {
        this.word(node.operator);
        this.space();
      } else {
        this.token(node.operator);
      }
      this.print(node.argument, node);
    }
    function DoExpression(node) {
      this.word("do");
      this.space();
      this.print(node.body, node);
    }
    function ParenthesizedExpression(node) {
      this.token("(");
      this.print(node.expression, node);
      this.token(")");
    }
    function UpdateExpression(node) {
      if (node.prefix) {
        this.token(node.operator);
        this.print(node.argument, node);
      } else {
        this.startTerminatorless(true);
        this.print(node.argument, node);
        this.endTerminatorless();
        this.token(node.operator);
      }
    }
    function ConditionalExpression(node) {
      this.print(node.test, node);
      this.space();
      this.token("?");
      this.space();
      this.print(node.consequent, node);
      this.space();
      this.token(":");
      this.space();
      this.print(node.alternate, node);
    }
    function NewExpression(node, parent) {
      this.word("new");
      this.space();
      this.print(node.callee, node);
      if (
        this.format.minified &&
        node.arguments.length === 0 &&
        !node.optional &&
        !t$6().isCallExpression(parent, { callee: node }) &&
        !t$6().isMemberExpression(parent) &&
        !t$6().isNewExpression(parent)
      ) {
        return;
      }
      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);
      if (node.optional) {
        this.token("?.");
      }
      this.token("(");
      this.printList(node.arguments, node);
      this.token(")");
    }
    function SequenceExpression(node) {
      this.printList(node.expressions, node);
    }
    function ThisExpression() {
      this.word("this");
    }
    function Super() {
      this.word("super");
    }
    function Decorator(node) {
      this.token("@");
      this.print(node.expression, node);
      this.newline();
    }
    function OptionalMemberExpression(node) {
      this.print(node.object, node);
      if (!node.computed && t$6().isMemberExpression(node.property)) {
        throw new TypeError(
          "Got a MemberExpression for MemberExpression property"
        );
      }
      var computed = node.computed;
      if (
        t$6().isLiteral(node.property) &&
        typeof node.property.value === "number"
      ) {
        computed = true;
      }
      if (node.optional) {
        this.token("?.");
      }
      if (computed) {
        this.token("[");
        this.print(node.property, node);
        this.token("]");
      } else {
        if (!node.optional) {
          this.token(".");
        }
        this.print(node.property, node);
      }
    }
    function OptionalCallExpression(node) {
      this.print(node.callee, node);
      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);
      if (node.optional) {
        this.token("?.");
      }
      this.token("(");
      this.printList(node.arguments, node);
      this.token(")");
    }
    function CallExpression(node) {
      this.print(node.callee, node);
      this.print(node.typeArguments, node);
      this.print(node.typeParameters, node);
      this.token("(");
      this.printList(node.arguments, node);
      this.token(")");
    }
    function Import() {
      this.word("import");
    }
    function buildYieldAwait(keyword) {
      return function (node) {
        this.word(keyword);
        if (node.delegate) {
          this.token("*");
        }
        if (node.argument) {
          this.space();
          var terminatorState = this.startTerminatorless();
          this.print(node.argument, node);
          this.endTerminatorless(terminatorState);
        }
      };
    }
    var YieldExpression = buildYieldAwait("yield");
    expressions.YieldExpression = YieldExpression;
    var AwaitExpression = buildYieldAwait("await");
    expressions.AwaitExpression = AwaitExpression;
    function EmptyStatement() {
      this.semicolon(true);
    }
    function ExpressionStatement(node) {
      this.print(node.expression, node);
      this.semicolon();
    }
    function AssignmentPattern(node) {
      this.print(node.left, node);
      if (node.left.optional) this.token("?");
      this.print(node.left.typeAnnotation, node);
      this.space();
      this.token("=");
      this.space();
      this.print(node.right, node);
    }
    function AssignmentExpression(node, parent) {
      var parens =
        this.inForStatementInitCounter &&
        node.operator === "in" &&
        !n$1.needsParens(node, parent);
      if (parens) {
        this.token("(");
      }
      this.print(node.left, node);
      this.space();
      if (node.operator === "in" || node.operator === "instanceof") {
        this.word(node.operator);
      } else {
        this.token(node.operator);
      }
      this.space();
      this.print(node.right, node);
      if (parens) {
        this.token(")");
      }
    }
    function BindExpression(node) {
      this.print(node.object, node);
      this.token("::");
      this.print(node.callee, node);
    }
    function MemberExpression(node) {
      this.print(node.object, node);
      if (!node.computed && t$6().isMemberExpression(node.property)) {
        throw new TypeError(
          "Got a MemberExpression for MemberExpression property"
        );
      }
      var computed = node.computed;
      if (
        t$6().isLiteral(node.property) &&
        typeof node.property.value === "number"
      ) {
        computed = true;
      }
      if (computed) {
        this.token("[");
        this.print(node.property, node);
        this.token("]");
      } else {
        this.token(".");
        this.print(node.property, node);
      }
    }
    function MetaProperty(node) {
      this.print(node.meta, node);
      this.token(".");
      this.print(node.property, node);
    }
    function PrivateName(node) {
      this.token("#");
      this.print(node.id, node);
    }
    var statements = {};
    Object.defineProperty(statements, "__esModule", { value: true });
    statements.WithStatement = WithStatement;
    statements.IfStatement = IfStatement;
    statements.ForStatement = ForStatement;
    statements.WhileStatement = WhileStatement;
    statements.DoWhileStatement = DoWhileStatement;
    statements.LabeledStatement = LabeledStatement;
    statements.TryStatement = TryStatement;
    statements.CatchClause = CatchClause;
    statements.SwitchStatement = SwitchStatement;
    statements.SwitchCase = SwitchCase;
    statements.DebuggerStatement = DebuggerStatement;
    statements.VariableDeclaration = VariableDeclaration;
    statements.VariableDeclarator = VariableDeclarator;
    statements.ThrowStatement =
      statements.BreakStatement =
      statements.ReturnStatement =
      statements.ContinueStatement =
      statements.ForOfStatement =
      statements.ForInStatement =
        void 0;
    function t$5() {
      var data = _interopRequireWildcard$6(requireLib());
      t$5 = function t$5() {
        return data;
      };
      return data;
    }
    function _interopRequireWildcard$6(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function WithStatement(node) {
      this.word("with");
      this.space();
      this.token("(");
      this.print(node.object, node);
      this.token(")");
      this.printBlock(node);
    }
    function IfStatement(node) {
      this.word("if");
      this.space();
      this.token("(");
      this.print(node.test, node);
      this.token(")");
      this.space();
      var needsBlock =
        node.alternate &&
        t$5().isIfStatement(getLastStatement(node.consequent));
      if (needsBlock) {
        this.token("{");
        this.newline();
        this.indent();
      }
      this.printAndIndentOnComments(node.consequent, node);
      if (needsBlock) {
        this.dedent();
        this.newline();
        this.token("}");
      }
      if (node.alternate) {
        if (this.endsWith("}")) this.space();
        this.word("else");
        this.space();
        this.printAndIndentOnComments(node.alternate, node);
      }
    }
    function getLastStatement(statement) {
      if (!t$5().isStatement(statement.body)) return statement;
      return getLastStatement(statement.body);
    }
    function ForStatement(node) {
      this.word("for");
      this.space();
      this.token("(");
      this.inForStatementInitCounter++;
      this.print(node.init, node);
      this.inForStatementInitCounter--;
      this.token(";");
      if (node.test) {
        this.space();
        this.print(node.test, node);
      }
      this.token(";");
      if (node.update) {
        this.space();
        this.print(node.update, node);
      }
      this.token(")");
      this.printBlock(node);
    }
    function WhileStatement(node) {
      this.word("while");
      this.space();
      this.token("(");
      this.print(node.test, node);
      this.token(")");
      this.printBlock(node);
    }
    var buildForXStatement = function buildForXStatement(op) {
      return function (node) {
        this.word("for");
        this.space();
        if (op === "of" && node["await"]) {
          this.word("await");
          this.space();
        }
        this.token("(");
        this.print(node.left, node);
        this.space();
        this.word(op);
        this.space();
        this.print(node.right, node);
        this.token(")");
        this.printBlock(node);
      };
    };
    var ForInStatement = buildForXStatement("in");
    statements.ForInStatement = ForInStatement;
    var ForOfStatement = buildForXStatement("of");
    statements.ForOfStatement = ForOfStatement;
    function DoWhileStatement(node) {
      this.word("do");
      this.space();
      this.print(node.body, node);
      this.space();
      this.word("while");
      this.space();
      this.token("(");
      this.print(node.test, node);
      this.token(")");
      this.semicolon();
    }
    function buildLabelStatement(prefix) {
      var key =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : "label";
      return function (node) {
        this.word(prefix);
        var label = node[key];
        if (label) {
          this.space();
          var isLabel = key == "label";
          var terminatorState = this.startTerminatorless(isLabel);
          this.print(label, node);
          this.endTerminatorless(terminatorState);
        }
        this.semicolon();
      };
    }
    var ContinueStatement = buildLabelStatement("continue");
    statements.ContinueStatement = ContinueStatement;
    var ReturnStatement = buildLabelStatement("return", "argument");
    statements.ReturnStatement = ReturnStatement;
    var BreakStatement = buildLabelStatement("break");
    statements.BreakStatement = BreakStatement;
    var ThrowStatement = buildLabelStatement("throw", "argument");
    statements.ThrowStatement = ThrowStatement;
    function LabeledStatement(node) {
      this.print(node.label, node);
      this.token(":");
      this.space();
      this.print(node.body, node);
    }
    function TryStatement(node) {
      this.word("try");
      this.space();
      this.print(node.block, node);
      this.space();
      if (node.handlers) {
        this.print(node.handlers[0], node);
      } else {
        this.print(node.handler, node);
      }
      if (node.finalizer) {
        this.space();
        this.word("finally");
        this.space();
        this.print(node.finalizer, node);
      }
    }
    function CatchClause(node) {
      this.word("catch");
      this.space();
      if (node.param) {
        this.token("(");
        this.print(node.param, node);
        this.token(")");
        this.space();
      }
      this.print(node.body, node);
    }
    function SwitchStatement(node) {
      this.word("switch");
      this.space();
      this.token("(");
      this.print(node.discriminant, node);
      this.token(")");
      this.space();
      this.token("{");
      this.printSequence(node.cases, node, {
        indent: true,
        addNewlines: function addNewlines(leading, cas) {
          if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
        }
      });
      this.token("}");
    }
    function SwitchCase(node) {
      if (node.test) {
        this.word("case");
        this.space();
        this.print(node.test, node);
        this.token(":");
      } else {
        this.word("default");
        this.token(":");
      }
      if (node.consequent.length) {
        this.newline();
        this.printSequence(node.consequent, node, { indent: true });
      }
    }
    function DebuggerStatement() {
      this.word("debugger");
      this.semicolon();
    }
    function variableDeclarationIndent() {
      this.token(",");
      this.newline();
      if (this.endsWith("\n")) for (var i = 0; i < 4; i++) this.space(true);
    }
    function constDeclarationIndent() {
      this.token(",");
      this.newline();
      if (this.endsWith("\n")) for (var i = 0; i < 6; i++) this.space(true);
    }
    function VariableDeclaration(node, parent) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      this.word(node.kind);
      this.space();
      var hasInits = false;
      if (!t$5().isFor(parent)) {
        var _iterator44 = _createForOfIteratorHelper(node.declarations),
          _step44;
        try {
          for (_iterator44.s(); !(_step44 = _iterator44.n()).done; ) {
            var declar = _step44.value;
            if (declar.init) {
              hasInits = true;
            }
          }
        } catch (err) {
          _iterator44.e(err);
        } finally {
          _iterator44.f();
        }
      }
      var separator;
      if (hasInits) {
        separator =
          node.kind === "const"
            ? constDeclarationIndent
            : variableDeclarationIndent;
      }
      this.printList(node.declarations, node, { separator: separator });
      if (t$5().isFor(parent)) {
        if (parent.left === node || parent.init === node) return;
      }
      this.semicolon();
    }
    function VariableDeclarator(node) {
      this.print(node.id, node);
      if (node.definite) this.token("!");
      this.print(node.id.typeAnnotation, node);
      if (node.init) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.init, node);
      }
    }
    var classes = {};
    Object.defineProperty(classes, "__esModule", { value: true });
    classes.ClassExpression = classes.ClassDeclaration = ClassDeclaration;
    classes.ClassBody = ClassBody;
    classes.ClassProperty = ClassProperty;
    classes.ClassPrivateProperty = ClassPrivateProperty;
    classes.ClassMethod = ClassMethod;
    classes.ClassPrivateMethod = ClassPrivateMethod;
    classes._classMethodHead = _classMethodHead;
    function t$4() {
      var data = _interopRequireWildcard$5(requireLib());
      t$4 = function t$4() {
        return data;
      };
      return data;
    }
    function _interopRequireWildcard$5(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function ClassDeclaration(node, parent) {
      if (
        !this.format.decoratorsBeforeExport ||
        (!t$4().isExportDefaultDeclaration(parent) &&
          !t$4().isExportNamedDeclaration(parent))
      ) {
        this.printJoin(node.decorators, node);
      }
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      if (node["abstract"]) {
        this.word("abstract");
        this.space();
      }
      this.word("class");
      if (node.id) {
        this.space();
        this.print(node.id, node);
      }
      this.print(node.typeParameters, node);
      if (node.superClass) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.superClass, node);
        this.print(node.superTypeParameters, node);
      }
      if (node["implements"]) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node["implements"], node);
      }
      this.space();
      this.print(node.body, node);
    }
    function ClassBody(node) {
      this.token("{");
      this.printInnerComments(node);
      if (node.body.length === 0) {
        this.token("}");
      } else {
        this.newline();
        this.indent();
        this.printSequence(node.body, node);
        this.dedent();
        if (!this.endsWith("\n")) this.newline();
        this.rightBrace();
      }
    }
    function ClassProperty(node) {
      this.printJoin(node.decorators, node);
      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }
      if (node["static"]) {
        this.word("static");
        this.space();
      }
      if (node["abstract"]) {
        this.word("abstract");
        this.space();
      }
      if (node.readonly) {
        this.word("readonly");
        this.space();
      }
      if (node.computed) {
        this.token("[");
        this.print(node.key, node);
        this.token("]");
      } else {
        this._variance(node);
        this.print(node.key, node);
      }
      if (node.optional) {
        this.token("?");
      }
      if (node.definite) {
        this.token("!");
      }
      this.print(node.typeAnnotation, node);
      if (node.value) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.value, node);
      }
      this.semicolon();
    }
    function ClassPrivateProperty(node) {
      if (node["static"]) {
        this.word("static");
        this.space();
      }
      this.print(node.key, node);
      this.print(node.typeAnnotation, node);
      if (node.value) {
        this.space();
        this.token("=");
        this.space();
        this.print(node.value, node);
      }
      this.semicolon();
    }
    function ClassMethod(node) {
      this._classMethodHead(node);
      this.space();
      this.print(node.body, node);
    }
    function ClassPrivateMethod(node) {
      this._classMethodHead(node);
      this.space();
      this.print(node.body, node);
    }
    function _classMethodHead(node) {
      this.printJoin(node.decorators, node);
      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }
      if (node["abstract"]) {
        this.word("abstract");
        this.space();
      }
      if (node["static"]) {
        this.word("static");
        this.space();
      }
      this._methodHead(node);
    }
    var methods = {};
    Object.defineProperty(methods, "__esModule", { value: true });
    methods._params = _params;
    methods._parameters = _parameters;
    methods._param = _param;
    methods._methodHead = _methodHead;
    methods._predicate = _predicate;
    methods._functionHead = _functionHead;
    methods.FunctionDeclaration = methods.FunctionExpression =
      FunctionExpression;
    methods.ArrowFunctionExpression = ArrowFunctionExpression;
    function t$3() {
      var data = _interopRequireWildcard$4(requireLib());
      t$3 = function t$3() {
        return data;
      };
      return data;
    }
    function _interopRequireWildcard$4(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function _params(node) {
      this.print(node.typeParameters, node);
      this.token("(");
      this._parameters(node.params, node);
      this.token(")");
      this.print(node.returnType, node);
    }
    function _parameters(parameters, parent) {
      for (var i = 0; i < parameters.length; i++) {
        this._param(parameters[i], parent);
        if (i < parameters.length - 1) {
          this.token(",");
          this.space();
        }
      }
    }
    function _param(parameter, parent) {
      this.printJoin(parameter.decorators, parameter);
      this.print(parameter, parent);
      if (parameter.optional) this.token("?");
      this.print(parameter.typeAnnotation, parameter);
    }
    function _methodHead(node) {
      var kind = node.kind;
      var key = node.key;
      if (kind === "get" || kind === "set") {
        this.word(kind);
        this.space();
      }
      if (node.async) {
        this.word("async");
        this.space();
      }
      if (kind === "method" || kind === "init") {
        if (node.generator) {
          this.token("*");
        }
      }
      if (node.computed) {
        this.token("[");
        this.print(key, node);
        this.token("]");
      } else {
        this.print(key, node);
      }
      if (node.optional) {
        this.token("?");
      }
      this._params(node);
    }
    function _predicate(node) {
      if (node.predicate) {
        if (!node.returnType) {
          this.token(":");
        }
        this.space();
        this.print(node.predicate, node);
      }
    }
    function _functionHead(node) {
      if (node.async) {
        this.word("async");
        this.space();
      }
      this.word("function");
      if (node.generator) this.token("*");
      this.space();
      if (node.id) {
        this.print(node.id, node);
      }
      this._params(node);
      this._predicate(node);
    }
    function FunctionExpression(node) {
      this._functionHead(node);
      this.space();
      this.print(node.body, node);
    }
    function ArrowFunctionExpression(node) {
      if (node.async) {
        this.word("async");
        this.space();
      }
      var firstParam = node.params[0];
      if (
        node.params.length === 1 &&
        t$3().isIdentifier(firstParam) &&
        !hasTypes(node, firstParam)
      ) {
        if (
          this.format.retainLines &&
          node.loc &&
          node.body.loc &&
          node.loc.start.line < node.body.loc.start.line
        ) {
          this.token("(");
          if (
            firstParam.loc &&
            firstParam.loc.start.line > node.loc.start.line
          ) {
            this.indent();
            this.print(firstParam, node);
            this.dedent();
            this._catchUp("start", node.body.loc);
          } else {
            this.print(firstParam, node);
          }
          this.token(")");
        } else {
          this.print(firstParam, node);
        }
      } else {
        this._params(node);
      }
      this._predicate(node);
      this.space();
      this.token("=>");
      this.space();
      this.print(node.body, node);
    }
    function hasTypes(node, param) {
      return (
        node.typeParameters ||
        node.returnType ||
        param.typeAnnotation ||
        param.optional ||
        param.trailingComments
      );
    }
    var modules = {};
    Object.defineProperty(modules, "__esModule", { value: true });
    modules.ImportSpecifier = ImportSpecifier;
    modules.ImportDefaultSpecifier = ImportDefaultSpecifier;
    modules.ExportDefaultSpecifier = ExportDefaultSpecifier;
    modules.ExportSpecifier = ExportSpecifier;
    modules.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
    modules.ExportAllDeclaration = ExportAllDeclaration;
    modules.ExportNamedDeclaration = ExportNamedDeclaration;
    modules.ExportDefaultDeclaration = ExportDefaultDeclaration;
    modules.ImportDeclaration = ImportDeclaration;
    modules.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
    function t$2() {
      var data = _interopRequireWildcard$3(requireLib());
      t$2 = function t$2() {
        return data;
      };
      return data;
    }
    function _interopRequireWildcard$3(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function ImportSpecifier(node) {
      if (node.importKind === "type" || node.importKind === "typeof") {
        this.word(node.importKind);
        this.space();
      }
      this.print(node.imported, node);
      if (node.local && node.local.name !== node.imported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.local, node);
      }
    }
    function ImportDefaultSpecifier(node) {
      this.print(node.local, node);
    }
    function ExportDefaultSpecifier(node) {
      this.print(node.exported, node);
    }
    function ExportSpecifier(node) {
      this.print(node.local, node);
      if (node.exported && node.local.name !== node.exported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.exported, node);
      }
    }
    function ExportNamespaceSpecifier(node) {
      this.token("*");
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported, node);
    }
    function ExportAllDeclaration(node) {
      this.word("export");
      this.space();
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.token("*");
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
      this.semicolon();
    }
    function ExportNamedDeclaration(node) {
      if (
        this.format.decoratorsBeforeExport &&
        t$2().isClassDeclaration(node.declaration)
      ) {
        this.printJoin(node.declaration.decorators, node);
      }
      this.word("export");
      this.space();
      ExportDeclaration.apply(this, arguments);
    }
    function ExportDefaultDeclaration(node) {
      if (
        this.format.decoratorsBeforeExport &&
        t$2().isClassDeclaration(node.declaration)
      ) {
        this.printJoin(node.declaration.decorators, node);
      }
      this.word("export");
      this.space();
      this.word("default");
      this.space();
      ExportDeclaration.apply(this, arguments);
    }
    function ExportDeclaration(node) {
      if (node.declaration) {
        var declar = node.declaration;
        this.print(declar, node);
        if (!t$2().isStatement(declar)) this.semicolon();
      } else {
        if (node.exportKind === "type") {
          this.word("type");
          this.space();
        }
        var specifiers = node.specifiers.slice(0);
        var hasSpecial = false;
        while (true) {
          var first = specifiers[0];
          if (
            t$2().isExportDefaultSpecifier(first) ||
            t$2().isExportNamespaceSpecifier(first)
          ) {
            hasSpecial = true;
            this.print(specifiers.shift(), node);
            if (specifiers.length) {
              this.token(",");
              this.space();
            }
          } else {
            break;
          }
        }
        if (specifiers.length || (!specifiers.length && !hasSpecial)) {
          this.token("{");
          if (specifiers.length) {
            this.space();
            this.printList(specifiers, node);
            this.space();
          }
          this.token("}");
        }
        if (node.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node.source, node);
        }
        this.semicolon();
      }
    }
    function ImportDeclaration(node) {
      this.word("import");
      this.space();
      if (node.importKind === "type" || node.importKind === "typeof") {
        this.word(node.importKind);
        this.space();
      }
      var specifiers = node.specifiers.slice(0);
      if (specifiers && specifiers.length) {
        while (true) {
          var first = specifiers[0];
          if (
            t$2().isImportDefaultSpecifier(first) ||
            t$2().isImportNamespaceSpecifier(first)
          ) {
            this.print(specifiers.shift(), node);
            if (specifiers.length) {
              this.token(",");
              this.space();
            }
          } else {
            break;
          }
        }
        if (specifiers.length) {
          this.token("{");
          this.space();
          this.printList(specifiers, node);
          this.space();
          this.token("}");
        }
        this.space();
        this.word("from");
        this.space();
      }
      this.print(node.source, node);
      this.semicolon();
    }
    function ImportNamespaceSpecifier(node) {
      this.token("*");
      this.space();
      this.word("as");
      this.space();
      this.print(node.local, node);
    }
    var types = {};
    var jsesc_1;
    var hasRequiredJsesc;
    function requireJsesc() {
      if (hasRequiredJsesc) return jsesc_1;
      hasRequiredJsesc = 1;
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var forOwn = function forOwn(object, callback) {
        for (var _key26 in object) {
          if (hasOwnProperty.call(object, _key26)) {
            callback(_key26, object[_key26]);
          }
        }
      };
      var extend = function extend(destination, source) {
        if (!source) {
          return destination;
        }
        forOwn(source, function (key, value) {
          destination[key] = value;
        });
        return destination;
      };
      var forEach = function forEach(array, callback) {
        var length = array.length;
        var index = -1;
        while (++index < length) {
          callback(array[index]);
        }
      };
      var toString = object.toString;
      var isArray = Array.isArray;
      var isBuffer = Buffer.isBuffer;
      var isObject = function isObject(value) {
        // This is a very simple check, but it’s good enough for what we need.
        return toString.call(value) == "[object Object]";
      };
      var isString = function isString(value) {
        return (
          typeof value == "string" || toString.call(value) == "[object String]"
        );
      };
      var isNumber = function isNumber(value) {
        return (
          typeof value == "number" || toString.call(value) == "[object Number]"
        );
      };
      var isFunction = function isFunction(value) {
        return typeof value == "function";
      };
      var isMap = function isMap(value) {
        return toString.call(value) == "[object Map]";
      };
      var isSet = function isSet(value) {
        return toString.call(value) == "[object Set]";
      }; /*--------------------------------------------------------------------------*/ // https://mathiasbynens.be/notes/javascript-escapes#single
      var singleEscapes = {
        '"': '\\"',
        "'": "\\'",
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "\t": "\\t" // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
        // '\v': '\\x0B'
      };
      var regexSingleEscape = /["'\\\b\f\n\r\t]/;
      var regexDigit = /[0-9]/;
      var regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;
      var _jsesc2 = function jsesc(argument, options) {
        var increaseIndentation = function increaseIndentation() {
          oldIndent = indent;
          ++options.indentLevel;
          indent = options.indent.repeat(options.indentLevel);
        }; // Handle options
        var defaults = {
          escapeEverything: false,
          minimal: false,
          isScriptContext: false,
          quotes: "single",
          wrap: false,
          es6: false,
          json: false,
          compact: true,
          lowercaseHex: false,
          numbers: "decimal",
          indent: "\t",
          indentLevel: 0,
          __inline1__: false,
          __inline2__: false
        };
        var json = options && options.json;
        if (json) {
          defaults.quotes = "double";
          defaults.wrap = true;
        }
        options = extend(defaults, options);
        if (
          options.quotes != "single" &&
          options.quotes != "double" &&
          options.quotes != "backtick"
        ) {
          options.quotes = "single";
        }
        var quote =
          options.quotes == "double"
            ? '"'
            : options.quotes == "backtick"
              ? "`"
              : "'";
        var compact = options.compact;
        var lowercaseHex = options.lowercaseHex;
        var indent = options.indent.repeat(options.indentLevel);
        var oldIndent = "";
        var inline1 = options.__inline1__;
        var inline2 = options.__inline2__;
        var newLine = compact ? "" : "\n";
        var result;
        var isEmpty = true;
        var useBinNumbers = options.numbers == "binary";
        var useOctNumbers = options.numbers == "octal";
        var useDecNumbers = options.numbers == "decimal";
        var useHexNumbers = options.numbers == "hexadecimal";
        if (json && argument && isFunction(argument.toJSON)) {
          argument = argument.toJSON();
        }
        if (!isString(argument)) {
          if (isMap(argument)) {
            if (argument.size == 0) {
              return "new Map()";
            }
            if (!compact) {
              options.__inline1__ = true;
              options.__inline2__ = false;
            }
            return "new Map(" + _jsesc2(Array.from(argument), options) + ")";
          }
          if (isSet(argument)) {
            if (argument.size == 0) {
              return "new Set()";
            }
            return "new Set(" + _jsesc2(Array.from(argument), options) + ")";
          }
          if (isBuffer(argument)) {
            if (argument.length == 0) {
              return "Buffer.from([])";
            }
            return (
              "Buffer.from(" + _jsesc2(Array.from(argument), options) + ")"
            );
          }
          if (isArray(argument)) {
            result = [];
            options.wrap = true;
            if (inline1) {
              options.__inline1__ = false;
              options.__inline2__ = true;
            }
            if (!inline2) {
              increaseIndentation();
            }
            forEach(argument, function (value) {
              isEmpty = false;
              if (inline2) {
                options.__inline2__ = false;
              }
              result.push(
                (compact || inline2 ? "" : indent) + _jsesc2(value, options)
              );
            });
            if (isEmpty) {
              return "[]";
            }
            if (inline2) {
              return "[" + result.join(", ") + "]";
            }
            return (
              "[" +
              newLine +
              result.join("," + newLine) +
              newLine +
              (compact ? "" : oldIndent) +
              "]"
            );
          } else if (isNumber(argument)) {
            if (json) {
              // Some number values (e.g. `Infinity`) cannot be represented in JSON.
              return JSON.stringify(argument);
            }
            if (useDecNumbers) {
              return String(argument);
            }
            if (useHexNumbers) {
              var hexadecimal = argument.toString(16);
              if (!lowercaseHex) {
                hexadecimal = hexadecimal.toUpperCase();
              }
              return "0x" + hexadecimal;
            }
            if (useBinNumbers) {
              return "0b" + argument.toString(2);
            }
            if (useOctNumbers) {
              return "0o" + argument.toString(8);
            }
          } else if (!isObject(argument)) {
            if (json) {
              // For some values (e.g. `undefined`, `function` objects),
              // `JSON.stringify(value)` returns `undefined` (which isn’t valid
              // JSON) instead of `'null'`.
              return JSON.stringify(argument) || "null";
            }
            return String(argument);
          } else {
            // it’s an object
            result = [];
            options.wrap = true;
            increaseIndentation();
            forOwn(argument, function (key, value) {
              isEmpty = false;
              result.push(
                (compact ? "" : indent) +
                  _jsesc2(key, options) +
                  ":" +
                  (compact ? "" : " ") +
                  _jsesc2(value, options)
              );
            });
            if (isEmpty) {
              return "{}";
            }
            return (
              "{" +
              newLine +
              result.join("," + newLine) +
              newLine +
              (compact ? "" : oldIndent) +
              "}"
            );
          }
        }
        var string = argument; // Loop over each code unit in the string and escape it
        var index = -1;
        var length = string.length;
        result = "";
        while (++index < length) {
          var character = string.charAt(index);
          if (options.es6) {
            var first = string.charCodeAt(index);
            if (
              // check if it’s the start of a surrogate pair
              first >= 0xd800 &&
              first <= 0xdbff && // high surrogate
              length > index + 1 // there is a next code unit
            ) {
              var second = string.charCodeAt(index + 1);
              if (second >= 0xdc00 && second <= 0xdfff) {
                // low surrogate
                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                var codePoint =
                  (first - 0xd800) * 0x400 + second - 0xdc00 + 0x10000;
                var _hexadecimal = codePoint.toString(16);
                if (!lowercaseHex) {
                  _hexadecimal = _hexadecimal.toUpperCase();
                }
                result += "\\u{" + _hexadecimal + "}";
                ++index;
                continue;
              }
            }
          }
          if (!options.escapeEverything) {
            if (regexWhitelist.test(character)) {
              // It’s a printable ASCII character that is not `"`, `'` or `\`,
              // so don’t escape it.
              result += character;
              continue;
            }
            if (character == '"') {
              result += quote == character ? '\\"' : character;
              continue;
            }
            if (character == "`") {
              result += quote == character ? "\\`" : character;
              continue;
            }
            if (character == "'") {
              result += quote == character ? "\\'" : character;
              continue;
            }
          }
          if (
            character == "\0" &&
            !json &&
            !regexDigit.test(string.charAt(index + 1))
          ) {
            result += "\\0";
            continue;
          }
          if (regexSingleEscape.test(character)) {
            // no need for a `hasOwnProperty` check here
            result += singleEscapes[character];
            continue;
          }
          var charCode = character.charCodeAt(0);
          if (options.minimal && charCode != 0x2028 && charCode != 0x2029) {
            result += character;
            continue;
          }
          var _hexadecimal2 = charCode.toString(16);
          if (!lowercaseHex) {
            _hexadecimal2 = _hexadecimal2.toUpperCase();
          }
          var longhand = _hexadecimal2.length > 2 || json;
          var escaped =
            "\\" +
            (longhand ? "u" : "x") +
            ("0000" + _hexadecimal2).slice(longhand ? -4 : -2);
          result += escaped;
          continue;
        }
        if (options.wrap) {
          result = quote + result + quote;
        }
        if (quote == "`") {
          result = result.replace(/\$\{/g, "\\${");
        }
        if (options.isScriptContext) {
          // https://mathiasbynens.be/notes/etago
          return result
            .replace(/<\/(script|style)/gi, "<\\/$1")
            .replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
        }
        return result;
      };
      _jsesc2.version = "2.5.2";
      jsesc_1 = _jsesc2;
      return jsesc_1;
    }
    Object.defineProperty(types, "__esModule", { value: true });
    types.Identifier = Identifier;
    types.SpreadElement = types.RestElement = RestElement;
    types.ObjectPattern = types.ObjectExpression = ObjectExpression;
    types.ObjectMethod = ObjectMethod;
    types.ObjectProperty = ObjectProperty;
    types.ArrayPattern = types.ArrayExpression = ArrayExpression;
    types.RegExpLiteral = RegExpLiteral;
    types.BooleanLiteral = BooleanLiteral;
    types.NullLiteral = NullLiteral;
    types.NumericLiteral = NumericLiteral;
    types.StringLiteral = StringLiteral;
    types.BigIntLiteral = BigIntLiteral;
    function t$1() {
      var data = _interopRequireWildcard$2(requireLib());
      t$1 = function t$1() {
        return data;
      };
      return data;
    }
    function _jsesc() {
      var data = _interopRequireDefault$5(requireJsesc());
      _jsesc = function _jsesc() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault$5(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _interopRequireWildcard$2(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function Identifier(node) {
      var _this2 = this;
      this.exactSource(node.loc, function () {
        _this2.word(node.name);
      });
    }
    function RestElement(node) {
      this.token("...");
      this.print(node.argument, node);
    }
    function ObjectExpression(node) {
      var props = node.properties;
      this.token("{");
      this.printInnerComments(node);
      if (props.length) {
        this.space();
        this.printList(props, node, { indent: true, statement: true });
        this.space();
      }
      this.token("}");
    }
    function ObjectMethod(node) {
      this.printJoin(node.decorators, node);
      this._methodHead(node);
      this.space();
      this.print(node.body, node);
    }
    function ObjectProperty(node) {
      this.printJoin(node.decorators, node);
      if (node.computed) {
        this.token("[");
        this.print(node.key, node);
        this.token("]");
      } else {
        if (
          t$1().isAssignmentPattern(node.value) &&
          t$1().isIdentifier(node.key) &&
          node.key.name === node.value.left.name
        ) {
          this.print(node.value, node);
          return;
        }
        this.print(node.key, node);
        if (
          node.shorthand &&
          t$1().isIdentifier(node.key) &&
          t$1().isIdentifier(node.value) &&
          node.key.name === node.value.name
        ) {
          return;
        }
      }
      this.token(":");
      this.space();
      this.print(node.value, node);
    }
    function ArrayExpression(node) {
      var elems = node.elements;
      var len = elems.length;
      this.token("[");
      this.printInnerComments(node);
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (elem) {
          if (i > 0) this.space();
          this.print(elem, node);
          if (i < len - 1) this.token(",");
        } else {
          this.token(",");
        }
      }
      this.token("]");
    }
    function RegExpLiteral(node) {
      this.word("/".concat(node.pattern, "/").concat(node.flags));
    }
    function BooleanLiteral(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteral() {
      this.word("null");
    }
    function NumericLiteral(node) {
      var raw = this.getPossibleRaw(node);
      var value = node.value + "";
      if (raw == null) {
        this.number(value);
      } else if (this.format.minified) {
        this.number(raw.length < value.length ? raw : value);
      } else {
        this.number(raw);
      }
    }
    function StringLiteral(node) {
      var raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw != null) {
        this.token(raw);
        return;
      }
      var opts = this.format.jsescOption;
      if (this.format.jsonCompatibleStrings) {
        opts.json = true;
      }
      var val = (0, _jsesc()["default"])(node.value, opts);
      return this.token(val);
    }
    function BigIntLiteral(node) {
      var raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw != null) {
        this.token(raw);
        return;
      }
      this.token(node.value);
    }
    var flow = {};
    (function (exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnyTypeAnnotation = AnyTypeAnnotation;
      exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
      exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
      exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
      exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
      exports.DeclareClass = DeclareClass;
      exports.DeclareFunction = DeclareFunction;
      exports.InferredPredicate = InferredPredicate;
      exports.DeclaredPredicate = DeclaredPredicate;
      exports.DeclareInterface = DeclareInterface;
      exports.DeclareModule = DeclareModule;
      exports.DeclareModuleExports = DeclareModuleExports;
      exports.DeclareTypeAlias = DeclareTypeAlias;
      exports.DeclareOpaqueType = DeclareOpaqueType;
      exports.DeclareVariable = DeclareVariable;
      exports.DeclareExportDeclaration = DeclareExportDeclaration;
      exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
      exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
      exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
      exports.FunctionTypeParam = FunctionTypeParam;
      exports.GenericTypeAnnotation =
        exports.ClassImplements =
        exports.InterfaceExtends =
          InterfaceExtends;
      exports._interfaceish = _interfaceish;
      exports._variance = _variance;
      exports.InterfaceDeclaration = InterfaceDeclaration;
      exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
      exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
      exports.MixedTypeAnnotation = MixedTypeAnnotation;
      exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
      exports.NullableTypeAnnotation = NullableTypeAnnotation;
      exports.NumberTypeAnnotation = NumberTypeAnnotation;
      exports.StringTypeAnnotation = StringTypeAnnotation;
      exports.ThisTypeAnnotation = ThisTypeAnnotation;
      exports.TupleTypeAnnotation = TupleTypeAnnotation;
      exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
      exports.TypeAlias = TypeAlias;
      exports.TypeAnnotation = TypeAnnotation;
      exports.TypeParameterDeclaration = exports.TypeParameterInstantiation =
        TypeParameterInstantiation;
      exports.TypeParameter = TypeParameter;
      exports.OpaqueType = OpaqueType;
      exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
      exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
      exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
      exports.ObjectTypeIndexer = ObjectTypeIndexer;
      exports.ObjectTypeProperty = ObjectTypeProperty;
      exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
      exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
      exports.UnionTypeAnnotation = UnionTypeAnnotation;
      exports.TypeCastExpression = TypeCastExpression;
      exports.Variance = Variance;
      exports.VoidTypeAnnotation = VoidTypeAnnotation;
      Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _types2.NumericLiteral;
        }
      });
      Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
        enumerable: true,
        get: function get() {
          return _types2.StringLiteral;
        }
      });
      function t() {
        var data = _interopRequireWildcard(requireLib());
        t = function t() {
          return data;
        };
        return data;
      }
      var _modules = modules;
      var _types2 = types;
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc =
                  Object.defineProperty && Object.getOwnPropertyDescriptor
                    ? Object.getOwnPropertyDescriptor(obj, key)
                    : {};
                if (desc.get || desc.set) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      function AnyTypeAnnotation() {
        this.word("any");
      }
      function ArrayTypeAnnotation(node) {
        this.print(node.elementType, node);
        this.token("[");
        this.token("]");
      }
      function BooleanTypeAnnotation() {
        this.word("boolean");
      }
      function BooleanLiteralTypeAnnotation(node) {
        this.word(node.value ? "true" : "false");
      }
      function NullLiteralTypeAnnotation() {
        this.word("null");
      }
      function DeclareClass(node, parent) {
        if (!t().isDeclareExportDeclaration(parent)) {
          this.word("declare");
          this.space();
        }
        this.word("class");
        this.space();
        this._interfaceish(node);
      }
      function DeclareFunction(node, parent) {
        if (!t().isDeclareExportDeclaration(parent)) {
          this.word("declare");
          this.space();
        }
        this.word("function");
        this.space();
        this.print(node.id, node);
        this.print(node.id.typeAnnotation.typeAnnotation, node);
        if (node.predicate) {
          this.space();
          this.print(node.predicate, node);
        }
        this.semicolon();
      }
      function InferredPredicate() {
        this.token("%");
        this.word("checks");
      }
      function DeclaredPredicate(node) {
        this.token("%");
        this.word("checks");
        this.token("(");
        this.print(node.value, node);
        this.token(")");
      }
      function DeclareInterface(node) {
        this.word("declare");
        this.space();
        this.InterfaceDeclaration(node);
      }
      function DeclareModule(node) {
        this.word("declare");
        this.space();
        this.word("module");
        this.space();
        this.print(node.id, node);
        this.space();
        this.print(node.body, node);
      }
      function DeclareModuleExports(node) {
        this.word("declare");
        this.space();
        this.word("module");
        this.token(".");
        this.word("exports");
        this.print(node.typeAnnotation, node);
      }
      function DeclareTypeAlias(node) {
        this.word("declare");
        this.space();
        this.TypeAlias(node);
      }
      function DeclareOpaqueType(node, parent) {
        if (!t().isDeclareExportDeclaration(parent)) {
          this.word("declare");
          this.space();
        }
        this.OpaqueType(node);
      }
      function DeclareVariable(node, parent) {
        if (!t().isDeclareExportDeclaration(parent)) {
          this.word("declare");
          this.space();
        }
        this.word("var");
        this.space();
        this.print(node.id, node);
        this.print(node.id.typeAnnotation, node);
        this.semicolon();
      }
      function DeclareExportDeclaration(node) {
        this.word("declare");
        this.space();
        this.word("export");
        this.space();
        if (node["default"]) {
          this.word("default");
          this.space();
        }
        FlowExportDeclaration.apply(this, arguments);
      }
      function DeclareExportAllDeclaration() {
        this.word("declare");
        this.space();
        _modules.ExportAllDeclaration.apply(this, arguments);
      }
      function FlowExportDeclaration(node) {
        if (node.declaration) {
          var declar = node.declaration;
          this.print(declar, node);
          if (!t().isStatement(declar)) this.semicolon();
        } else {
          this.token("{");
          if (node.specifiers.length) {
            this.space();
            this.printList(node.specifiers, node);
            this.space();
          }
          this.token("}");
          if (node.source) {
            this.space();
            this.word("from");
            this.space();
            this.print(node.source, node);
          }
          this.semicolon();
        }
      }
      function ExistsTypeAnnotation() {
        this.token("*");
      }
      function FunctionTypeAnnotation(node, parent) {
        this.print(node.typeParameters, node);
        this.token("(");
        this.printList(node.params, node);
        if (node.rest) {
          if (node.params.length) {
            this.token(",");
            this.space();
          }
          this.token("...");
          this.print(node.rest, node);
        }
        this.token(")");
        if (
          parent.type === "ObjectTypeCallProperty" ||
          parent.type === "DeclareFunction" ||
          (parent.type === "ObjectTypeProperty" && parent.method)
        ) {
          this.token(":");
        } else {
          this.space();
          this.token("=>");
        }
        this.space();
        this.print(node.returnType, node);
      }
      function FunctionTypeParam(node) {
        this.print(node.name, node);
        if (node.optional) this.token("?");
        if (node.name) {
          this.token(":");
          this.space();
        }
        this.print(node.typeAnnotation, node);
      }
      function InterfaceExtends(node) {
        this.print(node.id, node);
        this.print(node.typeParameters, node);
      }
      function _interfaceish(node) {
        this.print(node.id, node);
        this.print(node.typeParameters, node);
        if (node["extends"].length) {
          this.space();
          this.word("extends");
          this.space();
          this.printList(node["extends"], node);
        }
        if (node.mixins && node.mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node.mixins, node);
        }
        if (node["implements"] && node["implements"].length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node["implements"], node);
        }
        this.space();
        this.print(node.body, node);
      }
      function _variance(node) {
        if (node.variance) {
          if (node.variance.kind === "plus") {
            this.token("+");
          } else if (node.variance.kind === "minus") {
            this.token("-");
          }
        }
      }
      function InterfaceDeclaration(node) {
        this.word("interface");
        this.space();
        this._interfaceish(node);
      }
      function andSeparator() {
        this.space();
        this.token("&");
        this.space();
      }
      function InterfaceTypeAnnotation(node) {
        this.word("interface");
        if (node["extends"] && node["extends"].length) {
          this.space();
          this.word("extends");
          this.space();
          this.printList(node["extends"], node);
        }
        this.space();
        this.print(node.body, node);
      }
      function IntersectionTypeAnnotation(node) {
        this.printJoin(node.types, node, { separator: andSeparator });
      }
      function MixedTypeAnnotation() {
        this.word("mixed");
      }
      function EmptyTypeAnnotation() {
        this.word("empty");
      }
      function NullableTypeAnnotation(node) {
        this.token("?");
        this.print(node.typeAnnotation, node);
      }
      function NumberTypeAnnotation() {
        this.word("number");
      }
      function StringTypeAnnotation() {
        this.word("string");
      }
      function ThisTypeAnnotation() {
        this.word("this");
      }
      function TupleTypeAnnotation(node) {
        this.token("[");
        this.printList(node.types, node);
        this.token("]");
      }
      function TypeofTypeAnnotation(node) {
        this.word("typeof");
        this.space();
        this.print(node.argument, node);
      }
      function TypeAlias(node) {
        this.word("type");
        this.space();
        this.print(node.id, node);
        this.print(node.typeParameters, node);
        this.space();
        this.token("=");
        this.space();
        this.print(node.right, node);
        this.semicolon();
      }
      function TypeAnnotation(node) {
        this.token(":");
        this.space();
        if (node.optional) this.token("?");
        this.print(node.typeAnnotation, node);
      }
      function TypeParameterInstantiation(node) {
        this.token("<");
        this.printList(node.params, node, {});
        this.token(">");
      }
      function TypeParameter(node) {
        this._variance(node);
        this.word(node.name);
        if (node.bound) {
          this.print(node.bound, node);
        }
        if (node["default"]) {
          this.space();
          this.token("=");
          this.space();
          this.print(node["default"], node);
        }
      }
      function OpaqueType(node) {
        this.word("opaque");
        this.space();
        this.word("type");
        this.space();
        this.print(node.id, node);
        this.print(node.typeParameters, node);
        if (node.supertype) {
          this.token(":");
          this.space();
          this.print(node.supertype, node);
        }
        if (node.impltype) {
          this.space();
          this.token("=");
          this.space();
          this.print(node.impltype, node);
        }
        this.semicolon();
      }
      function ObjectTypeAnnotation(node) {
        var _this3 = this;
        if (node.exact) {
          this.token("{|");
        } else {
          this.token("{");
        }
        var props = node.properties.concat(
          node.callProperties || [],
          node.indexers || [],
          node.internalSlots || []
        );
        if (props.length) {
          this.space();
          this.printJoin(props, node, {
            addNewlines: function addNewlines(leading) {
              if (leading && !props[0]) return 1;
            },
            indent: true,
            statement: true,
            iterator: function iterator() {
              if (props.length !== 1) {
                _this3.token(",");
                _this3.space();
              }
            }
          });
          this.space();
        }
        if (node.exact) {
          this.token("|}");
        } else {
          this.token("}");
        }
      }
      function ObjectTypeInternalSlot(node) {
        if (node["static"]) {
          this.word("static");
          this.space();
        }
        this.token("[");
        this.token("[");
        this.print(node.id, node);
        this.token("]");
        this.token("]");
        if (node.optional) this.token("?");
        if (!node.method) {
          this.token(":");
          this.space();
        }
        this.print(node.value, node);
      }
      function ObjectTypeCallProperty(node) {
        if (node["static"]) {
          this.word("static");
          this.space();
        }
        this.print(node.value, node);
      }
      function ObjectTypeIndexer(node) {
        if (node["static"]) {
          this.word("static");
          this.space();
        }
        this._variance(node);
        this.token("[");
        if (node.id) {
          this.print(node.id, node);
          this.token(":");
          this.space();
        }
        this.print(node.key, node);
        this.token("]");
        this.token(":");
        this.space();
        this.print(node.value, node);
      }
      function ObjectTypeProperty(node) {
        if (node.proto) {
          this.word("proto");
          this.space();
        }
        if (node["static"]) {
          this.word("static");
          this.space();
        }
        this._variance(node);
        this.print(node.key, node);
        if (node.optional) this.token("?");
        if (!node.method) {
          this.token(":");
          this.space();
        }
        this.print(node.value, node);
      }
      function ObjectTypeSpreadProperty(node) {
        this.token("...");
        this.print(node.argument, node);
      }
      function QualifiedTypeIdentifier(node) {
        this.print(node.qualification, node);
        this.token(".");
        this.print(node.id, node);
      }
      function orSeparator() {
        this.space();
        this.token("|");
        this.space();
      }
      function UnionTypeAnnotation(node) {
        this.printJoin(node.types, node, { separator: orSeparator });
      }
      function TypeCastExpression(node) {
        this.token("(");
        this.print(node.expression, node);
        this.print(node.typeAnnotation, node);
        this.token(")");
      }
      function Variance(node) {
        if (node.kind === "plus") {
          this.token("+");
        } else {
          this.token("-");
        }
      }
      function VoidTypeAnnotation() {
        this.word("void");
      }
    })(flow);
    var base = {};
    (function (exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.File = File;
      exports.Program = Program;
      exports.BlockStatement = BlockStatement;
      exports.Noop = Noop;
      exports.Directive = Directive;
      exports.InterpreterDirective = InterpreterDirective;
      Object.defineProperty(exports, "DirectiveLiteral", {
        enumerable: true,
        get: function get() {
          return _types.StringLiteral;
        }
      });
      var _types = types;
      function File(node) {
        if (node.program) {
          this.print(node.program.interpreter, node);
        }
        this.print(node.program, node);
      }
      function Program(node) {
        this.printInnerComments(node, false);
        this.printSequence(node.directives, node);
        if (node.directives && node.directives.length) this.newline();
        this.printSequence(node.body, node);
      }
      function BlockStatement(node) {
        this.token("{");
        this.printInnerComments(node);
        var hasDirectives = node.directives && node.directives.length;
        if (node.body.length || hasDirectives) {
          this.newline();
          this.printSequence(node.directives, node, { indent: true });
          if (hasDirectives) this.newline();
          this.printSequence(node.body, node, { indent: true });
          this.removeTrailingNewline();
          this.source("end", node.loc);
          if (!this.endsWith("\n")) this.newline();
          this.rightBrace();
        } else {
          this.source("end", node.loc);
          this.token("}");
        }
      }
      function Noop() {}
      function Directive(node) {
        this.print(node.value, node);
        this.semicolon();
      }
      function InterpreterDirective(node) {
        this.token("#!".concat(node.value, "\n"));
      }
    })(base);
    var jsx = {};
    Object.defineProperty(jsx, "__esModule", { value: true });
    jsx.JSXAttribute = JSXAttribute;
    jsx.JSXIdentifier = JSXIdentifier;
    jsx.JSXNamespacedName = JSXNamespacedName;
    jsx.JSXMemberExpression = JSXMemberExpression;
    jsx.JSXSpreadAttribute = JSXSpreadAttribute;
    jsx.JSXExpressionContainer = JSXExpressionContainer;
    jsx.JSXSpreadChild = JSXSpreadChild;
    jsx.JSXText = JSXText;
    jsx.JSXElement = JSXElement;
    jsx.JSXOpeningElement = JSXOpeningElement;
    jsx.JSXClosingElement = JSXClosingElement;
    jsx.JSXEmptyExpression = JSXEmptyExpression;
    jsx.JSXFragment = JSXFragment;
    jsx.JSXOpeningFragment = JSXOpeningFragment;
    jsx.JSXClosingFragment = JSXClosingFragment;
    function JSXAttribute(node) {
      this.print(node.name, node);
      if (node.value) {
        this.token("=");
        this.print(node.value, node);
      }
    }
    function JSXIdentifier(node) {
      this.word(node.name);
    }
    function JSXNamespacedName(node) {
      this.print(node.namespace, node);
      this.token(":");
      this.print(node.name, node);
    }
    function JSXMemberExpression(node) {
      this.print(node.object, node);
      this.token(".");
      this.print(node.property, node);
    }
    function JSXSpreadAttribute(node) {
      this.token("{");
      this.token("...");
      this.print(node.argument, node);
      this.token("}");
    }
    function JSXExpressionContainer(node) {
      this.token("{");
      this.print(node.expression, node);
      this.token("}");
    }
    function JSXSpreadChild(node) {
      this.token("{");
      this.token("...");
      this.print(node.expression, node);
      this.token("}");
    }
    function JSXText(node) {
      var raw = this.getPossibleRaw(node);
      if (raw != null) {
        this.token(raw);
      } else {
        this.token(node.value);
      }
    }
    function JSXElement(node) {
      var open = node.openingElement;
      this.print(open, node);
      if (open.selfClosing) return;
      this.indent();
      var _iterator45 = _createForOfIteratorHelper(node.children),
        _step45;
      try {
        for (_iterator45.s(); !(_step45 = _iterator45.n()).done; ) {
          var child = _step45.value;
          this.print(child, node);
        }
      } catch (err) {
        _iterator45.e(err);
      } finally {
        _iterator45.f();
      }
      this.dedent();
      this.print(node.closingElement, node);
    }
    function spaceSeparator() {
      this.space();
    }
    function JSXOpeningElement(node) {
      this.token("<");
      this.print(node.name, node);
      this.print(node.typeParameters, node);
      if (node.attributes.length > 0) {
        this.space();
        this.printJoin(node.attributes, node, { separator: spaceSeparator });
      }
      if (node.selfClosing) {
        this.space();
        this.token("/>");
      } else {
        this.token(">");
      }
    }
    function JSXClosingElement(node) {
      this.token("</");
      this.print(node.name, node);
      this.token(">");
    }
    function JSXEmptyExpression(node) {
      this.printInnerComments(node);
    }
    function JSXFragment(node) {
      this.print(node.openingFragment, node);
      this.indent();
      var _iterator46 = _createForOfIteratorHelper(node.children),
        _step46;
      try {
        for (_iterator46.s(); !(_step46 = _iterator46.n()).done; ) {
          var child = _step46.value;
          this.print(child, node);
        }
      } catch (err) {
        _iterator46.e(err);
      } finally {
        _iterator46.f();
      }
      this.dedent();
      this.print(node.closingFragment, node);
    }
    function JSXOpeningFragment() {
      this.token("<");
      this.token(">");
    }
    function JSXClosingFragment() {
      this.token("</");
      this.token(">");
    }
    var typescript = {};
    Object.defineProperty(typescript, "__esModule", { value: true });
    typescript.TSTypeAnnotation = TSTypeAnnotation;
    typescript.TSTypeParameterDeclaration =
      typescript.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
    typescript.TSTypeParameter = TSTypeParameter;
    typescript.TSParameterProperty = TSParameterProperty;
    typescript.TSDeclareFunction = TSDeclareFunction;
    typescript.TSDeclareMethod = TSDeclareMethod;
    typescript.TSQualifiedName = TSQualifiedName;
    typescript.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
    typescript.TSConstructSignatureDeclaration =
      TSConstructSignatureDeclaration;
    typescript.TSPropertySignature = TSPropertySignature;
    typescript.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
    typescript.TSMethodSignature = TSMethodSignature;
    typescript.TSIndexSignature = TSIndexSignature;
    typescript.TSAnyKeyword = TSAnyKeyword;
    typescript.TSUnknownKeyword = TSUnknownKeyword;
    typescript.TSNumberKeyword = TSNumberKeyword;
    typescript.TSObjectKeyword = TSObjectKeyword;
    typescript.TSBooleanKeyword = TSBooleanKeyword;
    typescript.TSStringKeyword = TSStringKeyword;
    typescript.TSSymbolKeyword = TSSymbolKeyword;
    typescript.TSVoidKeyword = TSVoidKeyword;
    typescript.TSUndefinedKeyword = TSUndefinedKeyword;
    typescript.TSNullKeyword = TSNullKeyword;
    typescript.TSNeverKeyword = TSNeverKeyword;
    typescript.TSThisType = TSThisType;
    typescript.TSFunctionType = TSFunctionType;
    typescript.TSConstructorType = TSConstructorType;
    typescript.tsPrintFunctionOrConstructorType =
      tsPrintFunctionOrConstructorType;
    typescript.TSTypeReference = TSTypeReference;
    typescript.TSTypePredicate = TSTypePredicate;
    typescript.TSTypeQuery = TSTypeQuery;
    typescript.TSTypeLiteral = TSTypeLiteral;
    typescript.tsPrintTypeLiteralOrInterfaceBody =
      tsPrintTypeLiteralOrInterfaceBody;
    typescript.tsPrintBraced = tsPrintBraced;
    typescript.TSArrayType = TSArrayType;
    typescript.TSTupleType = TSTupleType;
    typescript.TSOptionalType = TSOptionalType;
    typescript.TSRestType = TSRestType;
    typescript.TSUnionType = TSUnionType;
    typescript.TSIntersectionType = TSIntersectionType;
    typescript.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;
    typescript.TSConditionalType = TSConditionalType;
    typescript.TSInferType = TSInferType;
    typescript.TSParenthesizedType = TSParenthesizedType;
    typescript.TSTypeOperator = TSTypeOperator;
    typescript.TSIndexedAccessType = TSIndexedAccessType;
    typescript.TSMappedType = TSMappedType;
    typescript.TSLiteralType = TSLiteralType;
    typescript.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
    typescript.TSInterfaceDeclaration = TSInterfaceDeclaration;
    typescript.TSInterfaceBody = TSInterfaceBody;
    typescript.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
    typescript.TSAsExpression = TSAsExpression;
    typescript.TSTypeAssertion = TSTypeAssertion;
    typescript.TSEnumDeclaration = TSEnumDeclaration;
    typescript.TSEnumMember = TSEnumMember;
    typescript.TSModuleDeclaration = TSModuleDeclaration;
    typescript.TSModuleBlock = TSModuleBlock;
    typescript.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
    typescript.TSExternalModuleReference = TSExternalModuleReference;
    typescript.TSNonNullExpression = TSNonNullExpression;
    typescript.TSExportAssignment = TSExportAssignment;
    typescript.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
    typescript.tsPrintSignatureDeclarationBase =
      tsPrintSignatureDeclarationBase;
    function TSTypeAnnotation(node) {
      this.token(":");
      this.space();
      if (node.optional) this.token("?");
      this.print(node.typeAnnotation, node);
    }
    function TSTypeParameterInstantiation(node) {
      this.token("<");
      this.printList(node.params, node, {});
      this.token(">");
    }
    function TSTypeParameter(node) {
      this.word(node.name);
      if (node.constraint) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.constraint, node);
      }
      if (node["default"]) {
        this.space();
        this.token("=");
        this.space();
        this.print(node["default"], node);
      }
    }
    function TSParameterProperty(node) {
      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }
      if (node.readonly) {
        this.word("readonly");
        this.space();
      }
      this._param(node.parameter);
    }
    function TSDeclareFunction(node) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      this._functionHead(node);
      this.token(";");
    }
    function TSDeclareMethod(node) {
      this._classMethodHead(node);
      this.token(";");
    }
    function TSQualifiedName(node) {
      this.print(node.left, node);
      this.token(".");
      this.print(node.right, node);
    }
    function TSCallSignatureDeclaration(node) {
      this.tsPrintSignatureDeclarationBase(node);
    }
    function TSConstructSignatureDeclaration(node) {
      this.word("new");
      this.space();
      this.tsPrintSignatureDeclarationBase(node);
    }
    function TSPropertySignature(node) {
      var readonly = node.readonly,
        initializer = node.initializer;
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node);
      this.print(node.typeAnnotation, node);
      if (initializer) {
        this.space();
        this.token("=");
        this.space();
        this.print(initializer, node);
      }
      this.token(";");
    }
    function tsPrintPropertyOrMethodName(node) {
      if (node.computed) {
        this.token("[");
      }
      this.print(node.key, node);
      if (node.computed) {
        this.token("]");
      }
      if (node.optional) {
        this.token("?");
      }
    }
    function TSMethodSignature(node) {
      this.tsPrintPropertyOrMethodName(node);
      this.tsPrintSignatureDeclarationBase(node);
      this.token(";");
    }
    function TSIndexSignature(node) {
      var readonly = node.readonly;
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.token("[");
      this._parameters(node.parameters, node);
      this.token("]");
      this.print(node.typeAnnotation, node);
      this.token(";");
    }
    function TSAnyKeyword() {
      this.word("any");
    }
    function TSUnknownKeyword() {
      this.word("unknown");
    }
    function TSNumberKeyword() {
      this.word("number");
    }
    function TSObjectKeyword() {
      this.word("object");
    }
    function TSBooleanKeyword() {
      this.word("boolean");
    }
    function TSStringKeyword() {
      this.word("string");
    }
    function TSSymbolKeyword() {
      this.word("symbol");
    }
    function TSVoidKeyword() {
      this.word("void");
    }
    function TSUndefinedKeyword() {
      this.word("undefined");
    }
    function TSNullKeyword() {
      this.word("null");
    }
    function TSNeverKeyword() {
      this.word("never");
    }
    function TSThisType() {
      this.word("this");
    }
    function TSFunctionType(node) {
      this.tsPrintFunctionOrConstructorType(node);
    }
    function TSConstructorType(node) {
      this.word("new");
      this.space();
      this.tsPrintFunctionOrConstructorType(node);
    }
    function tsPrintFunctionOrConstructorType(node) {
      var typeParameters = node.typeParameters,
        parameters = node.parameters;
      this.print(typeParameters, node);
      this.token("(");
      this._parameters(parameters, node);
      this.token(")");
      this.space();
      this.token("=>");
      this.space();
      this.print(node.typeAnnotation.typeAnnotation, node);
    }
    function TSTypeReference(node) {
      this.print(node.typeName, node);
      this.print(node.typeParameters, node);
    }
    function TSTypePredicate(node) {
      this.print(node.parameterName);
      this.space();
      this.word("is");
      this.space();
      this.print(node.typeAnnotation.typeAnnotation);
    }
    function TSTypeQuery(node) {
      this.word("typeof");
      this.space();
      this.print(node.exprName);
    }
    function TSTypeLiteral(node) {
      this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
    }
    function tsPrintTypeLiteralOrInterfaceBody(members, node) {
      this.tsPrintBraced(members, node);
    }
    function tsPrintBraced(members, node) {
      this.token("{");
      if (members.length) {
        this.indent();
        this.newline();
        var _iterator47 = _createForOfIteratorHelper(members),
          _step47;
        try {
          for (_iterator47.s(); !(_step47 = _iterator47.n()).done; ) {
            var member = _step47.value;
            this.print(member, node);
            this.newline();
          }
        } catch (err) {
          _iterator47.e(err);
        } finally {
          _iterator47.f();
        }
        this.dedent();
        this.rightBrace();
      } else {
        this.token("}");
      }
    }
    function TSArrayType(node) {
      this.print(node.elementType);
      this.token("[]");
    }
    function TSTupleType(node) {
      this.token("[");
      this.printList(node.elementTypes, node);
      this.token("]");
    }
    function TSOptionalType(node) {
      this.print(node.typeAnnotation, node);
      this.token("?");
    }
    function TSRestType(node) {
      this.token("...");
      this.print(node.typeAnnotation, node);
    }
    function TSUnionType(node) {
      this.tsPrintUnionOrIntersectionType(node, "|");
    }
    function TSIntersectionType(node) {
      this.tsPrintUnionOrIntersectionType(node, "&");
    }
    function tsPrintUnionOrIntersectionType(node, sep) {
      this.printJoin(node.types, node, {
        separator: function separator() {
          this.space();
          this.token(sep);
          this.space();
        }
      });
    }
    function TSConditionalType(node) {
      this.print(node.checkType);
      this.space();
      this.word("extends");
      this.space();
      this.print(node.extendsType);
      this.space();
      this.token("?");
      this.space();
      this.print(node.trueType);
      this.space();
      this.token(":");
      this.space();
      this.print(node.falseType);
    }
    function TSInferType(node) {
      this.token("infer");
      this.space();
      this.print(node.typeParameter);
    }
    function TSParenthesizedType(node) {
      this.token("(");
      this.print(node.typeAnnotation, node);
      this.token(")");
    }
    function TSTypeOperator(node) {
      this.token(node.operator);
      this.space();
      this.print(node.typeAnnotation, node);
    }
    function TSIndexedAccessType(node) {
      this.print(node.objectType, node);
      this.token("[");
      this.print(node.indexType, node);
      this.token("]");
    }
    function TSMappedType(node) {
      var readonly = node.readonly,
        typeParameter = node.typeParameter,
        optional = node.optional;
      this.token("{");
      this.space();
      if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word("readonly");
        this.space();
      }
      this.token("[");
      this.word(typeParameter.name);
      this.space();
      this.word("in");
      this.space();
      this.print(typeParameter.constraint, typeParameter);
      this.token("]");
      if (optional) {
        tokenIfPlusMinus(this, optional);
        this.token("?");
      }
      this.token(":");
      this.space();
      this.print(node.typeAnnotation, node);
      this.space();
      this.token("}");
    }
    function tokenIfPlusMinus(self, tok) {
      if (tok !== true) {
        self.token(tok);
      }
    }
    function TSLiteralType(node) {
      this.print(node.literal, node);
    }
    function TSExpressionWithTypeArguments(node) {
      this.print(node.expression, node);
      this.print(node.typeParameters, node);
    }
    function TSInterfaceDeclaration(node) {
      var declare = node.declare,
        id = node.id,
        typeParameters = node.typeParameters,
        extendz = node["extends"],
        body = node.body;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("interface");
      this.space();
      this.print(id, node);
      this.print(typeParameters, node);
      if (extendz) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(extendz, node);
      }
      this.space();
      this.print(body, node);
    }
    function TSInterfaceBody(node) {
      this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
    }
    function TSTypeAliasDeclaration(node) {
      var declare = node.declare,
        id = node.id,
        typeParameters = node.typeParameters,
        typeAnnotation = node.typeAnnotation;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("type");
      this.space();
      this.print(id, node);
      this.print(typeParameters, node);
      this.space();
      this.token("=");
      this.space();
      this.print(typeAnnotation, node);
      this.token(";");
    }
    function TSAsExpression(node) {
      var expression = node.expression,
        typeAnnotation = node.typeAnnotation;
      this.print(expression, node);
      this.space();
      this.word("as");
      this.space();
      this.print(typeAnnotation, node);
    }
    function TSTypeAssertion(node) {
      var typeAnnotation = node.typeAnnotation,
        expression = node.expression;
      this.token("<");
      this.print(typeAnnotation, node);
      this.token(">");
      this.space();
      this.print(expression, node);
    }
    function TSEnumDeclaration(node) {
      var declare = node.declare,
        isConst = node["const"],
        id = node.id,
        members = node.members;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (isConst) {
        this.word("const");
        this.space();
      }
      this.word("enum");
      this.space();
      this.print(id, node);
      this.space();
      this.tsPrintBraced(members, node);
    }
    function TSEnumMember(node) {
      var id = node.id,
        initializer = node.initializer;
      this.print(id, node);
      if (initializer) {
        this.space();
        this.token("=");
        this.space();
        this.print(initializer, node);
      }
      this.token(",");
    }
    function TSModuleDeclaration(node) {
      var declare = node.declare,
        id = node.id;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (!node.global) {
        this.word(id.type === "Identifier" ? "namespace" : "module");
        this.space();
      }
      this.print(id, node);
      if (!node.body) {
        this.token(";");
        return;
      }
      var body = node.body;
      while (body.type === "TSModuleDeclaration") {
        this.token(".");
        this.print(body.id, body);
        body = body.body;
      }
      this.space();
      this.print(body, node);
    }
    function TSModuleBlock(node) {
      this.tsPrintBraced(node.body, node);
    }
    function TSImportEqualsDeclaration(node) {
      var isExport = node.isExport,
        id = node.id,
        moduleReference = node.moduleReference;
      if (isExport) {
        this.word("export");
        this.space();
      }
      this.word("import");
      this.space();
      this.print(id, node);
      this.space();
      this.token("=");
      this.space();
      this.print(moduleReference, node);
      this.token(";");
    }
    function TSExternalModuleReference(node) {
      this.token("require(");
      this.print(node.expression, node);
      this.token(")");
    }
    function TSNonNullExpression(node) {
      this.print(node.expression, node);
      this.token("!");
    }
    function TSExportAssignment(node) {
      this.word("export");
      this.space();
      this.token("=");
      this.space();
      this.print(node.expression, node);
      this.token(";");
    }
    function TSNamespaceExportDeclaration(node) {
      this.word("export");
      this.space();
      this.word("as");
      this.space();
      this.word("namespace");
      this.space();
      this.print(node.id, node);
    }
    function tsPrintSignatureDeclarationBase(node) {
      var typeParameters = node.typeParameters,
        parameters = node.parameters;
      this.print(typeParameters, node);
      this.token("(");
      this._parameters(parameters, node);
      this.token(")");
      this.print(node.typeAnnotation, node);
    }
    (function (exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      var _templateLiterals = templateLiterals;
      Object.keys(_templateLiterals).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _templateLiterals[key];
          }
        });
      });
      var _expressions = expressions;
      Object.keys(_expressions).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _expressions[key];
          }
        });
      });
      var _statements = statements;
      Object.keys(_statements).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _statements[key];
          }
        });
      });
      var _classes = classes;
      Object.keys(_classes).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _classes[key];
          }
        });
      });
      var _methods = methods;
      Object.keys(_methods).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _methods[key];
          }
        });
      });
      var _modules = modules;
      Object.keys(_modules).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _modules[key];
          }
        });
      });
      var _types = types;
      Object.keys(_types).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _types[key];
          }
        });
      });
      var _flow = flow;
      Object.keys(_flow).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _flow[key];
          }
        });
      });
      var _base = base;
      Object.keys(_base).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _base[key];
          }
        });
      });
      var _jsx = jsx;
      Object.keys(_jsx).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _jsx[key];
          }
        });
      });
      var _typescript = typescript;
      Object.keys(_typescript).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _typescript[key];
          }
        });
      });
    })(generators);
    Object.defineProperty(printer$1, "__esModule", { value: true });
    printer$1["default"] = void 0;
    function _isInteger() {
      var data = _interopRequireDefault$4(requireIsInteger());
      _isInteger = function _isInteger() {
        return data;
      };
      return data;
    }
    function _repeat() {
      var data = _interopRequireDefault$4(requireRepeat());
      _repeat = function _repeat() {
        return data;
      };
      return data;
    }
    var _buffer = _interopRequireDefault$4(buffer);
    var n = _interopRequireWildcard$1(node);
    function t() {
      var data = _interopRequireWildcard$1(requireLib());
      t = function t() {
        return data;
      };
      return data;
    }
    var generatorFunctions = _interopRequireWildcard$1(generators);
    function _interopRequireWildcard$1(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function _interopRequireDefault$4(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SCIENTIFIC_NOTATION = /e/i;
    var ZERO_DECIMAL_INTEGER = /\.0+$/;
    var NON_DECIMAL_LITERAL = /^0[box]/;
    var Printer = /*#__PURE__*/ (function () {
      function Printer(format, map) {
        _classCallCheck(this, Printer);
        this.inForStatementInitCounter = 0;
        this._printStack = [];
        this._indent = 0;
        this._insideAux = false;
        this._printedCommentStarts = {};
        this._parenPushNewlineState = null;
        this._noLineTerminator = false;
        this._printAuxAfterOnNextUserNode = false;
        this._printedComments = new WeakSet();
        this._endsWithInteger = false;
        this._endsWithWord = false;
        this.format = format || {};
        this._buf = new _buffer["default"](map);
      }
      return _createClass(Printer, [
        {
          key: "generate",
          value: function generate(ast) {
            this.print(ast);
            this._maybeAddAuxComment();
            return this._buf.get();
          }
        },
        {
          key: "indent",
          value: function indent() {
            if (this.format.compact || this.format.concise) return;
            this._indent++;
          }
        },
        {
          key: "dedent",
          value: function dedent() {
            if (this.format.compact || this.format.concise) return;
            this._indent--;
          }
        },
        {
          key: "semicolon",
          value: function semicolon() {
            var force =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : false;
            this._maybeAddAuxComment();
            this._append(";", !force);
          }
        },
        {
          key: "rightBrace",
          value: function rightBrace() {
            if (this.format.minified) {
              this._buf.removeLastSemicolon();
            }
            this.token("}");
          }
        },
        {
          key: "space",
          value: function space() {
            var force =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : false;
            if (this.format.compact) return;
            if (
              (this._buf.hasContent() &&
                !this.endsWith(" ") &&
                !this.endsWith("\n")) ||
              force
            ) {
              this._space();
            }
          }
        },
        {
          key: "word",
          value: function word(str) {
            if (
              this._endsWithWord ||
              (this.endsWith("/") && str.indexOf("/") === 0)
            ) {
              this._space();
            }
            this._maybeAddAuxComment();
            this._append(str);
            this._endsWithWord = true;
          }
        },
        {
          key: "number",
          value: function number(str) {
            this.word(str);
            this._endsWithInteger =
              (0, _isInteger()["default"])(+str) &&
              !NON_DECIMAL_LITERAL.test(str) &&
              !SCIENTIFIC_NOTATION.test(str) &&
              !ZERO_DECIMAL_INTEGER.test(str) &&
              str[str.length - 1] !== ".";
          }
        },
        {
          key: "token",
          value: function token(str) {
            if (
              (str === "--" && this.endsWith("!")) ||
              (str[0] === "+" && this.endsWith("+")) ||
              (str[0] === "-" && this.endsWith("-")) ||
              (str[0] === "." && this._endsWithInteger)
            ) {
              this._space();
            }
            this._maybeAddAuxComment();
            this._append(str);
          }
        },
        {
          key: "newline",
          value: function newline(i) {
            if (this.format.retainLines || this.format.compact) return;
            if (this.format.concise) {
              this.space();
              return;
            }
            if (this.endsWith("\n\n")) return;
            if (typeof i !== "number") i = 1;
            i = Math.min(2, i);
            if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
            if (i <= 0) return;
            for (var j = 0; j < i; j++) {
              this._newline();
            }
          }
        },
        {
          key: "endsWith",
          value: function endsWith(str) {
            return this._buf.endsWith(str);
          }
        },
        {
          key: "removeTrailingNewline",
          value: function removeTrailingNewline() {
            this._buf.removeTrailingNewline();
          }
        },
        {
          key: "exactSource",
          value: function exactSource(loc, cb) {
            this._catchUp("start", loc);
            this._buf.exactSource(loc, cb);
          }
        },
        {
          key: "source",
          value: function source(prop, loc) {
            this._catchUp(prop, loc);
            this._buf.source(prop, loc);
          }
        },
        {
          key: "withSource",
          value: function withSource(prop, loc, cb) {
            this._catchUp(prop, loc);
            this._buf.withSource(prop, loc, cb);
          }
        },
        {
          key: "_space",
          value: function _space() {
            this._append(" ", true);
          }
        },
        {
          key: "_newline",
          value: function _newline() {
            this._append("\n", true);
          }
        },
        {
          key: "_append",
          value: function _append(str) {
            var queue =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : false;
            this._maybeAddParen(str);
            this._maybeIndent(str);
            if (queue) this._buf.queue(str);
            else this._buf.append(str);
            this._endsWithWord = false;
            this._endsWithInteger = false;
          }
        },
        {
          key: "_maybeIndent",
          value: function _maybeIndent(str) {
            if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
              this._buf.queue(this._getIndent());
            }
          }
        },
        {
          key: "_maybeAddParen",
          value: function _maybeAddParen(str) {
            var parenPushNewlineState = this._parenPushNewlineState;
            if (!parenPushNewlineState) return;
            this._parenPushNewlineState = null;
            var i;
            for (i = 0; i < str.length && str[i] === " "; i++) continue;
            if (i === str.length) return;
            var cha = str[i];
            if (cha !== "\n") {
              if (cha !== "/") return;
              if (i + 1 === str.length) return;
              var chaPost = str[i + 1];
              if (chaPost !== "/" && chaPost !== "*") return;
            }
            this.token("(");
            this.indent();
            parenPushNewlineState.printed = true;
          }
        },
        {
          key: "_catchUp",
          value: function _catchUp(prop, loc) {
            if (!this.format.retainLines) return;
            var pos = loc ? loc[prop] : null;
            if (pos && pos.line !== null) {
              var count = pos.line - this._buf.getCurrentLine();
              for (var i = 0; i < count; i++) {
                this._newline();
              }
            }
          }
        },
        {
          key: "_getIndent",
          value: function _getIndent() {
            return (0, _repeat()["default"])(
              this.format.indent.style,
              this._indent
            );
          }
        },
        {
          key: "startTerminatorless",
          value: function startTerminatorless() {
            var isLabel =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : false;
            if (isLabel) {
              this._noLineTerminator = true;
              return null;
            } else {
              return (this._parenPushNewlineState = { printed: false });
            }
          }
        },
        {
          key: "endTerminatorless",
          value: function endTerminatorless(state) {
            this._noLineTerminator = false;
            if (state && state.printed) {
              this.dedent();
              this.newline();
              this.token(")");
            }
          }
        },
        {
          key: "print",
          value: function print(node, parent) {
            var _this4 = this;
            if (!node) return;
            var oldConcise = this.format.concise;
            if (node._compact) {
              this.format.concise = true;
            }
            var printMethod = this[node.type];
            if (!printMethod) {
              throw new ReferenceError(
                "unknown node of type "
                  .concat(JSON.stringify(node.type), " with constructor ")
                  .concat(JSON.stringify(node && node.constructor.name))
              );
            }
            this._printStack.push(node);
            var oldInAux = this._insideAux;
            this._insideAux = !node.loc;
            this._maybeAddAuxComment(this._insideAux && !oldInAux);
            var needsParens = n.needsParens(node, parent, this._printStack);
            if (
              this.format.retainFunctionParens &&
              node.type === "FunctionExpression" &&
              node.extra &&
              node.extra.parenthesized
            ) {
              needsParens = true;
            }
            if (needsParens) this.token("(");
            this._printLeadingComments(node);
            var loc = t().isProgram(node) || t().isFile(node) ? null : node.loc;
            this.withSource("start", loc, function () {
              _this4[node.type](node, parent);
            });
            this._printTrailingComments(node);
            if (needsParens) this.token(")");
            this._printStack.pop();
            this.format.concise = oldConcise;
            this._insideAux = oldInAux;
          }
        },
        {
          key: "_maybeAddAuxComment",
          value: function _maybeAddAuxComment(enteredPositionlessNode) {
            if (enteredPositionlessNode) this._printAuxBeforeComment();
            if (!this._insideAux) this._printAuxAfterComment();
          }
        },
        {
          key: "_printAuxBeforeComment",
          value: function _printAuxBeforeComment() {
            if (this._printAuxAfterOnNextUserNode) return;
            this._printAuxAfterOnNextUserNode = true;
            var comment = this.format.auxiliaryCommentBefore;
            if (comment) {
              this._printComment({ type: "CommentBlock", value: comment });
            }
          }
        },
        {
          key: "_printAuxAfterComment",
          value: function _printAuxAfterComment() {
            if (!this._printAuxAfterOnNextUserNode) return;
            this._printAuxAfterOnNextUserNode = false;
            var comment = this.format.auxiliaryCommentAfter;
            if (comment) {
              this._printComment({ type: "CommentBlock", value: comment });
            }
          }
        },
        {
          key: "getPossibleRaw",
          value: function getPossibleRaw(node) {
            var extra = node.extra;
            if (
              extra &&
              extra.raw != null &&
              extra.rawValue != null &&
              node.value === extra.rawValue
            ) {
              return extra.raw;
            }
          }
        },
        {
          key: "printJoin",
          value: function printJoin(nodes, parent) {
            var opts =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : {};
            if (!nodes || !nodes.length) return;
            if (opts.indent) this.indent();
            var newlineOpts = { addNewlines: opts.addNewlines };
            for (var i = 0; i < nodes.length; i++) {
              var _node6 = nodes[i];
              if (!_node6) continue;
              if (opts.statement)
                this._printNewline(true, _node6, parent, newlineOpts);
              this.print(_node6, parent);
              if (opts.iterator) {
                opts.iterator(_node6, i);
              }
              if (opts.separator && i < nodes.length - 1) {
                opts.separator.call(this);
              }
              if (opts.statement)
                this._printNewline(false, _node6, parent, newlineOpts);
            }
            if (opts.indent) this.dedent();
          }
        },
        {
          key: "printAndIndentOnComments",
          value: function printAndIndentOnComments(node, parent) {
            var indent =
              node.leadingComments && node.leadingComments.length > 0;
            if (indent) this.indent();
            this.print(node, parent);
            if (indent) this.dedent();
          }
        },
        {
          key: "printBlock",
          value: function printBlock(parent) {
            var node = parent.body;
            if (!t().isEmptyStatement(node)) {
              this.space();
            }
            this.print(node, parent);
          }
        },
        {
          key: "_printTrailingComments",
          value: function _printTrailingComments(node) {
            this._printComments(this._getComments(false, node));
          }
        },
        {
          key: "_printLeadingComments",
          value: function _printLeadingComments(node) {
            this._printComments(this._getComments(true, node));
          }
        },
        {
          key: "printInnerComments",
          value: function printInnerComments(node) {
            var indent =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : true;
            if (!node.innerComments || !node.innerComments.length) return;
            if (indent) this.indent();
            this._printComments(node.innerComments);
            if (indent) this.dedent();
          }
        },
        {
          key: "printSequence",
          value: function printSequence(nodes, parent) {
            var opts =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : {};
            opts.statement = true;
            return this.printJoin(nodes, parent, opts);
          }
        },
        {
          key: "printList",
          value: function printList(items, parent) {
            var opts =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : {};
            if (opts.separator == null) {
              opts.separator = commaSeparator;
            }
            return this.printJoin(items, parent, opts);
          }
        },
        {
          key: "_printNewline",
          value: function _printNewline(leading, node, parent, opts) {
            if (this.format.retainLines || this.format.compact) return;
            if (this.format.concise) {
              this.space();
              return;
            }
            var lines = 0;
            if (this._buf.hasContent()) {
              if (!leading) lines++;
              if (opts.addNewlines)
                lines += opts.addNewlines(leading, node) || 0;
              var needs = leading
                ? n.needsWhitespaceBefore
                : n.needsWhitespaceAfter;
              if (needs(node, parent)) lines++;
            }
            this.newline(lines);
          }
        },
        {
          key: "_getComments",
          value: function _getComments(leading, node) {
            return (
              (node &&
                (leading ? node.leadingComments : node.trailingComments)) ||
              []
            );
          }
        },
        {
          key: "_printComment",
          value: function _printComment(comment) {
            var _this5 = this;
            if (!this.format.shouldPrintComment(comment.value)) return;
            if (comment.ignore) return;
            if (this._printedComments.has(comment)) return;
            this._printedComments.add(comment);
            if (comment.start != null) {
              if (this._printedCommentStarts[comment.start]) return;
              this._printedCommentStarts[comment.start] = true;
            }
            var isBlockComment = comment.type === "CommentBlock";
            this.newline(
              this._buf.hasContent() &&
                !this._noLineTerminator &&
                isBlockComment
                ? 1
                : 0
            );
            if (!this.endsWith("[") && !this.endsWith("{")) this.space();
            var val =
              !isBlockComment && !this._noLineTerminator
                ? "//".concat(comment.value, "\n")
                : "/*".concat(comment.value, "*/");
            if (isBlockComment && this.format.indent.adjustMultilineComment) {
              var offset = comment.loc && comment.loc.start.column;
              if (offset) {
                var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
                val = val.replace(newlineRegex, "\n");
              }
              var indentSize = Math.max(
                this._getIndent().length,
                this._buf.getCurrentColumn()
              );
              val = val.replace(
                /\n(?!$)/g,
                "\n".concat((0, _repeat()["default"])(" ", indentSize))
              );
            }
            if (this.endsWith("/")) this._space();
            this.withSource("start", comment.loc, function () {
              _this5._append(val);
            });
            this.newline(isBlockComment && !this._noLineTerminator ? 1 : 0);
          }
        },
        {
          key: "_printComments",
          value: function _printComments(comments) {
            if (!comments || !comments.length) return;
            var _iterator48 = _createForOfIteratorHelper(comments),
              _step48;
            try {
              for (_iterator48.s(); !(_step48 = _iterator48.n()).done; ) {
                var comment = _step48.value;
                this._printComment(comment);
              }
            } catch (err) {
              _iterator48.e(err);
            } finally {
              _iterator48.f();
            }
          }
        }
      ]);
    })();
    printer$1["default"] = Printer;
    Object.assign(Printer.prototype, generatorFunctions);
    function commaSeparator() {
      this.token(",");
      this.space();
    }
    Object.defineProperty(lib, "__esModule", { value: true });
    var default_1 = (lib["default"] = _default$7);
    lib.CodeGenerator = void 0;
    var _sourceMap = _interopRequireDefault$3(sourceMap$1);
    var _printer = _interopRequireDefault$3(printer$1);
    function _interopRequireDefault$3(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Generator = /*#__PURE__*/ (function (_printer$default) {
      function Generator(ast) {
        var _this6;
        var opts =
          arguments.length > 1 && arguments[1] !== undefined
            ? arguments[1]
            : {};
        var code = arguments.length > 2 ? arguments[2] : undefined;
        _classCallCheck(this, Generator);
        var format = normalizeOptions(code, opts);
        var map = opts.sourceMaps
          ? new _sourceMap["default"](opts, code)
          : null;
        _this6 = _callSuper(this, Generator, [format, map]);
        _this6.ast = ast;
        return _this6;
      }
      _inherits2(Generator, _printer$default);
      return _createClass(Generator, [
        {
          key: "generate",
          value: function generate() {
            return _get(
              _getPrototypeOf(Generator.prototype),
              "generate",
              this
            ).call(this, this.ast);
          }
        }
      ]);
    })(_printer["default"]);
    function normalizeOptions(code, opts) {
      var format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        jsonCompatibleStrings: opts.jsonCompatibleStrings,
        indent: { adjustMultilineComment: true, style: "  ", base: 0 },
        decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
        jsescOption: Object.assign(
          { quotes: "double", wrap: true },
          opts.jsescOption
        )
      };
      if (format.minified) {
        format.compact = true;
        format.shouldPrintComment =
          format.shouldPrintComment ||
          function () {
            return format.comments;
          };
      } else {
        format.shouldPrintComment =
          format.shouldPrintComment ||
          function (value) {
            return (
              format.comments ||
              value.indexOf("@license") >= 0 ||
              value.indexOf("@preserve") >= 0
            );
          };
      }
      if (format.compact === "auto") {
        format.compact = code.length > 500000;
        if (format.compact) {
          console.error(
            "[BABEL] Note: The code generator has deoptimised the styling of " +
              "".concat(
                opts.filename,
                " as it exceeds the max of ",
                "500KB",
                "."
              )
          );
        }
      }
      if (format.compact) {
        format.indent.adjustMultilineComment = false;
      }
      return format;
    }
    var CodeGenerator = /*#__PURE__*/ (function () {
      function CodeGenerator(ast, opts, code) {
        _classCallCheck(this, CodeGenerator);
        this._generator = new Generator(ast, opts, code);
      }
      return _createClass(CodeGenerator, [
        {
          key: "generate",
          value: function generate() {
            return this._generator.generate();
          }
        }
      ]);
    })();
    lib.CodeGenerator = CodeGenerator;
    function _default$7(ast, opts, code) {
      var gen = new Generator(ast, opts, code);
      return gen.generate();
    }
    /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise */ function __classPrivateFieldGet(
      receiver,
      state,
      kind,
      f
    ) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (
        typeof state === "function"
          ? receiver !== state || !f
          : !state.has(receiver)
      )
        throw new TypeError(
          "Cannot read private member from an object whose class did not declare it"
        );
      return kind === "m"
        ? f
        : kind === "a"
          ? f.call(receiver)
          : f
            ? f.value
            : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (
        typeof state === "function"
          ? receiver !== state || !f
          : !state.has(receiver)
      )
        throw new TypeError(
          "Cannot write private member to an object whose class did not declare it"
        );
      return (
        kind === "a"
          ? f.call(receiver, value)
          : f
            ? (f.value = value)
            : state.set(receiver, value),
        value
      );
    }
    function printReactiveScopeSummary(scope) {
      var items = [];
      items.push("scope");
      items.push("@".concat(scope.id));
      items.push(
        "[".concat(scope.range.start, ":").concat(scope.range.end, "]")
      );
      items.push(
        "dependencies=[".concat(
          Array.from(scope.dependencies)
            .map(function (dep) {
              return printDependency(dep);
            })
            .join(", "),
          "]"
        )
      );
      items.push(
        "declarations=[".concat(
          Array.from(scope.declarations)
            .map(function (_ref18) {
              var _ref19 = _slicedToArray(_ref18, 2),
                decl = _ref19[1];
              return printIdentifier(
                Object.assign(Object.assign({}, decl.identifier), {
                  scope: decl.scope
                })
              );
            })
            .join(", "),
          "]"
        )
      );
      items.push(
        "reassignments=[".concat(
          Array.from(scope.reassignments).map(function (reassign) {
            return printIdentifier(reassign);
          }),
          "]"
        )
      );
      if (scope.earlyReturnValue !== null) {
        items.push(
          "earlyReturn={id: "
            .concat(printIdentifier(scope.earlyReturnValue.value), ", label: ")
            .concat(scope.earlyReturnValue.label, "}}")
        );
      }
      return items.join(" ");
    }
    function printDependency(dependency) {
      var identifier =
        printIdentifier(dependency.identifier) +
        printType(dependency.identifier.type);
      return "".concat(identifier).concat(
        dependency.path
          .map(function (token) {
            return ""
              .concat(token.optional ? "?." : ".")
              .concat(token.property);
          })
          .join("")
      );
    }
    function printFunction$1(fn) {
      var output = [];
      var definition = "";
      if (fn.id !== null) {
        definition += fn.id;
      }
      if (fn.params.length !== 0) {
        definition +=
          "(" +
          fn.params
            .map(function (param) {
              if (param.kind === "Identifier") {
                return printPlace(param);
              } else {
                return "...".concat(printPlace(param.place));
              }
            })
            .join(", ") +
          ")";
      }
      if (definition.length !== 0) {
        output.push(definition);
      }
      output.push(printType(fn.returnType));
      output.push(printHIR(fn.body));
      output.push.apply(output, _toConsumableArray(fn.directives));
      return output.join("\n");
    }
    function printHIR(ir) {
      var options =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : null;
      var _a;
      var output = [];
      var indent = " ".repeat(
        (_a =
          options === null || options === void 0 ? void 0 : options.indent) !==
          null && _a !== void 0
          ? _a
          : 0
      );
      var push = function push(text) {
        var indent =
          arguments.length > 1 && arguments[1] !== undefined
            ? arguments[1]
            : "  ";
        output.push("".concat(indent).concat(text));
      };
      var _iterator49 = _createForOfIteratorHelper(ir.blocks),
        _step49;
      try {
        for (_iterator49.s(); !(_step49 = _iterator49.n()).done; ) {
          var _step49$value = _slicedToArray(_step49.value, 2),
            blockId = _step49$value[0],
            block = _step49$value[1];
          output.push("bb".concat(blockId, " (").concat(block.kind, "):"));
          if (block.preds.size > 0) {
            var preds = ["predecessor blocks:"];
            var _iterator50 = _createForOfIteratorHelper(block.preds),
              _step50;
            try {
              for (_iterator50.s(); !(_step50 = _iterator50.n()).done; ) {
                var pred = _step50.value;
                preds.push("bb".concat(pred));
              }
            } catch (err) {
              _iterator50.e(err);
            } finally {
              _iterator50.f();
            }
            push(preds.join(" "));
          }
          var _iterator51 = _createForOfIteratorHelper(block.phis),
            _step51;
          try {
            for (_iterator51.s(); !(_step51 = _iterator51.n()).done; ) {
              var phi = _step51.value;
              push(printPhi(phi));
            }
          } catch (err) {
            _iterator51.e(err);
          } finally {
            _iterator51.f();
          }
          var _iterator52 = _createForOfIteratorHelper(block.instructions),
            _step52;
          try {
            for (_iterator52.s(); !(_step52 = _iterator52.n()).done; ) {
              var instr = _step52.value;
              push(printInstruction(instr));
            }
          } catch (err) {
            _iterator52.e(err);
          } finally {
            _iterator52.f();
          }
          var terminal = printTerminal(block.terminal);
          if (Array.isArray(terminal)) {
            terminal.forEach(function (line) {
              return push(line);
            });
          } else {
            push(terminal);
          }
        }
      } catch (err) {
        _iterator49.e(err);
      } finally {
        _iterator49.f();
      }
      return output
        .map(function (line) {
          return indent + line;
        })
        .join("\n");
    }
    function printMixedHIR(value) {
      if (!("kind" in value)) {
        return printInstruction(value);
      }
      switch (value.kind) {
        case "try":
        case "maybe-throw":
        case "sequence":
        case "label":
        case "optional":
        case "branch":
        case "if":
        case "logical":
        case "ternary":
        case "return":
        case "switch":
        case "throw":
        case "while":
        case "for":
        case "unreachable":
        case "unsupported":
        case "goto":
        case "do-while":
        case "for-in":
        case "for-of":
        case "scope":
        case "pruned-scope": {
          var terminal = printTerminal(value);
          if (Array.isArray(terminal)) {
            return terminal.join("; ");
          }
          return terminal;
        }
        default: {
          return printInstructionValue(value);
        }
      }
    }
    function printInstruction(instr) {
      var id = "[".concat(instr.id, "]");
      var value = printInstructionValue(instr.value);
      if (instr.lvalue !== null) {
        return ""
          .concat(id, " ")
          .concat(printPlace(instr.lvalue), " = ")
          .concat(value);
      } else {
        return "".concat(id, " ").concat(value);
      }
    }
    function printPhi(phi) {
      var items = [];
      items.push(printPlace(phi.place));
      items.push(printMutableRange(phi.place.identifier));
      items.push(printType(phi.place.identifier.type));
      items.push(": phi(");
      var phis = [];
      var _iterator53 = _createForOfIteratorHelper(phi.operands),
        _step53;
      try {
        for (_iterator53.s(); !(_step53 = _iterator53.n()).done; ) {
          var _step53$value = _slicedToArray(_step53.value, 2),
            blockId = _step53$value[0],
            place = _step53$value[1];
          phis.push("bb".concat(blockId, ": ").concat(printPlace(place)));
        }
      } catch (err) {
        _iterator53.e(err);
      } finally {
        _iterator53.f();
      }
      items.push(phis.join(", "));
      items.push(")");
      return items.join("");
    }
    function printTerminal(terminal) {
      var value;
      switch (terminal.kind) {
        case "if": {
          value = "["
            .concat(terminal.id, "] If (")
            .concat(printPlace(terminal.test), ") then:bb")
            .concat(terminal.consequent, " else:bb")
            .concat(terminal.alternate)
            .concat(
              terminal.fallthrough
                ? " fallthrough=bb".concat(terminal.fallthrough)
                : ""
            );
          break;
        }
        case "branch": {
          value = "["
            .concat(terminal.id, "] Branch (")
            .concat(printPlace(terminal.test), ") then:bb")
            .concat(terminal.consequent, " else:bb")
            .concat(terminal.alternate, " fallthrough:bb")
            .concat(terminal.fallthrough);
          break;
        }
        case "logical": {
          value = "["
            .concat(terminal.id, "] Logical ")
            .concat(terminal.operator, " test:bb")
            .concat(terminal.test, " fallthrough=bb")
            .concat(terminal.fallthrough);
          break;
        }
        case "ternary": {
          value = "["
            .concat(terminal.id, "] Ternary test:bb")
            .concat(terminal.test, " fallthrough=bb")
            .concat(terminal.fallthrough);
          break;
        }
        case "optional": {
          value = "["
            .concat(terminal.id, "] Optional (optional=")
            .concat(terminal.optional, ") test:bb")
            .concat(terminal.test, " fallthrough=bb")
            .concat(terminal.fallthrough);
          break;
        }
        case "throw": {
          value = "["
            .concat(terminal.id, "] Throw ")
            .concat(printPlace(terminal.value));
          break;
        }
        case "return": {
          value = "["
            .concat(terminal.id, "] Return")
            .concat(
              terminal.value != null ? " " + printPlace(terminal.value) : ""
            );
          break;
        }
        case "goto": {
          value = "["
            .concat(terminal.id, "] Goto")
            .concat(
              terminal.variant === GotoVariant.Continue ? "(Continue)" : "",
              " bb"
            )
            .concat(terminal.block);
          break;
        }
        case "switch": {
          var output = [];
          output.push(
            "["
              .concat(terminal.id, "] Switch (")
              .concat(printPlace(terminal.test), ")")
          );
          terminal.cases.forEach(function (case_) {
            if (case_.test !== null) {
              output.push(
                "  Case "
                  .concat(printPlace(case_.test), ": bb")
                  .concat(case_.block)
              );
            } else {
              output.push("  Default: bb".concat(case_.block));
            }
          });
          if (terminal.fallthrough) {
            output.push("  Fallthrough: bb".concat(terminal.fallthrough));
          }
          value = output;
          break;
        }
        case "do-while": {
          value = "["
            .concat(
              terminal.id,
              "] DoWhile loop=",
              "bb".concat(terminal.loop),
              " test=bb"
            )
            .concat(
              terminal.test,
              " fallthrough=",
              "bb".concat(terminal.fallthrough)
            );
          break;
        }
        case "while": {
          value = "["
            .concat(terminal.id, "] While test=bb")
            .concat(terminal.test, " loop=")
            .concat(
              terminal.loop !== null ? "bb".concat(terminal.loop) : "",
              " fallthrough="
            )
            .concat(
              terminal.fallthrough ? "bb".concat(terminal.fallthrough) : ""
            );
          break;
        }
        case "for": {
          value = "["
            .concat(terminal.id, "] For init=bb")
            .concat(terminal.init, " test=bb")
            .concat(terminal.test, " loop=bb")
            .concat(terminal.loop, " update=bb")
            .concat(terminal.update, " fallthrough=bb")
            .concat(terminal.fallthrough);
          break;
        }
        case "for-of": {
          value = "["
            .concat(terminal.id, "] ForOf init=bb")
            .concat(terminal.init, " test=bb")
            .concat(terminal.test, " loop=bb")
            .concat(terminal.loop, " fallthrough=bb")
            .concat(terminal.fallthrough);
          break;
        }
        case "for-in": {
          value = "["
            .concat(terminal.id, "] ForIn init=bb")
            .concat(terminal.init, " loop=bb")
            .concat(terminal.loop, " fallthrough=bb")
            .concat(terminal.fallthrough);
          break;
        }
        case "label": {
          value = "["
            .concat(terminal.id, "] Label block=bb")
            .concat(terminal.block, " fallthrough=")
            .concat(
              terminal.fallthrough ? "bb".concat(terminal.fallthrough) : ""
            );
          break;
        }
        case "sequence": {
          value = "["
            .concat(terminal.id, "] Sequence block=bb")
            .concat(terminal.block, " fallthrough=bb")
            .concat(terminal.fallthrough);
          break;
        }
        case "unreachable": {
          value = "[".concat(terminal.id, "] Unreachable");
          break;
        }
        case "unsupported": {
          value = "[".concat(terminal.id, "] Unsupported");
          break;
        }
        case "maybe-throw": {
          value = "["
            .concat(terminal.id, "] MaybeThrow continuation=bb")
            .concat(terminal.continuation, " handler=bb")
            .concat(terminal.handler);
          break;
        }
        case "scope": {
          value = "["
            .concat(terminal.id, "] Scope ")
            .concat(printReactiveScopeSummary(terminal.scope), " block=bb")
            .concat(terminal.block, " fallthrough=bb")
            .concat(terminal.fallthrough);
          break;
        }
        case "pruned-scope": {
          value = "["
            .concat(terminal.id, "] <pruned> Scope ")
            .concat(printReactiveScopeSummary(terminal.scope), " block=bb")
            .concat(terminal.block, " fallthrough=bb")
            .concat(terminal.fallthrough);
          break;
        }
        case "try": {
          value = "["
            .concat(terminal.id, "] Try block=bb")
            .concat(terminal.block, " handler=bb")
            .concat(terminal.handler)
            .concat(
              terminal.handlerBinding !== null
                ? " handlerBinding=(".concat(
                    printPlace(terminal.handlerBinding),
                    ")"
                  )
                : "",
              " fallthrough="
            )
            .concat(
              terminal.fallthrough != null
                ? "bb".concat(terminal.fallthrough)
                : ""
            );
          break;
        }
        default: {
          assertExhaustive$1(
            terminal,
            "Unexpected terminal kind `".concat(terminal, "`")
          );
        }
      }
      return value;
    }
    function printHole() {
      return "<hole>";
    }
    function printObjectPropertyKey(key) {
      switch (key.kind) {
        case "identifier":
          return key.name;
        case "string":
          return '"'.concat(key.name, '"');
        case "computed": {
          return "[".concat(printPlace(key.name), "]");
        }
      }
    }
    function printInstructionValue(instrValue) {
      var _a, _b, _c, _d;
      var value = "";
      switch (instrValue.kind) {
        case "ArrayExpression": {
          value = "Array [".concat(
            instrValue.elements
              .map(function (element) {
                if (element.kind === "Identifier") {
                  return printPlace(element);
                } else if (element.kind === "Hole") {
                  return printHole();
                } else {
                  return "...".concat(printPlace(element.place));
                }
              })
              .join(", "),
            "]"
          );
          break;
        }
        case "ObjectExpression": {
          var properties = [];
          if (instrValue.properties !== null) {
            var _iterator54 = _createForOfIteratorHelper(instrValue.properties),
              _step54;
            try {
              for (_iterator54.s(); !(_step54 = _iterator54.n()).done; ) {
                var property = _step54.value;
                if (property.kind === "ObjectProperty") {
                  properties.push(
                    ""
                      .concat(printObjectPropertyKey(property.key), ": ")
                      .concat(printPlace(property.place))
                  );
                } else {
                  properties.push("...".concat(printPlace(property.place)));
                }
              }
            } catch (err) {
              _iterator54.e(err);
            } finally {
              _iterator54.f();
            }
          }
          value = "Object { ".concat(properties.join(", "), " }");
          break;
        }
        case "UnaryExpression": {
          value = "Unary ".concat(printPlace(instrValue.value));
          break;
        }
        case "BinaryExpression": {
          value = "Binary "
            .concat(printPlace(instrValue.left), " ")
            .concat(instrValue.operator, " ")
            .concat(printPlace(instrValue.right));
          break;
        }
        case "NewExpression": {
          value = "New ".concat(printPlace(instrValue.callee), "(").concat(
            instrValue.args
              .map(function (arg) {
                return printPattern(arg);
              })
              .join(", "),
            ")"
          );
          break;
        }
        case "CallExpression": {
          value = "Call ".concat(printPlace(instrValue.callee), "(").concat(
            instrValue.args
              .map(function (arg) {
                return printPattern(arg);
              })
              .join(", "),
            ")"
          );
          break;
        }
        case "MethodCall": {
          value = "MethodCall "
            .concat(printPlace(instrValue.receiver), ".")
            .concat(printPlace(instrValue.property), "(")
            .concat(
              instrValue.args
                .map(function (arg) {
                  return printPattern(arg);
                })
                .join(", "),
              ")"
            );
          break;
        }
        case "JSXText": {
          value = "JSXText ".concat(JSON.stringify(instrValue.value));
          break;
        }
        case "Primitive": {
          if (instrValue.value === undefined) {
            value = "<undefined>";
          } else {
            value = JSON.stringify(instrValue.value);
          }
          break;
        }
        case "TypeCastExpression": {
          value = "TypeCast "
            .concat(printPlace(instrValue.value), ": ")
            .concat(printType(instrValue.type));
          break;
        }
        case "JsxExpression": {
          var propItems = [];
          var _iterator55 = _createForOfIteratorHelper(instrValue.props),
            _step55;
          try {
            for (_iterator55.s(); !(_step55 = _iterator55.n()).done; ) {
              var attribute = _step55.value;
              if (attribute.kind === "JsxAttribute") {
                propItems.push(
                  ""
                    .concat(attribute.name, "={")
                    .concat(
                      attribute.place !== null
                        ? printPlace(attribute.place)
                        : "<empty>",
                      "}"
                    )
                );
              } else {
                propItems.push("...".concat(printPlace(attribute.argument)));
              }
            }
          } catch (err) {
            _iterator55.e(err);
          } finally {
            _iterator55.f();
          }
          var tag =
            instrValue.tag.kind === "Identifier"
              ? printPlace(instrValue.tag)
              : instrValue.tag.name;
          var props = propItems.length !== 0 ? " " + propItems.join(" ") : "";
          if (instrValue.children !== null) {
            var children = instrValue.children.map(function (child) {
              return "{".concat(printPlace(child), "}");
            });
            value = "JSX <"
              .concat(tag)
              .concat(props)
              .concat(props.length > 0 ? " " : "", ">")
              .concat(children.join(""), "</")
              .concat(tag, ">");
          } else {
            value = "JSX <"
              .concat(tag)
              .concat(props)
              .concat(props.length > 0 ? " " : "", "/>");
          }
          break;
        }
        case "JsxFragment": {
          value = "JsxFragment [".concat(
            instrValue.children
              .map(function (child) {
                return printPlace(child);
              })
              .join(", "),
            "]"
          );
          break;
        }
        case "UnsupportedNode": {
          value = "UnsupportedNode(".concat(
            default_1(instrValue.node).code,
            ")"
          );
          break;
        }
        case "LoadLocal": {
          value = "LoadLocal ".concat(printPlace(instrValue.place));
          break;
        }
        case "DeclareLocal": {
          value = "DeclareLocal "
            .concat(instrValue.lvalue.kind, " ")
            .concat(printPlace(instrValue.lvalue.place));
          break;
        }
        case "DeclareContext": {
          value = "DeclareContext "
            .concat(instrValue.lvalue.kind, " ")
            .concat(printPlace(instrValue.lvalue.place));
          break;
        }
        case "StoreLocal": {
          value = "StoreLocal "
            .concat(instrValue.lvalue.kind, " ")
            .concat(printPlace(instrValue.lvalue.place), " = ")
            .concat(printPlace(instrValue.value));
          break;
        }
        case "LoadContext": {
          value = "LoadContext ".concat(printPlace(instrValue.place));
          break;
        }
        case "StoreContext": {
          value = "StoreContext "
            .concat(instrValue.lvalue.kind, " ")
            .concat(printPlace(instrValue.lvalue.place), " = ")
            .concat(printPlace(instrValue.value));
          break;
        }
        case "Destructure": {
          value = "Destructure "
            .concat(instrValue.lvalue.kind, " ")
            .concat(printPattern(instrValue.lvalue.pattern), " = ")
            .concat(printPlace(instrValue.value));
          break;
        }
        case "PropertyLoad": {
          value = "PropertyLoad "
            .concat(printPlace(instrValue.object), ".")
            .concat(instrValue.property);
          break;
        }
        case "PropertyStore": {
          value = "PropertyStore "
            .concat(printPlace(instrValue.object), ".")
            .concat(instrValue.property, " = ")
            .concat(printPlace(instrValue.value));
          break;
        }
        case "PropertyDelete": {
          value = "PropertyDelete "
            .concat(printPlace(instrValue.object), ".")
            .concat(instrValue.property);
          break;
        }
        case "ComputedLoad": {
          value = "ComputedLoad "
            .concat(printPlace(instrValue.object), "[")
            .concat(printPlace(instrValue.property), "]");
          break;
        }
        case "ComputedStore": {
          value = "ComputedStore "
            .concat(printPlace(instrValue.object), "[")
            .concat(printPlace(instrValue.property), "] = ")
            .concat(printPlace(instrValue.value));
          break;
        }
        case "ComputedDelete": {
          value = "ComputedDelete "
            .concat(printPlace(instrValue.object), "[")
            .concat(printPlace(instrValue.property), "]");
          break;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          var kind =
            instrValue.kind === "FunctionExpression"
              ? "Function"
              : "ObjectMethod";
          var name = getFunctionName$2(instrValue, "");
          var fn = printFunction$1(instrValue.loweredFunc.func)
            .split("\n")
            .map(function (line) {
              return "      ".concat(line);
            })
            .join("\n");
          var context = instrValue.loweredFunc.func.context
            .map(function (dep) {
              return printPlace(dep);
            })
            .join(",");
          var effects =
            (_b =
              (_a = instrValue.loweredFunc.func.effects) === null ||
              _a === void 0
                ? void 0
                : _a
                    .map(function (effect) {
                      if (effect.kind === "ContextMutation") {
                        return "ContextMutation places=["
                          .concat(
                            _toConsumableArray(effect.places)
                              .map(function (place) {
                                return printPlace(place);
                              })
                              .join(", "),
                            "] effect="
                          )
                          .concat(effect.effect);
                      } else {
                        return "GlobalMutation";
                      }
                    })
                    .join(", ")) !== null && _b !== void 0
              ? _b
              : "";
          var type = printType(instrValue.loweredFunc.func.returnType).trim();
          value = ""
            .concat(kind, " ")
            .concat(name, " @context[")
            .concat(context, "] @effects[")
            .concat(effects, "]")
            .concat(type !== "" ? " return".concat(type) : "", ":\n")
            .concat(fn);
          break;
        }
        case "TaggedTemplateExpression": {
          value = ""
            .concat(printPlace(instrValue.tag), "`")
            .concat(instrValue.value.raw, "`");
          break;
        }
        case "LogicalExpression": {
          value = "Logical "
            .concat(printInstructionValue(instrValue.left), " ")
            .concat(instrValue.operator, " ")
            .concat(printInstructionValue(instrValue.right));
          break;
        }
        case "SequenceExpression": {
          value = ["Sequence"]
            .concat(
              _toConsumableArray(
                instrValue.instructions.map(function (instr) {
                  return "    ".concat(printInstruction(instr));
                })
              ),
              ["    ".concat(printInstructionValue(instrValue.value))]
            )
            .join("\n");
          break;
        }
        case "ConditionalExpression": {
          value = "Ternary "
            .concat(printInstructionValue(instrValue.test), " ? ")
            .concat(printInstructionValue(instrValue.consequent), " : ")
            .concat(printInstructionValue(instrValue.alternate));
          break;
        }
        case "TemplateLiteral": {
          value = "`";
          CompilerError.invariant(
            instrValue.subexprs.length === instrValue.quasis.length - 1,
            {
              reason: "Bad assumption about quasi length.",
              description: null,
              loc: instrValue.loc,
              suggestions: null
            }
          );
          for (var i = 0; i < instrValue.subexprs.length; i++) {
            value += instrValue.quasis[i].raw;
            value += "${".concat(printPlace(instrValue.subexprs[i]), "}");
          }
          value += instrValue.quasis.at(-1).raw + "`";
          break;
        }
        case "LoadGlobal": {
          switch (instrValue.binding.kind) {
            case "Global": {
              value = "LoadGlobal(global) ".concat(instrValue.binding.name);
              break;
            }
            case "ModuleLocal": {
              value = "LoadGlobal(module) ".concat(instrValue.binding.name);
              break;
            }
            case "ImportDefault": {
              value = "LoadGlobal import "
                .concat(instrValue.binding.name, " from '")
                .concat(instrValue.binding.module, "'");
              break;
            }
            case "ImportNamespace": {
              value = "LoadGlobal import * as "
                .concat(instrValue.binding.name, " from '")
                .concat(instrValue.binding.module, "'");
              break;
            }
            case "ImportSpecifier": {
              if (instrValue.binding.imported !== instrValue.binding.name) {
                value = "LoadGlobal import { "
                  .concat(instrValue.binding.imported, " as ")
                  .concat(instrValue.binding.name, " } from '")
                  .concat(instrValue.binding.module, "'");
              } else {
                value = "LoadGlobal import { "
                  .concat(instrValue.binding.name, " } from '")
                  .concat(instrValue.binding.module, "'");
              }
              break;
            }
            default: {
              assertExhaustive$1(
                instrValue.binding,
                "Unexpected binding kind `".concat(instrValue.binding.kind, "`")
              );
            }
          }
          break;
        }
        case "StoreGlobal": {
          value = "StoreGlobal "
            .concat(instrValue.name, " = ")
            .concat(printPlace(instrValue.value));
          break;
        }
        case "OptionalExpression": {
          value = "OptionalExpression ".concat(
            printInstructionValue(instrValue.value)
          );
          break;
        }
        case "RegExpLiteral": {
          value = "RegExp /"
            .concat(instrValue.pattern, "/")
            .concat(instrValue.flags);
          break;
        }
        case "MetaProperty": {
          value = "MetaProperty "
            .concat(instrValue.meta, ".")
            .concat(instrValue.property);
          break;
        }
        case "Await": {
          value = "Await ".concat(printPlace(instrValue.value));
          break;
        }
        case "GetIterator": {
          value = "GetIterator collection=".concat(
            printPlace(instrValue.collection)
          );
          break;
        }
        case "IteratorNext": {
          value = "IteratorNext iterator="
            .concat(printPlace(instrValue.iterator), " collection=")
            .concat(printPlace(instrValue.collection));
          break;
        }
        case "NextPropertyOf": {
          value = "NextPropertyOf ".concat(printPlace(instrValue.value));
          break;
        }
        case "Debugger": {
          value = "Debugger";
          break;
        }
        case "PostfixUpdate": {
          value = "PostfixUpdate "
            .concat(printPlace(instrValue.lvalue), " = ")
            .concat(printPlace(instrValue.value), " ")
            .concat(instrValue.operation);
          break;
        }
        case "PrefixUpdate": {
          value = "PrefixUpdate "
            .concat(printPlace(instrValue.lvalue), " = ")
            .concat(instrValue.operation, " ")
            .concat(printPlace(instrValue.value));
          break;
        }
        case "StartMemoize": {
          value = "StartMemoize deps=".concat(
            (_d =
              (_c = instrValue.deps) === null || _c === void 0
                ? void 0
                : _c.map(function (dep) {
                    return printManualMemoDependency(dep, false);
                  })) !== null && _d !== void 0
              ? _d
              : "(none)"
          );
          break;
        }
        case "FinishMemoize": {
          value = "FinishMemoize decl=".concat(printPlace(instrValue.decl));
          break;
        }
        default: {
          assertExhaustive$1(
            instrValue,
            "Unexpected instruction kind '".concat(instrValue.kind, "'")
          );
        }
      }
      return value;
    }
    function isMutable$1(range) {
      return range.end > range.start + 1;
    }
    function printMutableRange(identifier) {
      var _b, _c;
      var range =
        (_c =
          (_b = identifier.scope) === null || _b === void 0
            ? void 0
            : _b.range) !== null && _c !== void 0
          ? _c
          : identifier.mutableRange;
      return isMutable$1(range)
        ? "[".concat(range.start, ":").concat(range.end, "]")
        : "";
    }
    function printPattern(pattern) {
      switch (pattern.kind) {
        case "ArrayPattern": {
          return (
            "[ " +
            pattern.items
              .map(function (item) {
                if (item.kind === "Hole") {
                  return "<hole>";
                }
                return printPattern(item);
              })
              .join(", ") +
            " ]"
          );
        }
        case "ObjectPattern": {
          return (
            "{ " +
            pattern.properties
              .map(function (item) {
                switch (item.kind) {
                  case "ObjectProperty": {
                    return ""
                      .concat(printObjectPropertyKey(item.key), ": ")
                      .concat(printPattern(item.place));
                  }
                  case "Spread": {
                    return printPattern(item);
                  }
                  default: {
                    assertExhaustive$1(item, "Unexpected object property kind");
                  }
                }
              })
              .join(", ") +
            " }"
          );
        }
        case "Spread": {
          return "...".concat(printPlace(pattern.place));
        }
        case "Identifier": {
          return printPlace(pattern);
        }
        default: {
          assertExhaustive$1(
            pattern,
            "Unexpected pattern kind `".concat(pattern.kind, "`")
          );
        }
      }
    }
    function printPlace(place) {
      var items = [
        place.effect,
        " ",
        printIdentifier(place.identifier),
        printMutableRange(place.identifier),
        printType(place.identifier.type),
        place.reactive ? "{reactive}" : null
      ];
      return items
        .filter(function (x) {
          return x != null;
        })
        .join("");
    }
    function printIdentifier(id) {
      return ""
        .concat(printName(id.name), "$")
        .concat(id.id)
        .concat(printScope(id.scope));
    }
    function printName(name) {
      if (name === null) {
        return "";
      }
      return name.value;
    }
    function printScope(scope) {
      return "".concat(scope !== null ? "_@".concat(scope.id) : "");
    }
    function printManualMemoDependency(val, nameOnly) {
      var _a;
      var rootStr;
      if (val.root.kind === "Global") {
        rootStr = val.root.identifierName;
      } else {
        CompilerError.invariant(
          ((_a = val.root.value.identifier.name) === null || _a === void 0
            ? void 0
            : _a.kind) === "named",
          {
            reason: "DepsValidation: expected named local variable in depslist",
            suggestions: null,
            loc: val.root.value.loc
          }
        );
        rootStr = nameOnly
          ? val.root.value.identifier.name.value
          : printIdentifier(val.root.value.identifier);
      }
      return "".concat(rootStr).concat(
        val.path
          .map(function (v) {
            return "".concat(v.optional ? "?." : ".").concat(v.property);
          })
          .join("")
      );
    }
    function printType(type) {
      if (type.kind === "Type") return "";
      if (type.kind === "Object" && type.shapeId != null) {
        return ":T".concat(type.kind, "<").concat(type.shapeId, ">");
      } else if (type.kind === "Function" && type.shapeId != null) {
        return ":T".concat(type.kind, "<").concat(type.shapeId, ">");
      } else {
        return ":T".concat(type.kind);
      }
    }
    function printSourceLocation(loc) {
      if (_typeof(loc) === "symbol") {
        return "generated";
      } else {
        return ""
          .concat(loc.start.line, ":")
          .concat(loc.start.column, ":")
          .concat(loc.end.line, ":")
          .concat(loc.end.column);
      }
    }
    function printSourceLocationLine(loc) {
      if (_typeof(loc) === "symbol") {
        return "generated";
      } else {
        return "".concat(loc.start.line, ":").concat(loc.end.line);
      }
    }
    function getFunctionName$2(instrValue, defaultValue) {
      var _a;
      switch (instrValue.kind) {
        case "FunctionExpression":
          return (_a = instrValue.name) !== null && _a !== void 0
            ? _a
            : defaultValue;
        case "ObjectMethod":
          return defaultValue;
      }
    }
    var _ScopeBlockTraversal_activeScopes;
    function eachInstructionLValue(instr) {
      return _regeneratorRuntime().wrap(function eachInstructionLValue$(
        _context
      ) {
        while (1)
          switch ((_context.prev = _context.next)) {
            case 0:
              if (!(instr.lvalue !== null)) {
                _context.next = 3;
                break;
              }
              _context.next = 3;
              return instr.lvalue;
            case 3:
              return _context.delegateYield(
                eachInstructionValueLValue(instr.value),
                "t0",
                4
              );
            case 4:
            case "end":
              return _context.stop();
          }
      }, _marked);
    }
    function eachInstructionValueLValue(value) {
      return _regeneratorRuntime().wrap(function eachInstructionValueLValue$(
        _context2
      ) {
        while (1)
          switch ((_context2.prev = _context2.next)) {
            case 0:
              _context2.t0 = value.kind;
              _context2.next =
                _context2.t0 === "DeclareContext"
                  ? 3
                  : _context2.t0 === "StoreContext"
                    ? 3
                    : _context2.t0 === "DeclareLocal"
                      ? 3
                      : _context2.t0 === "StoreLocal"
                        ? 3
                        : _context2.t0 === "Destructure"
                          ? 6
                          : _context2.t0 === "PostfixUpdate"
                            ? 8
                            : _context2.t0 === "PrefixUpdate"
                              ? 8
                              : 11;
              break;
            case 3:
              _context2.next = 5;
              return value.lvalue.place;
            case 5:
              return _context2.abrupt("break", 11);
            case 6:
              return _context2.delegateYield(
                eachPatternOperand(value.lvalue.pattern),
                "t1",
                7
              );
            case 7:
              return _context2.abrupt("break", 11);
            case 8:
              _context2.next = 10;
              return value.lvalue;
            case 10:
              return _context2.abrupt("break", 11);
            case 11:
            case "end":
              return _context2.stop();
          }
      }, _marked2);
    }
    function eachInstructionOperand(instr) {
      return _regeneratorRuntime().wrap(function eachInstructionOperand$(
        _context3
      ) {
        while (1)
          switch ((_context3.prev = _context3.next)) {
            case 0:
              return _context3.delegateYield(
                eachInstructionValueOperand(instr.value),
                "t0",
                1
              );
            case 1:
            case "end":
              return _context3.stop();
          }
      }, _marked3);
    }
    function eachInstructionValueOperand(instrValue) {
      var _iterator56,
        _step56,
        attribute,
        _iterator57,
        _step57,
        property,
        _iterator58,
        _step58,
        element,
        _iterator59,
        _step59,
        dep;
      return _regeneratorRuntime().wrap(
        function eachInstructionValueOperand$(_context4) {
          while (1)
            switch ((_context4.prev = _context4.next)) {
              case 0:
                _context4.t0 = instrValue.kind;
                _context4.next =
                  _context4.t0 === "NewExpression"
                    ? 3
                    : _context4.t0 === "CallExpression"
                      ? 3
                      : _context4.t0 === "BinaryExpression"
                        ? 7
                        : _context4.t0 === "MethodCall"
                          ? 12
                          : _context4.t0 === "DeclareContext"
                            ? 18
                            : _context4.t0 === "DeclareLocal"
                              ? 18
                              : _context4.t0 === "LoadLocal"
                                ? 19
                                : _context4.t0 === "LoadContext"
                                  ? 19
                                  : _context4.t0 === "StoreLocal"
                                    ? 22
                                    : _context4.t0 === "StoreContext"
                                      ? 25
                                      : _context4.t0 === "StoreGlobal"
                                        ? 30
                                        : _context4.t0 === "Destructure"
                                          ? 33
                                          : _context4.t0 === "PropertyLoad"
                                            ? 36
                                            : _context4.t0 === "PropertyDelete"
                                              ? 39
                                              : _context4.t0 === "PropertyStore"
                                                ? 42
                                                : _context4.t0 ===
                                                    "ComputedLoad"
                                                  ? 47
                                                  : _context4.t0 ===
                                                      "ComputedDelete"
                                                    ? 52
                                                    : _context4.t0 ===
                                                        "ComputedStore"
                                                      ? 57
                                                      : _context4.t0 ===
                                                          "UnaryExpression"
                                                        ? 64
                                                        : _context4.t0 ===
                                                            "JsxExpression"
                                                          ? 67
                                                          : _context4.t0 ===
                                                              "JsxFragment"
                                                            ? 98
                                                            : _context4.t0 ===
                                                                "ObjectExpression"
                                                              ? 100
                                                              : _context4.t0 ===
                                                                  "ArrayExpression"
                                                                ? 121
                                                                : _context4.t0 ===
                                                                    "ObjectMethod"
                                                                  ? 145
                                                                  : _context4.t0 ===
                                                                      "FunctionExpression"
                                                                    ? 145
                                                                    : _context4.t0 ===
                                                                        "TaggedTemplateExpression"
                                                                      ? 147
                                                                      : _context4.t0 ===
                                                                          "TypeCastExpression"
                                                                        ? 150
                                                                        : _context4.t0 ===
                                                                            "TemplateLiteral"
                                                                          ? 153
                                                                          : _context4.t0 ===
                                                                              "Await"
                                                                            ? 155
                                                                            : _context4.t0 ===
                                                                                "GetIterator"
                                                                              ? 158
                                                                              : _context4.t0 ===
                                                                                  "IteratorNext"
                                                                                ? 161
                                                                                : _context4.t0 ===
                                                                                    "NextPropertyOf"
                                                                                  ? 166
                                                                                  : _context4.t0 ===
                                                                                      "PostfixUpdate"
                                                                                    ? 169
                                                                                    : _context4.t0 ===
                                                                                        "PrefixUpdate"
                                                                                      ? 169
                                                                                      : _context4.t0 ===
                                                                                          "StartMemoize"
                                                                                        ? 172
                                                                                        : _context4.t0 ===
                                                                                            "FinishMemoize"
                                                                                          ? 192
                                                                                          : _context4.t0 ===
                                                                                              "Debugger"
                                                                                            ? 195
                                                                                            : _context4.t0 ===
                                                                                                "RegExpLiteral"
                                                                                              ? 195
                                                                                              : _context4.t0 ===
                                                                                                  "MetaProperty"
                                                                                                ? 195
                                                                                                : _context4.t0 ===
                                                                                                    "LoadGlobal"
                                                                                                  ? 195
                                                                                                  : _context4.t0 ===
                                                                                                      "UnsupportedNode"
                                                                                                    ? 195
                                                                                                    : _context4.t0 ===
                                                                                                        "Primitive"
                                                                                                      ? 195
                                                                                                      : _context4.t0 ===
                                                                                                          "JSXText"
                                                                                                        ? 195
                                                                                                        : 196;
                break;
              case 3:
                _context4.next = 5;
                return instrValue.callee;
              case 5:
                return _context4.delegateYield(
                  eachCallArgument(instrValue.args),
                  "t1",
                  6
                );
              case 6:
                return _context4.abrupt("break", 197);
              case 7:
                _context4.next = 9;
                return instrValue.left;
              case 9:
                _context4.next = 11;
                return instrValue.right;
              case 11:
                return _context4.abrupt("break", 197);
              case 12:
                _context4.next = 14;
                return instrValue.receiver;
              case 14:
                _context4.next = 16;
                return instrValue.property;
              case 16:
                return _context4.delegateYield(
                  eachCallArgument(instrValue.args),
                  "t2",
                  17
                );
              case 17:
                return _context4.abrupt("break", 197);
              case 18:
                return _context4.abrupt("break", 197);
              case 19:
                _context4.next = 21;
                return instrValue.place;
              case 21:
                return _context4.abrupt("break", 197);
              case 22:
                _context4.next = 24;
                return instrValue.value;
              case 24:
                return _context4.abrupt("break", 197);
              case 25:
                _context4.next = 27;
                return instrValue.lvalue.place;
              case 27:
                _context4.next = 29;
                return instrValue.value;
              case 29:
                return _context4.abrupt("break", 197);
              case 30:
                _context4.next = 32;
                return instrValue.value;
              case 32:
                return _context4.abrupt("break", 197);
              case 33:
                _context4.next = 35;
                return instrValue.value;
              case 35:
                return _context4.abrupt("break", 197);
              case 36:
                _context4.next = 38;
                return instrValue.object;
              case 38:
                return _context4.abrupt("break", 197);
              case 39:
                _context4.next = 41;
                return instrValue.object;
              case 41:
                return _context4.abrupt("break", 197);
              case 42:
                _context4.next = 44;
                return instrValue.object;
              case 44:
                _context4.next = 46;
                return instrValue.value;
              case 46:
                return _context4.abrupt("break", 197);
              case 47:
                _context4.next = 49;
                return instrValue.object;
              case 49:
                _context4.next = 51;
                return instrValue.property;
              case 51:
                return _context4.abrupt("break", 197);
              case 52:
                _context4.next = 54;
                return instrValue.object;
              case 54:
                _context4.next = 56;
                return instrValue.property;
              case 56:
                return _context4.abrupt("break", 197);
              case 57:
                _context4.next = 59;
                return instrValue.object;
              case 59:
                _context4.next = 61;
                return instrValue.property;
              case 61:
                _context4.next = 63;
                return instrValue.value;
              case 63:
                return _context4.abrupt("break", 197);
              case 64:
                _context4.next = 66;
                return instrValue.value;
              case 66:
                return _context4.abrupt("break", 197);
              case 67:
                if (!(instrValue.tag.kind === "Identifier")) {
                  _context4.next = 70;
                  break;
                }
                _context4.next = 70;
                return instrValue.tag;
              case 70:
                _iterator56 = _createForOfIteratorHelper(instrValue.props);
                _context4.prev = 71;
                _iterator56.s();
              case 73:
                if ((_step56 = _iterator56.n()).done) {
                  _context4.next = 87;
                  break;
                }
                attribute = _step56.value;
                _context4.t3 = attribute.kind;
                _context4.next =
                  _context4.t3 === "JsxAttribute"
                    ? 78
                    : _context4.t3 === "JsxSpreadAttribute"
                      ? 81
                      : 84;
                break;
              case 78:
                _context4.next = 80;
                return attribute.place;
              case 80:
                return _context4.abrupt("break", 85);
              case 81:
                _context4.next = 83;
                return attribute.argument;
              case 83:
                return _context4.abrupt("break", 85);
              case 84:
                assertExhaustive$1(
                  attribute,
                  "Unexpected attribute kind `".concat(attribute.kind, "`")
                );
              case 85:
                _context4.next = 73;
                break;
              case 87:
                _context4.next = 92;
                break;
              case 89:
                _context4.prev = 89;
                _context4.t4 = _context4["catch"](71);
                _iterator56.e(_context4.t4);
              case 92:
                _context4.prev = 92;
                _iterator56.f();
                return _context4.finish(92);
              case 95:
                if (!instrValue.children) {
                  _context4.next = 97;
                  break;
                }
                return _context4.delegateYield(instrValue.children, "t5", 97);
              case 97:
                return _context4.abrupt("break", 197);
              case 98:
                return _context4.delegateYield(instrValue.children, "t6", 99);
              case 99:
                return _context4.abrupt("break", 197);
              case 100:
                _iterator57 = _createForOfIteratorHelper(instrValue.properties);
                _context4.prev = 101;
                _iterator57.s();
              case 103:
                if ((_step57 = _iterator57.n()).done) {
                  _context4.next = 112;
                  break;
                }
                property = _step57.value;
                if (
                  !(
                    property.kind === "ObjectProperty" &&
                    property.key.kind === "computed"
                  )
                ) {
                  _context4.next = 108;
                  break;
                }
                _context4.next = 108;
                return property.key.name;
              case 108:
                _context4.next = 110;
                return property.place;
              case 110:
                _context4.next = 103;
                break;
              case 112:
                _context4.next = 117;
                break;
              case 114:
                _context4.prev = 114;
                _context4.t7 = _context4["catch"](101);
                _iterator57.e(_context4.t7);
              case 117:
                _context4.prev = 117;
                _iterator57.f();
                return _context4.finish(117);
              case 120:
                return _context4.abrupt("break", 197);
              case 121:
                _iterator58 = _createForOfIteratorHelper(instrValue.elements);
                _context4.prev = 122;
                _iterator58.s();
              case 124:
                if ((_step58 = _iterator58.n()).done) {
                  _context4.next = 136;
                  break;
                }
                element = _step58.value;
                if (!(element.kind === "Identifier")) {
                  _context4.next = 131;
                  break;
                }
                _context4.next = 129;
                return element;
              case 129:
                _context4.next = 134;
                break;
              case 131:
                if (!(element.kind === "Spread")) {
                  _context4.next = 134;
                  break;
                }
                _context4.next = 134;
                return element.place;
              case 134:
                _context4.next = 124;
                break;
              case 136:
                _context4.next = 141;
                break;
              case 138:
                _context4.prev = 138;
                _context4.t8 = _context4["catch"](122);
                _iterator58.e(_context4.t8);
              case 141:
                _context4.prev = 141;
                _iterator58.f();
                return _context4.finish(141);
              case 144:
                return _context4.abrupt("break", 197);
              case 145:
                return _context4.delegateYield(
                  instrValue.loweredFunc.func.context,
                  "t9",
                  146
                );
              case 146:
                return _context4.abrupt("break", 197);
              case 147:
                _context4.next = 149;
                return instrValue.tag;
              case 149:
                return _context4.abrupt("break", 197);
              case 150:
                _context4.next = 152;
                return instrValue.value;
              case 152:
                return _context4.abrupt("break", 197);
              case 153:
                return _context4.delegateYield(instrValue.subexprs, "t10", 154);
              case 154:
                return _context4.abrupt("break", 197);
              case 155:
                _context4.next = 157;
                return instrValue.value;
              case 157:
                return _context4.abrupt("break", 197);
              case 158:
                _context4.next = 160;
                return instrValue.collection;
              case 160:
                return _context4.abrupt("break", 197);
              case 161:
                _context4.next = 163;
                return instrValue.iterator;
              case 163:
                _context4.next = 165;
                return instrValue.collection;
              case 165:
                return _context4.abrupt("break", 197);
              case 166:
                _context4.next = 168;
                return instrValue.value;
              case 168:
                return _context4.abrupt("break", 197);
              case 169:
                _context4.next = 171;
                return instrValue.value;
              case 171:
                return _context4.abrupt("break", 197);
              case 172:
                if (!(instrValue.deps != null)) {
                  _context4.next = 191;
                  break;
                }
                _iterator59 = _createForOfIteratorHelper(instrValue.deps);
                _context4.prev = 174;
                _iterator59.s();
              case 176:
                if ((_step59 = _iterator59.n()).done) {
                  _context4.next = 183;
                  break;
                }
                dep = _step59.value;
                if (!(dep.root.kind === "NamedLocal")) {
                  _context4.next = 181;
                  break;
                }
                _context4.next = 181;
                return dep.root.value;
              case 181:
                _context4.next = 176;
                break;
              case 183:
                _context4.next = 188;
                break;
              case 185:
                _context4.prev = 185;
                _context4.t11 = _context4["catch"](174);
                _iterator59.e(_context4.t11);
              case 188:
                _context4.prev = 188;
                _iterator59.f();
                return _context4.finish(188);
              case 191:
                return _context4.abrupt("break", 197);
              case 192:
                _context4.next = 194;
                return instrValue.decl;
              case 194:
                return _context4.abrupt("break", 197);
              case 195:
                return _context4.abrupt("break", 197);
              case 196:
                assertExhaustive$1(
                  instrValue,
                  "Unexpected instruction kind `".concat(instrValue.kind, "`")
                );
              case 197:
              case "end":
                return _context4.stop();
            }
        },
        _marked4,
        null,
        [
          [71, 89, 92, 95],
          [101, 114, 117, 120],
          [122, 138, 141, 144],
          [174, 185, 188, 191]
        ]
      );
    }
    function eachCallArgument(args) {
      var _iterator60, _step60, arg;
      return _regeneratorRuntime().wrap(
        function eachCallArgument$(_context5) {
          while (1)
            switch ((_context5.prev = _context5.next)) {
              case 0:
                _iterator60 = _createForOfIteratorHelper(args);
                _context5.prev = 1;
                _iterator60.s();
              case 3:
                if ((_step60 = _iterator60.n()).done) {
                  _context5.next = 14;
                  break;
                }
                arg = _step60.value;
                if (!(arg.kind === "Identifier")) {
                  _context5.next = 10;
                  break;
                }
                _context5.next = 8;
                return arg;
              case 8:
                _context5.next = 12;
                break;
              case 10:
                _context5.next = 12;
                return arg.place;
              case 12:
                _context5.next = 3;
                break;
              case 14:
                _context5.next = 19;
                break;
              case 16:
                _context5.prev = 16;
                _context5.t0 = _context5["catch"](1);
                _iterator60.e(_context5.t0);
              case 19:
                _context5.prev = 19;
                _iterator60.f();
                return _context5.finish(19);
              case 22:
              case "end":
                return _context5.stop();
            }
        },
        _marked5,
        null,
        [[1, 16, 19, 22]]
      );
    }
    function doesPatternContainSpreadElement(pattern) {
      switch (pattern.kind) {
        case "ArrayPattern": {
          var _iterator61 = _createForOfIteratorHelper(pattern.items),
            _step61;
          try {
            for (_iterator61.s(); !(_step61 = _iterator61.n()).done; ) {
              var item = _step61.value;
              if (item.kind === "Spread") {
                return true;
              }
            }
          } catch (err) {
            _iterator61.e(err);
          } finally {
            _iterator61.f();
          }
          break;
        }
        case "ObjectPattern": {
          var _iterator62 = _createForOfIteratorHelper(pattern.properties),
            _step62;
          try {
            for (_iterator62.s(); !(_step62 = _iterator62.n()).done; ) {
              var property = _step62.value;
              if (property.kind === "Spread") {
                return true;
              }
            }
          } catch (err) {
            _iterator62.e(err);
          } finally {
            _iterator62.f();
          }
          break;
        }
        default: {
          assertExhaustive$1(
            pattern,
            "Unexpected pattern kind `".concat(pattern.kind, "`")
          );
        }
      }
      return false;
    }
    function eachPatternOperand(pattern) {
      var _iterator63, _step63, item, _iterator64, _step64, property;
      return _regeneratorRuntime().wrap(
        function eachPatternOperand$(_context6) {
          while (1)
            switch ((_context6.prev = _context6.next)) {
              case 0:
                _context6.t0 = pattern.kind;
                _context6.next =
                  _context6.t0 === "ArrayPattern"
                    ? 3
                    : _context6.t0 === "ObjectPattern"
                      ? 34
                      : 61;
                break;
              case 3:
                _iterator63 = _createForOfIteratorHelper(pattern.items);
                _context6.prev = 4;
                _iterator63.s();
              case 6:
                if ((_step63 = _iterator63.n()).done) {
                  _context6.next = 25;
                  break;
                }
                item = _step63.value;
                if (!(item.kind === "Identifier")) {
                  _context6.next = 13;
                  break;
                }
                _context6.next = 11;
                return item;
              case 11:
                _context6.next = 23;
                break;
              case 13:
                if (!(item.kind === "Spread")) {
                  _context6.next = 18;
                  break;
                }
                _context6.next = 16;
                return item.place;
              case 16:
                _context6.next = 23;
                break;
              case 18:
                if (!(item.kind === "Hole")) {
                  _context6.next = 22;
                  break;
                }
                return _context6.abrupt("continue", 23);
              case 22:
                assertExhaustive$1(
                  item,
                  "Unexpected item kind `".concat(item.kind, "`")
                );
              case 23:
                _context6.next = 6;
                break;
              case 25:
                _context6.next = 30;
                break;
              case 27:
                _context6.prev = 27;
                _context6.t1 = _context6["catch"](4);
                _iterator63.e(_context6.t1);
              case 30:
                _context6.prev = 30;
                _iterator63.f();
                return _context6.finish(30);
              case 33:
                return _context6.abrupt("break", 62);
              case 34:
                _iterator64 = _createForOfIteratorHelper(pattern.properties);
                _context6.prev = 35;
                _iterator64.s();
              case 37:
                if ((_step64 = _iterator64.n()).done) {
                  _context6.next = 52;
                  break;
                }
                property = _step64.value;
                if (!(property.kind === "ObjectProperty")) {
                  _context6.next = 44;
                  break;
                }
                _context6.next = 42;
                return property.place;
              case 42:
                _context6.next = 50;
                break;
              case 44:
                if (!(property.kind === "Spread")) {
                  _context6.next = 49;
                  break;
                }
                _context6.next = 47;
                return property.place;
              case 47:
                _context6.next = 50;
                break;
              case 49:
                assertExhaustive$1(
                  property,
                  "Unexpected item kind `".concat(property.kind, "`")
                );
              case 50:
                _context6.next = 37;
                break;
              case 52:
                _context6.next = 57;
                break;
              case 54:
                _context6.prev = 54;
                _context6.t2 = _context6["catch"](35);
                _iterator64.e(_context6.t2);
              case 57:
                _context6.prev = 57;
                _iterator64.f();
                return _context6.finish(57);
              case 60:
                return _context6.abrupt("break", 62);
              case 61:
                assertExhaustive$1(
                  pattern,
                  "Unexpected pattern kind `".concat(pattern.kind, "`")
                );
              case 62:
              case "end":
                return _context6.stop();
            }
        },
        _marked6,
        null,
        [
          [4, 27, 30, 33],
          [35, 54, 57, 60]
        ]
      );
    }
    function mapInstructionLValues(instr, fn) {
      switch (instr.value.kind) {
        case "DeclareLocal":
        case "StoreLocal": {
          var lvalue = instr.value.lvalue;
          lvalue.place = fn(lvalue.place);
          break;
        }
        case "Destructure": {
          mapPatternOperands(instr.value.lvalue.pattern, fn);
          break;
        }
        case "PostfixUpdate":
        case "PrefixUpdate": {
          instr.value.lvalue = fn(instr.value.lvalue);
          break;
        }
      }
      if (instr.lvalue !== null) {
        instr.lvalue = fn(instr.lvalue);
      }
    }
    function mapInstructionOperands(instr, fn) {
      mapInstructionValueOperands(instr.value, fn);
    }
    function mapInstructionValueOperands(instrValue, fn) {
      switch (instrValue.kind) {
        case "BinaryExpression": {
          instrValue.left = fn(instrValue.left);
          instrValue.right = fn(instrValue.right);
          break;
        }
        case "PropertyLoad": {
          instrValue.object = fn(instrValue.object);
          break;
        }
        case "PropertyDelete": {
          instrValue.object = fn(instrValue.object);
          break;
        }
        case "PropertyStore": {
          instrValue.object = fn(instrValue.object);
          instrValue.value = fn(instrValue.value);
          break;
        }
        case "ComputedLoad": {
          instrValue.object = fn(instrValue.object);
          instrValue.property = fn(instrValue.property);
          break;
        }
        case "ComputedDelete": {
          instrValue.object = fn(instrValue.object);
          instrValue.property = fn(instrValue.property);
          break;
        }
        case "ComputedStore": {
          instrValue.object = fn(instrValue.object);
          instrValue.property = fn(instrValue.property);
          instrValue.value = fn(instrValue.value);
          break;
        }
        case "DeclareContext":
        case "DeclareLocal": {
          break;
        }
        case "LoadLocal":
        case "LoadContext": {
          instrValue.place = fn(instrValue.place);
          break;
        }
        case "StoreLocal": {
          instrValue.value = fn(instrValue.value);
          break;
        }
        case "StoreContext": {
          instrValue.lvalue.place = fn(instrValue.lvalue.place);
          instrValue.value = fn(instrValue.value);
          break;
        }
        case "StoreGlobal": {
          instrValue.value = fn(instrValue.value);
          break;
        }
        case "Destructure": {
          instrValue.value = fn(instrValue.value);
          break;
        }
        case "NewExpression":
        case "CallExpression": {
          instrValue.callee = fn(instrValue.callee);
          instrValue.args = mapCallArguments(instrValue.args, fn);
          break;
        }
        case "MethodCall": {
          instrValue.receiver = fn(instrValue.receiver);
          instrValue.property = fn(instrValue.property);
          instrValue.args = mapCallArguments(instrValue.args, fn);
          break;
        }
        case "UnaryExpression": {
          instrValue.value = fn(instrValue.value);
          break;
        }
        case "JsxExpression": {
          if (instrValue.tag.kind === "Identifier") {
            instrValue.tag = fn(instrValue.tag);
          }
          var _iterator65 = _createForOfIteratorHelper(instrValue.props),
            _step65;
          try {
            for (_iterator65.s(); !(_step65 = _iterator65.n()).done; ) {
              var attribute = _step65.value;
              switch (attribute.kind) {
                case "JsxAttribute": {
                  attribute.place = fn(attribute.place);
                  break;
                }
                case "JsxSpreadAttribute": {
                  attribute.argument = fn(attribute.argument);
                  break;
                }
                default: {
                  assertExhaustive$1(
                    attribute,
                    "Unexpected attribute kind `".concat(attribute.kind, "`")
                  );
                }
              }
            }
          } catch (err) {
            _iterator65.e(err);
          } finally {
            _iterator65.f();
          }
          if (instrValue.children) {
            instrValue.children = instrValue.children.map(function (p) {
              return fn(p);
            });
          }
          break;
        }
        case "ObjectExpression": {
          var _iterator66 = _createForOfIteratorHelper(instrValue.properties),
            _step66;
          try {
            for (_iterator66.s(); !(_step66 = _iterator66.n()).done; ) {
              var property = _step66.value;
              if (
                property.kind === "ObjectProperty" &&
                property.key.kind === "computed"
              ) {
                property.key.name = fn(property.key.name);
              }
              property.place = fn(property.place);
            }
          } catch (err) {
            _iterator66.e(err);
          } finally {
            _iterator66.f();
          }
          break;
        }
        case "ArrayExpression": {
          instrValue.elements = instrValue.elements.map(function (element) {
            if (element.kind === "Identifier") {
              return fn(element);
            } else if (element.kind === "Spread") {
              element.place = fn(element.place);
              return element;
            } else {
              return element;
            }
          });
          break;
        }
        case "JsxFragment": {
          instrValue.children = instrValue.children.map(function (e) {
            return fn(e);
          });
          break;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          instrValue.loweredFunc.func.context =
            instrValue.loweredFunc.func.context.map(function (d) {
              return fn(d);
            });
          break;
        }
        case "TaggedTemplateExpression": {
          instrValue.tag = fn(instrValue.tag);
          break;
        }
        case "TypeCastExpression": {
          instrValue.value = fn(instrValue.value);
          break;
        }
        case "TemplateLiteral": {
          instrValue.subexprs = instrValue.subexprs.map(fn);
          break;
        }
        case "Await": {
          instrValue.value = fn(instrValue.value);
          break;
        }
        case "GetIterator": {
          instrValue.collection = fn(instrValue.collection);
          break;
        }
        case "IteratorNext": {
          instrValue.iterator = fn(instrValue.iterator);
          instrValue.collection = fn(instrValue.collection);
          break;
        }
        case "NextPropertyOf": {
          instrValue.value = fn(instrValue.value);
          break;
        }
        case "PostfixUpdate":
        case "PrefixUpdate": {
          instrValue.value = fn(instrValue.value);
          break;
        }
        case "StartMemoize": {
          if (instrValue.deps != null) {
            var _iterator67 = _createForOfIteratorHelper(instrValue.deps),
              _step67;
            try {
              for (_iterator67.s(); !(_step67 = _iterator67.n()).done; ) {
                var dep = _step67.value;
                if (dep.root.kind === "NamedLocal") {
                  dep.root.value = fn(dep.root.value);
                }
              }
            } catch (err) {
              _iterator67.e(err);
            } finally {
              _iterator67.f();
            }
          }
          break;
        }
        case "FinishMemoize": {
          instrValue.decl = fn(instrValue.decl);
          break;
        }
        case "Debugger":
        case "RegExpLiteral":
        case "MetaProperty":
        case "LoadGlobal":
        case "UnsupportedNode":
        case "Primitive":
        case "JSXText": {
          break;
        }
        default: {
          assertExhaustive$1(instrValue, "Unexpected instruction kind");
        }
      }
    }
    function mapCallArguments(args, fn) {
      return args.map(function (arg) {
        if (arg.kind === "Identifier") {
          return fn(arg);
        } else {
          arg.place = fn(arg.place);
          return arg;
        }
      });
    }
    function mapPatternOperands(pattern, fn) {
      switch (pattern.kind) {
        case "ArrayPattern": {
          pattern.items = pattern.items.map(function (item) {
            if (item.kind === "Identifier") {
              return fn(item);
            } else if (item.kind === "Spread") {
              item.place = fn(item.place);
              return item;
            } else {
              return item;
            }
          });
          break;
        }
        case "ObjectPattern": {
          var _iterator68 = _createForOfIteratorHelper(pattern.properties),
            _step68;
          try {
            for (_iterator68.s(); !(_step68 = _iterator68.n()).done; ) {
              var property = _step68.value;
              property.place = fn(property.place);
            }
          } catch (err) {
            _iterator68.e(err);
          } finally {
            _iterator68.f();
          }
          break;
        }
        default: {
          assertExhaustive$1(
            pattern,
            "Unexpected pattern kind `".concat(pattern.kind, "`")
          );
        }
      }
    }
    function mapTerminalSuccessors(terminal, fn) {
      switch (terminal.kind) {
        case "goto": {
          var target = fn(terminal.block);
          return {
            kind: "goto",
            block: target,
            variant: terminal.variant,
            id: makeInstructionId(0),
            loc: terminal.loc
          };
        }
        case "if": {
          var consequent = fn(terminal.consequent);
          var alternate = fn(terminal.alternate);
          var fallthrough = fn(terminal.fallthrough);
          return {
            kind: "if",
            test: terminal.test,
            consequent: consequent,
            alternate: alternate,
            fallthrough: fallthrough,
            id: makeInstructionId(0),
            loc: terminal.loc
          };
        }
        case "branch": {
          var _consequent = fn(terminal.consequent);
          var _alternate = fn(terminal.alternate);
          var _fallthrough = fn(terminal.fallthrough);
          return {
            kind: "branch",
            test: terminal.test,
            consequent: _consequent,
            alternate: _alternate,
            fallthrough: _fallthrough,
            id: makeInstructionId(0),
            loc: terminal.loc
          };
        }
        case "switch": {
          var cases = terminal.cases.map(function (case_) {
            var target = fn(case_.block);
            return { test: case_.test, block: target };
          });
          var _fallthrough2 = fn(terminal.fallthrough);
          return {
            kind: "switch",
            test: terminal.test,
            cases: cases,
            fallthrough: _fallthrough2,
            id: makeInstructionId(0),
            loc: terminal.loc
          };
        }
        case "logical": {
          var _test = fn(terminal.test);
          var _fallthrough3 = fn(terminal.fallthrough);
          return {
            kind: "logical",
            test: _test,
            fallthrough: _fallthrough3,
            operator: terminal.operator,
            id: makeInstructionId(0),
            loc: terminal.loc
          };
        }
        case "ternary": {
          var _test2 = fn(terminal.test);
          var _fallthrough4 = fn(terminal.fallthrough);
          return {
            kind: "ternary",
            test: _test2,
            fallthrough: _fallthrough4,
            id: makeInstructionId(0),
            loc: terminal.loc
          };
        }
        case "optional": {
          var _test3 = fn(terminal.test);
          var _fallthrough5 = fn(terminal.fallthrough);
          return {
            kind: "optional",
            optional: terminal.optional,
            test: _test3,
            fallthrough: _fallthrough5,
            id: makeInstructionId(0),
            loc: terminal.loc
          };
        }
        case "return": {
          return {
            kind: "return",
            loc: terminal.loc,
            value: terminal.value,
            id: makeInstructionId(0)
          };
        }
        case "throw": {
          return terminal;
        }
        case "do-while": {
          var loop = fn(terminal.loop);
          var _test4 = fn(terminal.test);
          var _fallthrough6 = fn(terminal.fallthrough);
          return {
            kind: "do-while",
            loc: terminal.loc,
            test: _test4,
            loop: loop,
            fallthrough: _fallthrough6,
            id: makeInstructionId(0)
          };
        }
        case "while": {
          var _test5 = fn(terminal.test);
          var _loop2 = fn(terminal.loop);
          var _fallthrough7 = fn(terminal.fallthrough);
          return {
            kind: "while",
            loc: terminal.loc,
            test: _test5,
            loop: _loop2,
            fallthrough: _fallthrough7,
            id: makeInstructionId(0)
          };
        }
        case "for": {
          var init = fn(terminal.init);
          var _test6 = fn(terminal.test);
          var _update = terminal.update !== null ? fn(terminal.update) : null;
          var _loop3 = fn(terminal.loop);
          var _fallthrough8 = fn(terminal.fallthrough);
          return {
            kind: "for",
            loc: terminal.loc,
            init: init,
            test: _test6,
            update: _update,
            loop: _loop3,
            fallthrough: _fallthrough8,
            id: makeInstructionId(0)
          };
        }
        case "for-of": {
          var _init = fn(terminal.init);
          var _loop4 = fn(terminal.loop);
          var _test7 = fn(terminal.test);
          var _fallthrough9 = fn(terminal.fallthrough);
          return {
            kind: "for-of",
            loc: terminal.loc,
            init: _init,
            test: _test7,
            loop: _loop4,
            fallthrough: _fallthrough9,
            id: makeInstructionId(0)
          };
        }
        case "for-in": {
          var _init2 = fn(terminal.init);
          var _loop5 = fn(terminal.loop);
          var _fallthrough10 = fn(terminal.fallthrough);
          return {
            kind: "for-in",
            loc: terminal.loc,
            init: _init2,
            loop: _loop5,
            fallthrough: _fallthrough10,
            id: makeInstructionId(0)
          };
        }
        case "label": {
          var block = fn(terminal.block);
          var _fallthrough11 = fn(terminal.fallthrough);
          return {
            kind: "label",
            block: block,
            fallthrough: _fallthrough11,
            id: makeInstructionId(0),
            loc: terminal.loc
          };
        }
        case "sequence": {
          var _block = fn(terminal.block);
          var _fallthrough12 = fn(terminal.fallthrough);
          return {
            kind: "sequence",
            block: _block,
            fallthrough: _fallthrough12,
            id: makeInstructionId(0),
            loc: terminal.loc
          };
        }
        case "maybe-throw": {
          var continuation = fn(terminal.continuation);
          var handler = fn(terminal.handler);
          return {
            kind: "maybe-throw",
            continuation: continuation,
            handler: handler,
            id: makeInstructionId(0),
            loc: terminal.loc
          };
        }
        case "try": {
          var _block2 = fn(terminal.block);
          var _handler = fn(terminal.handler);
          var _fallthrough13 = fn(terminal.fallthrough);
          return {
            kind: "try",
            block: _block2,
            handlerBinding: terminal.handlerBinding,
            handler: _handler,
            fallthrough: _fallthrough13,
            id: makeInstructionId(0),
            loc: terminal.loc
          };
        }
        case "scope":
        case "pruned-scope": {
          var _block3 = fn(terminal.block);
          var _fallthrough14 = fn(terminal.fallthrough);
          return {
            kind: terminal.kind,
            scope: terminal.scope,
            block: _block3,
            fallthrough: _fallthrough14,
            id: makeInstructionId(0),
            loc: terminal.loc
          };
        }
        case "unreachable":
        case "unsupported": {
          return terminal;
        }
        default: {
          assertExhaustive$1(
            terminal,
            "Unexpected terminal kind `".concat(terminal.kind, "`")
          );
        }
      }
    }
    function terminalHasFallthrough(terminal) {
      switch (terminal.kind) {
        case "maybe-throw":
        case "goto":
        case "return":
        case "throw":
        case "unreachable":
        case "unsupported": {
          return false;
        }
        case "branch":
        case "try":
        case "do-while":
        case "for-of":
        case "for-in":
        case "for":
        case "if":
        case "label":
        case "logical":
        case "optional":
        case "sequence":
        case "switch":
        case "ternary":
        case "while":
        case "scope":
        case "pruned-scope": {
          return true;
        }
        default: {
          assertExhaustive$1(
            terminal,
            "Unexpected terminal kind `".concat(terminal.kind, "`")
          );
        }
      }
    }
    function terminalFallthrough(terminal) {
      if (terminalHasFallthrough(terminal)) {
        return terminal.fallthrough;
      } else {
        return null;
      }
    }
    function eachTerminalSuccessor(terminal) {
      var _iterator69, _step69, case_;
      return _regeneratorRuntime().wrap(
        function eachTerminalSuccessor$(_context7) {
          while (1)
            switch ((_context7.prev = _context7.next)) {
              case 0:
                _context7.t0 = terminal.kind;
                _context7.next =
                  _context7.t0 === "goto"
                    ? 3
                    : _context7.t0 === "if"
                      ? 6
                      : _context7.t0 === "branch"
                        ? 11
                        : _context7.t0 === "switch"
                          ? 16
                          : _context7.t0 === "optional"
                            ? 34
                            : _context7.t0 === "ternary"
                              ? 34
                              : _context7.t0 === "logical"
                                ? 34
                                : _context7.t0 === "return"
                                  ? 37
                                  : _context7.t0 === "throw"
                                    ? 38
                                    : _context7.t0 === "do-while"
                                      ? 39
                                      : _context7.t0 === "while"
                                        ? 42
                                        : _context7.t0 === "for"
                                          ? 45
                                          : _context7.t0 === "for-of"
                                            ? 48
                                            : _context7.t0 === "for-in"
                                              ? 51
                                              : _context7.t0 === "label"
                                                ? 54
                                                : _context7.t0 === "sequence"
                                                  ? 57
                                                  : _context7.t0 ===
                                                      "maybe-throw"
                                                    ? 60
                                                    : _context7.t0 === "try"
                                                      ? 65
                                                      : _context7.t0 === "scope"
                                                        ? 68
                                                        : _context7.t0 ===
                                                            "pruned-scope"
                                                          ? 68
                                                          : _context7.t0 ===
                                                              "unreachable"
                                                            ? 71
                                                            : _context7.t0 ===
                                                                "unsupported"
                                                              ? 71
                                                              : 72;
                break;
              case 3:
                _context7.next = 5;
                return terminal.block;
              case 5:
                return _context7.abrupt("break", 73);
              case 6:
                _context7.next = 8;
                return terminal.consequent;
              case 8:
                _context7.next = 10;
                return terminal.alternate;
              case 10:
                return _context7.abrupt("break", 73);
              case 11:
                _context7.next = 13;
                return terminal.consequent;
              case 13:
                _context7.next = 15;
                return terminal.alternate;
              case 15:
                return _context7.abrupt("break", 73);
              case 16:
                _iterator69 = _createForOfIteratorHelper(terminal.cases);
                _context7.prev = 17;
                _iterator69.s();
              case 19:
                if ((_step69 = _iterator69.n()).done) {
                  _context7.next = 25;
                  break;
                }
                case_ = _step69.value;
                _context7.next = 23;
                return case_.block;
              case 23:
                _context7.next = 19;
                break;
              case 25:
                _context7.next = 30;
                break;
              case 27:
                _context7.prev = 27;
                _context7.t1 = _context7["catch"](17);
                _iterator69.e(_context7.t1);
              case 30:
                _context7.prev = 30;
                _iterator69.f();
                return _context7.finish(30);
              case 33:
                return _context7.abrupt("break", 73);
              case 34:
                _context7.next = 36;
                return terminal.test;
              case 36:
                return _context7.abrupt("break", 73);
              case 37:
                return _context7.abrupt("break", 73);
              case 38:
                return _context7.abrupt("break", 73);
              case 39:
                _context7.next = 41;
                return terminal.loop;
              case 41:
                return _context7.abrupt("break", 73);
              case 42:
                _context7.next = 44;
                return terminal.test;
              case 44:
                return _context7.abrupt("break", 73);
              case 45:
                _context7.next = 47;
                return terminal.init;
              case 47:
                return _context7.abrupt("break", 73);
              case 48:
                _context7.next = 50;
                return terminal.init;
              case 50:
                return _context7.abrupt("break", 73);
              case 51:
                _context7.next = 53;
                return terminal.init;
              case 53:
                return _context7.abrupt("break", 73);
              case 54:
                _context7.next = 56;
                return terminal.block;
              case 56:
                return _context7.abrupt("break", 73);
              case 57:
                _context7.next = 59;
                return terminal.block;
              case 59:
                return _context7.abrupt("break", 73);
              case 60:
                _context7.next = 62;
                return terminal.continuation;
              case 62:
                _context7.next = 64;
                return terminal.handler;
              case 64:
                return _context7.abrupt("break", 73);
              case 65:
                _context7.next = 67;
                return terminal.block;
              case 67:
                return _context7.abrupt("break", 73);
              case 68:
                _context7.next = 70;
                return terminal.block;
              case 70:
                return _context7.abrupt("break", 73);
              case 71:
                return _context7.abrupt("break", 73);
              case 72:
                assertExhaustive$1(
                  terminal,
                  "Unexpected terminal kind `".concat(terminal.kind, "`")
                );
              case 73:
              case "end":
                return _context7.stop();
            }
        },
        _marked7,
        null,
        [[17, 27, 30, 33]]
      );
    }
    function mapTerminalOperands(terminal, fn) {
      switch (terminal.kind) {
        case "if": {
          terminal.test = fn(terminal.test);
          break;
        }
        case "branch": {
          terminal.test = fn(terminal.test);
          break;
        }
        case "switch": {
          terminal.test = fn(terminal.test);
          var _iterator70 = _createForOfIteratorHelper(terminal.cases),
            _step70;
          try {
            for (_iterator70.s(); !(_step70 = _iterator70.n()).done; ) {
              var case_ = _step70.value;
              if (case_.test === null) {
                continue;
              }
              case_.test = fn(case_.test);
            }
          } catch (err) {
            _iterator70.e(err);
          } finally {
            _iterator70.f();
          }
          break;
        }
        case "return":
        case "throw": {
          terminal.value = fn(terminal.value);
          break;
        }
        case "try": {
          if (terminal.handlerBinding !== null) {
            terminal.handlerBinding = fn(terminal.handlerBinding);
          } else {
            terminal.handlerBinding = null;
          }
          break;
        }
        case "maybe-throw":
        case "sequence":
        case "label":
        case "optional":
        case "ternary":
        case "logical":
        case "do-while":
        case "while":
        case "for":
        case "for-of":
        case "for-in":
        case "goto":
        case "unreachable":
        case "unsupported":
        case "scope":
        case "pruned-scope": {
          break;
        }
        default: {
          assertExhaustive$1(
            terminal,
            "Unexpected terminal kind `".concat(terminal.kind, "`")
          );
        }
      }
    }
    function eachTerminalOperand(terminal) {
      var _iterator71, _step71, case_;
      return _regeneratorRuntime().wrap(
        function eachTerminalOperand$(_context8) {
          while (1)
            switch ((_context8.prev = _context8.next)) {
              case 0:
                _context8.t0 = terminal.kind;
                _context8.next =
                  _context8.t0 === "if"
                    ? 3
                    : _context8.t0 === "branch"
                      ? 6
                      : _context8.t0 === "switch"
                        ? 9
                        : _context8.t0 === "return"
                          ? 31
                          : _context8.t0 === "throw"
                            ? 31
                            : _context8.t0 === "try"
                              ? 34
                              : _context8.t0 === "maybe-throw"
                                ? 38
                                : _context8.t0 === "sequence"
                                  ? 38
                                  : _context8.t0 === "label"
                                    ? 38
                                    : _context8.t0 === "optional"
                                      ? 38
                                      : _context8.t0 === "ternary"
                                        ? 38
                                        : _context8.t0 === "logical"
                                          ? 38
                                          : _context8.t0 === "do-while"
                                            ? 38
                                            : _context8.t0 === "while"
                                              ? 38
                                              : _context8.t0 === "for"
                                                ? 38
                                                : _context8.t0 === "for-of"
                                                  ? 38
                                                  : _context8.t0 === "for-in"
                                                    ? 38
                                                    : _context8.t0 === "goto"
                                                      ? 38
                                                      : _context8.t0 ===
                                                          "unreachable"
                                                        ? 38
                                                        : _context8.t0 ===
                                                            "unsupported"
                                                          ? 38
                                                          : _context8.t0 ===
                                                              "scope"
                                                            ? 38
                                                            : _context8.t0 ===
                                                                "pruned-scope"
                                                              ? 38
                                                              : 39;
                break;
              case 3:
                _context8.next = 5;
                return terminal.test;
              case 5:
                return _context8.abrupt("break", 40);
              case 6:
                _context8.next = 8;
                return terminal.test;
              case 8:
                return _context8.abrupt("break", 40);
              case 9:
                _context8.next = 11;
                return terminal.test;
              case 11:
                _iterator71 = _createForOfIteratorHelper(terminal.cases);
                _context8.prev = 12;
                _iterator71.s();
              case 14:
                if ((_step71 = _iterator71.n()).done) {
                  _context8.next = 22;
                  break;
                }
                case_ = _step71.value;
                if (!(case_.test === null)) {
                  _context8.next = 18;
                  break;
                }
                return _context8.abrupt("continue", 20);
              case 18:
                _context8.next = 20;
                return case_.test;
              case 20:
                _context8.next = 14;
                break;
              case 22:
                _context8.next = 27;
                break;
              case 24:
                _context8.prev = 24;
                _context8.t1 = _context8["catch"](12);
                _iterator71.e(_context8.t1);
              case 27:
                _context8.prev = 27;
                _iterator71.f();
                return _context8.finish(27);
              case 30:
                return _context8.abrupt("break", 40);
              case 31:
                _context8.next = 33;
                return terminal.value;
              case 33:
                return _context8.abrupt("break", 40);
              case 34:
                if (!(terminal.handlerBinding !== null)) {
                  _context8.next = 37;
                  break;
                }
                _context8.next = 37;
                return terminal.handlerBinding;
              case 37:
                return _context8.abrupt("break", 40);
              case 38:
                return _context8.abrupt("break", 40);
              case 39:
                assertExhaustive$1(
                  terminal,
                  "Unexpected terminal kind `".concat(terminal.kind, "`")
                );
              case 40:
              case "end":
                return _context8.stop();
            }
        },
        _marked8,
        null,
        [[12, 24, 27, 30]]
      );
    }
    var ScopeBlockTraversal = /*#__PURE__*/ (function () {
      function ScopeBlockTraversal() {
        _classCallCheck(this, ScopeBlockTraversal);
        _ScopeBlockTraversal_activeScopes.set(this, []);
        this.blockInfos = new Map();
      }
      return _createClass(ScopeBlockTraversal, [
        {
          key: "recordScopes",
          value: function recordScopes(block) {
            var _a, _b;
            var blockInfo = this.blockInfos.get(block.id);
            if (
              (blockInfo === null || blockInfo === void 0
                ? void 0
                : blockInfo.kind) === "begin"
            ) {
              __classPrivateFieldGet(
                this,
                _ScopeBlockTraversal_activeScopes,
                "f"
              ).push(blockInfo.scope.id);
            } else if (
              (blockInfo === null || blockInfo === void 0
                ? void 0
                : blockInfo.kind) === "end"
            ) {
              var top = __classPrivateFieldGet(
                this,
                _ScopeBlockTraversal_activeScopes,
                "f"
              ).at(-1);
              CompilerError.invariant(blockInfo.scope.id === top, {
                reason:
                  "Expected traversed block fallthrough to match top-most active scope",
                loc:
                  (_b =
                    (_a = block.instructions[0]) === null || _a === void 0
                      ? void 0
                      : _a.loc) !== null && _b !== void 0
                    ? _b
                    : block.terminal.id
              });
              __classPrivateFieldGet(
                this,
                _ScopeBlockTraversal_activeScopes,
                "f"
              ).pop();
            }
            if (
              block.terminal.kind === "scope" ||
              block.terminal.kind === "pruned-scope"
            ) {
              CompilerError.invariant(
                !this.blockInfos.has(block.terminal.block) &&
                  !this.blockInfos.has(block.terminal.fallthrough),
                {
                  reason: "Expected unique scope blocks and fallthroughs",
                  loc: block.terminal.loc
                }
              );
              this.blockInfos.set(block.terminal.block, {
                kind: "begin",
                scope: block.terminal.scope,
                pruned: block.terminal.kind === "pruned-scope",
                fallthrough: block.terminal.fallthrough
              });
              this.blockInfos.set(block.terminal.fallthrough, {
                kind: "end",
                scope: block.terminal.scope,
                pruned: block.terminal.kind === "pruned-scope"
              });
            }
          }
        },
        {
          key: "isScopeActive",
          value: function isScopeActive(scopeId) {
            return (
              __classPrivateFieldGet(
                this,
                _ScopeBlockTraversal_activeScopes,
                "f"
              ).indexOf(scopeId) !== -1
            );
          }
        },
        {
          key: "currentScope",
          get: function get() {
            var _a;
            return (_a = __classPrivateFieldGet(
              this,
              _ScopeBlockTraversal_activeScopes,
              "f"
            ).at(-1)) !== null && _a !== void 0
              ? _a
              : null;
          }
        }
      ]);
    })();
    _ScopeBlockTraversal_activeScopes = new WeakMap();
    function assertConsistentIdentifiers(fn) {
      var identifiers = new Map();
      var assignments = new Set();
      var _iterator72 = _createForOfIteratorHelper(fn.body.blocks),
        _step72;
      try {
        for (_iterator72.s(); !(_step72 = _iterator72.n()).done; ) {
          var _step72$value = _slicedToArray(_step72.value, 2),
            block = _step72$value[1];
          var _iterator73 = _createForOfIteratorHelper(block.phis),
            _step73;
          try {
            for (_iterator73.s(); !(_step73 = _iterator73.n()).done; ) {
              var phi = _step73.value;
              validate(identifiers, phi.place.identifier);
              var _iterator76 = _createForOfIteratorHelper(phi.operands),
                _step76;
              try {
                for (_iterator76.s(); !(_step76 = _iterator76.n()).done; ) {
                  var _step76$value = _slicedToArray(_step76.value, 2),
                    operand = _step76$value[1];
                  validate(identifiers, operand.identifier);
                }
              } catch (err) {
                _iterator76.e(err);
              } finally {
                _iterator76.f();
              }
            }
          } catch (err) {
            _iterator73.e(err);
          } finally {
            _iterator73.f();
          }
          var _iterator74 = _createForOfIteratorHelper(block.instructions),
            _step74;
          try {
            for (_iterator74.s(); !(_step74 = _iterator74.n()).done; ) {
              var instr = _step74.value;
              CompilerError.invariant(instr.lvalue.identifier.name === null, {
                reason: "Expected all lvalues to be temporaries",
                description: "Found named lvalue `".concat(
                  instr.lvalue.identifier.name,
                  "`"
                ),
                loc: instr.lvalue.loc,
                suggestions: null
              });
              CompilerError.invariant(
                !assignments.has(instr.lvalue.identifier.id),
                {
                  reason: "Expected lvalues to be assigned exactly once",
                  description: "Found duplicate assignment of '".concat(
                    printPlace(instr.lvalue),
                    "'"
                  ),
                  loc: instr.lvalue.loc,
                  suggestions: null
                }
              );
              assignments.add(instr.lvalue.identifier.id);
              var _iterator77 = _createForOfIteratorHelper(
                  eachInstructionLValue(instr)
                ),
                _step77;
              try {
                for (_iterator77.s(); !(_step77 = _iterator77.n()).done; ) {
                  var _operand = _step77.value;
                  validate(identifiers, _operand.identifier, _operand.loc);
                }
              } catch (err) {
                _iterator77.e(err);
              } finally {
                _iterator77.f();
              }
              var _iterator78 = _createForOfIteratorHelper(
                  eachInstructionValueOperand(instr.value)
                ),
                _step78;
              try {
                for (_iterator78.s(); !(_step78 = _iterator78.n()).done; ) {
                  var _operand2 = _step78.value;
                  validate(identifiers, _operand2.identifier, _operand2.loc);
                }
              } catch (err) {
                _iterator78.e(err);
              } finally {
                _iterator78.f();
              }
            }
          } catch (err) {
            _iterator74.e(err);
          } finally {
            _iterator74.f();
          }
          var _iterator75 = _createForOfIteratorHelper(
              eachTerminalOperand(block.terminal)
            ),
            _step75;
          try {
            for (_iterator75.s(); !(_step75 = _iterator75.n()).done; ) {
              var _operand3 = _step75.value;
              validate(identifiers, _operand3.identifier, _operand3.loc);
            }
          } catch (err) {
            _iterator75.e(err);
          } finally {
            _iterator75.f();
          }
        }
      } catch (err) {
        _iterator72.e(err);
      } finally {
        _iterator72.f();
      }
    }
    function validate(identifiers, identifier) {
      var loc =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var previous = identifiers.get(identifier.id);
      if (previous === undefined) {
        identifiers.set(identifier.id, identifier);
      } else {
        CompilerError.invariant(identifier === previous, {
          reason: "Duplicate identifier object",
          description: "Found duplicate identifier object for id ".concat(
            identifier.id
          ),
          loc: loc !== null && loc !== void 0 ? loc : GeneratedSource,
          suggestions: null
        });
      }
    }
    function assertTerminalSuccessorsExist(fn) {
      var _iterator79 = _createForOfIteratorHelper(fn.body.blocks),
        _step79;
      try {
        var _loop6 = function _loop6() {
          var _step79$value = _slicedToArray(_step79.value, 2),
            block = _step79$value[1];
          mapTerminalSuccessors(block.terminal, function (successor) {
            var _a;
            CompilerError.invariant(fn.body.blocks.has(successor), {
              reason: "Terminal successor references unknown block",
              description: "Block bb"
                .concat(successor, " does not exist for terminal '")
                .concat(printTerminal(block.terminal), "'"),
              loc:
                (_a = block.terminal.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource,
              suggestions: null
            });
            return successor;
          });
        };
        for (_iterator79.s(); !(_step79 = _iterator79.n()).done; ) {
          _loop6();
        }
      } catch (err) {
        _iterator79.e(err);
      } finally {
        _iterator79.f();
      }
    }
    function assertTerminalPredsExist(fn) {
      var _iterator80 = _createForOfIteratorHelper(fn.body.blocks),
        _step80;
      try {
        for (_iterator80.s(); !(_step80 = _iterator80.n()).done; ) {
          var _step80$value = _slicedToArray(_step80.value, 2),
            block = _step80$value[1];
          var _iterator81 = _createForOfIteratorHelper(block.preds),
            _step81;
          try {
            for (_iterator81.s(); !(_step81 = _iterator81.n()).done; ) {
              var pred = _step81.value;
              var predBlock = fn.body.blocks.get(pred);
              CompilerError.invariant(predBlock != null, {
                reason: "Expected predecessor block to exist",
                description: "Block "
                  .concat(block.id, " references non-existent ")
                  .concat(pred),
                loc: GeneratedSource
              });
              CompilerError.invariant(
                _toConsumableArray(
                  eachTerminalSuccessor(predBlock.terminal)
                ).includes(block.id),
                {
                  reason:
                    "Terminal successor does not reference correct predecessor",
                  description: "Block bb"
                    .concat(block.id, " has bb")
                    .concat(predBlock.id, " as a predecessor, but bb")
                    .concat(predBlock.id, "'s successors do not include bb")
                    .concat(block.id),
                  loc: GeneratedSource
                }
              );
            }
          } catch (err) {
            _iterator81.e(err);
          } finally {
            _iterator81.f();
          }
        }
      } catch (err) {
        _iterator80.e(err);
      } finally {
        _iterator80.f();
      }
    }
    function getScopes(fn) {
      var scopes = new Set();
      function visitPlace(place) {
        var scope = place.identifier.scope;
        if (scope != null) {
          if (scope.range.start !== scope.range.end) {
            scopes.add(scope);
          }
        }
      }
      var _iterator82 = _createForOfIteratorHelper(fn.body.blocks),
        _step82;
      try {
        for (_iterator82.s(); !(_step82 = _iterator82.n()).done; ) {
          var _step82$value = _slicedToArray(_step82.value, 2),
            block = _step82$value[1];
          var _iterator83 = _createForOfIteratorHelper(block.instructions),
            _step83;
          try {
            for (_iterator83.s(); !(_step83 = _iterator83.n()).done; ) {
              var instr = _step83.value;
              var _iterator85 = _createForOfIteratorHelper(
                  eachInstructionLValue(instr)
                ),
                _step85;
              try {
                for (_iterator85.s(); !(_step85 = _iterator85.n()).done; ) {
                  var operand = _step85.value;
                  visitPlace(operand);
                }
              } catch (err) {
                _iterator85.e(err);
              } finally {
                _iterator85.f();
              }
              var _iterator86 = _createForOfIteratorHelper(
                  eachInstructionOperand(instr)
                ),
                _step86;
              try {
                for (_iterator86.s(); !(_step86 = _iterator86.n()).done; ) {
                  var _operand4 = _step86.value;
                  visitPlace(_operand4);
                }
              } catch (err) {
                _iterator86.e(err);
              } finally {
                _iterator86.f();
              }
            }
          } catch (err) {
            _iterator83.e(err);
          } finally {
            _iterator83.f();
          }
          var _iterator84 = _createForOfIteratorHelper(
              eachTerminalOperand(block.terminal)
            ),
            _step84;
          try {
            for (_iterator84.s(); !(_step84 = _iterator84.n()).done; ) {
              var _operand5 = _step84.value;
              visitPlace(_operand5);
            }
          } catch (err) {
            _iterator84.e(err);
          } finally {
            _iterator84.f();
          }
        }
      } catch (err) {
        _iterator82.e(err);
      } finally {
        _iterator82.f();
      }
      return scopes;
    }
    function rangePreOrderComparator(a, b) {
      var startDiff = a.start - b.start;
      if (startDiff !== 0) return startDiff;
      return b.end - a.end;
    }
    function recursivelyTraverseItems(items, getRange, context, enter, exit) {
      items.sort(function (a, b) {
        return rangePreOrderComparator(getRange(a), getRange(b));
      });
      var activeItems = [];
      var ranges = items.map(getRange);
      for (var i = 0; i < items.length; i++) {
        var _curr = items[i];
        var currRange = ranges[i];
        for (var _i19 = activeItems.length - 1; _i19 >= 0; _i19--) {
          var maybeParent = activeItems[_i19];
          var maybeParentRange = getRange(maybeParent);
          var disjoint = currRange.start >= maybeParentRange.end;
          var nested = currRange.end <= maybeParentRange.end;
          CompilerError.invariant(disjoint || nested, {
            reason: "Invalid nesting in program blocks or scopes",
            description: "Items overlap but are not nested: "
              .concat(maybeParentRange.start, ":")
              .concat(maybeParentRange.end, "(")
              .concat(currRange.start, ":")
              .concat(currRange.end, ")"),
            loc: GeneratedSource
          });
          if (disjoint) {
            exit(maybeParent, context);
            activeItems.length = _i19;
          } else {
            break;
          }
        }
        enter(_curr, context);
        activeItems.push(_curr);
      }
      var curr = activeItems.pop();
      while (curr != null) {
        exit(curr, context);
        curr = activeItems.pop();
      }
    }
    var no_op = function no_op() {};
    function assertValidBlockNesting(fn) {
      var _a, _b;
      var scopes = getScopes(fn);
      var blocks = _toConsumableArray(scopes).map(function (scope) {
        return Object.assign({ kind: "Scope", id: scope.id }, scope.range);
      });
      var _iterator87 = _createForOfIteratorHelper(fn.body.blocks),
        _step87;
      try {
        for (_iterator87.s(); !(_step87 = _iterator87.n()).done; ) {
          var _step87$value = _slicedToArray(_step87.value, 2),
            block = _step87$value[1];
          var fallthroughId = terminalFallthrough(block.terminal);
          if (fallthroughId != null) {
            var fallthrough = fn.body.blocks.get(fallthroughId);
            var end =
              (_b =
                (_a = fallthrough.instructions[0]) === null || _a === void 0
                  ? void 0
                  : _a.id) !== null && _b !== void 0
                ? _b
                : fallthrough.terminal.id;
            blocks.push({
              kind: "ProgramBlockSubtree",
              id: block.id,
              start: block.terminal.id,
              end: end
            });
          }
        }
      } catch (err) {
        _iterator87.e(err);
      } finally {
        _iterator87.f();
      }
      recursivelyTraverseItems(
        blocks,
        function (block) {
          return block;
        },
        null,
        no_op,
        no_op
      );
    }
    function assertValidMutableRanges(fn) {
      var _iterator88 = _createForOfIteratorHelper(fn.body.blocks),
        _step88;
      try {
        for (_iterator88.s(); !(_step88 = _iterator88.n()).done; ) {
          var _step88$value = _slicedToArray(_step88.value, 2),
            block = _step88$value[1];
          var _iterator89 = _createForOfIteratorHelper(block.phis),
            _step89;
          try {
            for (_iterator89.s(); !(_step89 = _iterator89.n()).done; ) {
              var phi = _step89.value;
              visitIdentifier(phi.place.identifier);
              var _iterator92 = _createForOfIteratorHelper(phi.operands),
                _step92;
              try {
                for (_iterator92.s(); !(_step92 = _iterator92.n()).done; ) {
                  var _step92$value = _slicedToArray(_step92.value, 2),
                    operand = _step92$value[1];
                  visitIdentifier(operand.identifier);
                }
              } catch (err) {
                _iterator92.e(err);
              } finally {
                _iterator92.f();
              }
            }
          } catch (err) {
            _iterator89.e(err);
          } finally {
            _iterator89.f();
          }
          var _iterator90 = _createForOfIteratorHelper(block.instructions),
            _step90;
          try {
            for (_iterator90.s(); !(_step90 = _iterator90.n()).done; ) {
              var instr = _step90.value;
              var _iterator93 = _createForOfIteratorHelper(
                  eachInstructionLValue(instr)
                ),
                _step93;
              try {
                for (_iterator93.s(); !(_step93 = _iterator93.n()).done; ) {
                  var _operand6 = _step93.value;
                  visitIdentifier(_operand6.identifier);
                }
              } catch (err) {
                _iterator93.e(err);
              } finally {
                _iterator93.f();
              }
              var _iterator94 = _createForOfIteratorHelper(
                  eachInstructionOperand(instr)
                ),
                _step94;
              try {
                for (_iterator94.s(); !(_step94 = _iterator94.n()).done; ) {
                  var _operand7 = _step94.value;
                  visitIdentifier(_operand7.identifier);
                }
              } catch (err) {
                _iterator94.e(err);
              } finally {
                _iterator94.f();
              }
            }
          } catch (err) {
            _iterator90.e(err);
          } finally {
            _iterator90.f();
          }
          var _iterator91 = _createForOfIteratorHelper(
              eachTerminalOperand(block.terminal)
            ),
            _step91;
          try {
            for (_iterator91.s(); !(_step91 = _iterator91.n()).done; ) {
              var _operand8 = _step91.value;
              visitIdentifier(_operand8.identifier);
            }
          } catch (err) {
            _iterator91.e(err);
          } finally {
            _iterator91.f();
          }
        }
      } catch (err) {
        _iterator88.e(err);
      } finally {
        _iterator88.f();
      }
    }
    function visitIdentifier(identifier) {
      validateMutableRange(identifier.mutableRange);
      if (identifier.scope !== null) {
        validateMutableRange(identifier.scope.range);
      }
    }
    function validateMutableRange(mutableRange) {
      invariant_1(
        (mutableRange.start === 0 && mutableRange.end === 0) ||
          mutableRange.end > mutableRange.start,
        "Identifier scope mutableRange was invalid: [%s:%s]",
        mutableRange.start,
        mutableRange.end
      );
    }
    function Ok(val) {
      return new OkImpl(val);
    }
    var OkImpl = /*#__PURE__*/ (function () {
      function OkImpl(val) {
        _classCallCheck(this, OkImpl);
        this.val = val;
      }
      return _createClass(OkImpl, [
        {
          key: "map",
          value: function map(fn) {
            return new OkImpl(fn(this.val));
          }
        },
        {
          key: "mapErr",
          value: function mapErr(_fn) {
            return this;
          }
        },
        {
          key: "mapOr",
          value: function mapOr(_fallback, fn) {
            return fn(this.val);
          }
        },
        {
          key: "mapOrElse",
          value: function mapOrElse(_fallback, fn) {
            return fn(this.val);
          }
        },
        {
          key: "andThen",
          value: function andThen(fn) {
            return fn(this.val);
          }
        },
        {
          key: "and",
          value: function and(res) {
            return res;
          }
        },
        {
          key: "or",
          value: function or(_res) {
            return this;
          }
        },
        {
          key: "orElse",
          value: function orElse(_fn) {
            return this;
          }
        },
        {
          key: "isOk",
          value: function isOk() {
            return true;
          }
        },
        {
          key: "isErr",
          value: function isErr() {
            return false;
          }
        },
        {
          key: "expect",
          value: function expect(_msg) {
            return this.val;
          }
        },
        {
          key: "expectErr",
          value: function expectErr(msg) {
            throw new Error("".concat(msg, ": ").concat(this.val));
          }
        },
        {
          key: "unwrap",
          value: function unwrap() {
            return this.val;
          }
        },
        {
          key: "unwrapOr",
          value: function unwrapOr(_fallback) {
            return this.val;
          }
        },
        {
          key: "unwrapOrElse",
          value: function unwrapOrElse(_fallback) {
            return this.val;
          }
        },
        {
          key: "unwrapErr",
          value: function unwrapErr() {
            if (this.val instanceof Error) {
              throw this.val;
            }
            throw new Error("Can't unwrap `Ok` to `Err`: ".concat(this.val));
          }
        }
      ]);
    })();
    function Err(val) {
      return new ErrImpl(val);
    }
    var ErrImpl = /*#__PURE__*/ (function () {
      function ErrImpl(val) {
        _classCallCheck(this, ErrImpl);
        this.val = val;
      }
      return _createClass(ErrImpl, [
        {
          key: "map",
          value: function map(_fn) {
            return this;
          }
        },
        {
          key: "mapErr",
          value: function mapErr(fn) {
            return new ErrImpl(fn(this.val));
          }
        },
        {
          key: "mapOr",
          value: function mapOr(fallback, _fn) {
            return fallback;
          }
        },
        {
          key: "mapOrElse",
          value: function mapOrElse(fallback, _fn) {
            return fallback();
          }
        },
        {
          key: "andThen",
          value: function andThen(_fn) {
            return this;
          }
        },
        {
          key: "and",
          value: function and(_res) {
            return this;
          }
        },
        {
          key: "or",
          value: function or(res) {
            return res;
          }
        },
        {
          key: "orElse",
          value: function orElse(fn) {
            return fn(this.val);
          }
        },
        {
          key: "isOk",
          value: function isOk() {
            return false;
          }
        },
        {
          key: "isErr",
          value: function isErr() {
            return true;
          }
        },
        {
          key: "expect",
          value: function expect(msg) {
            throw new Error("".concat(msg, ": ").concat(this.val));
          }
        },
        {
          key: "expectErr",
          value: function expectErr(_msg) {
            return this.val;
          }
        },
        {
          key: "unwrap",
          value: function unwrap() {
            if (this.val instanceof Error) {
              throw this.val;
            }
            throw new Error("Can't unwrap `Err` to `Ok`: ".concat(this.val));
          }
        },
        {
          key: "unwrapOr",
          value: function unwrapOr(fallback) {
            return fallback;
          }
        },
        {
          key: "unwrapOrElse",
          value: function unwrapOrElse(fallback) {
            return fallback(this.val);
          }
        },
        {
          key: "unwrapErr",
          value: function unwrapErr() {
            return this.val;
          }
        }
      ]);
    })();
    var _HIRBuilder_instances,
      _HIRBuilder_completed,
      _HIRBuilder_current,
      _HIRBuilder_entry,
      _HIRBuilder_scopes,
      _HIRBuilder_context,
      _HIRBuilder_bindings,
      _HIRBuilder_env,
      _HIRBuilder_exceptionHandlerStack,
      _HIRBuilder_resolveBabelBinding;
    function newBlock(id, kind) {
      return { id: id, kind: kind, instructions: [] };
    }
    var HIRBuilder = /*#__PURE__*/ (function () {
      function HIRBuilder(env, parentFunction) {
        var bindings =
          arguments.length > 2 && arguments[2] !== undefined
            ? arguments[2]
            : null;
        var context =
          arguments.length > 3 && arguments[3] !== undefined
            ? arguments[3]
            : null;
        _classCallCheck(this, HIRBuilder);
        _HIRBuilder_instances.add(this);
        _HIRBuilder_completed.set(this, new Map());
        _HIRBuilder_current.set(this, void 0);
        _HIRBuilder_entry.set(this, void 0);
        _HIRBuilder_scopes.set(this, []);
        _HIRBuilder_context.set(this, void 0);
        _HIRBuilder_bindings.set(this, void 0);
        _HIRBuilder_env.set(this, void 0);
        _HIRBuilder_exceptionHandlerStack.set(this, []);
        this.errors = new CompilerError();
        this.fbtDepth = 0;
        __classPrivateFieldSet(this, _HIRBuilder_env, env, "f");
        __classPrivateFieldSet(
          this,
          _HIRBuilder_bindings,
          bindings !== null && bindings !== void 0 ? bindings : new Map(),
          "f"
        );
        this.parentFunction = parentFunction;
        __classPrivateFieldSet(
          this,
          _HIRBuilder_context,
          context !== null && context !== void 0 ? context : [],
          "f"
        );
        __classPrivateFieldSet(
          this,
          _HIRBuilder_entry,
          makeBlockId(env.nextBlockId),
          "f"
        );
        __classPrivateFieldSet(
          this,
          _HIRBuilder_current,
          newBlock(
            __classPrivateFieldGet(this, _HIRBuilder_entry, "f"),
            "block"
          ),
          "f"
        );
      }
      return _createClass(HIRBuilder, [
        {
          key: "nextIdentifierId",
          get: function get() {
            return __classPrivateFieldGet(this, _HIRBuilder_env, "f")
              .nextIdentifierId;
          }
        },
        {
          key: "context",
          get: function get() {
            return __classPrivateFieldGet(this, _HIRBuilder_context, "f");
          }
        },
        {
          key: "bindings",
          get: function get() {
            return __classPrivateFieldGet(this, _HIRBuilder_bindings, "f");
          }
        },
        {
          key: "environment",
          get: function get() {
            return __classPrivateFieldGet(this, _HIRBuilder_env, "f");
          }
        },
        {
          key: "currentBlockKind",
          value: function currentBlockKind() {
            return __classPrivateFieldGet(this, _HIRBuilder_current, "f").kind;
          }
        },
        {
          key: "push",
          value: function push(instruction) {
            __classPrivateFieldGet(
              this,
              _HIRBuilder_current,
              "f"
            ).instructions.push(instruction);
            var exceptionHandler = __classPrivateFieldGet(
              this,
              _HIRBuilder_exceptionHandlerStack,
              "f"
            ).at(-1);
            if (exceptionHandler !== undefined) {
              var continuationBlock = this.reserve(this.currentBlockKind());
              this.terminateWithContinuation(
                {
                  kind: "maybe-throw",
                  continuation: continuationBlock.id,
                  handler: exceptionHandler,
                  id: makeInstructionId(0),
                  loc: instruction.loc
                },
                continuationBlock
              );
            }
          }
        },
        {
          key: "enterTryCatch",
          value: function enterTryCatch(handler, fn) {
            __classPrivateFieldGet(
              this,
              _HIRBuilder_exceptionHandlerStack,
              "f"
            ).push(handler);
            fn();
            __classPrivateFieldGet(
              this,
              _HIRBuilder_exceptionHandlerStack,
              "f"
            ).pop();
          }
        },
        {
          key: "resolveThrowHandler",
          value: function resolveThrowHandler() {
            var handler = __classPrivateFieldGet(
              this,
              _HIRBuilder_exceptionHandlerStack,
              "f"
            ).at(-1);
            return handler !== null && handler !== void 0 ? handler : null;
          }
        },
        {
          key: "makeTemporary",
          value: function makeTemporary(loc) {
            var id = this.nextIdentifierId;
            return makeTemporaryIdentifier(id, loc);
          }
        },
        {
          key: "resolveIdentifier",
          value: function resolveIdentifier(path) {
            var originalName = path.node.name;
            var babelBinding = __classPrivateFieldGet(
              this,
              _HIRBuilder_instances,
              "m",
              _HIRBuilder_resolveBabelBinding
            ).call(this, path);
            if (babelBinding == null) {
              return { kind: "Global", name: originalName };
            }
            var outerBinding =
              this.parentFunction.scope.parent.getBinding(originalName);
            if (babelBinding === outerBinding) {
              var _path = babelBinding.path;
              if (_path.isImportDefaultSpecifier()) {
                var _importDeclaration = _path.parentPath;
                return {
                  kind: "ImportDefault",
                  name: originalName,
                  module: _importDeclaration.node.source.value
                };
              } else if (_path.isImportSpecifier()) {
                var _importDeclaration2 = _path.parentPath;
                return {
                  kind: "ImportSpecifier",
                  name: originalName,
                  module: _importDeclaration2.node.source.value,
                  imported:
                    _path.node.imported.type === "Identifier"
                      ? _path.node.imported.name
                      : _path.node.imported.value
                };
              } else if (_path.isImportNamespaceSpecifier()) {
                var _importDeclaration3 = _path.parentPath;
                return {
                  kind: "ImportNamespace",
                  name: originalName,
                  module: _importDeclaration3.node.source.value
                };
              } else {
                return { kind: "ModuleLocal", name: originalName };
              }
            }
            var resolvedBinding = this.resolveBinding(babelBinding.identifier);
            if (
              resolvedBinding.name &&
              resolvedBinding.name.value !== originalName
            ) {
              babelBinding.scope.rename(
                originalName,
                resolvedBinding.name.value
              );
            }
            return {
              kind: "Identifier",
              identifier: resolvedBinding,
              bindingKind: babelBinding.kind
            };
          }
        },
        {
          key: "isContextIdentifier",
          value: function isContextIdentifier(path) {
            var binding = __classPrivateFieldGet(
              this,
              _HIRBuilder_instances,
              "m",
              _HIRBuilder_resolveBabelBinding
            ).call(this, path);
            if (binding) {
              var outerBinding = this.parentFunction.scope.parent.getBinding(
                path.node.name
              );
              if (binding === outerBinding) {
                return false;
              }
              return __classPrivateFieldGet(
                this,
                _HIRBuilder_env,
                "f"
              ).isContextIdentifier(binding.identifier);
            } else {
              return false;
            }
          }
        },
        {
          key: "resolveBinding",
          value: function resolveBinding(node) {
            var _a, _b;
            if (node.name === "fbt") {
              CompilerError.throwTodo({
                reason: 'Support local variables named "fbt"',
                loc: (_a = node.loc) !== null && _a !== void 0 ? _a : null
              });
            }
            var originalName = node.name;
            var name = originalName;
            var index = 0;
            while (true) {
              var mapping = __classPrivateFieldGet(
                this,
                _HIRBuilder_bindings,
                "f"
              ).get(name);
              if (mapping === undefined) {
                var id = this.nextIdentifierId;
                var _identifier3 = {
                  id: id,
                  declarationId: makeDeclarationId(id),
                  name: makeIdentifierName(name),
                  mutableRange: {
                    start: makeInstructionId(0),
                    end: makeInstructionId(0)
                  },
                  scope: null,
                  type: makeType(),
                  loc:
                    (_b = node.loc) !== null && _b !== void 0
                      ? _b
                      : GeneratedSource
                };
                __classPrivateFieldGet(this, _HIRBuilder_bindings, "f").set(
                  name,
                  { node: node, identifier: _identifier3 }
                );
                return _identifier3;
              } else if (mapping.node === node) {
                return mapping.identifier;
              } else {
                name = "".concat(originalName, "_").concat(index++);
              }
            }
          }
        },
        {
          key: "build",
          value: function build() {
            var _a, _b;
            var ir = {
              blocks: __classPrivateFieldGet(this, _HIRBuilder_completed, "f"),
              entry: __classPrivateFieldGet(this, _HIRBuilder_entry, "f")
            };
            var rpoBlocks = getReversePostorderedBlocks(ir);
            var _iterator95 = _createForOfIteratorHelper(ir.blocks),
              _step95;
            try {
              for (_iterator95.s(); !(_step95 = _iterator95.n()).done; ) {
                var _step95$value = _slicedToArray(_step95.value, 2),
                  id = _step95$value[0],
                  block = _step95$value[1];
                if (
                  !rpoBlocks.has(id) &&
                  block.instructions.some(function (instr) {
                    return instr.value.kind === "FunctionExpression";
                  })
                ) {
                  CompilerError.throwTodo({
                    reason:
                      "Support functions with unreachable code that may contain hoisted declarations",
                    loc:
                      (_b =
                        (_a = block.instructions[0]) === null || _a === void 0
                          ? void 0
                          : _a.loc) !== null && _b !== void 0
                        ? _b
                        : block.terminal.loc,
                    description: null,
                    suggestions: null
                  });
                }
              }
            } catch (err) {
              _iterator95.e(err);
            } finally {
              _iterator95.f();
            }
            ir.blocks = rpoBlocks;
            removeUnreachableForUpdates(ir);
            removeDeadDoWhileStatements(ir);
            removeUnnecessaryTryCatch(ir);
            markInstructionIds(ir);
            markPredecessors(ir);
            return ir;
          }
        },
        {
          key: "terminate",
          value: function terminate(terminal, nextBlockKind) {
            var _classPrivateFieldGe = __classPrivateFieldGet(
                this,
                _HIRBuilder_current,
                "f"
              ),
              blockId = _classPrivateFieldGe.id,
              kind = _classPrivateFieldGe.kind,
              instructions = _classPrivateFieldGe.instructions;
            __classPrivateFieldGet(this, _HIRBuilder_completed, "f").set(
              blockId,
              {
                kind: kind,
                id: blockId,
                instructions: instructions,
                terminal: terminal,
                preds: new Set(),
                phis: new Set()
              }
            );
            if (nextBlockKind) {
              var nextId = __classPrivateFieldGet(
                this,
                _HIRBuilder_env,
                "f"
              ).nextBlockId;
              __classPrivateFieldSet(
                this,
                _HIRBuilder_current,
                newBlock(nextId, nextBlockKind),
                "f"
              );
            }
          }
        },
        {
          key: "terminateWithContinuation",
          value: function terminateWithContinuation(terminal, continuation) {
            var _classPrivateFieldGe2 = __classPrivateFieldGet(
                this,
                _HIRBuilder_current,
                "f"
              ),
              blockId = _classPrivateFieldGe2.id,
              kind = _classPrivateFieldGe2.kind,
              instructions = _classPrivateFieldGe2.instructions;
            __classPrivateFieldGet(this, _HIRBuilder_completed, "f").set(
              blockId,
              {
                kind: kind,
                id: blockId,
                instructions: instructions,
                terminal: terminal,
                preds: new Set(),
                phis: new Set()
              }
            );
            __classPrivateFieldSet(
              this,
              _HIRBuilder_current,
              continuation,
              "f"
            );
          }
        },
        {
          key: "reserve",
          value: function reserve(kind) {
            return newBlock(
              makeBlockId(
                __classPrivateFieldGet(this, _HIRBuilder_env, "f").nextBlockId
              ),
              kind
            );
          }
        },
        {
          key: "complete",
          value: function complete(block, terminal) {
            var blockId = block.id,
              kind = block.kind,
              instructions = block.instructions;
            __classPrivateFieldGet(this, _HIRBuilder_completed, "f").set(
              blockId,
              {
                kind: kind,
                id: blockId,
                instructions: instructions,
                terminal: terminal,
                preds: new Set(),
                phis: new Set()
              }
            );
          }
        },
        {
          key: "enterReserved",
          value: function enterReserved(wip, fn) {
            var current = __classPrivateFieldGet(
              this,
              _HIRBuilder_current,
              "f"
            );
            __classPrivateFieldSet(this, _HIRBuilder_current, wip, "f");
            var terminal = fn();
            var _classPrivateFieldGe3 = __classPrivateFieldGet(
                this,
                _HIRBuilder_current,
                "f"
              ),
              blockId = _classPrivateFieldGe3.id,
              kind = _classPrivateFieldGe3.kind,
              instructions = _classPrivateFieldGe3.instructions;
            __classPrivateFieldGet(this, _HIRBuilder_completed, "f").set(
              blockId,
              {
                kind: kind,
                id: blockId,
                instructions: instructions,
                terminal: terminal,
                preds: new Set(),
                phis: new Set()
              }
            );
            __classPrivateFieldSet(this, _HIRBuilder_current, current, "f");
          }
        },
        {
          key: "enter",
          value: function enter(nextBlockKind, fn) {
            var wip = this.reserve(nextBlockKind);
            this.enterReserved(wip, function () {
              return fn(wip.id);
            });
            return wip.id;
          }
        },
        {
          key: "label",
          value: function label(_label, breakBlock, fn) {
            __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").push({
              kind: "label",
              breakBlock: breakBlock,
              label: _label
            });
            var value = fn();
            var last = __classPrivateFieldGet(
              this,
              _HIRBuilder_scopes,
              "f"
            ).pop();
            CompilerError.invariant(
              last != null &&
                last.kind === "label" &&
                last.label === _label &&
                last.breakBlock === breakBlock,
              {
                reason: "Mismatched label",
                description: null,
                loc: null,
                suggestions: null
              }
            );
            return value;
          }
        },
        {
          key: "switch",
          value: function _switch(label, breakBlock, fn) {
            __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").push({
              kind: "switch",
              breakBlock: breakBlock,
              label: label
            });
            var value = fn();
            var last = __classPrivateFieldGet(
              this,
              _HIRBuilder_scopes,
              "f"
            ).pop();
            CompilerError.invariant(
              last != null &&
                last.kind === "switch" &&
                last.label === label &&
                last.breakBlock === breakBlock,
              {
                reason: "Mismatched label",
                description: null,
                loc: null,
                suggestions: null
              }
            );
            return value;
          }
        },
        {
          key: "loop",
          value: function loop(label, continueBlock, breakBlock, fn) {
            __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").push({
              kind: "loop",
              label: label,
              continueBlock: continueBlock,
              breakBlock: breakBlock
            });
            var value = fn();
            var last = __classPrivateFieldGet(
              this,
              _HIRBuilder_scopes,
              "f"
            ).pop();
            CompilerError.invariant(
              last != null &&
                last.kind === "loop" &&
                last.label === label &&
                last.continueBlock === continueBlock &&
                last.breakBlock === breakBlock,
              {
                reason: "Mismatched loops",
                description: null,
                loc: null,
                suggestions: null
              }
            );
            return value;
          }
        },
        {
          key: "lookupBreak",
          value: function lookupBreak(label) {
            for (
              var ii =
                __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").length -
                1;
              ii >= 0;
              ii--
            ) {
              var scope = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f")[
                ii
              ];
              if (
                (label === null &&
                  (scope.kind === "loop" || scope.kind === "switch")) ||
                label === scope.label
              ) {
                return scope.breakBlock;
              }
            }
            CompilerError.invariant(false, {
              reason: "Expected a loop or switch to be in scope",
              description: null,
              loc: null,
              suggestions: null
            });
          }
        },
        {
          key: "lookupContinue",
          value: function lookupContinue(label) {
            for (
              var ii =
                __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").length -
                1;
              ii >= 0;
              ii--
            ) {
              var scope = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f")[
                ii
              ];
              if (scope.kind === "loop") {
                if (label === null || label === scope.label) {
                  return scope.continueBlock;
                }
              } else if (label !== null && scope.label === label) {
                CompilerError.invariant(false, {
                  reason: "Continue may only refer to a labeled loop",
                  description: null,
                  loc: null,
                  suggestions: null
                });
              }
            }
            CompilerError.invariant(false, {
              reason: "Expected a loop to be in scope",
              description: null,
              loc: null,
              suggestions: null
            });
          }
        }
      ]);
    })();
    (_HIRBuilder_completed = new WeakMap()),
      (_HIRBuilder_current = new WeakMap()),
      (_HIRBuilder_entry = new WeakMap()),
      (_HIRBuilder_scopes = new WeakMap()),
      (_HIRBuilder_context = new WeakMap()),
      (_HIRBuilder_bindings = new WeakMap()),
      (_HIRBuilder_env = new WeakMap()),
      (_HIRBuilder_exceptionHandlerStack = new WeakMap()),
      (_HIRBuilder_instances = new WeakSet()),
      (_HIRBuilder_resolveBabelBinding =
        function _HIRBuilder_resolveBabelBinding(path) {
          var originalName = path.node.name;
          var binding = path.scope.getBinding(originalName);
          if (binding == null) {
            return null;
          }
          return binding;
        });
    function removeUnreachableForUpdates(fn) {
      var _iterator96 = _createForOfIteratorHelper(fn.blocks),
        _step96;
      try {
        for (_iterator96.s(); !(_step96 = _iterator96.n()).done; ) {
          var _step96$value = _slicedToArray(_step96.value, 2),
            block = _step96$value[1];
          if (
            block.terminal.kind === "for" &&
            block.terminal.update !== null &&
            !fn.blocks.has(block.terminal.update)
          ) {
            block.terminal.update = null;
          }
        }
      } catch (err) {
        _iterator96.e(err);
      } finally {
        _iterator96.f();
      }
    }
    function removeDeadDoWhileStatements(func) {
      var visited = new Set();
      var _iterator97 = _createForOfIteratorHelper(func.blocks),
        _step97;
      try {
        for (_iterator97.s(); !(_step97 = _iterator97.n()).done; ) {
          var _step97$value = _slicedToArray(_step97.value, 2),
            _ = _step97$value[0],
            block = _step97$value[1];
          visited.add(block.id);
        }
      } catch (err) {
        _iterator97.e(err);
      } finally {
        _iterator97.f();
      }
      var _iterator98 = _createForOfIteratorHelper(func.blocks),
        _step98;
      try {
        for (_iterator98.s(); !(_step98 = _iterator98.n()).done; ) {
          var _step98$value = _slicedToArray(_step98.value, 2),
            _30 = _step98$value[0],
            _block4 = _step98$value[1];
          if (_block4.terminal.kind === "do-while") {
            if (!visited.has(_block4.terminal.test)) {
              _block4.terminal = {
                kind: "goto",
                block: _block4.terminal.loop,
                variant: GotoVariant.Break,
                id: _block4.terminal.id,
                loc: _block4.terminal.loc
              };
            }
          }
        }
      } catch (err) {
        _iterator98.e(err);
      } finally {
        _iterator98.f();
      }
    }
    function reversePostorderBlocks(func) {
      var rpoBlocks = getReversePostorderedBlocks(func);
      func.blocks = rpoBlocks;
    }
    function getReversePostorderedBlocks(func) {
      var visited = new Set();
      var used = new Set();
      var usedFallthroughs = new Set();
      var postorder = [];
      function visit(blockId, isUsed) {
        var wasUsed = used.has(blockId);
        var wasVisited = visited.has(blockId);
        visited.add(blockId);
        if (isUsed) {
          used.add(blockId);
        }
        if (wasVisited && (wasUsed || !isUsed)) {
          return;
        }
        var block = func.blocks.get(blockId);
        var successors = _toConsumableArray(
          eachTerminalSuccessor(block.terminal)
        ).reverse();
        var fallthrough = terminalFallthrough(block.terminal);
        if (fallthrough != null) {
          if (isUsed) {
            usedFallthroughs.add(fallthrough);
          }
          visit(fallthrough, false);
        }
        var _iterator99 = _createForOfIteratorHelper(successors),
          _step99;
        try {
          for (_iterator99.s(); !(_step99 = _iterator99.n()).done; ) {
            var successor = _step99.value;
            visit(successor, isUsed);
          }
        } catch (err) {
          _iterator99.e(err);
        } finally {
          _iterator99.f();
        }
        if (!wasVisited) {
          postorder.push(blockId);
        }
      }
      visit(func.entry, true);
      var blocks = new Map();
      var _iterator100 = _createForOfIteratorHelper(postorder.reverse()),
        _step100;
      try {
        for (_iterator100.s(); !(_step100 = _iterator100.n()).done; ) {
          var blockId = _step100.value;
          var block = func.blocks.get(blockId);
          if (used.has(blockId)) {
            blocks.set(blockId, func.blocks.get(blockId));
          } else if (usedFallthroughs.has(blockId)) {
            blocks.set(
              blockId,
              Object.assign(Object.assign({}, block), {
                instructions: [],
                terminal: {
                  kind: "unreachable",
                  id: block.terminal.id,
                  loc: block.terminal.loc
                }
              })
            );
          }
        }
      } catch (err) {
        _iterator100.e(err);
      } finally {
        _iterator100.f();
      }
      return blocks;
    }
    function markInstructionIds(func) {
      var id = 0;
      var visited = new Set();
      var _iterator101 = _createForOfIteratorHelper(func.blocks),
        _step101;
      try {
        for (_iterator101.s(); !(_step101 = _iterator101.n()).done; ) {
          var _step101$value = _slicedToArray(_step101.value, 2),
            _ = _step101$value[0],
            block = _step101$value[1];
          var _iterator102 = _createForOfIteratorHelper(block.instructions),
            _step102;
          try {
            for (_iterator102.s(); !(_step102 = _iterator102.n()).done; ) {
              var instr = _step102.value;
              CompilerError.invariant(!visited.has(instr), {
                reason: "".concat(printInstruction(instr), " already visited!"),
                description: null,
                loc: instr.loc,
                suggestions: null
              });
              visited.add(instr);
              instr.id = makeInstructionId(++id);
            }
          } catch (err) {
            _iterator102.e(err);
          } finally {
            _iterator102.f();
          }
          block.terminal.id = makeInstructionId(++id);
        }
      } catch (err) {
        _iterator101.e(err);
      } finally {
        _iterator101.f();
      }
    }
    function markPredecessors(func) {
      var _iterator103 = _createForOfIteratorHelper(func.blocks),
        _step103;
      try {
        for (_iterator103.s(); !(_step103 = _iterator103.n()).done; ) {
          var _step103$value = _slicedToArray(_step103.value, 2),
            block = _step103$value[1];
          block.preds.clear();
        }
      } catch (err) {
        _iterator103.e(err);
      } finally {
        _iterator103.f();
      }
      var visited = new Set();
      function visit(blockId, prevBlock) {
        var block = func.blocks.get(blockId);
        if (block == null) {
          return;
        }
        CompilerError.invariant(block != null, {
          reason: "unexpected missing block",
          description: "block ".concat(blockId),
          loc: GeneratedSource
        });
        if (prevBlock) {
          block.preds.add(prevBlock.id);
        }
        if (visited.has(blockId)) {
          return;
        }
        visited.add(blockId);
        var terminal = block.terminal;
        var _iterator104 = _createForOfIteratorHelper(
            eachTerminalSuccessor(terminal)
          ),
          _step104;
        try {
          for (_iterator104.s(); !(_step104 = _iterator104.n()).done; ) {
            var successor = _step104.value;
            visit(successor, block);
          }
        } catch (err) {
          _iterator104.e(err);
        } finally {
          _iterator104.f();
        }
      }
      visit(func.entry, null);
    }
    function removeUnnecessaryTryCatch(fn) {
      var _iterator105 = _createForOfIteratorHelper(fn.blocks),
        _step105;
      try {
        for (_iterator105.s(); !(_step105 = _iterator105.n()).done; ) {
          var _step105$value = _slicedToArray(_step105.value, 2),
            block = _step105$value[1];
          if (
            block.terminal.kind === "try" &&
            !fn.blocks.has(block.terminal.handler)
          ) {
            var handlerId = block.terminal.handler;
            var fallthroughId = block.terminal.fallthrough;
            var fallthrough = fn.blocks.get(fallthroughId);
            block.terminal = {
              kind: "goto",
              block: block.terminal.block,
              id: makeInstructionId(0),
              loc: block.terminal.loc,
              variant: GotoVariant.Break
            };
            if (fallthrough != null) {
              if (
                fallthrough.preds.size === 1 &&
                fallthrough.preds.has(handlerId)
              ) {
                fn.blocks["delete"](fallthroughId);
              } else {
                fallthrough.preds["delete"](handlerId);
              }
            }
          }
        }
      } catch (err) {
        _iterator105.e(err);
      } finally {
        _iterator105.f();
      }
    }
    function createTemporaryPlace(env, loc) {
      return {
        kind: "Identifier",
        identifier: makeTemporaryIdentifier(env.nextIdentifierId, loc),
        reactive: false,
        effect: Effect.Unknown,
        loc: GeneratedSource
      };
    }
    function clonePlaceToTemporary(env, place) {
      var temp = createTemporaryPlace(env, place.loc);
      temp.effect = place.effect;
      temp.identifier.type = place.identifier.type;
      temp.reactive = place.reactive;
      return temp;
    }
    function fixScopeAndIdentifierRanges(func) {
      var _a, _b;
      var _iterator106 = _createForOfIteratorHelper(func.blocks),
        _step106;
      try {
        for (_iterator106.s(); !(_step106 = _iterator106.n()).done; ) {
          var _step106$value = _slicedToArray(_step106.value, 2),
            block = _step106$value[1];
          var terminal = block.terminal;
          if (terminal.kind === "scope" || terminal.kind === "pruned-scope") {
            var fallthroughBlock = func.blocks.get(terminal.fallthrough);
            var firstId =
              (_b =
                (_a = fallthroughBlock.instructions[0]) === null ||
                _a === void 0
                  ? void 0
                  : _a.id) !== null && _b !== void 0
                ? _b
                : fallthroughBlock.terminal.id;
            terminal.scope.range.start = terminal.id;
            terminal.scope.range.end = firstId;
          }
        }
      } catch (err) {
        _iterator106.e(err);
      } finally {
        _iterator106.f();
      }
    }
    var PRIMITIVE_TYPE = { kind: "Primitive" };
    var nextAnonId = 0;
    function createAnonId() {
      return "<generated_".concat(nextAnonId++, ">");
    }
    function addFunction(registry, properties, fn) {
      var id =
        arguments.length > 3 && arguments[3] !== undefined
          ? arguments[3]
          : null;
      var shapeId = id !== null && id !== void 0 ? id : createAnonId();
      addShape(
        registry,
        shapeId,
        properties,
        Object.assign(Object.assign({}, fn), { hookKind: null })
      );
      return { kind: "Function", return: fn.returnType, shapeId: shapeId };
    }
    function addHook(registry, fn) {
      var id =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var shapeId = id !== null && id !== void 0 ? id : createAnonId();
      addShape(registry, shapeId, [], fn);
      return { kind: "Function", return: fn.returnType, shapeId: shapeId };
    }
    function addObject(registry, id, properties) {
      var shapeId = id !== null && id !== void 0 ? id : createAnonId();
      addShape(registry, shapeId, properties, null);
      return { kind: "Object", shapeId: shapeId };
    }
    function addShape(registry, id, properties, functionType) {
      var shape = {
        properties: new Map(properties),
        functionType: functionType
      };
      CompilerError.invariant(!registry.has(id), {
        reason: "[ObjectShape] Could not add shape to registry: name ".concat(
          id,
          " already exists."
        ),
        description: null,
        loc: null,
        suggestions: null
      });
      registry.set(id, shape);
      return shape;
    }
    var BuiltInPropsId = "BuiltInProps";
    var BuiltInArrayId = "BuiltInArray";
    var BuiltInFunctionId = "BuiltInFunction";
    var BuiltInJsxId = "BuiltInJsx";
    var BuiltInObjectId = "BuiltInObject";
    var BuiltInUseStateId = "BuiltInUseState";
    var BuiltInSetStateId = "BuiltInSetState";
    var BuiltInUseActionStateId = "BuiltInUseActionState";
    var BuiltInSetActionStateId = "BuiltInSetActionState";
    var BuiltInUseRefId = "BuiltInUseRefId";
    var BuiltInRefValueId = "BuiltInRefValue";
    var BuiltInMixedReadonlyId = "BuiltInMixedReadonly";
    var BuiltInUseEffectHookId = "BuiltInUseEffectHook";
    var BuiltInUseLayoutEffectHookId = "BuiltInUseLayoutEffectHook";
    var BuiltInUseInsertionEffectHookId = "BuiltInUseInsertionEffectHook";
    var BuiltInUseOperatorId = "BuiltInUseOperator";
    var BuiltInUseReducerId = "BuiltInUseReducer";
    var BuiltInDispatchId = "BuiltInDispatch";
    var BuiltInUseContextHookId = "BuiltInUseContextHook";
    var BuiltInUseTransitionId = "BuiltInUseTransition";
    var BuiltInStartTransitionId = "BuiltInStartTransition";
    var BuiltInFireId = "BuiltInFire";
    var BUILTIN_SHAPES = new Map();
    addObject(BUILTIN_SHAPES, BuiltInPropsId, [
      ["ref", { kind: "Object", shapeId: BuiltInUseRefId }]
    ]);
    addObject(BUILTIN_SHAPES, BuiltInArrayId, [
      [
        "indexOf",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive
        })
      ],
      [
        "includes",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive
        })
      ],
      [
        "pop",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: null,
          returnType: { kind: "Poly" },
          calleeEffect: Effect.Store,
          returnValueKind: ValueKind.Mutable
        })
      ],
      [
        "at",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [Effect.Read],
          restParam: null,
          returnType: { kind: "Poly" },
          calleeEffect: Effect.Capture,
          returnValueKind: ValueKind.Mutable
        })
      ],
      [
        "concat",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Capture,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: Effect.Capture,
          returnValueKind: ValueKind.Mutable
        })
      ],
      ["length", PRIMITIVE_TYPE],
      [
        "push",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Capture,
          returnType: PRIMITIVE_TYPE,
          calleeEffect: Effect.Store,
          returnValueKind: ValueKind.Primitive
        })
      ],
      [
        "slice",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: Effect.Capture,
          returnValueKind: ValueKind.Mutable
        })
      ],
      [
        "map",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Mutable,
          noAlias: true,
          mutableOnlyIfOperandsAreMutable: true
        })
      ],
      [
        "flatMap",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Mutable,
          noAlias: true,
          mutableOnlyIfOperandsAreMutable: true
        })
      ],
      [
        "filter",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Mutable,
          noAlias: true,
          mutableOnlyIfOperandsAreMutable: true
        })
      ],
      [
        "every",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Primitive,
          noAlias: true,
          mutableOnlyIfOperandsAreMutable: true
        })
      ],
      [
        "some",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Primitive,
          noAlias: true,
          mutableOnlyIfOperandsAreMutable: true
        })
      ],
      [
        "find",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Poly" },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Mutable,
          noAlias: true,
          mutableOnlyIfOperandsAreMutable: true
        })
      ],
      [
        "findIndex",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Primitive,
          noAlias: true,
          mutableOnlyIfOperandsAreMutable: true
        })
      ],
      [
        "join",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: PRIMITIVE_TYPE,
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive
        })
      ]
    ]);
    addObject(BUILTIN_SHAPES, BuiltInObjectId, [
      [
        "toString",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: null,
          returnType: PRIMITIVE_TYPE,
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive
        })
      ]
    ]);
    addObject(BUILTIN_SHAPES, BuiltInUseStateId, [
      ["0", { kind: "Poly" }],
      [
        "1",
        addFunction(
          BUILTIN_SHAPES,
          [],
          {
            positionalParams: [],
            restParam: Effect.Freeze,
            returnType: PRIMITIVE_TYPE,
            calleeEffect: Effect.Read,
            returnValueKind: ValueKind.Primitive
          },
          BuiltInSetStateId
        )
      ]
    ]);
    addObject(BUILTIN_SHAPES, BuiltInUseTransitionId, [
      ["0", { kind: "Primitive" }],
      [
        "1",
        addFunction(
          BUILTIN_SHAPES,
          [],
          {
            positionalParams: [],
            restParam: null,
            returnType: PRIMITIVE_TYPE,
            calleeEffect: Effect.Read,
            returnValueKind: ValueKind.Primitive
          },
          BuiltInStartTransitionId
        )
      ]
    ]);
    addObject(BUILTIN_SHAPES, BuiltInUseActionStateId, [
      ["0", { kind: "Poly" }],
      [
        "1",
        addFunction(
          BUILTIN_SHAPES,
          [],
          {
            positionalParams: [],
            restParam: Effect.Freeze,
            returnType: PRIMITIVE_TYPE,
            calleeEffect: Effect.Read,
            returnValueKind: ValueKind.Primitive
          },
          BuiltInSetActionStateId
        )
      ]
    ]);
    addObject(BUILTIN_SHAPES, BuiltInUseReducerId, [
      ["0", { kind: "Poly" }],
      [
        "1",
        addFunction(
          BUILTIN_SHAPES,
          [],
          {
            positionalParams: [],
            restParam: Effect.Freeze,
            returnType: PRIMITIVE_TYPE,
            calleeEffect: Effect.Read,
            returnValueKind: ValueKind.Primitive
          },
          BuiltInDispatchId
        )
      ]
    ]);
    addObject(BUILTIN_SHAPES, BuiltInUseRefId, [
      ["current", { kind: "Object", shapeId: BuiltInRefValueId }]
    ]);
    addObject(BUILTIN_SHAPES, BuiltInRefValueId, [
      ["*", { kind: "Object", shapeId: BuiltInRefValueId }]
    ]);
    addObject(BUILTIN_SHAPES, BuiltInMixedReadonlyId, [
      [
        "toString",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: PRIMITIVE_TYPE,
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive
        })
      ],
      [
        "indexOf",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive
        })
      ],
      [
        "includes",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive
        })
      ],
      [
        "at",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [Effect.Read],
          restParam: null,
          returnType: { kind: "Object", shapeId: BuiltInMixedReadonlyId },
          calleeEffect: Effect.Capture,
          returnValueKind: ValueKind.Frozen
        })
      ],
      [
        "map",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Mutable,
          noAlias: true
        })
      ],
      [
        "flatMap",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Mutable,
          noAlias: true
        })
      ],
      [
        "filter",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Mutable,
          noAlias: true
        })
      ],
      [
        "concat",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Capture,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: Effect.Capture,
          returnValueKind: ValueKind.Mutable
        })
      ],
      [
        "slice",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: Effect.Capture,
          returnValueKind: ValueKind.Mutable
        })
      ],
      [
        "every",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Primitive,
          noAlias: true,
          mutableOnlyIfOperandsAreMutable: true
        })
      ],
      [
        "some",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Primitive,
          noAlias: true,
          mutableOnlyIfOperandsAreMutable: true
        })
      ],
      [
        "find",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Object", shapeId: BuiltInMixedReadonlyId },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Frozen,
          noAlias: true,
          mutableOnlyIfOperandsAreMutable: true
        })
      ],
      [
        "findIndex",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.ConditionallyMutate,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.ConditionallyMutate,
          returnValueKind: ValueKind.Primitive,
          noAlias: true,
          mutableOnlyIfOperandsAreMutable: true
        })
      ],
      [
        "join",
        addFunction(BUILTIN_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: PRIMITIVE_TYPE,
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive
        })
      ],
      ["*", { kind: "Object", shapeId: BuiltInMixedReadonlyId }]
    ]);
    addObject(BUILTIN_SHAPES, BuiltInJsxId, []);
    addObject(BUILTIN_SHAPES, BuiltInFunctionId, []);
    var DefaultMutatingHook = addHook(
      BUILTIN_SHAPES,
      {
        positionalParams: [],
        restParam: Effect.ConditionallyMutate,
        returnType: { kind: "Poly" },
        calleeEffect: Effect.Read,
        hookKind: "Custom",
        returnValueKind: ValueKind.Mutable
      },
      "DefaultMutatingHook"
    );
    var DefaultNonmutatingHook = addHook(
      BUILTIN_SHAPES,
      {
        positionalParams: [],
        restParam: Effect.Freeze,
        returnType: { kind: "Poly" },
        calleeEffect: Effect.Read,
        hookKind: "Custom",
        returnValueKind: ValueKind.Frozen
      },
      "DefaultNonmutatingHook"
    );
    function lower$1(func, env) {
      var bindings =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var capturedRefs =
        arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      var parent =
        arguments.length > 4 && arguments[4] !== undefined
          ? arguments[4]
          : null;
      var _a, _b, _c;
      var builder = new HIRBuilder(
        env,
        parent !== null && parent !== void 0 ? parent : func,
        bindings,
        capturedRefs
      );
      var context = [];
      var _iterator107 = _createForOfIteratorHelper(
          capturedRefs !== null && capturedRefs !== void 0 ? capturedRefs : []
        ),
        _step107;
      try {
        for (_iterator107.s(); !(_step107 = _iterator107.n()).done; ) {
          var ref = _step107.value;
          context.push({
            kind: "Identifier",
            identifier: builder.resolveBinding(ref),
            effect: Effect.Unknown,
            reactive: false,
            loc: (_a = ref.loc) !== null && _a !== void 0 ? _a : GeneratedSource
          });
        }
      } catch (err) {
        _iterator107.e(err);
      } finally {
        _iterator107.f();
      }
      var id = null;
      if (func.isFunctionDeclaration() || func.isFunctionExpression()) {
        var idNode = func.get("id");
        if (hasNode(idNode)) {
          id = idNode.node.name;
        }
      }
      var params = [];
      func.get("params").forEach(function (param) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (param.isIdentifier()) {
          var binding = builder.resolveIdentifier(param);
          if (binding.kind !== "Identifier") {
            builder.errors.push({
              reason:
                "(BuildHIR::lower) Could not find binding for param `".concat(
                  param.node.name,
                  "`"
                ),
              severity: ErrorSeverity.Invariant,
              loc: (_a = param.node.loc) !== null && _a !== void 0 ? _a : null,
              suggestions: null
            });
            return;
          }
          var place = {
            kind: "Identifier",
            identifier: binding.identifier,
            effect: Effect.Unknown,
            reactive: false,
            loc:
              (_b = param.node.loc) !== null && _b !== void 0
                ? _b
                : GeneratedSource
          };
          params.push(place);
        } else if (
          param.isObjectPattern() ||
          param.isArrayPattern() ||
          param.isAssignmentPattern()
        ) {
          var _place2 = {
            kind: "Identifier",
            identifier: builder.makeTemporary(
              (_c = param.node.loc) !== null && _c !== void 0
                ? _c
                : GeneratedSource
            ),
            effect: Effect.Unknown,
            reactive: false,
            loc:
              (_d = param.node.loc) !== null && _d !== void 0
                ? _d
                : GeneratedSource
          };
          promoteTemporary(_place2.identifier);
          params.push(_place2);
          lowerAssignment(
            builder,
            (_e = param.node.loc) !== null && _e !== void 0
              ? _e
              : GeneratedSource,
            InstructionKind.Let,
            param,
            _place2,
            "Assignment"
          );
        } else if (param.isRestElement()) {
          var _place3 = {
            kind: "Identifier",
            identifier: builder.makeTemporary(
              (_f = param.node.loc) !== null && _f !== void 0
                ? _f
                : GeneratedSource
            ),
            effect: Effect.Unknown,
            reactive: false,
            loc:
              (_g = param.node.loc) !== null && _g !== void 0
                ? _g
                : GeneratedSource
          };
          params.push({ kind: "Spread", place: _place3 });
          lowerAssignment(
            builder,
            (_h = param.node.loc) !== null && _h !== void 0
              ? _h
              : GeneratedSource,
            InstructionKind.Let,
            param.get("argument"),
            _place3,
            "Assignment"
          );
        } else {
          builder.errors.push({
            reason: "(BuildHIR::lower) Handle ".concat(
              param.node.type,
              " params"
            ),
            severity: ErrorSeverity.Todo,
            loc: (_j = param.node.loc) !== null && _j !== void 0 ? _j : null,
            suggestions: null
          });
        }
      });
      var directives = [];
      var body = func.get("body");
      if (body.isExpression()) {
        var fallthrough = builder.reserve("block");
        var terminal = {
          kind: "return",
          loc: GeneratedSource,
          value: lowerExpressionToTemporary(builder, body),
          id: makeInstructionId(0)
        };
        builder.terminateWithContinuation(terminal, fallthrough);
      } else if (body.isBlockStatement()) {
        lowerStatement(builder, body);
        directives = body.get("directives").map(function (d) {
          return d.node.value.value;
        });
      } else {
        builder.errors.push({
          severity: ErrorSeverity.InvalidJS,
          reason: "Unexpected function body kind",
          description:
            "Expected function body to be an expression or a block statement, got `".concat(
              body.type,
              "`"
            ),
          loc: (_b = body.node.loc) !== null && _b !== void 0 ? _b : null,
          suggestions: null
        });
      }
      if (builder.errors.hasErrors()) {
        return Err(builder.errors);
      }
      builder.terminate(
        {
          kind: "return",
          loc: GeneratedSource,
          value: lowerValueToTemporary(builder, {
            kind: "Primitive",
            value: undefined,
            loc: GeneratedSource
          }),
          id: makeInstructionId(0)
        },
        null
      );
      return Ok({
        id: id,
        params: params,
        fnType: parent == null ? env.fnType : "Other",
        returnTypeAnnotation: null,
        returnType: makeType(),
        body: builder.build(),
        context: context,
        generator: func.node.generator === true,
        async: func.node.async === true,
        loc:
          (_c = func.node.loc) !== null && _c !== void 0 ? _c : GeneratedSource,
        env: env,
        effects: null,
        directives: directives
      });
    }
    function lowerStatement(builder, stmtPath) {
      var label =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var _a,
        _b,
        _c,
        _d,
        _e,
        _f,
        _g,
        _h,
        _j,
        _k,
        _l,
        _m,
        _o,
        _p,
        _q,
        _r,
        _s,
        _t,
        _u,
        _v,
        _w,
        _x,
        _y,
        _z,
        _0,
        _1,
        _2,
        _3,
        _4,
        _5,
        _6,
        _7,
        _8,
        _9,
        _10,
        _11,
        _12,
        _13,
        _14,
        _15,
        _16,
        _17,
        _18,
        _19,
        _20,
        _21,
        _22,
        _23,
        _24,
        _25,
        _26,
        _27,
        _28,
        _29;
      var stmtNode = stmtPath.node;
      switch (stmtNode.type) {
        case "ThrowStatement": {
          var stmt = stmtPath;
          var value = lowerExpressionToTemporary(builder, stmt.get("argument"));
          var handler = builder.resolveThrowHandler();
          if (handler != null) {
            builder.errors.push({
              reason:
                "(BuildHIR::lowerStatement) Support ThrowStatement inside of try/catch",
              severity: ErrorSeverity.Todo,
              loc: (_a = stmt.node.loc) !== null && _a !== void 0 ? _a : null,
              suggestions: null
            });
          }
          var terminal = {
            kind: "throw",
            value: value,
            id: makeInstructionId(0),
            loc:
              (_b = stmt.node.loc) !== null && _b !== void 0
                ? _b
                : GeneratedSource
          };
          builder.terminate(terminal, "block");
          return;
        }
        case "ReturnStatement": {
          var _stmt = stmtPath;
          var argument = _stmt.get("argument");
          var _value2;
          if (argument.node === null) {
            _value2 = lowerValueToTemporary(builder, {
              kind: "Primitive",
              value: undefined,
              loc: GeneratedSource
            });
          } else {
            _value2 = lowerExpressionToTemporary(builder, argument);
          }
          var _terminal = {
            kind: "return",
            loc:
              (_c = _stmt.node.loc) !== null && _c !== void 0
                ? _c
                : GeneratedSource,
            value: _value2,
            id: makeInstructionId(0)
          };
          builder.terminate(_terminal, "block");
          return;
        }
        case "IfStatement": {
          var _stmt2 = stmtPath;
          var continuationBlock = builder.reserve("block");
          var consequentBlock = builder.enter("block", function (_blockId) {
            var _a;
            var consequent = _stmt2.get("consequent");
            lowerStatement(builder, consequent);
            return {
              kind: "goto",
              block: continuationBlock.id,
              variant: GotoVariant.Break,
              id: makeInstructionId(0),
              loc:
                (_a = consequent.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource
            };
          });
          var alternateBlock;
          var alternate = _stmt2.get("alternate");
          if (hasNode(alternate)) {
            alternateBlock = builder.enter("block", function (_blockId) {
              var _a, _b;
              lowerStatement(builder, alternate);
              return {
                kind: "goto",
                block: continuationBlock.id,
                variant: GotoVariant.Break,
                id: makeInstructionId(0),
                loc:
                  (_b =
                    (_a = alternate.node) === null || _a === void 0
                      ? void 0
                      : _a.loc) !== null && _b !== void 0
                    ? _b
                    : GeneratedSource
              };
            });
          } else {
            alternateBlock = continuationBlock.id;
          }
          var _test8 = lowerExpressionToTemporary(builder, _stmt2.get("test"));
          var _terminal2 = {
            kind: "if",
            test: _test8,
            consequent: consequentBlock,
            alternate: alternateBlock,
            fallthrough: continuationBlock.id,
            id: makeInstructionId(0),
            loc:
              (_d = _stmt2.node.loc) !== null && _d !== void 0
                ? _d
                : GeneratedSource
          };
          builder.terminateWithContinuation(_terminal2, continuationBlock);
          return;
        }
        case "BlockStatement": {
          var _stmt3 = stmtPath;
          var _statements2 = _stmt3.get("body");
          var hoistableIdentifiers = new Set();
          for (
            var _i20 = 0,
              _Object$entries2 = Object.entries(_stmt3.scope.bindings);
            _i20 < _Object$entries2.length;
            _i20++
          ) {
            var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i20], 2),
              binding = _Object$entries2$_i[1];
            if (binding.kind !== "param") {
              hoistableIdentifiers.add(binding.identifier);
            }
          }
          var _iterator108 = _createForOfIteratorHelper(_statements2),
            _step108;
          try {
            var _loop7 = function _loop7() {
              var s = _step108.value;
              var willHoist = new Set();
              var fnDepth = s.isFunctionDeclaration() ? 1 : 0;
              var withFunctionContext = {
                enter: function enter() {
                  fnDepth++;
                },
                exit: function exit() {
                  fnDepth--;
                }
              };
              s.traverse({
                FunctionExpression: withFunctionContext,
                FunctionDeclaration: withFunctionContext,
                ArrowFunctionExpression: withFunctionContext,
                ObjectMethod: withFunctionContext,
                Identifier: function Identifier(id) {
                  var id2 = id;
                  if (
                    !id2.isReferencedIdentifier() &&
                    id.parent.type !== "AssignmentExpression"
                  ) {
                    return;
                  }
                  var binding = id.scope.getBinding(id.node.name);
                  if (
                    binding != null &&
                    hoistableIdentifiers.has(binding.identifier) &&
                    (fnDepth > 0 || binding.kind === "hoisted")
                  ) {
                    willHoist.add(id);
                  }
                }
              });
              s.traverse({
                Identifier: function Identifier(path) {
                  if (hoistableIdentifiers.has(path.node)) {
                    hoistableIdentifiers["delete"](path.node);
                  }
                }
              });
              var _iterator109 = _createForOfIteratorHelper(willHoist),
                _step109;
              try {
                for (_iterator109.s(); !(_step109 = _iterator109.n()).done; ) {
                  var id = _step109.value;
                  var _binding = _stmt3.scope.getBinding(id.node.name);
                  CompilerError.invariant(_binding != null, {
                    reason: "Expected to find binding for hoisted identifier",
                    description: "Could not find a binding for ".concat(
                      id.node.name
                    ),
                    suggestions: null,
                    loc:
                      (_e = id.node.loc) !== null && _e !== void 0
                        ? _e
                        : GeneratedSource
                  });
                  if (
                    builder.environment.isHoistedIdentifier(_binding.identifier)
                  ) {
                    continue;
                  }
                  var kind = void 0;
                  if (_binding.kind === "const" || _binding.kind === "var") {
                    kind = InstructionKind.HoistedConst;
                  } else if (_binding.kind === "let") {
                    kind = InstructionKind.HoistedLet;
                  } else if (_binding.path.isFunctionDeclaration()) {
                    kind = InstructionKind.HoistedFunction;
                  } else if (!_binding.path.isVariableDeclarator()) {
                    builder.errors.push({
                      severity: ErrorSeverity.Todo,
                      reason: "Unsupported declaration type for hoisting",
                      description: 'variable "'
                        .concat(_binding.identifier.name, '" declared with ')
                        .concat(_binding.path.type),
                      suggestions: null,
                      loc:
                        (_f = id.parentPath.node.loc) !== null && _f !== void 0
                          ? _f
                          : GeneratedSource
                    });
                    continue;
                  } else {
                    builder.errors.push({
                      severity: ErrorSeverity.Todo,
                      reason: "Handle non-const declarations for hoisting",
                      description: 'variable "'
                        .concat(_binding.identifier.name, '" declared with ')
                        .concat(_binding.kind),
                      suggestions: null,
                      loc:
                        (_g = id.parentPath.node.loc) !== null && _g !== void 0
                          ? _g
                          : GeneratedSource
                    });
                    continue;
                  }
                  var _identifier4 = builder.resolveIdentifier(id);
                  CompilerError.invariant(_identifier4.kind === "Identifier", {
                    reason:
                      "Expected hoisted binding to be a local identifier, not a global",
                    loc:
                      (_h = id.node.loc) !== null && _h !== void 0
                        ? _h
                        : GeneratedSource
                  });
                  var place = {
                    effect: Effect.Unknown,
                    identifier: _identifier4.identifier,
                    kind: "Identifier",
                    reactive: false,
                    loc:
                      (_j = id.node.loc) !== null && _j !== void 0
                        ? _j
                        : GeneratedSource
                  };
                  lowerValueToTemporary(builder, {
                    kind: "DeclareContext",
                    lvalue: { kind: kind, place: place },
                    loc:
                      (_k = id.node.loc) !== null && _k !== void 0
                        ? _k
                        : GeneratedSource
                  });
                  builder.environment.addHoistedIdentifier(_binding.identifier);
                }
              } catch (err) {
                _iterator109.e(err);
              } finally {
                _iterator109.f();
              }
              lowerStatement(builder, s);
            };
            for (_iterator108.s(); !(_step108 = _iterator108.n()).done; ) {
              _loop7();
            }
          } catch (err) {
            _iterator108.e(err);
          } finally {
            _iterator108.f();
          }
          return;
        }
        case "BreakStatement": {
          var _stmt4 = stmtPath;
          var block = builder.lookupBreak(
            (_m =
              (_l = _stmt4.node.label) === null || _l === void 0
                ? void 0
                : _l.name) !== null && _m !== void 0
              ? _m
              : null
          );
          builder.terminate(
            {
              kind: "goto",
              block: block,
              variant: GotoVariant.Break,
              id: makeInstructionId(0),
              loc:
                (_o = _stmt4.node.loc) !== null && _o !== void 0
                  ? _o
                  : GeneratedSource
            },
            "block"
          );
          return;
        }
        case "ContinueStatement": {
          var _stmt5 = stmtPath;
          var _block5 = builder.lookupContinue(
            (_q =
              (_p = _stmt5.node.label) === null || _p === void 0
                ? void 0
                : _p.name) !== null && _q !== void 0
              ? _q
              : null
          );
          builder.terminate(
            {
              kind: "goto",
              block: _block5,
              variant: GotoVariant.Continue,
              id: makeInstructionId(0),
              loc:
                (_r = _stmt5.node.loc) !== null && _r !== void 0
                  ? _r
                  : GeneratedSource
            },
            "block"
          );
          return;
        }
        case "ForStatement": {
          var _stmt6 = stmtPath;
          var testBlock = builder.reserve("loop");
          var _continuationBlock = builder.reserve("block");
          var initBlock = builder.enter("loop", function (_blockId) {
            var _a, _b, _c, _d;
            var init = _stmt6.get("init");
            if (!init.isVariableDeclaration()) {
              builder.errors.push({
                reason:
                  "(BuildHIR::lowerStatement) Handle non-variable initialization in ForStatement",
                severity: ErrorSeverity.Todo,
                loc:
                  (_a = _stmt6.node.loc) !== null && _a !== void 0 ? _a : null,
                suggestions: null
              });
              return {
                kind: "unsupported",
                id: makeInstructionId(0),
                loc:
                  (_c =
                    (_b = init.node) === null || _b === void 0
                      ? void 0
                      : _b.loc) !== null && _c !== void 0
                    ? _c
                    : GeneratedSource
              };
            }
            lowerStatement(builder, init);
            return {
              kind: "goto",
              block: testBlock.id,
              variant: GotoVariant.Break,
              id: makeInstructionId(0),
              loc:
                (_d = init.node.loc) !== null && _d !== void 0
                  ? _d
                  : GeneratedSource
            };
          });
          var updateBlock = null;
          var _update2 = _stmt6.get("update");
          if (hasNode(_update2)) {
            updateBlock = builder.enter("loop", function (_blockId) {
              var _a, _b;
              lowerExpressionToTemporary(builder, _update2);
              return {
                kind: "goto",
                block: testBlock.id,
                variant: GotoVariant.Break,
                id: makeInstructionId(0),
                loc:
                  (_b =
                    (_a = _update2.node) === null || _a === void 0
                      ? void 0
                      : _a.loc) !== null && _b !== void 0
                    ? _b
                    : GeneratedSource
              };
            });
          }
          var bodyBlock = builder.enter("block", function (_blockId) {
            return builder.loop(
              label,
              updateBlock !== null && updateBlock !== void 0
                ? updateBlock
                : testBlock.id,
              _continuationBlock.id,
              function () {
                var _a;
                var body = _stmt6.get("body");
                lowerStatement(builder, body);
                return {
                  kind: "goto",
                  block:
                    updateBlock !== null && updateBlock !== void 0
                      ? updateBlock
                      : testBlock.id,
                  variant: GotoVariant.Continue,
                  id: makeInstructionId(0),
                  loc:
                    (_a = body.node.loc) !== null && _a !== void 0
                      ? _a
                      : GeneratedSource
                };
              }
            );
          });
          builder.terminateWithContinuation(
            {
              kind: "for",
              loc:
                (_s = stmtNode.loc) !== null && _s !== void 0
                  ? _s
                  : GeneratedSource,
              init: initBlock,
              test: testBlock.id,
              update: updateBlock,
              loop: bodyBlock,
              fallthrough: _continuationBlock.id,
              id: makeInstructionId(0)
            },
            testBlock
          );
          var _test9 = _stmt6.get("test");
          if (_test9.node == null) {
            builder.errors.push({
              reason:
                "(BuildHIR::lowerStatement) Handle empty test in ForStatement",
              severity: ErrorSeverity.Todo,
              loc: (_t = _stmt6.node.loc) !== null && _t !== void 0 ? _t : null,
              suggestions: null
            });
          } else {
            builder.terminateWithContinuation(
              {
                kind: "branch",
                test: lowerExpressionToTemporary(builder, _test9),
                consequent: bodyBlock,
                alternate: _continuationBlock.id,
                fallthrough: _continuationBlock.id,
                id: makeInstructionId(0),
                loc:
                  (_u = _stmt6.node.loc) !== null && _u !== void 0
                    ? _u
                    : GeneratedSource
              },
              _continuationBlock
            );
          }
          return;
        }
        case "WhileStatement": {
          var _stmt7 = stmtPath;
          var conditionalBlock = builder.reserve("loop");
          var _continuationBlock2 = builder.reserve("block");
          var loopBlock = builder.enter("block", function (_blockId) {
            return builder.loop(
              label,
              conditionalBlock.id,
              _continuationBlock2.id,
              function () {
                var _a;
                var body = _stmt7.get("body");
                lowerStatement(builder, body);
                return {
                  kind: "goto",
                  block: conditionalBlock.id,
                  variant: GotoVariant.Continue,
                  id: makeInstructionId(0),
                  loc:
                    (_a = body.node.loc) !== null && _a !== void 0
                      ? _a
                      : GeneratedSource
                };
              }
            );
          });
          var loc =
            (_v = _stmt7.node.loc) !== null && _v !== void 0
              ? _v
              : GeneratedSource;
          builder.terminateWithContinuation(
            {
              kind: "while",
              loc: loc,
              test: conditionalBlock.id,
              loop: loopBlock,
              fallthrough: _continuationBlock2.id,
              id: makeInstructionId(0)
            },
            conditionalBlock
          );
          var _test10 = lowerExpressionToTemporary(builder, _stmt7.get("test"));
          var _terminal3 = {
            kind: "branch",
            test: _test10,
            consequent: loopBlock,
            alternate: _continuationBlock2.id,
            fallthrough: conditionalBlock.id,
            id: makeInstructionId(0),
            loc:
              (_w = _stmt7.node.loc) !== null && _w !== void 0
                ? _w
                : GeneratedSource
          };
          builder.terminateWithContinuation(_terminal3, _continuationBlock2);
          return;
        }
        case "LabeledStatement": {
          var _stmt8 = stmtPath;
          var _label2 = _stmt8.node.label.name;
          var body = _stmt8.get("body");
          switch (body.node.type) {
            case "ForInStatement":
            case "ForOfStatement":
            case "ForStatement":
            case "WhileStatement":
            case "DoWhileStatement": {
              lowerStatement(builder, _stmt8.get("body"), _label2);
              break;
            }
            default: {
              var _continuationBlock3 = builder.reserve("block");
              var _block6 = builder.enter("block", function () {
                var _a;
                var body = _stmt8.get("body");
                builder.label(_label2, _continuationBlock3.id, function () {
                  lowerStatement(builder, body);
                });
                return {
                  kind: "goto",
                  block: _continuationBlock3.id,
                  variant: GotoVariant.Break,
                  id: makeInstructionId(0),
                  loc:
                    (_a = body.node.loc) !== null && _a !== void 0
                      ? _a
                      : GeneratedSource
                };
              });
              builder.terminateWithContinuation(
                {
                  kind: "label",
                  block: _block6,
                  fallthrough: _continuationBlock3.id,
                  id: makeInstructionId(0),
                  loc:
                    (_x = _stmt8.node.loc) !== null && _x !== void 0
                      ? _x
                      : GeneratedSource
                },
                _continuationBlock3
              );
            }
          }
          return;
        }
        case "SwitchStatement": {
          var _stmt9 = stmtPath;
          var _continuationBlock4 = builder.reserve("block");
          var fallthrough = _continuationBlock4.id;
          var cases = [];
          var hasDefault = false;
          var _loop8 = function _loop8() {
            var case_ = _stmt9.get("cases")[ii];
            var testExpr = case_.get("test");
            if (testExpr.node == null) {
              if (hasDefault) {
                builder.errors.push({
                  reason:
                    "Expected at most one `default` branch in a switch statement, this code should have failed to parse",
                  severity: ErrorSeverity.InvalidJS,
                  loc:
                    (_y = case_.node.loc) !== null && _y !== void 0 ? _y : null,
                  suggestions: null
                });
                return 1; // break
              }
              hasDefault = true;
            }
            var block = builder.enter("block", function (_blockId) {
              return builder["switch"](
                label,
                _continuationBlock4.id,
                function () {
                  var _a;
                  case_.get("consequent").forEach(function (consequent) {
                    return lowerStatement(builder, consequent);
                  });
                  return {
                    kind: "goto",
                    block: fallthrough,
                    variant: GotoVariant.Break,
                    id: makeInstructionId(0),
                    loc:
                      (_a = case_.node.loc) !== null && _a !== void 0
                        ? _a
                        : GeneratedSource
                  };
                }
              );
            });
            var test = null;
            if (hasNode(testExpr)) {
              test = lowerReorderableExpression(builder, testExpr);
            }
            cases.push({ test: test, block: block });
            fallthrough = block;
          };
          for (var ii = _stmt9.get("cases").length - 1; ii >= 0; ii--) {
            if (_loop8()) break;
          }
          cases.reverse();
          if (!hasDefault) {
            cases.push({ test: null, block: _continuationBlock4.id });
          }
          var _test11 = lowerExpressionToTemporary(
            builder,
            _stmt9.get("discriminant")
          );
          builder.terminateWithContinuation(
            {
              kind: "switch",
              test: _test11,
              cases: cases,
              fallthrough: _continuationBlock4.id,
              id: makeInstructionId(0),
              loc:
                (_z = _stmt9.node.loc) !== null && _z !== void 0
                  ? _z
                  : GeneratedSource
            },
            _continuationBlock4
          );
          return;
        }
        case "VariableDeclaration": {
          var _stmt10 = stmtPath;
          var nodeKind = _stmt10.node.kind;
          if (nodeKind === "var") {
            builder.errors.push({
              reason: "(BuildHIR::lowerStatement) Handle ".concat(
                nodeKind,
                " kinds in VariableDeclaration"
              ),
              severity: ErrorSeverity.Todo,
              loc:
                (_0 = _stmt10.node.loc) !== null && _0 !== void 0 ? _0 : null,
              suggestions: null
            });
            return;
          }
          var kind =
            nodeKind === "let" ? InstructionKind.Let : InstructionKind.Const;
          var _iterator110 = _createForOfIteratorHelper(
              _stmt10.get("declarations")
            ),
            _step110;
          try {
            for (_iterator110.s(); !(_step110 = _iterator110.n()).done; ) {
              var declaration = _step110.value;
              var id = declaration.get("id");
              var init = declaration.get("init");
              if (hasNode(init)) {
                var _value3 = lowerExpressionToTemporary(builder, init);
                lowerAssignment(
                  builder,
                  (_1 = _stmt10.node.loc) !== null && _1 !== void 0
                    ? _1
                    : GeneratedSource,
                  kind,
                  id,
                  _value3,
                  id.isObjectPattern() || id.isArrayPattern()
                    ? "Destructure"
                    : "Assignment"
                );
              } else if (id.isIdentifier()) {
                var _binding2 = builder.resolveIdentifier(id);
                if (_binding2.kind !== "Identifier") {
                  builder.errors.push({
                    reason:
                      "(BuildHIR::lowerAssignment) Could not find binding for declaration.",
                    severity: ErrorSeverity.Invariant,
                    loc:
                      (_2 = id.node.loc) !== null && _2 !== void 0 ? _2 : null,
                    suggestions: null
                  });
                } else {
                  var place = {
                    effect: Effect.Unknown,
                    identifier: _binding2.identifier,
                    kind: "Identifier",
                    reactive: false,
                    loc:
                      (_3 = id.node.loc) !== null && _3 !== void 0
                        ? _3
                        : GeneratedSource
                  };
                  if (builder.isContextIdentifier(id)) {
                    if (kind === InstructionKind.Const) {
                      var declRangeStart = declaration.parentPath.node.start;
                      builder.errors.push({
                        reason:
                          "Expect `const` declaration not to be reassigned",
                        severity: ErrorSeverity.InvalidJS,
                        loc:
                          (_4 = id.node.loc) !== null && _4 !== void 0
                            ? _4
                            : null,
                        suggestions: [
                          {
                            description: "Change to a `let` declaration",
                            op: CompilerSuggestionOperation.Replace,
                            range: [declRangeStart, declRangeStart + 5],
                            text: "let"
                          }
                        ]
                      });
                    }
                    lowerValueToTemporary(builder, {
                      kind: "DeclareContext",
                      lvalue: { kind: InstructionKind.Let, place: place },
                      loc:
                        (_5 = id.node.loc) !== null && _5 !== void 0
                          ? _5
                          : GeneratedSource
                    });
                  } else {
                    var _typeAnnotation = id.get("typeAnnotation");
                    var type = void 0;
                    if (_typeAnnotation.isTSTypeAnnotation()) {
                      var typePath = _typeAnnotation.get("typeAnnotation");
                      type = typePath.node;
                    } else if (_typeAnnotation.isTypeAnnotation()) {
                      var _typePath = _typeAnnotation.get("typeAnnotation");
                      type = _typePath.node;
                    } else {
                      type = null;
                    }
                    lowerValueToTemporary(builder, {
                      kind: "DeclareLocal",
                      lvalue: { kind: kind, place: place },
                      type: type,
                      loc:
                        (_6 = id.node.loc) !== null && _6 !== void 0
                          ? _6
                          : GeneratedSource
                    });
                  }
                }
              } else {
                builder.errors.push({
                  reason:
                    "Expected variable declaration to be an identifier if no initializer was provided",
                  description: "Got a `".concat(id.type, "`"),
                  severity: ErrorSeverity.InvalidJS,
                  loc:
                    (_7 = _stmt10.node.loc) !== null && _7 !== void 0
                      ? _7
                      : null,
                  suggestions: null
                });
              }
            }
          } catch (err) {
            _iterator110.e(err);
          } finally {
            _iterator110.f();
          }
          return;
        }
        case "ExpressionStatement": {
          var _stmt11 = stmtPath;
          var expression = _stmt11.get("expression");
          lowerExpressionToTemporary(builder, expression);
          return;
        }
        case "DoWhileStatement": {
          var _stmt12 = stmtPath;
          var _conditionalBlock = builder.reserve("loop");
          var _continuationBlock5 = builder.reserve("block");
          var _loopBlock = builder.enter("block", function (_loopBlockId) {
            return builder.loop(
              label,
              _conditionalBlock.id,
              _continuationBlock5.id,
              function () {
                var _a;
                var body = _stmt12.get("body");
                lowerStatement(builder, body);
                return {
                  kind: "goto",
                  block: _conditionalBlock.id,
                  variant: GotoVariant.Continue,
                  id: makeInstructionId(0),
                  loc:
                    (_a = body.node.loc) !== null && _a !== void 0
                      ? _a
                      : GeneratedSource
                };
              }
            );
          });
          var _loc =
            (_8 = _stmt12.node.loc) !== null && _8 !== void 0
              ? _8
              : GeneratedSource;
          builder.terminateWithContinuation(
            {
              kind: "do-while",
              loc: _loc,
              test: _conditionalBlock.id,
              loop: _loopBlock,
              fallthrough: _continuationBlock5.id,
              id: makeInstructionId(0)
            },
            _conditionalBlock
          );
          var _test12 = lowerExpressionToTemporary(
            builder,
            _stmt12.get("test")
          );
          var _terminal4 = {
            kind: "branch",
            test: _test12,
            consequent: _loopBlock,
            alternate: _continuationBlock5.id,
            fallthrough: _conditionalBlock.id,
            id: makeInstructionId(0),
            loc: _loc
          };
          builder.terminateWithContinuation(_terminal4, _continuationBlock5);
          return;
        }
        case "FunctionDeclaration": {
          var _stmt13 = stmtPath;
          _stmt13.skip();
          CompilerError.invariant(_stmt13.get("id").type === "Identifier", {
            reason: "function declarations must have a name",
            description: null,
            loc: (_9 = _stmt13.node.loc) !== null && _9 !== void 0 ? _9 : null,
            suggestions: null
          });
          var _id3 = _stmt13.get("id");
          var fn = lowerValueToTemporary(
            builder,
            lowerFunctionToValue(builder, _stmt13)
          );
          lowerAssignment(
            builder,
            (_10 = _stmt13.node.loc) !== null && _10 !== void 0
              ? _10
              : GeneratedSource,
            InstructionKind.Function,
            _id3,
            fn,
            "Assignment"
          );
          return;
        }
        case "ForOfStatement": {
          var _stmt14 = stmtPath;
          var _continuationBlock6 = builder.reserve("block");
          var _initBlock = builder.reserve("loop");
          var _testBlock = builder.reserve("loop");
          if (_stmt14.node["await"]) {
            builder.errors.push({
              reason: "(BuildHIR::lowerStatement) Handle for-await loops",
              severity: ErrorSeverity.Todo,
              loc:
                (_11 = _stmt14.node.loc) !== null && _11 !== void 0
                  ? _11
                  : null,
              suggestions: null
            });
            return;
          }
          var _loopBlock2 = builder.enter("block", function (_blockId) {
            return builder.loop(
              label,
              _initBlock.id,
              _continuationBlock6.id,
              function () {
                var _a;
                var body = _stmt14.get("body");
                lowerStatement(builder, body);
                return {
                  kind: "goto",
                  block: _initBlock.id,
                  variant: GotoVariant.Continue,
                  id: makeInstructionId(0),
                  loc:
                    (_a = body.node.loc) !== null && _a !== void 0
                      ? _a
                      : GeneratedSource
                };
              }
            );
          });
          var _loc2 =
            (_12 = _stmt14.node.loc) !== null && _12 !== void 0
              ? _12
              : GeneratedSource;
          var _value4 = lowerExpressionToTemporary(
            builder,
            _stmt14.get("right")
          );
          builder.terminateWithContinuation(
            {
              kind: "for-of",
              loc: _loc2,
              init: _initBlock.id,
              test: _testBlock.id,
              loop: _loopBlock2,
              fallthrough: _continuationBlock6.id,
              id: makeInstructionId(0)
            },
            _initBlock
          );
          var iterator = lowerValueToTemporary(builder, {
            kind: "GetIterator",
            loc: _value4.loc,
            collection: Object.assign({}, _value4)
          });
          builder.terminateWithContinuation(
            {
              id: makeInstructionId(0),
              kind: "goto",
              block: _testBlock.id,
              variant: GotoVariant.Break,
              loc:
                (_13 = _stmt14.node.loc) !== null && _13 !== void 0
                  ? _13
                  : GeneratedSource
            },
            _testBlock
          );
          var left = _stmt14.get("left");
          var leftLoc =
            (_14 = left.node.loc) !== null && _14 !== void 0
              ? _14
              : GeneratedSource;
          var _test13;
          var advanceIterator = lowerValueToTemporary(builder, {
            kind: "IteratorNext",
            loc: leftLoc,
            iterator: Object.assign({}, iterator),
            collection: Object.assign({}, _value4)
          });
          if (left.isVariableDeclaration()) {
            var declarations = left.get("declarations");
            CompilerError.invariant(declarations.length === 1, {
              reason:
                "Expected only one declaration in the init of a ForOfStatement, got ".concat(
                  declarations.length
                ),
              description: null,
              loc:
                (_15 = left.node.loc) !== null && _15 !== void 0 ? _15 : null,
              suggestions: null
            });
            var _id4 = declarations[0].get("id");
            var assign = lowerAssignment(
              builder,
              leftLoc,
              InstructionKind.Let,
              _id4,
              advanceIterator,
              "Assignment"
            );
            _test13 = lowerValueToTemporary(builder, assign);
          } else {
            CompilerError.invariant(left.isLVal(), {
              loc: leftLoc,
              reason: "Expected ForOf init to be a variable declaration or lval"
            });
            var _assign = lowerAssignment(
              builder,
              leftLoc,
              InstructionKind.Reassign,
              left,
              advanceIterator,
              "Assignment"
            );
            _test13 = lowerValueToTemporary(builder, _assign);
          }
          builder.terminateWithContinuation(
            {
              id: makeInstructionId(0),
              kind: "branch",
              test: _test13,
              consequent: _loopBlock2,
              alternate: _continuationBlock6.id,
              loc:
                (_16 = _stmt14.node.loc) !== null && _16 !== void 0
                  ? _16
                  : GeneratedSource,
              fallthrough: _continuationBlock6.id
            },
            _continuationBlock6
          );
          return;
        }
        case "ForInStatement": {
          var _stmt15 = stmtPath;
          var _continuationBlock7 = builder.reserve("block");
          var _initBlock2 = builder.reserve("loop");
          var _loopBlock3 = builder.enter("block", function (_blockId) {
            return builder.loop(
              label,
              _initBlock2.id,
              _continuationBlock7.id,
              function () {
                var _a;
                var body = _stmt15.get("body");
                lowerStatement(builder, body);
                return {
                  kind: "goto",
                  block: _initBlock2.id,
                  variant: GotoVariant.Continue,
                  id: makeInstructionId(0),
                  loc:
                    (_a = body.node.loc) !== null && _a !== void 0
                      ? _a
                      : GeneratedSource
                };
              }
            );
          });
          var _loc3 =
            (_17 = _stmt15.node.loc) !== null && _17 !== void 0
              ? _17
              : GeneratedSource;
          var _value5 = lowerExpressionToTemporary(
            builder,
            _stmt15.get("right")
          );
          builder.terminateWithContinuation(
            {
              kind: "for-in",
              loc: _loc3,
              init: _initBlock2.id,
              loop: _loopBlock3,
              fallthrough: _continuationBlock7.id,
              id: makeInstructionId(0)
            },
            _initBlock2
          );
          var _left = _stmt15.get("left");
          var _leftLoc =
            (_18 = _left.node.loc) !== null && _18 !== void 0
              ? _18
              : GeneratedSource;
          var _test14;
          var nextPropertyTemp = lowerValueToTemporary(builder, {
            kind: "NextPropertyOf",
            loc: _leftLoc,
            value: _value5
          });
          if (_left.isVariableDeclaration()) {
            var _declarations = _left.get("declarations");
            CompilerError.invariant(_declarations.length === 1, {
              reason:
                "Expected only one declaration in the init of a ForInStatement, got ".concat(
                  _declarations.length
                ),
              description: null,
              loc:
                (_19 = _left.node.loc) !== null && _19 !== void 0 ? _19 : null,
              suggestions: null
            });
            var _id5 = _declarations[0].get("id");
            var _assign2 = lowerAssignment(
              builder,
              _leftLoc,
              InstructionKind.Let,
              _id5,
              nextPropertyTemp,
              "Assignment"
            );
            _test14 = lowerValueToTemporary(builder, _assign2);
          } else {
            CompilerError.invariant(_left.isLVal(), {
              loc: _leftLoc,
              reason: "Expected ForIn init to be a variable declaration or lval"
            });
            var _assign3 = lowerAssignment(
              builder,
              _leftLoc,
              InstructionKind.Reassign,
              _left,
              nextPropertyTemp,
              "Assignment"
            );
            _test14 = lowerValueToTemporary(builder, _assign3);
          }
          builder.terminateWithContinuation(
            {
              id: makeInstructionId(0),
              kind: "branch",
              test: _test14,
              consequent: _loopBlock3,
              alternate: _continuationBlock7.id,
              fallthrough: _continuationBlock7.id,
              loc:
                (_20 = _stmt15.node.loc) !== null && _20 !== void 0
                  ? _20
                  : GeneratedSource
            },
            _continuationBlock7
          );
          return;
        }
        case "DebuggerStatement": {
          var _stmt16 = stmtPath;
          var _loc4 =
            (_21 = _stmt16.node.loc) !== null && _21 !== void 0
              ? _21
              : GeneratedSource;
          builder.push({
            id: makeInstructionId(0),
            lvalue: buildTemporaryPlace(builder, _loc4),
            value: { kind: "Debugger", loc: _loc4 },
            loc: _loc4
          });
          return;
        }
        case "EmptyStatement": {
          return;
        }
        case "TryStatement": {
          var _stmt17 = stmtPath;
          var _continuationBlock8 = builder.reserve("block");
          var handlerPath = _stmt17.get("handler");
          if (!hasNode(handlerPath)) {
            builder.errors.push({
              reason:
                "(BuildHIR::lowerStatement) Handle TryStatement without a catch clause",
              severity: ErrorSeverity.Todo,
              loc:
                (_22 = _stmt17.node.loc) !== null && _22 !== void 0
                  ? _22
                  : null,
              suggestions: null
            });
            return;
          }
          if (hasNode(_stmt17.get("finalizer"))) {
            builder.errors.push({
              reason:
                "(BuildHIR::lowerStatement) Handle TryStatement with a finalizer ('finally') clause",
              severity: ErrorSeverity.Todo,
              loc:
                (_23 = _stmt17.node.loc) !== null && _23 !== void 0
                  ? _23
                  : null,
              suggestions: null
            });
          }
          var handlerBindingPath = handlerPath.get("param");
          var handlerBinding = null;
          if (hasNode(handlerBindingPath)) {
            var _place4 = {
              kind: "Identifier",
              identifier: builder.makeTemporary(
                (_24 = handlerBindingPath.node.loc) !== null && _24 !== void 0
                  ? _24
                  : GeneratedSource
              ),
              effect: Effect.Unknown,
              reactive: false,
              loc:
                (_25 = handlerBindingPath.node.loc) !== null && _25 !== void 0
                  ? _25
                  : GeneratedSource
            };
            promoteTemporary(_place4.identifier);
            lowerValueToTemporary(builder, {
              kind: "DeclareLocal",
              lvalue: {
                kind: InstructionKind.Catch,
                place: Object.assign({}, _place4)
              },
              type: null,
              loc:
                (_26 = handlerBindingPath.node.loc) !== null && _26 !== void 0
                  ? _26
                  : GeneratedSource
            });
            handlerBinding = { path: handlerBindingPath, place: _place4 };
          }
          var _handler2 = builder.enter("catch", function (_blockId) {
            var _a, _b;
            if (handlerBinding !== null) {
              lowerAssignment(
                builder,
                (_a = handlerBinding.path.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource,
                InstructionKind.Catch,
                handlerBinding.path,
                Object.assign({}, handlerBinding.place),
                "Assignment"
              );
            }
            lowerStatement(builder, handlerPath.get("body"));
            return {
              kind: "goto",
              block: _continuationBlock8.id,
              variant: GotoVariant.Break,
              id: makeInstructionId(0),
              loc:
                (_b = handlerPath.node.loc) !== null && _b !== void 0
                  ? _b
                  : GeneratedSource
            };
          });
          var _block7 = builder.enter("block", function (_blockId) {
            var _a;
            var block = _stmt17.get("block");
            builder.enterTryCatch(_handler2, function () {
              lowerStatement(builder, block);
            });
            return {
              kind: "goto",
              block: _continuationBlock8.id,
              variant: GotoVariant.Try,
              id: makeInstructionId(0),
              loc:
                (_a = block.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource
            };
          });
          builder.terminateWithContinuation(
            {
              kind: "try",
              block: _block7,
              handlerBinding:
                handlerBinding !== null
                  ? Object.assign({}, handlerBinding.place)
                  : null,
              handler: _handler2,
              fallthrough: _continuationBlock8.id,
              id: makeInstructionId(0),
              loc:
                (_27 = _stmt17.node.loc) !== null && _27 !== void 0
                  ? _27
                  : GeneratedSource
            },
            _continuationBlock8
          );
          return;
        }
        case "TypeAlias":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration": {
          return;
        }
        case "ClassDeclaration":
        case "DeclareClass":
        case "DeclareExportAllDeclaration":
        case "DeclareExportDeclaration":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareOpaqueType":
        case "DeclareTypeAlias":
        case "DeclareVariable":
        case "EnumDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TSDeclareFunction":
        case "TSEnumDeclaration":
        case "TSExportAssignment":
        case "TSImportEqualsDeclaration":
        case "TSModuleDeclaration":
        case "TSNamespaceExportDeclaration":
        case "WithStatement": {
          builder.errors.push({
            reason: "(BuildHIR::lowerStatement) Handle ".concat(
              stmtPath.type,
              " statements"
            ),
            severity: ErrorSeverity.Todo,
            loc:
              (_28 = stmtPath.node.loc) !== null && _28 !== void 0 ? _28 : null,
            suggestions: null
          });
          lowerValueToTemporary(builder, {
            kind: "UnsupportedNode",
            loc:
              (_29 = stmtPath.node.loc) !== null && _29 !== void 0
                ? _29
                : GeneratedSource,
            node: stmtPath.node
          });
          return;
        }
        default: {
          return assertExhaustive$1(
            stmtNode,
            "Unsupported statement kind '".concat(stmtNode.type, "'")
          );
        }
      }
    }
    function lowerObjectMethod(builder, property) {
      var _a;
      var loc =
        (_a = property.node.loc) !== null && _a !== void 0
          ? _a
          : GeneratedSource;
      var loweredFunc = lowerFunction(builder, property);
      if (!loweredFunc) {
        return { kind: "UnsupportedNode", node: property.node, loc: loc };
      }
      return { kind: "ObjectMethod", loc: loc, loweredFunc: loweredFunc };
    }
    function lowerObjectPropertyKey(builder, property) {
      var _a, _b;
      var key = property.get("key");
      if (key.isStringLiteral()) {
        return { kind: "string", name: key.node.value };
      } else if (property.node.computed && key.isExpression()) {
        if (!key.isIdentifier() && !key.isMemberExpression()) {
          builder.errors.push({
            reason:
              "(BuildHIR::lowerExpression) Expected Identifier, got ".concat(
                key.type,
                " key in ObjectExpression"
              ),
            severity: ErrorSeverity.Todo,
            loc: (_a = key.node.loc) !== null && _a !== void 0 ? _a : null,
            suggestions: null
          });
          return null;
        }
        var place = lowerExpressionToTemporary(builder, key);
        return { kind: "computed", name: place };
      } else if (key.isIdentifier()) {
        return { kind: "identifier", name: key.node.name };
      }
      builder.errors.push({
        reason: "(BuildHIR::lowerExpression) Expected Identifier, got ".concat(
          key.type,
          " key in ObjectExpression"
        ),
        severity: ErrorSeverity.Todo,
        loc: (_b = key.node.loc) !== null && _b !== void 0 ? _b : null,
        suggestions: null
      });
      return null;
    }
    function lowerExpression(builder, exprPath) {
      var _a,
        _b,
        _c,
        _d,
        _e,
        _f,
        _g,
        _h,
        _j,
        _k,
        _l,
        _m,
        _o,
        _p,
        _q,
        _r,
        _s,
        _t,
        _u,
        _v,
        _w,
        _x,
        _y,
        _z,
        _0,
        _1,
        _2,
        _3,
        _4,
        _5,
        _6,
        _7,
        _8,
        _9,
        _10,
        _11,
        _12,
        _13,
        _14,
        _15,
        _16,
        _17,
        _18,
        _19,
        _20,
        _21,
        _22,
        _23,
        _24;
      var exprNode = exprPath.node;
      var exprLoc =
        (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
      switch (exprNode.type) {
        case "Identifier": {
          var expr = exprPath;
          var place = lowerIdentifier(builder, expr);
          return {
            kind: getLoadKind(builder, expr),
            place: place,
            loc: exprLoc
          };
        }
        case "NullLiteral": {
          return { kind: "Primitive", value: null, loc: exprLoc };
        }
        case "BooleanLiteral":
        case "NumericLiteral":
        case "StringLiteral": {
          var _expr = exprPath;
          var value = _expr.node.value;
          return { kind: "Primitive", value: value, loc: exprLoc };
        }
        case "ObjectExpression": {
          var _expr2 = exprPath;
          var propertyPaths = _expr2.get("properties");
          var properties = [];
          var _iterator111 = _createForOfIteratorHelper(propertyPaths),
            _step111;
          try {
            for (_iterator111.s(); !(_step111 = _iterator111.n()).done; ) {
              var propertyPath = _step111.value;
              if (propertyPath.isObjectProperty()) {
                var loweredKey = lowerObjectPropertyKey(builder, propertyPath);
                if (!loweredKey) {
                  continue;
                }
                var valuePath = propertyPath.get("value");
                if (!valuePath.isExpression()) {
                  builder.errors.push({
                    reason: "(BuildHIR::lowerExpression) Handle ".concat(
                      valuePath.type,
                      " values in ObjectExpression"
                    ),
                    severity: ErrorSeverity.Todo,
                    loc:
                      (_b = valuePath.node.loc) !== null && _b !== void 0
                        ? _b
                        : null,
                    suggestions: null
                  });
                  continue;
                }
                var _value6 = lowerExpressionToTemporary(builder, valuePath);
                properties.push({
                  kind: "ObjectProperty",
                  type: "property",
                  place: _value6,
                  key: loweredKey
                });
              } else if (propertyPath.isSpreadElement()) {
                var _place5 = lowerExpressionToTemporary(
                  builder,
                  propertyPath.get("argument")
                );
                properties.push({ kind: "Spread", place: _place5 });
              } else if (propertyPath.isObjectMethod()) {
                if (propertyPath.node.kind !== "method") {
                  builder.errors.push({
                    reason: "(BuildHIR::lowerExpression) Handle ".concat(
                      propertyPath.node.kind,
                      " functions in ObjectExpression"
                    ),
                    severity: ErrorSeverity.Todo,
                    loc:
                      (_c = propertyPath.node.loc) !== null && _c !== void 0
                        ? _c
                        : null,
                    suggestions: null
                  });
                  continue;
                }
                var method = lowerObjectMethod(builder, propertyPath);
                var _place6 = lowerValueToTemporary(builder, method);
                var _loweredKey = lowerObjectPropertyKey(builder, propertyPath);
                if (!_loweredKey) {
                  continue;
                }
                properties.push({
                  kind: "ObjectProperty",
                  type: "method",
                  place: _place6,
                  key: _loweredKey
                });
              } else {
                builder.errors.push({
                  reason: "(BuildHIR::lowerExpression) Handle ".concat(
                    propertyPath.type,
                    " properties in ObjectExpression"
                  ),
                  severity: ErrorSeverity.Todo,
                  loc:
                    (_d = propertyPath.node.loc) !== null && _d !== void 0
                      ? _d
                      : null,
                  suggestions: null
                });
                continue;
              }
            }
          } catch (err) {
            _iterator111.e(err);
          } finally {
            _iterator111.f();
          }
          return {
            kind: "ObjectExpression",
            properties: properties,
            loc: exprLoc
          };
        }
        case "ArrayExpression": {
          var _expr3 = exprPath;
          var elements = [];
          var _iterator112 = _createForOfIteratorHelper(_expr3.get("elements")),
            _step112;
          try {
            for (_iterator112.s(); !(_step112 = _iterator112.n()).done; ) {
              var element = _step112.value;
              if (element.node == null) {
                elements.push({ kind: "Hole" });
                continue;
              } else if (element.isExpression()) {
                elements.push(lowerExpressionToTemporary(builder, element));
              } else if (element.isSpreadElement()) {
                var _place7 = lowerExpressionToTemporary(
                  builder,
                  element.get("argument")
                );
                elements.push({ kind: "Spread", place: _place7 });
              } else {
                builder.errors.push({
                  reason: "(BuildHIR::lowerExpression) Handle ".concat(
                    element.type,
                    " elements in ArrayExpression"
                  ),
                  severity: ErrorSeverity.Todo,
                  loc:
                    (_e = element.node.loc) !== null && _e !== void 0
                      ? _e
                      : null,
                  suggestions: null
                });
                continue;
              }
            }
          } catch (err) {
            _iterator112.e(err);
          } finally {
            _iterator112.f();
          }
          return { kind: "ArrayExpression", elements: elements, loc: exprLoc };
        }
        case "NewExpression": {
          var _expr4 = exprPath;
          var calleePath = _expr4.get("callee");
          if (!calleePath.isExpression()) {
            builder.errors.push({
              reason:
                "Expected an expression as the `new` expression receiver (v8 intrinsics are not supported)",
              description: "Got a `".concat(calleePath.node.type, "`"),
              severity: ErrorSeverity.InvalidJS,
              loc:
                (_f = calleePath.node.loc) !== null && _f !== void 0
                  ? _f
                  : null,
              suggestions: null
            });
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          }
          var callee = lowerExpressionToTemporary(builder, calleePath);
          var args = lowerArguments(builder, _expr4.get("arguments"));
          return {
            kind: "NewExpression",
            callee: callee,
            args: args,
            loc: exprLoc
          };
        }
        case "OptionalCallExpression": {
          var _expr5 = exprPath;
          return lowerOptionalCallExpression(builder, _expr5, null);
        }
        case "CallExpression": {
          var _expr6 = exprPath;
          var _calleePath = _expr6.get("callee");
          if (!_calleePath.isExpression()) {
            builder.errors.push({
              reason: "Expected Expression, got ".concat(
                _calleePath.type,
                " in CallExpression (v8 intrinsics not supported). This error is likely caused by a bug in React Compiler. Please file an issue"
              ),
              severity: ErrorSeverity.Todo,
              loc:
                (_g = _calleePath.node.loc) !== null && _g !== void 0
                  ? _g
                  : null,
              suggestions: null
            });
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          }
          if (_calleePath.isMemberExpression()) {
            var memberExpr = lowerMemberExpression(builder, _calleePath);
            var propertyPlace = lowerValueToTemporary(
              builder,
              memberExpr.value
            );
            var _args9 = lowerArguments(builder, _expr6.get("arguments"));
            return {
              kind: "MethodCall",
              receiver: memberExpr.object,
              property: Object.assign({}, propertyPlace),
              args: _args9,
              loc: exprLoc
            };
          } else {
            var _callee2 = lowerExpressionToTemporary(builder, _calleePath);
            var _args10 = lowerArguments(builder, _expr6.get("arguments"));
            return {
              kind: "CallExpression",
              callee: _callee2,
              args: _args10,
              loc: exprLoc
            };
          }
        }
        case "BinaryExpression": {
          var _expr7 = exprPath;
          var leftPath = _expr7.get("left");
          if (!leftPath.isExpression()) {
            builder.errors.push({
              reason:
                "(BuildHIR::lowerExpression) Expected Expression, got ".concat(
                  leftPath.type,
                  " lval in BinaryExpression"
                ),
              severity: ErrorSeverity.Todo,
              loc:
                (_h = leftPath.node.loc) !== null && _h !== void 0 ? _h : null,
              suggestions: null
            });
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          }
          var left = lowerExpressionToTemporary(builder, leftPath);
          var right = lowerExpressionToTemporary(builder, _expr7.get("right"));
          var operator = _expr7.node.operator;
          if (operator === "|>") {
            builder.errors.push({
              reason: "(BuildHIR::lowerExpression) Pipe operator not supported",
              severity: ErrorSeverity.Todo,
              loc:
                (_j = leftPath.node.loc) !== null && _j !== void 0 ? _j : null,
              suggestions: null
            });
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          }
          return {
            kind: "BinaryExpression",
            operator: operator,
            left: left,
            right: right,
            loc: exprLoc
          };
        }
        case "SequenceExpression": {
          var _expr8 = exprPath;
          var _exprLoc =
            (_k = _expr8.node.loc) !== null && _k !== void 0
              ? _k
              : GeneratedSource;
          var continuationBlock = builder.reserve(builder.currentBlockKind());
          var _place8 = buildTemporaryPlace(builder, _exprLoc);
          var sequenceBlock = builder.enter("sequence", function (_) {
            var _a;
            var last = null;
            var _iterator113 = _createForOfIteratorHelper(
                _expr8.get("expressions")
              ),
              _step113;
            try {
              for (_iterator113.s(); !(_step113 = _iterator113.n()).done; ) {
                var item = _step113.value;
                last = lowerExpressionToTemporary(builder, item);
              }
            } catch (err) {
              _iterator113.e(err);
            } finally {
              _iterator113.f();
            }
            if (last === null) {
              builder.errors.push({
                reason:
                  "Expected sequence expression to have at least one expression",
                severity: ErrorSeverity.InvalidJS,
                loc:
                  (_a = _expr8.node.loc) !== null && _a !== void 0 ? _a : null,
                suggestions: null
              });
            } else {
              lowerValueToTemporary(builder, {
                kind: "StoreLocal",
                lvalue: {
                  kind: InstructionKind.Const,
                  place: Object.assign({}, _place8)
                },
                value: last,
                type: null,
                loc: _exprLoc
              });
            }
            return {
              kind: "goto",
              id: makeInstructionId(0),
              block: continuationBlock.id,
              loc: _exprLoc,
              variant: GotoVariant.Break
            };
          });
          builder.terminateWithContinuation(
            {
              kind: "sequence",
              block: sequenceBlock,
              fallthrough: continuationBlock.id,
              id: makeInstructionId(0),
              loc: _exprLoc
            },
            continuationBlock
          );
          return { kind: "LoadLocal", place: _place8, loc: _place8.loc };
        }
        case "ConditionalExpression": {
          var _expr9 = exprPath;
          var _exprLoc2 =
            (_l = _expr9.node.loc) !== null && _l !== void 0
              ? _l
              : GeneratedSource;
          var _continuationBlock9 = builder.reserve(builder.currentBlockKind());
          var testBlock = builder.reserve("value");
          var _place9 = buildTemporaryPlace(builder, _exprLoc2);
          var consequentBlock = builder.enter("value", function (_blockId) {
            var _a;
            var consequentPath = _expr9.get("consequent");
            var consequent = lowerExpressionToTemporary(
              builder,
              consequentPath
            );
            lowerValueToTemporary(builder, {
              kind: "StoreLocal",
              lvalue: {
                kind: InstructionKind.Const,
                place: Object.assign({}, _place9)
              },
              value: consequent,
              type: null,
              loc: _exprLoc2
            });
            return {
              kind: "goto",
              block: _continuationBlock9.id,
              variant: GotoVariant.Break,
              id: makeInstructionId(0),
              loc:
                (_a = consequentPath.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource
            };
          });
          var alternateBlock = builder.enter("value", function (_blockId) {
            var _a;
            var alternatePath = _expr9.get("alternate");
            var alternate = lowerExpressionToTemporary(builder, alternatePath);
            lowerValueToTemporary(builder, {
              kind: "StoreLocal",
              lvalue: {
                kind: InstructionKind.Const,
                place: Object.assign({}, _place9)
              },
              value: alternate,
              type: null,
              loc: _exprLoc2
            });
            return {
              kind: "goto",
              block: _continuationBlock9.id,
              variant: GotoVariant.Break,
              id: makeInstructionId(0),
              loc:
                (_a = alternatePath.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource
            };
          });
          builder.terminateWithContinuation(
            {
              kind: "ternary",
              fallthrough: _continuationBlock9.id,
              id: makeInstructionId(0),
              test: testBlock.id,
              loc: _exprLoc2
            },
            testBlock
          );
          var testPlace = lowerExpressionToTemporary(
            builder,
            _expr9.get("test")
          );
          builder.terminateWithContinuation(
            {
              kind: "branch",
              test: Object.assign({}, testPlace),
              consequent: consequentBlock,
              alternate: alternateBlock,
              fallthrough: _continuationBlock9.id,
              id: makeInstructionId(0),
              loc: _exprLoc2
            },
            _continuationBlock9
          );
          return { kind: "LoadLocal", place: _place9, loc: _place9.loc };
        }
        case "LogicalExpression": {
          var _expr10 = exprPath;
          var _exprLoc3 =
            (_m = _expr10.node.loc) !== null && _m !== void 0
              ? _m
              : GeneratedSource;
          var _continuationBlock10 = builder.reserve(
            builder.currentBlockKind()
          );
          var _testBlock2 = builder.reserve("value");
          var _place10 = buildTemporaryPlace(builder, _exprLoc3);
          var leftPlace = buildTemporaryPlace(
            builder,
            (_o = _expr10.get("left").node.loc) !== null && _o !== void 0
              ? _o
              : GeneratedSource
          );
          var consequent = builder.enter("value", function () {
            lowerValueToTemporary(builder, {
              kind: "StoreLocal",
              lvalue: {
                kind: InstructionKind.Const,
                place: Object.assign({}, _place10)
              },
              value: Object.assign({}, leftPlace),
              type: null,
              loc: leftPlace.loc
            });
            return {
              kind: "goto",
              block: _continuationBlock10.id,
              variant: GotoVariant.Break,
              id: makeInstructionId(0),
              loc: leftPlace.loc
            };
          });
          var alternate = builder.enter("value", function () {
            var right = lowerExpressionToTemporary(
              builder,
              _expr10.get("right")
            );
            lowerValueToTemporary(builder, {
              kind: "StoreLocal",
              lvalue: {
                kind: InstructionKind.Const,
                place: Object.assign({}, _place10)
              },
              value: Object.assign({}, right),
              type: null,
              loc: right.loc
            });
            return {
              kind: "goto",
              block: _continuationBlock10.id,
              variant: GotoVariant.Break,
              id: makeInstructionId(0),
              loc: right.loc
            };
          });
          builder.terminateWithContinuation(
            {
              kind: "logical",
              fallthrough: _continuationBlock10.id,
              id: makeInstructionId(0),
              test: _testBlock2.id,
              operator: _expr10.node.operator,
              loc: _exprLoc3
            },
            _testBlock2
          );
          var leftValue = lowerExpressionToTemporary(
            builder,
            _expr10.get("left")
          );
          builder.push({
            id: makeInstructionId(0),
            lvalue: Object.assign({}, leftPlace),
            value: { kind: "LoadLocal", place: leftValue, loc: _exprLoc3 },
            loc: _exprLoc3
          });
          builder.terminateWithContinuation(
            {
              kind: "branch",
              test: Object.assign({}, leftPlace),
              consequent: consequent,
              alternate: alternate,
              fallthrough: _continuationBlock10.id,
              id: makeInstructionId(0),
              loc: _exprLoc3
            },
            _continuationBlock10
          );
          return { kind: "LoadLocal", place: _place10, loc: _place10.loc };
        }
        case "AssignmentExpression": {
          var _expr11 = exprPath;
          var _operator = _expr11.node.operator;
          if (_operator === "=") {
            var _left2 = _expr11.get("left");
            if (_left2.isLVal()) {
              return lowerAssignment(
                builder,
                (_p = _left2.node.loc) !== null && _p !== void 0
                  ? _p
                  : GeneratedSource,
                InstructionKind.Reassign,
                _left2,
                lowerExpressionToTemporary(builder, _expr11.get("right")),
                _left2.isArrayPattern() || _left2.isObjectPattern()
                  ? "Destructure"
                  : "Assignment"
              );
            } else {
              builder.errors.push({
                reason:
                  "(BuildHIR::lowerExpression) Unsupported syntax on the left side of an AssignmentExpression",
                description: "Expected an LVal, got: ".concat(_left2.type),
                severity: ErrorSeverity.Todo,
                loc:
                  (_q = _left2.node.loc) !== null && _q !== void 0 ? _q : null,
                suggestions: null
              });
              return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
            }
          }
          var operators = {
            "+=": "+",
            "-=": "-",
            "/=": "/",
            "%=": "%",
            "*=": "*",
            "**=": "**",
            "&=": "&",
            "|=": "|",
            ">>=": ">>",
            ">>>=": ">>>",
            "<<=": "<<",
            "^=": "^"
          };
          var binaryOperator = operators[_operator];
          if (binaryOperator == null) {
            builder.errors.push({
              reason: "(BuildHIR::lowerExpression) Handle ".concat(
                _operator,
                " operators in AssignmentExpression"
              ),
              severity: ErrorSeverity.Todo,
              loc:
                (_r = _expr11.node.loc) !== null && _r !== void 0 ? _r : null,
              suggestions: null
            });
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          }
          var _left3 = _expr11.get("left");
          var leftNode = _left3.node;
          switch (leftNode.type) {
            case "Identifier": {
              var leftExpr = _left3;
              var _leftPlace = lowerExpressionToTemporary(builder, leftExpr);
              var _right = lowerExpressionToTemporary(
                builder,
                _expr11.get("right")
              );
              var binaryPlace = lowerValueToTemporary(builder, {
                kind: "BinaryExpression",
                operator: binaryOperator,
                left: _leftPlace,
                right: _right,
                loc: exprLoc
              });
              var binding = builder.resolveIdentifier(leftExpr);
              if (binding.kind === "Identifier") {
                var _identifier5 = lowerIdentifier(builder, leftExpr);
                var kind = getStoreKind(builder, leftExpr);
                if (kind === "StoreLocal") {
                  lowerValueToTemporary(builder, {
                    kind: "StoreLocal",
                    lvalue: {
                      place: Object.assign({}, _identifier5),
                      kind: InstructionKind.Reassign
                    },
                    value: Object.assign({}, binaryPlace),
                    type: null,
                    loc: exprLoc
                  });
                  return {
                    kind: "LoadLocal",
                    place: _identifier5,
                    loc: exprLoc
                  };
                } else {
                  lowerValueToTemporary(builder, {
                    kind: "StoreContext",
                    lvalue: {
                      place: Object.assign({}, _identifier5),
                      kind: InstructionKind.Reassign
                    },
                    value: Object.assign({}, binaryPlace),
                    loc: exprLoc
                  });
                  return {
                    kind: "LoadContext",
                    place: _identifier5,
                    loc: exprLoc
                  };
                }
              } else {
                var temporary = lowerValueToTemporary(builder, {
                  kind: "StoreGlobal",
                  name: leftExpr.node.name,
                  value: Object.assign({}, binaryPlace),
                  loc: exprLoc
                });
                return {
                  kind: "LoadLocal",
                  place: temporary,
                  loc: temporary.loc
                };
              }
            }
            case "MemberExpression": {
              var _leftExpr = _left3;
              var _lowerMemberExpressio = lowerMemberExpression(
                  builder,
                  _leftExpr
                ),
                object = _lowerMemberExpressio.object,
                property = _lowerMemberExpressio.property,
                _value7 = _lowerMemberExpressio.value;
              var previousValuePlace = lowerValueToTemporary(builder, _value7);
              var newValuePlace = lowerValueToTemporary(builder, {
                kind: "BinaryExpression",
                operator: binaryOperator,
                left: Object.assign({}, previousValuePlace),
                right: lowerExpressionToTemporary(
                  builder,
                  _expr11.get("right")
                ),
                loc:
                  (_s = _leftExpr.node.loc) !== null && _s !== void 0
                    ? _s
                    : GeneratedSource
              });
              if (
                typeof property === "string" ||
                typeof property === "number"
              ) {
                return {
                  kind: "PropertyStore",
                  object: Object.assign({}, object),
                  property: makePropertyLiteral(property),
                  value: Object.assign({}, newValuePlace),
                  loc:
                    (_t = _leftExpr.node.loc) !== null && _t !== void 0
                      ? _t
                      : GeneratedSource
                };
              } else {
                return {
                  kind: "ComputedStore",
                  object: Object.assign({}, object),
                  property: Object.assign({}, property),
                  value: Object.assign({}, newValuePlace),
                  loc:
                    (_u = _leftExpr.node.loc) !== null && _u !== void 0
                      ? _u
                      : GeneratedSource
                };
              }
            }
            default: {
              builder.errors.push({
                reason:
                  "(BuildHIR::lowerExpression) Expected Identifier or MemberExpression, got ".concat(
                    _expr11.type,
                    " lval in AssignmentExpression"
                  ),
                severity: ErrorSeverity.Todo,
                loc:
                  (_v = _expr11.node.loc) !== null && _v !== void 0 ? _v : null,
                suggestions: null
              });
              return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
            }
          }
        }
        case "OptionalMemberExpression": {
          var _expr12 = exprPath;
          var _lowerOptionalMemberE = lowerOptionalMemberExpression(
              builder,
              _expr12,
              null
            ),
            _value8 = _lowerOptionalMemberE.value;
          return { kind: "LoadLocal", place: _value8, loc: _value8.loc };
        }
        case "MemberExpression": {
          var _expr13 = exprPath;
          var _lowerMemberExpressio2 = lowerMemberExpression(builder, _expr13),
            _value9 = _lowerMemberExpressio2.value;
          var _place11 = lowerValueToTemporary(builder, _value9);
          return { kind: "LoadLocal", place: _place11, loc: _place11.loc };
        }
        case "JSXElement": {
          var _expr14 = exprPath;
          var opening = _expr14.get("openingElement");
          var openingLoc =
            (_w = opening.node.loc) !== null && _w !== void 0
              ? _w
              : GeneratedSource;
          var tag = lowerJsxElementName(builder, opening.get("name"));
          var props = [];
          var _iterator114 = _createForOfIteratorHelper(
              opening.get("attributes")
            ),
            _step114;
          try {
            for (_iterator114.s(); !(_step114 = _iterator114.n()).done; ) {
              var attribute = _step114.value;
              if (attribute.isJSXSpreadAttribute()) {
                var argument = lowerExpressionToTemporary(
                  builder,
                  attribute.get("argument")
                );
                props.push({ kind: "JsxSpreadAttribute", argument: argument });
                continue;
              }
              if (!attribute.isJSXAttribute()) {
                builder.errors.push({
                  reason: "(BuildHIR::lowerExpression) Handle ".concat(
                    attribute.type,
                    " attributes in JSXElement"
                  ),
                  severity: ErrorSeverity.Todo,
                  loc:
                    (_x = attribute.node.loc) !== null && _x !== void 0
                      ? _x
                      : null,
                  suggestions: null
                });
                continue;
              }
              var namePath = attribute.get("name");
              var propName = void 0;
              if (namePath.isJSXIdentifier()) {
                propName = namePath.node.name;
                if (propName.indexOf(":") !== -1) {
                  builder.errors.push({
                    reason:
                      "(BuildHIR::lowerExpression) Unexpected colon in attribute name `".concat(
                        propName,
                        "`"
                      ),
                    severity: ErrorSeverity.Todo,
                    loc:
                      (_y = namePath.node.loc) !== null && _y !== void 0
                        ? _y
                        : null,
                    suggestions: null
                  });
                }
              } else {
                CompilerError.invariant(namePath.isJSXNamespacedName(), {
                  reason: "Refinement",
                  description: null,
                  loc:
                    (_z = namePath.node.loc) !== null && _z !== void 0
                      ? _z
                      : null,
                  suggestions: null
                });
                var namespace = namePath.node.namespace.name;
                var _name = namePath.node.name.name;
                propName = "".concat(namespace, ":").concat(_name);
              }
              var valueExpr = attribute.get("value");
              var _value10 = void 0;
              if (valueExpr.isJSXElement() || valueExpr.isStringLiteral()) {
                _value10 = lowerExpressionToTemporary(builder, valueExpr);
              } else if (valueExpr.type == null) {
                _value10 = lowerValueToTemporary(builder, {
                  kind: "Primitive",
                  value: true,
                  loc:
                    (_0 = attribute.node.loc) !== null && _0 !== void 0
                      ? _0
                      : GeneratedSource
                });
              } else {
                if (!valueExpr.isJSXExpressionContainer()) {
                  builder.errors.push({
                    reason: "(BuildHIR::lowerExpression) Handle ".concat(
                      valueExpr.type,
                      " attribute values in JSXElement"
                    ),
                    severity: ErrorSeverity.Todo,
                    loc:
                      (_2 =
                        (_1 = valueExpr.node) === null || _1 === void 0
                          ? void 0
                          : _1.loc) !== null && _2 !== void 0
                        ? _2
                        : null,
                    suggestions: null
                  });
                  continue;
                }
                var expression = valueExpr.get("expression");
                if (!expression.isExpression()) {
                  builder.errors.push({
                    reason: "(BuildHIR::lowerExpression) Handle ".concat(
                      expression.type,
                      " expressions in JSXExpressionContainer within JSXElement"
                    ),
                    severity: ErrorSeverity.Todo,
                    loc:
                      (_3 = valueExpr.node.loc) !== null && _3 !== void 0
                        ? _3
                        : null,
                    suggestions: null
                  });
                  continue;
                }
                _value10 = lowerExpressionToTemporary(builder, expression);
              }
              props.push({
                kind: "JsxAttribute",
                name: propName,
                place: _value10
              });
            }
          } catch (err) {
            _iterator114.e(err);
          } finally {
            _iterator114.f();
          }
          var isFbt =
            tag.kind === "BuiltinTag" &&
            (tag.name === "fbt" || tag.name === "fbs");
          if (isFbt) {
            var tagName = tag.name;
            var openingIdentifier = opening.get("name");
            var tagIdentifier = openingIdentifier.isJSXIdentifier()
              ? builder.resolveIdentifier(openingIdentifier)
              : null;
            if (tagIdentifier != null) {
              CompilerError.invariant(tagIdentifier.kind !== "Identifier", {
                reason: "<".concat(
                  tagName,
                  "> tags should be module-level imports"
                ),
                loc:
                  (_4 = openingIdentifier.node.loc) !== null && _4 !== void 0
                    ? _4
                    : GeneratedSource,
                description: null,
                suggestions: null
              });
            }
            var fbtLocations = {
              enum: new Array(),
              plural: new Array(),
              pronoun: new Array()
            };
            _expr14.traverse({
              JSXClosingElement: function JSXClosingElement(path) {
                path.skip();
              },
              JSXNamespacedName: function JSXNamespacedName(path) {
                var _a, _b, _c;
                if (path.node.namespace.name === tagName) {
                  switch (path.node.name.name) {
                    case "enum":
                      fbtLocations["enum"].push(
                        (_a = path.node.loc) !== null && _a !== void 0
                          ? _a
                          : GeneratedSource
                      );
                      break;
                    case "plural":
                      fbtLocations.plural.push(
                        (_b = path.node.loc) !== null && _b !== void 0
                          ? _b
                          : GeneratedSource
                      );
                      break;
                    case "pronoun":
                      fbtLocations.pronoun.push(
                        (_c = path.node.loc) !== null && _c !== void 0
                          ? _c
                          : GeneratedSource
                      );
                      break;
                  }
                }
              }
            });
            for (
              var _i21 = 0, _Object$entries3 = Object.entries(fbtLocations);
              _i21 < _Object$entries3.length;
              _i21++
            ) {
              var _Object$entries3$_i = _slicedToArray(
                  _Object$entries3[_i21],
                  2
                ),
                name = _Object$entries3$_i[0],
                locations = _Object$entries3$_i[1];
              if (locations.length > 1) {
                CompilerError.throwTodo({
                  reason: "Support <"
                    .concat(tagName, "> tags with multiple <")
                    .concat(tagName, ":")
                    .concat(name, "> values"),
                  loc:
                    (_5 = locations.at(-1)) !== null && _5 !== void 0
                      ? _5
                      : GeneratedSource,
                  description: null,
                  suggestions: null
                });
              }
            }
          }
          isFbt && builder.fbtDepth++;
          var children = _expr14
            .get("children")
            .map(function (child) {
              return lowerJsxElement(builder, child);
            })
            .filter(notNull);
          isFbt && builder.fbtDepth--;
          return {
            kind: "JsxExpression",
            tag: tag,
            props: props,
            children: children.length === 0 ? null : children,
            loc: exprLoc,
            openingLoc: openingLoc,
            closingLoc:
              (_7 =
                (_6 = _expr14.get("closingElement").node) === null ||
                _6 === void 0
                  ? void 0
                  : _6.loc) !== null && _7 !== void 0
                ? _7
                : GeneratedSource
          };
        }
        case "JSXFragment": {
          var _expr15 = exprPath;
          var _children = _expr15
            .get("children")
            .map(function (child) {
              return lowerJsxElement(builder, child);
            })
            .filter(notNull);
          return { kind: "JsxFragment", children: _children, loc: exprLoc };
        }
        case "ArrowFunctionExpression":
        case "FunctionExpression": {
          var _expr16 = exprPath;
          return lowerFunctionToValue(builder, _expr16);
        }
        case "TaggedTemplateExpression": {
          var _expr17 = exprPath;
          if (_expr17.get("quasi").get("expressions").length !== 0) {
            builder.errors.push({
              reason:
                "(BuildHIR::lowerExpression) Handle tagged template with interpolations",
              severity: ErrorSeverity.Todo,
              loc:
                (_8 = exprPath.node.loc) !== null && _8 !== void 0 ? _8 : null,
              suggestions: null
            });
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          }
          CompilerError.invariant(
            _expr17.get("quasi").get("quasis").length == 1,
            {
              reason:
                "there should be only one quasi as we don't support interpolations yet",
              description: null,
              loc:
                (_9 = _expr17.node.loc) !== null && _9 !== void 0 ? _9 : null,
              suggestions: null
            }
          );
          var _value11 = _expr17.get("quasi").get("quasis").at(0).node.value;
          if (_value11.raw !== _value11.cooked) {
            builder.errors.push({
              reason:
                "(BuildHIR::lowerExpression) Handle tagged template where cooked value is different from raw value",
              severity: ErrorSeverity.Todo,
              loc:
                (_10 = exprPath.node.loc) !== null && _10 !== void 0
                  ? _10
                  : null,
              suggestions: null
            });
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          }
          return {
            kind: "TaggedTemplateExpression",
            tag: lowerExpressionToTemporary(builder, _expr17.get("tag")),
            value: _value11,
            loc: exprLoc
          };
        }
        case "TemplateLiteral": {
          var _expr18 = exprPath;
          var subexprs = _expr18.get("expressions");
          var quasis = _expr18.get("quasis");
          if (subexprs.length !== quasis.length - 1) {
            builder.errors.push({
              reason:
                "Unexpected quasi and subexpression lengths in template literal",
              severity: ErrorSeverity.InvalidJS,
              loc:
                (_11 = exprPath.node.loc) !== null && _11 !== void 0
                  ? _11
                  : null,
              suggestions: null
            });
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          }
          if (
            subexprs.some(function (e) {
              return !e.isExpression();
            })
          ) {
            builder.errors.push({
              reason:
                "(BuildHIR::lowerAssignment) Handle TSType in TemplateLiteral.",
              severity: ErrorSeverity.Todo,
              loc:
                (_12 = exprPath.node.loc) !== null && _12 !== void 0
                  ? _12
                  : null,
              suggestions: null
            });
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          }
          var subexprPlaces = subexprs.map(function (e) {
            return lowerExpressionToTemporary(builder, e);
          });
          return {
            kind: "TemplateLiteral",
            subexprs: subexprPlaces,
            quasis: _expr18.get("quasis").map(function (q) {
              return q.node.value;
            }),
            loc: exprLoc
          };
        }
        case "UnaryExpression": {
          var _expr19 = exprPath;
          if (_expr19.node.operator === "delete") {
            var _argument = _expr19.get("argument");
            if (_argument.isMemberExpression()) {
              var _lowerMemberExpressio3 = lowerMemberExpression(
                  builder,
                  _argument
                ),
                _object3 = _lowerMemberExpressio3.object,
                _property4 = _lowerMemberExpressio3.property;
              if (
                typeof _property4 === "string" ||
                typeof _property4 === "number"
              ) {
                return {
                  kind: "PropertyDelete",
                  object: _object3,
                  property: makePropertyLiteral(_property4),
                  loc: exprLoc
                };
              } else {
                return {
                  kind: "ComputedDelete",
                  object: _object3,
                  property: _property4,
                  loc: exprLoc
                };
              }
            } else {
              builder.errors.push({
                reason: "Only object properties can be deleted",
                severity: ErrorSeverity.InvalidJS,
                loc:
                  (_13 = _expr19.node.loc) !== null && _13 !== void 0
                    ? _13
                    : null,
                suggestions: [
                  {
                    description: "Remove this line",
                    range: [_expr19.node.start, _expr19.node.end],
                    op: CompilerSuggestionOperation.Remove
                  }
                ]
              });
              return {
                kind: "UnsupportedNode",
                node: _expr19.node,
                loc: exprLoc
              };
            }
          } else if (_expr19.node.operator === "throw") {
            builder.errors.push({
              reason: "Throw expressions are not supported",
              severity: ErrorSeverity.InvalidJS,
              loc:
                (_14 = _expr19.node.loc) !== null && _14 !== void 0
                  ? _14
                  : null,
              suggestions: [
                {
                  description: "Remove this line",
                  range: [_expr19.node.start, _expr19.node.end],
                  op: CompilerSuggestionOperation.Remove
                }
              ]
            });
            return {
              kind: "UnsupportedNode",
              node: _expr19.node,
              loc: exprLoc
            };
          } else {
            return {
              kind: "UnaryExpression",
              operator: _expr19.node.operator,
              value: lowerExpressionToTemporary(
                builder,
                _expr19.get("argument")
              ),
              loc: exprLoc
            };
          }
        }
        case "AwaitExpression": {
          var _expr20 = exprPath;
          return {
            kind: "Await",
            value: lowerExpressionToTemporary(builder, _expr20.get("argument")),
            loc: exprLoc
          };
        }
        case "TypeCastExpression": {
          var _expr21 = exprPath;
          var _typeAnnotation2 = _expr21
            .get("typeAnnotation")
            .get("typeAnnotation");
          return {
            kind: "TypeCastExpression",
            value: lowerExpressionToTemporary(
              builder,
              _expr21.get("expression")
            ),
            typeAnnotation: _typeAnnotation2.node,
            type: lowerType(_typeAnnotation2.node),
            loc: exprLoc
          };
        }
        case "TSAsExpression": {
          var _expr22 = exprPath;
          var _typeAnnotation3 = _expr22.get("typeAnnotation");
          return {
            kind: "TypeCastExpression",
            value: lowerExpressionToTemporary(
              builder,
              _expr22.get("expression")
            ),
            typeAnnotation: _typeAnnotation3.node,
            type: lowerType(_typeAnnotation3.node),
            loc: exprLoc
          };
        }
        case "UpdateExpression": {
          var _expr23 = exprPath;
          var _argument2 = _expr23.get("argument");
          if (_argument2.isMemberExpression()) {
            var _binaryOperator = _expr23.node.operator === "++" ? "+" : "-";
            var _leftExpr2 = _argument2;
            var _lowerMemberExpressio4 = lowerMemberExpression(
                builder,
                _leftExpr2
              ),
              _object4 = _lowerMemberExpressio4.object,
              _property5 = _lowerMemberExpressio4.property,
              _value12 = _lowerMemberExpressio4.value;
            var _previousValuePlace = lowerValueToTemporary(builder, _value12);
            var updatedValue = lowerValueToTemporary(builder, {
              kind: "BinaryExpression",
              operator: _binaryOperator,
              left: Object.assign({}, _previousValuePlace),
              right: lowerValueToTemporary(builder, {
                kind: "Primitive",
                value: 1,
                loc: GeneratedSource
              }),
              loc:
                (_15 = _leftExpr2.node.loc) !== null && _15 !== void 0
                  ? _15
                  : GeneratedSource
            });
            var _newValuePlace;
            if (
              typeof _property5 === "string" ||
              typeof _property5 === "number"
            ) {
              _newValuePlace = lowerValueToTemporary(builder, {
                kind: "PropertyStore",
                object: Object.assign({}, _object4),
                property: makePropertyLiteral(_property5),
                value: Object.assign({}, updatedValue),
                loc:
                  (_16 = _leftExpr2.node.loc) !== null && _16 !== void 0
                    ? _16
                    : GeneratedSource
              });
            } else {
              _newValuePlace = lowerValueToTemporary(builder, {
                kind: "ComputedStore",
                object: Object.assign({}, _object4),
                property: Object.assign({}, _property5),
                value: Object.assign({}, updatedValue),
                loc:
                  (_17 = _leftExpr2.node.loc) !== null && _17 !== void 0
                    ? _17
                    : GeneratedSource
              });
            }
            return {
              kind: "LoadLocal",
              place: _expr23.node.prefix
                ? Object.assign({}, _newValuePlace)
                : Object.assign({}, _previousValuePlace),
              loc: exprLoc
            };
          }
          if (!_argument2.isIdentifier()) {
            builder.errors.push({
              reason:
                "(BuildHIR::lowerExpression) Handle UpdateExpression with ".concat(
                  _argument2.type,
                  " argument"
                ),
              severity: ErrorSeverity.Todo,
              loc:
                (_18 = exprPath.node.loc) !== null && _18 !== void 0
                  ? _18
                  : null,
              suggestions: null
            });
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          } else if (builder.isContextIdentifier(_argument2)) {
            builder.errors.push({
              reason:
                "(BuildHIR::lowerExpression) Handle UpdateExpression to variables captured within lambdas.",
              severity: ErrorSeverity.Todo,
              loc:
                (_19 = exprPath.node.loc) !== null && _19 !== void 0
                  ? _19
                  : null,
              suggestions: null
            });
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          }
          var lvalue = lowerIdentifierForAssignment(
            builder,
            (_20 = _argument2.node.loc) !== null && _20 !== void 0
              ? _20
              : GeneratedSource,
            InstructionKind.Reassign,
            _argument2
          );
          if (lvalue === null) {
            if (!builder.errors.hasErrors()) {
              builder.errors.push({
                reason:
                  "(BuildHIR::lowerExpression) Found an invalid UpdateExpression without a previously reported error",
                severity: ErrorSeverity.Invariant,
                loc: exprLoc,
                suggestions: null
              });
            }
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          } else if (lvalue.kind === "Global") {
            builder.errors.push({
              reason:
                "(BuildHIR::lowerExpression) Support UpdateExpression where argument is a global",
              severity: ErrorSeverity.Todo,
              loc: exprLoc,
              suggestions: null
            });
            return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
          }
          var _value13 = lowerIdentifier(builder, _argument2);
          if (_expr23.node.prefix) {
            return {
              kind: "PrefixUpdate",
              lvalue: lvalue,
              operation: _expr23.node.operator,
              value: _value13,
              loc: exprLoc
            };
          } else {
            return {
              kind: "PostfixUpdate",
              lvalue: lvalue,
              operation: _expr23.node.operator,
              value: _value13,
              loc: exprLoc
            };
          }
        }
        case "RegExpLiteral": {
          var _expr24 = exprPath;
          return {
            kind: "RegExpLiteral",
            pattern: _expr24.node.pattern,
            flags: _expr24.node.flags,
            loc:
              (_21 = _expr24.node.loc) !== null && _21 !== void 0
                ? _21
                : GeneratedSource
          };
        }
        case "TSInstantiationExpression":
        case "TSNonNullExpression": {
          var _expr25 = exprPath;
          return lowerExpression(builder, _expr25.get("expression"));
        }
        case "MetaProperty": {
          var _expr26 = exprPath;
          if (
            _expr26.node.meta.name === "import" &&
            _expr26.node.property.name === "meta"
          ) {
            return {
              kind: "MetaProperty",
              meta: _expr26.node.meta.name,
              property: _expr26.node.property.name,
              loc:
                (_22 = _expr26.node.loc) !== null && _22 !== void 0
                  ? _22
                  : GeneratedSource
            };
          }
          builder.errors.push({
            reason:
              "(BuildHIR::lowerExpression) Handle MetaProperty expressions other than import.meta",
            severity: ErrorSeverity.Todo,
            loc:
              (_23 = exprPath.node.loc) !== null && _23 !== void 0 ? _23 : null,
            suggestions: null
          });
          return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
        }
        default: {
          builder.errors.push({
            reason: "(BuildHIR::lowerExpression) Handle ".concat(
              exprPath.type,
              " expressions"
            ),
            severity: ErrorSeverity.Todo,
            loc:
              (_24 = exprPath.node.loc) !== null && _24 !== void 0 ? _24 : null,
            suggestions: null
          });
          return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
        }
      }
    }
    function lowerOptionalMemberExpression(builder, expr, parentAlternate) {
      var _a;
      var optional = expr.node.optional;
      var loc =
        (_a = expr.node.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
      var place = buildTemporaryPlace(builder, loc);
      var continuationBlock = builder.reserve(builder.currentBlockKind());
      var consequent = builder.reserve("value");
      var alternate =
        parentAlternate !== null
          ? parentAlternate
          : builder.enter("value", function () {
              var temp = lowerValueToTemporary(builder, {
                kind: "Primitive",
                value: undefined,
                loc: loc
              });
              lowerValueToTemporary(builder, {
                kind: "StoreLocal",
                lvalue: {
                  kind: InstructionKind.Const,
                  place: Object.assign({}, place)
                },
                value: Object.assign({}, temp),
                type: null,
                loc: loc
              });
              return {
                kind: "goto",
                variant: GotoVariant.Break,
                block: continuationBlock.id,
                id: makeInstructionId(0),
                loc: loc
              };
            });
      var object = null;
      var testBlock = builder.enter("value", function () {
        var objectPath = expr.get("object");
        if (objectPath.isOptionalMemberExpression()) {
          var _lowerOptionalMemberE2 = lowerOptionalMemberExpression(
              builder,
              objectPath,
              alternate
            ),
            value = _lowerOptionalMemberE2.value;
          object = value;
        } else if (objectPath.isOptionalCallExpression()) {
          var _value14 = lowerOptionalCallExpression(
            builder,
            objectPath,
            alternate
          );
          object = lowerValueToTemporary(builder, _value14);
        } else {
          object = lowerExpressionToTemporary(builder, objectPath);
        }
        return {
          kind: "branch",
          test: Object.assign({}, object),
          consequent: consequent.id,
          alternate: alternate,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc
        };
      });
      CompilerError.invariant(object !== null, {
        reason: "Satisfy type checker",
        description: null,
        loc: null,
        suggestions: null
      });
      builder.enterReserved(consequent, function () {
        var _lowerMemberExpressio5 = lowerMemberExpression(
            builder,
            expr,
            object
          ),
          value = _lowerMemberExpressio5.value;
        var temp = lowerValueToTemporary(builder, value);
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, place)
          },
          value: Object.assign({}, temp),
          type: null,
          loc: loc
        });
        return {
          kind: "goto",
          variant: GotoVariant.Break,
          block: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "optional",
          optional: optional,
          test: testBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc
        },
        continuationBlock
      );
      return { object: object, value: place };
    }
    function lowerOptionalCallExpression(builder, expr, parentAlternate) {
      var _a;
      var optional = expr.node.optional;
      var calleePath = expr.get("callee");
      var loc =
        (_a = expr.node.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
      var place = buildTemporaryPlace(builder, loc);
      var continuationBlock = builder.reserve(builder.currentBlockKind());
      var consequent = builder.reserve("value");
      var alternate =
        parentAlternate !== null
          ? parentAlternate
          : builder.enter("value", function () {
              var temp = lowerValueToTemporary(builder, {
                kind: "Primitive",
                value: undefined,
                loc: loc
              });
              lowerValueToTemporary(builder, {
                kind: "StoreLocal",
                lvalue: {
                  kind: InstructionKind.Const,
                  place: Object.assign({}, place)
                },
                value: Object.assign({}, temp),
                type: null,
                loc: loc
              });
              return {
                kind: "goto",
                variant: GotoVariant.Break,
                block: continuationBlock.id,
                id: makeInstructionId(0),
                loc: loc
              };
            });
      var callee;
      var testBlock = builder.enter("value", function () {
        if (calleePath.isOptionalCallExpression()) {
          var value = lowerOptionalCallExpression(
            builder,
            calleePath,
            alternate
          );
          var valuePlace = lowerValueToTemporary(builder, value);
          callee = { kind: "CallExpression", callee: valuePlace };
        } else if (calleePath.isOptionalMemberExpression()) {
          var _lowerOptionalMemberE3 = lowerOptionalMemberExpression(
              builder,
              calleePath,
              alternate
            ),
            object = _lowerOptionalMemberE3.object,
            _value15 = _lowerOptionalMemberE3.value;
          callee = { kind: "MethodCall", receiver: object, property: _value15 };
        } else if (calleePath.isMemberExpression()) {
          var memberExpr = lowerMemberExpression(builder, calleePath);
          var propertyPlace = lowerValueToTemporary(builder, memberExpr.value);
          callee = {
            kind: "MethodCall",
            receiver: memberExpr.object,
            property: propertyPlace
          };
        } else {
          callee = {
            kind: "CallExpression",
            callee: lowerExpressionToTemporary(builder, calleePath)
          };
        }
        var testPlace =
          callee.kind === "CallExpression" ? callee.callee : callee.property;
        return {
          kind: "branch",
          test: Object.assign({}, testPlace),
          consequent: consequent.id,
          alternate: alternate,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc
        };
      });
      builder.enterReserved(consequent, function () {
        var args = lowerArguments(builder, expr.get("arguments"));
        var temp = buildTemporaryPlace(builder, loc);
        if (callee.kind === "CallExpression") {
          builder.push({
            id: makeInstructionId(0),
            lvalue: Object.assign({}, temp),
            value: {
              kind: "CallExpression",
              callee: Object.assign({}, callee.callee),
              args: args,
              loc: loc
            },
            loc: loc
          });
        } else {
          builder.push({
            id: makeInstructionId(0),
            lvalue: Object.assign({}, temp),
            value: {
              kind: "MethodCall",
              receiver: Object.assign({}, callee.receiver),
              property: Object.assign({}, callee.property),
              args: args,
              loc: loc
            },
            loc: loc
          });
        }
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, place)
          },
          value: Object.assign({}, temp),
          type: null,
          loc: loc
        });
        return {
          kind: "goto",
          variant: GotoVariant.Break,
          block: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "optional",
          optional: optional,
          test: testBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc
        },
        continuationBlock
      );
      return { kind: "LoadLocal", place: place, loc: place.loc };
    }
    function lowerReorderableExpression(builder, expr) {
      var _a;
      if (!isReorderableExpression(builder, expr, true)) {
        builder.errors.push({
          reason:
            "(BuildHIR::node.lowerReorderableExpression) Expression type `".concat(
              expr.type,
              "` cannot be safely reordered"
            ),
          severity: ErrorSeverity.Todo,
          loc: (_a = expr.node.loc) !== null && _a !== void 0 ? _a : null,
          suggestions: null
        });
      }
      return lowerExpressionToTemporary(builder, expr);
    }
    function isReorderableExpression(builder, expr, allowLocalIdentifiers) {
      switch (expr.node.type) {
        case "Identifier": {
          var binding = builder.resolveIdentifier(expr);
          if (binding.kind === "Identifier") {
            return allowLocalIdentifiers;
          } else {
            return true;
          }
        }
        case "RegExpLiteral":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "BigIntLiteral": {
          return true;
        }
        case "UnaryExpression": {
          var unary = expr;
          switch (expr.node.operator) {
            case "!":
            case "+":
            case "-": {
              return isReorderableExpression(
                builder,
                unary.get("argument"),
                allowLocalIdentifiers
              );
            }
            default: {
              return false;
            }
          }
        }
        case "TypeCastExpression": {
          return isReorderableExpression(
            builder,
            expr.get("expression"),
            allowLocalIdentifiers
          );
        }
        case "LogicalExpression": {
          var logical = expr;
          return (
            isReorderableExpression(
              builder,
              logical.get("left"),
              allowLocalIdentifiers
            ) &&
            isReorderableExpression(
              builder,
              logical.get("right"),
              allowLocalIdentifiers
            )
          );
        }
        case "ConditionalExpression": {
          var conditional = expr;
          return (
            isReorderableExpression(
              builder,
              conditional.get("test"),
              allowLocalIdentifiers
            ) &&
            isReorderableExpression(
              builder,
              conditional.get("consequent"),
              allowLocalIdentifiers
            ) &&
            isReorderableExpression(
              builder,
              conditional.get("alternate"),
              allowLocalIdentifiers
            )
          );
        }
        case "ArrayExpression": {
          return expr.get("elements").every(function (element) {
            return (
              element.isExpression() &&
              isReorderableExpression(builder, element, allowLocalIdentifiers)
            );
          });
        }
        case "ObjectExpression": {
          return expr.get("properties").every(function (property) {
            if (!property.isObjectProperty() || property.node.computed) {
              return false;
            }
            var value = property.get("value");
            return (
              value.isExpression() &&
              isReorderableExpression(builder, value, allowLocalIdentifiers)
            );
          });
        }
        case "MemberExpression": {
          var _test15 = expr;
          var innerObject = _test15;
          while (innerObject.isMemberExpression()) {
            innerObject = innerObject.get("object");
          }
          if (
            innerObject.isIdentifier() &&
            builder.resolveIdentifier(innerObject).kind !== "Identifier"
          ) {
            return true;
          } else {
            return false;
          }
        }
        case "ArrowFunctionExpression": {
          var fn = expr;
          var body = fn.get("body");
          if (body.node.type === "BlockStatement") {
            return body.node.body.length === 0;
          } else {
            invariant_1(body.isExpression(), "Expected an expression");
            return isReorderableExpression(builder, body, false);
          }
        }
        case "CallExpression": {
          var call = expr;
          var callee = call.get("callee");
          return (
            callee.isExpression() &&
            isReorderableExpression(builder, callee, allowLocalIdentifiers) &&
            call.get("arguments").every(function (arg) {
              return (
                arg.isExpression() &&
                isReorderableExpression(builder, arg, allowLocalIdentifiers)
              );
            })
          );
        }
        default: {
          return false;
        }
      }
    }
    function lowerArguments(builder, expr) {
      var _a;
      var args = [];
      var _iterator115 = _createForOfIteratorHelper(expr),
        _step115;
      try {
        for (_iterator115.s(); !(_step115 = _iterator115.n()).done; ) {
          var argPath = _step115.value;
          if (argPath.isSpreadElement()) {
            args.push({
              kind: "Spread",
              place: lowerExpressionToTemporary(
                builder,
                argPath.get("argument")
              )
            });
          } else if (argPath.isExpression()) {
            args.push(lowerExpressionToTemporary(builder, argPath));
          } else {
            builder.errors.push({
              reason: "(BuildHIR::lowerExpression) Handle ".concat(
                argPath.type,
                " arguments in CallExpression"
              ),
              severity: ErrorSeverity.Todo,
              loc:
                (_a = argPath.node.loc) !== null && _a !== void 0 ? _a : null,
              suggestions: null
            });
          }
        }
      } catch (err) {
        _iterator115.e(err);
      } finally {
        _iterator115.f();
      }
      return args;
    }
    function lowerMemberExpression(builder, expr) {
      var loweredObject =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      var _a, _b, _c;
      var exprNode = expr.node;
      var exprLoc =
        (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
      var objectNode = expr.get("object");
      var propertyNode = expr.get("property");
      var object =
        loweredObject !== null && loweredObject !== void 0
          ? loweredObject
          : lowerExpressionToTemporary(builder, objectNode);
      if (!expr.node.computed || expr.node.property.type === "NumericLiteral") {
        var property;
        if (propertyNode.isIdentifier()) {
          property = makePropertyLiteral(propertyNode.node.name);
        } else if (propertyNode.isNumericLiteral()) {
          property = makePropertyLiteral(propertyNode.node.value);
        } else {
          builder.errors.push({
            reason: "(BuildHIR::lowerMemberExpression) Handle ".concat(
              propertyNode.type,
              " property"
            ),
            severity: ErrorSeverity.Todo,
            loc:
              (_b = propertyNode.node.loc) !== null && _b !== void 0
                ? _b
                : null,
            suggestions: null
          });
          return {
            object: object,
            property: propertyNode.toString(),
            value: { kind: "UnsupportedNode", node: exprNode, loc: exprLoc }
          };
        }
        var value = {
          kind: "PropertyLoad",
          object: Object.assign({}, object),
          property: property,
          loc: exprLoc
        };
        return { object: object, property: property, value: value };
      } else {
        if (!propertyNode.isExpression()) {
          builder.errors.push({
            reason:
              "(BuildHIR::lowerMemberExpression) Expected Expression, got ".concat(
                propertyNode.type,
                " property"
              ),
            severity: ErrorSeverity.Todo,
            loc:
              (_c = propertyNode.node.loc) !== null && _c !== void 0
                ? _c
                : null,
            suggestions: null
          });
          return {
            object: object,
            property: propertyNode.toString(),
            value: { kind: "UnsupportedNode", node: exprNode, loc: exprLoc }
          };
        }
        var _property6 = lowerExpressionToTemporary(builder, propertyNode);
        var _value16 = {
          kind: "ComputedLoad",
          object: Object.assign({}, object),
          property: Object.assign({}, _property6),
          loc: exprLoc
        };
        return { object: object, property: _property6, value: _value16 };
      }
    }
    function lowerJsxElementName(builder, exprPath) {
      var _a, _b, _c;
      var exprNode = exprPath.node;
      var exprLoc =
        (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
      if (exprPath.isJSXIdentifier()) {
        var tag = exprPath.node.name;
        if (tag.match(/^[A-Z]/)) {
          var kind = getLoadKind(builder, exprPath);
          return lowerValueToTemporary(builder, {
            kind: kind,
            place: lowerIdentifier(builder, exprPath),
            loc: exprLoc
          });
        } else {
          return { kind: "BuiltinTag", name: tag, loc: exprLoc };
        }
      } else if (exprPath.isJSXMemberExpression()) {
        return lowerJsxMemberExpression(builder, exprPath);
      } else if (exprPath.isJSXNamespacedName()) {
        var namespace = exprPath.node.namespace.name;
        var name = exprPath.node.name.name;
        var _tag = "".concat(namespace, ":").concat(name);
        if (namespace.indexOf(":") !== -1 || name.indexOf(":") !== -1) {
          builder.errors.push({
            reason:
              "Expected JSXNamespacedName to have no colons in the namespace or name",
            description: "Got `".concat(namespace, "` : `").concat(name, "`"),
            severity: ErrorSeverity.InvalidJS,
            loc: (_b = exprPath.node.loc) !== null && _b !== void 0 ? _b : null,
            suggestions: null
          });
        }
        var place = lowerValueToTemporary(builder, {
          kind: "Primitive",
          value: _tag,
          loc: exprLoc
        });
        return place;
      } else {
        builder.errors.push({
          reason: "(BuildHIR::lowerJsxElementName) Handle ".concat(
            exprPath.type,
            " tags"
          ),
          severity: ErrorSeverity.Todo,
          loc: (_c = exprPath.node.loc) !== null && _c !== void 0 ? _c : null,
          suggestions: null
        });
        return lowerValueToTemporary(builder, {
          kind: "UnsupportedNode",
          node: exprNode,
          loc: exprLoc
        });
      }
    }
    function lowerJsxMemberExpression(builder, exprPath) {
      var _a, _b, _c;
      var loc =
        (_a = exprPath.node.loc) !== null && _a !== void 0
          ? _a
          : GeneratedSource;
      var object = exprPath.get("object");
      var objectPlace;
      if (object.isJSXMemberExpression()) {
        objectPlace = lowerJsxMemberExpression(builder, object);
      } else {
        CompilerError.invariant(object.isJSXIdentifier(), {
          reason:
            "TypeScript refinement fail: expected 'JsxIdentifier', got `".concat(
              object.node.type,
              "`"
            ),
          description: null,
          loc: (_b = object.node.loc) !== null && _b !== void 0 ? _b : null,
          suggestions: null
        });
        var kind = getLoadKind(builder, object);
        objectPlace = lowerValueToTemporary(builder, {
          kind: kind,
          place: lowerIdentifier(builder, object),
          loc:
            (_c = exprPath.node.loc) !== null && _c !== void 0
              ? _c
              : GeneratedSource
        });
      }
      var property = exprPath.get("property").node.name;
      return lowerValueToTemporary(builder, {
        kind: "PropertyLoad",
        object: objectPlace,
        property: makePropertyLiteral(property),
        loc: loc
      });
    }
    function lowerJsxElement(builder, exprPath) {
      var _a, _b, _c;
      var exprNode = exprPath.node;
      var exprLoc =
        (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
      if (exprPath.isJSXElement() || exprPath.isJSXFragment()) {
        return lowerExpressionToTemporary(builder, exprPath);
      } else if (exprPath.isJSXExpressionContainer()) {
        var expression = exprPath.get("expression");
        if (expression.isJSXEmptyExpression()) {
          return null;
        } else {
          CompilerError.invariant(expression.isExpression(), {
            reason:
              "(BuildHIR::lowerJsxElement) Expected Expression but found ".concat(
                expression.type,
                "!"
              ),
            description: null,
            loc:
              (_b = expression.node.loc) !== null && _b !== void 0 ? _b : null,
            suggestions: null
          });
          return lowerExpressionToTemporary(builder, expression);
        }
      } else if (exprPath.isJSXText()) {
        var text;
        if (builder.fbtDepth > 0) {
          text = exprPath.node.value;
        } else {
          text = trimJsxText(exprPath.node.value);
        }
        if (text === null) {
          return null;
        }
        var place = lowerValueToTemporary(builder, {
          kind: "JSXText",
          value: text,
          loc: exprLoc
        });
        return place;
      } else {
        builder.errors.push({
          reason:
            "(BuildHIR::lowerJsxElement) Unhandled JsxElement, got: ".concat(
              exprPath.type
            ),
          severity: ErrorSeverity.Todo,
          loc: (_c = exprPath.node.loc) !== null && _c !== void 0 ? _c : null,
          suggestions: null
        });
        var _place12 = lowerValueToTemporary(builder, {
          kind: "UnsupportedNode",
          node: exprNode,
          loc: exprLoc
        });
        return _place12;
      }
    }
    function trimJsxText(original) {
      var lines = original.split(/\r\n|\n|\r/);
      var lastNonEmptyLine = 0;
      for (var i = 0; i < lines.length; i++) {
        if (lines[i].match(/[^ \t]/)) {
          lastNonEmptyLine = i;
        }
      }
      var str = "";
      for (var _i22 = 0; _i22 < lines.length; _i22++) {
        var line = lines[_i22];
        var isFirstLine = _i22 === 0;
        var isLastLine = _i22 === lines.length - 1;
        var isLastNonEmptyLine = _i22 === lastNonEmptyLine;
        var trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) {
          trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        }
        if (!isLastLine) {
          trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        }
        if (trimmedLine) {
          if (!isLastNonEmptyLine) {
            trimmedLine += " ";
          }
          str += trimmedLine;
        }
      }
      if (str.length !== 0) {
        return str;
      } else {
        return null;
      }
    }
    function lowerFunctionToValue(builder, expr) {
      var _a, _b, _c, _d;
      var exprNode = expr.node;
      var exprLoc =
        (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
      var name = null;
      if (expr.isFunctionExpression()) {
        name =
          (_d =
            (_c =
              (_b = expr.get("id")) === null || _b === void 0
                ? void 0
                : _b.node) === null || _c === void 0
              ? void 0
              : _c.name) !== null && _d !== void 0
            ? _d
            : null;
      }
      var loweredFunc = lowerFunction(builder, expr);
      if (!loweredFunc) {
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      return {
        kind: "FunctionExpression",
        name: name,
        type: expr.node.type,
        loc: exprLoc,
        loweredFunc: loweredFunc
      };
    }
    function lowerFunction(builder, expr) {
      var componentScope = builder.parentFunction.scope;
      var capturedContext = gatherCapturedContext(expr, componentScope);
      var lowering = lower$1(
        expr,
        builder.environment,
        builder.bindings,
        [].concat(
          _toConsumableArray(builder.context),
          _toConsumableArray(capturedContext)
        ),
        builder.parentFunction
      );
      var loweredFunc;
      if (lowering.isErr()) {
        lowering.unwrapErr().details.forEach(function (detail) {
          return builder.errors.pushErrorDetail(detail);
        });
        return null;
      }
      loweredFunc = lowering.unwrap();
      return { func: loweredFunc };
    }
    function lowerExpressionToTemporary(builder, exprPath) {
      var value = lowerExpression(builder, exprPath);
      return lowerValueToTemporary(builder, value);
    }
    function lowerValueToTemporary(builder, value) {
      if (value.kind === "LoadLocal" && value.place.identifier.name === null) {
        return value.place;
      }
      var place = buildTemporaryPlace(builder, value.loc);
      builder.push({
        id: makeInstructionId(0),
        value: value,
        loc: value.loc,
        lvalue: Object.assign({}, place)
      });
      return place;
    }
    function lowerIdentifier(builder, exprPath) {
      var _a;
      var exprNode = exprPath.node;
      var exprLoc =
        (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
      var binding = builder.resolveIdentifier(exprPath);
      switch (binding.kind) {
        case "Identifier": {
          var place = {
            kind: "Identifier",
            identifier: binding.identifier,
            effect: Effect.Unknown,
            reactive: false,
            loc: exprLoc
          };
          return place;
        }
        default: {
          return lowerValueToTemporary(builder, {
            kind: "LoadGlobal",
            binding: binding,
            loc: exprLoc
          });
        }
      }
    }
    function buildTemporaryPlace(builder, loc) {
      var place = {
        kind: "Identifier",
        identifier: builder.makeTemporary(loc),
        effect: Effect.Unknown,
        reactive: false,
        loc: loc
      };
      return place;
    }
    function getStoreKind(builder, identifier) {
      var isContext = builder.isContextIdentifier(identifier);
      return isContext ? "StoreContext" : "StoreLocal";
    }
    function getLoadKind(builder, identifier) {
      var isContext = builder.isContextIdentifier(identifier);
      return isContext ? "LoadContext" : "LoadLocal";
    }
    function lowerIdentifierForAssignment(builder, loc, kind, path) {
      var _a, _b;
      var binding = builder.resolveIdentifier(path);
      if (binding.kind !== "Identifier") {
        if (kind === InstructionKind.Reassign) {
          return { kind: "Global", name: path.node.name };
        } else {
          builder.errors.push({
            reason:
              "(BuildHIR::lowerAssignment) Could not find binding for declaration.",
            severity: ErrorSeverity.Invariant,
            loc: (_a = path.node.loc) !== null && _a !== void 0 ? _a : null,
            suggestions: null
          });
          return null;
        }
      } else if (
        binding.bindingKind === "const" &&
        kind === InstructionKind.Reassign
      ) {
        builder.errors.push({
          reason: "Cannot reassign a `const` variable",
          severity: ErrorSeverity.InvalidJS,
          loc: (_b = path.node.loc) !== null && _b !== void 0 ? _b : null,
          description:
            binding.identifier.name != null
              ? "`".concat(
                  binding.identifier.name.value,
                  "` is declared as const"
                )
              : null
        });
        return null;
      }
      var place = {
        kind: "Identifier",
        identifier: binding.identifier,
        effect: Effect.Unknown,
        reactive: false,
        loc: loc
      };
      return place;
    }
    function lowerAssignment(
      builder,
      loc,
      kind,
      lvaluePath,
      value,
      assignmentKind
    ) {
      var _a,
        _b,
        _c,
        _d,
        _e,
        _f,
        _g,
        _h,
        _j,
        _k,
        _l,
        _m,
        _o,
        _p,
        _q,
        _r,
        _s,
        _t,
        _u,
        _v,
        _w,
        _x,
        _y,
        _z,
        _0;
      var lvalueNode = lvaluePath.node;
      switch (lvalueNode.type) {
        case "Identifier": {
          var lvalue = lvaluePath;
          var place = lowerIdentifierForAssignment(builder, loc, kind, lvalue);
          if (place === null) {
            return {
              kind: "UnsupportedNode",
              loc:
                (_a = lvalue.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource,
              node: lvalue.node
            };
          } else if (place.kind === "Global") {
            var _temporary = lowerValueToTemporary(builder, {
              kind: "StoreGlobal",
              name: place.name,
              value: value,
              loc: loc
            });
            return {
              kind: "LoadLocal",
              place: _temporary,
              loc: _temporary.loc
            };
          }
          var isHoistedIdentifier = builder.environment.isHoistedIdentifier(
            lvalue.node
          );
          var temporary;
          if (builder.isContextIdentifier(lvalue)) {
            if (kind !== InstructionKind.Reassign && !isHoistedIdentifier) {
              if (kind === InstructionKind.Const) {
                builder.errors.push({
                  reason: "Expected `const` declaration not to be reassigned",
                  severity: ErrorSeverity.InvalidJS,
                  loc:
                    (_b = lvalue.node.loc) !== null && _b !== void 0
                      ? _b
                      : null,
                  suggestions: null
                });
              }
              lowerValueToTemporary(builder, {
                kind: "DeclareContext",
                lvalue: {
                  kind: InstructionKind.Let,
                  place: Object.assign({}, place)
                },
                loc: place.loc
              });
            }
            temporary = lowerValueToTemporary(builder, {
              kind: "StoreContext",
              lvalue: {
                place: Object.assign({}, place),
                kind: InstructionKind.Reassign
              },
              value: value,
              loc: loc
            });
          } else {
            var _typeAnnotation4 = lvalue.get("typeAnnotation");
            var type;
            if (_typeAnnotation4.isTSTypeAnnotation()) {
              var typePath = _typeAnnotation4.get("typeAnnotation");
              type = typePath.node;
            } else if (_typeAnnotation4.isTypeAnnotation()) {
              var _typePath2 = _typeAnnotation4.get("typeAnnotation");
              type = _typePath2.node;
            } else {
              type = null;
            }
            temporary = lowerValueToTemporary(builder, {
              kind: "StoreLocal",
              lvalue: { place: Object.assign({}, place), kind: kind },
              value: value,
              type: type,
              loc: loc
            });
          }
          return { kind: "LoadLocal", place: temporary, loc: temporary.loc };
        }
        case "MemberExpression": {
          CompilerError.invariant(kind === InstructionKind.Reassign, {
            reason:
              "MemberExpression may only appear in an assignment expression",
            description: null,
            loc:
              (_c = lvaluePath.node.loc) !== null && _c !== void 0 ? _c : null,
            suggestions: null
          });
          var _lvalue2 = lvaluePath;
          var property = _lvalue2.get("property");
          var object = lowerExpressionToTemporary(
            builder,
            _lvalue2.get("object")
          );
          if (
            !_lvalue2.node.computed ||
            _lvalue2.get("property").isNumericLiteral()
          ) {
            var _temporary2;
            if (property.isIdentifier()) {
              _temporary2 = lowerValueToTemporary(builder, {
                kind: "PropertyStore",
                object: object,
                property: makePropertyLiteral(property.node.name),
                value: value,
                loc: loc
              });
            } else if (property.isNumericLiteral()) {
              _temporary2 = lowerValueToTemporary(builder, {
                kind: "PropertyStore",
                object: object,
                property: makePropertyLiteral(property.node.value),
                value: value,
                loc: loc
              });
            } else {
              builder.errors.push({
                reason: "(BuildHIR::lowerAssignment) Handle ".concat(
                  property.type,
                  " properties in MemberExpression"
                ),
                severity: ErrorSeverity.Todo,
                loc:
                  (_d = property.node.loc) !== null && _d !== void 0
                    ? _d
                    : null,
                suggestions: null
              });
              return { kind: "UnsupportedNode", node: lvalueNode, loc: loc };
            }
            return {
              kind: "LoadLocal",
              place: _temporary2,
              loc: _temporary2.loc
            };
          } else {
            if (!property.isExpression()) {
              builder.errors.push({
                reason:
                  "(BuildHIR::lowerAssignment) Expected private name to appear as a non-computed property",
                severity: ErrorSeverity.Todo,
                loc:
                  (_e = property.node.loc) !== null && _e !== void 0
                    ? _e
                    : null,
                suggestions: null
              });
              return { kind: "UnsupportedNode", node: lvalueNode, loc: loc };
            }
            var propertyPlace = lowerExpressionToTemporary(builder, property);
            var _temporary3 = lowerValueToTemporary(builder, {
              kind: "ComputedStore",
              object: object,
              property: propertyPlace,
              value: value,
              loc: loc
            });
            return {
              kind: "LoadLocal",
              place: _temporary3,
              loc: _temporary3.loc
            };
          }
        }
        case "ArrayPattern": {
          var _lvalue3 = lvaluePath;
          var elements = _lvalue3.get("elements");
          var items = [];
          var followups = [];
          var forceTemporaries =
            kind === InstructionKind.Reassign &&
            (elements.some(function (element) {
              return !element.isIdentifier();
            }) ||
              elements.some(function (element) {
                return (
                  element.isIdentifier() &&
                  (getStoreKind(builder, element) !== "StoreLocal" ||
                    builder.resolveIdentifier(element).kind !== "Identifier")
                );
              }));
          for (var i = 0; i < elements.length; i++) {
            var element = elements[i];
            if (element.node == null) {
              items.push({ kind: "Hole" });
              continue;
            }
            if (element.isRestElement()) {
              var argument = element.get("argument");
              if (
                argument.isIdentifier() &&
                !forceTemporaries &&
                (assignmentKind === "Assignment" ||
                  getStoreKind(builder, argument) === "StoreLocal")
              ) {
                var _identifier6 = lowerIdentifierForAssignment(
                  builder,
                  (_f = element.node.loc) !== null && _f !== void 0
                    ? _f
                    : GeneratedSource,
                  kind,
                  argument
                );
                if (_identifier6 === null) {
                  continue;
                } else if (_identifier6.kind === "Global") {
                  builder.errors.push({
                    severity: ErrorSeverity.Todo,
                    reason:
                      "Expected reassignment of globals to enable forceTemporaries",
                    loc:
                      (_g = element.node.loc) !== null && _g !== void 0
                        ? _g
                        : GeneratedSource
                  });
                  continue;
                }
                items.push({ kind: "Spread", place: _identifier6 });
              } else {
                var temp = buildTemporaryPlace(
                  builder,
                  (_h = element.node.loc) !== null && _h !== void 0
                    ? _h
                    : GeneratedSource
                );
                promoteTemporary(temp.identifier);
                items.push({ kind: "Spread", place: Object.assign({}, temp) });
                followups.push({ place: temp, path: argument });
              }
            } else if (
              element.isIdentifier() &&
              !forceTemporaries &&
              (assignmentKind === "Assignment" ||
                getStoreKind(builder, element) === "StoreLocal")
            ) {
              var _identifier7 = lowerIdentifierForAssignment(
                builder,
                (_j = element.node.loc) !== null && _j !== void 0
                  ? _j
                  : GeneratedSource,
                kind,
                element
              );
              if (_identifier7 === null) {
                continue;
              } else if (_identifier7.kind === "Global") {
                builder.errors.push({
                  severity: ErrorSeverity.Todo,
                  reason:
                    "Expected reassignment of globals to enable forceTemporaries",
                  loc:
                    (_k = element.node.loc) !== null && _k !== void 0
                      ? _k
                      : GeneratedSource
                });
                continue;
              }
              items.push(_identifier7);
            } else {
              var _temp = buildTemporaryPlace(
                builder,
                (_l = element.node.loc) !== null && _l !== void 0
                  ? _l
                  : GeneratedSource
              );
              promoteTemporary(_temp.identifier);
              items.push(Object.assign({}, _temp));
              followups.push({ place: _temp, path: element });
            }
          }
          var _temporary4 = lowerValueToTemporary(builder, {
            kind: "Destructure",
            lvalue: {
              kind: kind,
              pattern: { kind: "ArrayPattern", items: items }
            },
            value: value,
            loc: loc
          });
          for (
            var _i23 = 0, _followups = followups;
            _i23 < _followups.length;
            _i23++
          ) {
            var _followups$_i = _followups[_i23],
              _place13 = _followups$_i.place,
              path = _followups$_i.path;
            lowerAssignment(
              builder,
              (_m = path.node.loc) !== null && _m !== void 0 ? _m : loc,
              kind,
              path,
              _place13,
              assignmentKind
            );
          }
          return { kind: "LoadLocal", place: _temporary4, loc: value.loc };
        }
        case "ObjectPattern": {
          var _lvalue4 = lvaluePath;
          var propertiesPaths = _lvalue4.get("properties");
          var properties = [];
          var _followups2 = [];
          var _forceTemporaries =
            kind === InstructionKind.Reassign &&
            propertiesPaths.some(function (property) {
              return (
                property.isRestElement() ||
                (property.isObjectProperty() &&
                  (!property.get("value").isIdentifier() ||
                    builder.resolveIdentifier(property.get("value")).kind !==
                      "Identifier"))
              );
            });
          for (var _i24 = 0; _i24 < propertiesPaths.length; _i24++) {
            var _property7 = propertiesPaths[_i24];
            if (_property7.isRestElement()) {
              var _argument3 = _property7.get("argument");
              if (!_argument3.isIdentifier()) {
                builder.errors.push({
                  reason: "(BuildHIR::lowerAssignment) Handle ".concat(
                    _argument3.node.type,
                    " rest element in ObjectPattern"
                  ),
                  severity: ErrorSeverity.Todo,
                  loc:
                    (_o = _argument3.node.loc) !== null && _o !== void 0
                      ? _o
                      : null,
                  suggestions: null
                });
                continue;
              }
              if (
                _forceTemporaries ||
                getStoreKind(builder, _argument3) === "StoreContext"
              ) {
                var _temp2 = buildTemporaryPlace(
                  builder,
                  (_p = _property7.node.loc) !== null && _p !== void 0
                    ? _p
                    : GeneratedSource
                );
                promoteTemporary(_temp2.identifier);
                properties.push({
                  kind: "Spread",
                  place: Object.assign({}, _temp2)
                });
                _followups2.push({ place: _temp2, path: _argument3 });
              } else {
                var _identifier8 = lowerIdentifierForAssignment(
                  builder,
                  (_q = _property7.node.loc) !== null && _q !== void 0
                    ? _q
                    : GeneratedSource,
                  kind,
                  _argument3
                );
                if (_identifier8 === null) {
                  continue;
                } else if (_identifier8.kind === "Global") {
                  builder.errors.push({
                    severity: ErrorSeverity.Todo,
                    reason:
                      "Expected reassignment of globals to enable forceTemporaries",
                    loc:
                      (_r = _property7.node.loc) !== null && _r !== void 0
                        ? _r
                        : GeneratedSource
                  });
                  continue;
                }
                properties.push({ kind: "Spread", place: _identifier8 });
              }
            } else {
              if (!_property7.isObjectProperty()) {
                builder.errors.push({
                  reason: "(BuildHIR::lowerAssignment) Handle ".concat(
                    _property7.type,
                    " properties in ObjectPattern"
                  ),
                  severity: ErrorSeverity.Todo,
                  loc:
                    (_s = _property7.node.loc) !== null && _s !== void 0
                      ? _s
                      : null,
                  suggestions: null
                });
                continue;
              }
              if (_property7.node.computed) {
                builder.errors.push({
                  reason:
                    "(BuildHIR::lowerAssignment) Handle computed properties in ObjectPattern",
                  severity: ErrorSeverity.Todo,
                  loc:
                    (_t = _property7.node.loc) !== null && _t !== void 0
                      ? _t
                      : null,
                  suggestions: null
                });
                continue;
              }
              var loweredKey = lowerObjectPropertyKey(builder, _property7);
              if (!loweredKey) {
                continue;
              }
              var _element = _property7.get("value");
              if (!_element.isLVal()) {
                builder.errors.push({
                  reason:
                    "(BuildHIR::lowerAssignment) Expected object property value to be an LVal, got: ".concat(
                      _element.type
                    ),
                  severity: ErrorSeverity.Todo,
                  loc:
                    (_u = _element.node.loc) !== null && _u !== void 0
                      ? _u
                      : null,
                  suggestions: null
                });
                continue;
              }
              if (
                _element.isIdentifier() &&
                !_forceTemporaries &&
                (assignmentKind === "Assignment" ||
                  getStoreKind(builder, _element) === "StoreLocal")
              ) {
                var _identifier9 = lowerIdentifierForAssignment(
                  builder,
                  (_v = _element.node.loc) !== null && _v !== void 0
                    ? _v
                    : GeneratedSource,
                  kind,
                  _element
                );
                if (_identifier9 === null) {
                  continue;
                } else if (_identifier9.kind === "Global") {
                  builder.errors.push({
                    severity: ErrorSeverity.Todo,
                    reason:
                      "Expected reassignment of globals to enable forceTemporaries",
                    loc:
                      (_w = _element.node.loc) !== null && _w !== void 0
                        ? _w
                        : GeneratedSource
                  });
                  continue;
                }
                properties.push({
                  kind: "ObjectProperty",
                  type: "property",
                  place: _identifier9,
                  key: loweredKey
                });
              } else {
                var _temp3 = buildTemporaryPlace(
                  builder,
                  (_x = _element.node.loc) !== null && _x !== void 0
                    ? _x
                    : GeneratedSource
                );
                promoteTemporary(_temp3.identifier);
                properties.push({
                  kind: "ObjectProperty",
                  type: "property",
                  place: Object.assign({}, _temp3),
                  key: loweredKey
                });
                _followups2.push({ place: _temp3, path: _element });
              }
            }
          }
          var _temporary5 = lowerValueToTemporary(builder, {
            kind: "Destructure",
            lvalue: {
              kind: kind,
              pattern: { kind: "ObjectPattern", properties: properties }
            },
            value: value,
            loc: loc
          });
          for (
            var _i25 = 0, _followups3 = _followups2;
            _i25 < _followups3.length;
            _i25++
          ) {
            var _followups3$_i = _followups3[_i25],
              _place14 = _followups3$_i.place,
              _path2 = _followups3$_i.path;
            lowerAssignment(
              builder,
              (_y = _path2.node.loc) !== null && _y !== void 0 ? _y : loc,
              kind,
              _path2,
              _place14,
              assignmentKind
            );
          }
          return { kind: "LoadLocal", place: _temporary5, loc: value.loc };
        }
        case "AssignmentPattern": {
          var _lvalue5 = lvaluePath;
          var _loc5 =
            (_z = _lvalue5.node.loc) !== null && _z !== void 0
              ? _z
              : GeneratedSource;
          var _temp4 = buildTemporaryPlace(builder, _loc5);
          var testBlock = builder.reserve("value");
          var continuationBlock = builder.reserve(builder.currentBlockKind());
          var consequent = builder.enter("value", function () {
            var defaultValue = lowerReorderableExpression(
              builder,
              _lvalue5.get("right")
            );
            lowerValueToTemporary(builder, {
              kind: "StoreLocal",
              lvalue: {
                kind: InstructionKind.Const,
                place: Object.assign({}, _temp4)
              },
              value: Object.assign({}, defaultValue),
              type: null,
              loc: _loc5
            });
            return {
              kind: "goto",
              variant: GotoVariant.Break,
              block: continuationBlock.id,
              id: makeInstructionId(0),
              loc: _loc5
            };
          });
          var alternate = builder.enter("value", function () {
            lowerValueToTemporary(builder, {
              kind: "StoreLocal",
              lvalue: {
                kind: InstructionKind.Const,
                place: Object.assign({}, _temp4)
              },
              value: Object.assign({}, value),
              type: null,
              loc: _loc5
            });
            return {
              kind: "goto",
              variant: GotoVariant.Break,
              block: continuationBlock.id,
              id: makeInstructionId(0),
              loc: _loc5
            };
          });
          builder.terminateWithContinuation(
            {
              kind: "ternary",
              test: testBlock.id,
              fallthrough: continuationBlock.id,
              id: makeInstructionId(0),
              loc: _loc5
            },
            testBlock
          );
          var undef = lowerValueToTemporary(builder, {
            kind: "Primitive",
            value: undefined,
            loc: _loc5
          });
          var _test16 = lowerValueToTemporary(builder, {
            kind: "BinaryExpression",
            left: Object.assign({}, value),
            operator: "===",
            right: Object.assign({}, undef),
            loc: _loc5
          });
          builder.terminateWithContinuation(
            {
              kind: "branch",
              test: Object.assign({}, _test16),
              consequent: consequent,
              alternate: alternate,
              fallthrough: continuationBlock.id,
              id: makeInstructionId(0),
              loc: _loc5
            },
            continuationBlock
          );
          return lowerAssignment(
            builder,
            _loc5,
            kind,
            _lvalue5.get("left"),
            _temp4,
            assignmentKind
          );
        }
        default: {
          builder.errors.push({
            reason: "(BuildHIR::lowerAssignment) Handle ".concat(
              lvaluePath.type,
              " assignments"
            ),
            severity: ErrorSeverity.Todo,
            loc:
              (_0 = lvaluePath.node.loc) !== null && _0 !== void 0 ? _0 : null,
            suggestions: null
          });
          return { kind: "UnsupportedNode", node: lvalueNode, loc: loc };
        }
      }
    }
    function captureScopes(_ref20) {
      var from = _ref20.from,
        to = _ref20.to;
      var scopes = new Set();
      while (from) {
        scopes.add(from);
        if (from === to) {
          break;
        }
        from = from.parent;
      }
      return scopes;
    }
    function gatherCapturedContext(fn, componentScope) {
      var capturedIds = new Set();
      var pureScopes = captureScopes({
        from: fn.scope.parent,
        to: componentScope
      });
      function handleMaybeDependency(path) {
        var baseIdentifier;
        if (path.isJSXOpeningElement()) {
          var name = path.get("name");
          if (!(name.isJSXMemberExpression() || name.isJSXIdentifier())) {
            return;
          }
          var current = name;
          while (current.isJSXMemberExpression()) {
            current = current.get("object");
          }
          invariant_1(
            current.isJSXIdentifier(),
            "Invalid logic in gatherCapturedDeps"
          );
          baseIdentifier = current;
        } else {
          baseIdentifier = path;
        }
        path.skip();
        var binding = baseIdentifier.scope.getBinding(baseIdentifier.node.name);
        if (binding !== undefined && pureScopes.has(binding.scope)) {
          capturedIds.add(binding.identifier);
        }
      }
      fn.traverse({
        TypeAnnotation: function TypeAnnotation(path) {
          path.skip();
        },
        TSTypeAnnotation: function TSTypeAnnotation(path) {
          path.skip();
        },
        TypeAlias: function TypeAlias(path) {
          path.skip();
        },
        TSTypeAliasDeclaration: function TSTypeAliasDeclaration(path) {
          path.skip();
        },
        Expression: function Expression(path) {
          if (path.isAssignmentExpression()) {
            var left = path.get("left");
            if (left.isIdentifier()) {
              handleMaybeDependency(left);
            }
            return;
          } else if (path.isJSXElement()) {
            handleMaybeDependency(path.get("openingElement"));
          } else if (path.isIdentifier()) {
            handleMaybeDependency(path);
          }
        }
      });
      return _toConsumableArray(capturedIds.keys());
    }
    function notNull(value) {
      return value !== null;
    }
    function lowerType(node) {
      switch (node.type) {
        case "GenericTypeAnnotation": {
          var id = node.id;
          if (id.type === "Identifier" && id.name === "Array") {
            return { kind: "Object", shapeId: BuiltInArrayId };
          }
          return makeType();
        }
        case "TSTypeReference": {
          var typeName = node.typeName;
          if (typeName.type === "Identifier" && typeName.name === "Array") {
            return { kind: "Object", shapeId: BuiltInArrayId };
          }
          return makeType();
        }
        case "ArrayTypeAnnotation":
        case "TSArrayType": {
          return { kind: "Object", shapeId: BuiltInArrayId };
        }
        case "BooleanLiteralTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "TSBooleanKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSVoidKeyword":
        case "VoidTypeAnnotation": {
          return { kind: "Primitive" };
        }
        default: {
          return makeType();
        }
      }
    }
    function buildReactiveScopeTerminalsHIR(fn) {
      var queuedRewrites = [];
      recursivelyTraverseItems(
        _toConsumableArray(getScopes(fn)),
        function (scope) {
          return scope.range;
        },
        { fallthroughs: new Map(), rewrites: queuedRewrites, env: fn.env },
        pushStartScopeTerminal,
        pushEndScopeTerminal
      );
      var rewrittenFinalBlocks = new Map();
      var nextBlocks = new Map();
      queuedRewrites.reverse();
      var _iterator116 = _createForOfIteratorHelper(fn.body.blocks),
        _step116;
      try {
        for (_iterator116.s(); !(_step116 = _iterator116.n()).done; ) {
          var _step116$value = _slicedToArray(_step116.value, 2),
            block = _step116$value[1];
          var context = {
            nextBlockId: block.id,
            rewrites: [],
            nextPreds: block.preds,
            instrSliceIdx: 0,
            source: block
          };
          for (var i = 0; i < block.instructions.length + 1; i++) {
            var instrId =
              i < block.instructions.length
                ? block.instructions[i].id
                : block.terminal.id;
            var rewrite = queuedRewrites.at(-1);
            while (rewrite != null && rewrite.instrId <= instrId) {
              handleRewrite(rewrite, i, context);
              queuedRewrites.pop();
              rewrite = queuedRewrites.at(-1);
            }
          }
          if (context.rewrites.length > 0) {
            var finalBlock = {
              id: context.nextBlockId,
              kind: block.kind,
              preds: context.nextPreds,
              terminal: block.terminal,
              instructions: block.instructions.slice(context.instrSliceIdx),
              phis: new Set()
            };
            context.rewrites.push(finalBlock);
            var _iterator118 = _createForOfIteratorHelper(context.rewrites),
              _step118;
            try {
              for (_iterator118.s(); !(_step118 = _iterator118.n()).done; ) {
                var b = _step118.value;
                nextBlocks.set(b.id, b);
              }
            } catch (err) {
              _iterator118.e(err);
            } finally {
              _iterator118.f();
            }
            rewrittenFinalBlocks.set(block.id, finalBlock.id);
          } else {
            nextBlocks.set(block.id, block);
          }
        }
      } catch (err) {
        _iterator116.e(err);
      } finally {
        _iterator116.f();
      }
      var originalBlocks = fn.body.blocks;
      fn.body.blocks = nextBlocks;
      var _iterator117 = _createForOfIteratorHelper(originalBlocks),
        _step117;
      try {
        for (_iterator117.s(); !(_step117 = _iterator117.n()).done; ) {
          var _step117$value = _slicedToArray(_step117.value, 2),
            _block8 = _step117$value[1];
          var _iterator119 = _createForOfIteratorHelper(_block8.phis),
            _step119;
          try {
            for (_iterator119.s(); !(_step119 = _iterator119.n()).done; ) {
              var phi = _step119.value;
              var _iterator120 = _createForOfIteratorHelper(phi.operands),
                _step120;
              try {
                for (_iterator120.s(); !(_step120 = _iterator120.n()).done; ) {
                  var _step120$value = _slicedToArray(_step120.value, 2),
                    originalId = _step120$value[0],
                    value = _step120$value[1];
                  var newId = rewrittenFinalBlocks.get(originalId);
                  if (newId != null) {
                    phi.operands["delete"](originalId);
                    phi.operands.set(newId, value);
                  }
                }
              } catch (err) {
                _iterator120.e(err);
              } finally {
                _iterator120.f();
              }
            }
          } catch (err) {
            _iterator119.e(err);
          } finally {
            _iterator119.f();
          }
        }
      } catch (err) {
        _iterator117.e(err);
      } finally {
        _iterator117.f();
      }
      reversePostorderBlocks(fn.body);
      markPredecessors(fn.body);
      markInstructionIds(fn.body);
      fixScopeAndIdentifierRanges(fn.body);
    }
    function pushStartScopeTerminal(scope, context) {
      var blockId = context.env.nextBlockId;
      var fallthroughId = context.env.nextBlockId;
      context.rewrites.push({
        kind: "StartScope",
        blockId: blockId,
        fallthroughId: fallthroughId,
        instrId: scope.range.start,
        scope: scope
      });
      context.fallthroughs.set(scope.id, fallthroughId);
    }
    function pushEndScopeTerminal(scope, context) {
      var fallthroughId = context.fallthroughs.get(scope.id);
      CompilerError.invariant(fallthroughId != null, {
        reason: "Expected scope to exist",
        loc: GeneratedSource
      });
      context.rewrites.push({
        kind: "EndScope",
        fallthroughId: fallthroughId,
        instrId: scope.range.end
      });
    }
    function handleRewrite(terminalInfo, idx, context) {
      var terminal =
        terminalInfo.kind === "StartScope"
          ? {
              kind: "scope",
              fallthrough: terminalInfo.fallthroughId,
              block: terminalInfo.blockId,
              scope: terminalInfo.scope,
              id: terminalInfo.instrId,
              loc: GeneratedSource
            }
          : {
              kind: "goto",
              variant: GotoVariant.Break,
              block: terminalInfo.fallthroughId,
              id: terminalInfo.instrId,
              loc: GeneratedSource
            };
      var currBlockId = context.nextBlockId;
      context.rewrites.push({
        kind: context.source.kind,
        id: currBlockId,
        instructions: context.source.instructions.slice(
          context.instrSliceIdx,
          idx
        ),
        preds: context.nextPreds,
        phis: context.rewrites.length === 0 ? context.source.phis : new Set(),
        terminal: terminal
      });
      context.nextPreds = new Set([currBlockId]);
      context.nextBlockId =
        terminalInfo.kind === "StartScope"
          ? terminalInfo.blockId
          : terminalInfo.fallthroughId;
      context.instrSliceIdx = idx;
    }
    var ansiStylesExports = {};
    var ansiStyles = {
      get exports() {
        return ansiStylesExports;
      },
      set exports(v) {
        ansiStylesExports = v;
      }
    };
    var conversionsExports = {};
    var conversions$2 = {
      get exports() {
        return conversionsExports;
      },
      set exports(v) {
        conversionsExports = v;
      }
    };
    var colorName = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    var cssKeywords = colorName; // NOTE: conversions should only return primitive values (i.e. arrays, or
    //       values that give correct `typeof` results).
    //       do not use box values types (i.e. Number(), String(), etc.)
    var reverseKeywords = {};
    for (var key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var convert$1 = (conversions$2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    }); // hide .channels and .labels properties
    for (var model in convert$1) {
      if (convert$1.hasOwnProperty(model)) {
        if (!("channels" in convert$1[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert$1[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert$1[model].labels.length !== convert$1[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        var channels = convert$1[model].channels;
        var labels = convert$1[model].labels;
        delete convert$1[model].channels;
        delete convert$1[model].labels;
        Object.defineProperty(convert$1[model], "channels", {
          value: channels
        });
        Object.defineProperty(convert$1[model], "labels", { value: labels });
      }
    }
    convert$1.rgb.hsl = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert$1.rgb.hsv = function (rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function diffc(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [h * 360, s * 100, v * 100];
    };
    convert$1.rgb.hwb = function (rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert$1.rgb.hsl(rgb)[0];
      var w = (1 / 255) * Math.min(r, Math.min(g, b));
      b = 1 - (1 / 255) * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert$1.rgb.cmyk = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    /**
     * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
     * */ function comparativeDistance(x, y) {
      return (
        Math.pow(x[0] - y[0], 2) +
        Math.pow(x[1] - y[1], 2) +
        Math.pow(x[2] - y[2], 2)
      );
    }
    convert$1.rgb.keyword = function (rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword]; // Compute comparative distance
          var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert$1.keyword.rgb = function (keyword) {
      return cssKeywords[keyword];
    };
    convert$1.rgb.xyz = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255; // assume sRGB
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert$1.rgb.lab = function (rgb) {
      var xyz = convert$1.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert$1.hsl.rgb = function (hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + (1 / 3) * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert$1.hsl.hsv = function (hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert$1.hsv.rgb = function (hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert$1.hsv.hsl = function (hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    }; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
    convert$1.hwb.rgb = function (hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n; // wh + bl cant be > 1
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 0x01) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh); // linear interpolation
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert$1.cmyk.rgb = function (cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert$1.xyz.rgb = function (xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057; // assume sRGB
      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert$1.xyz.lab = function (xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert$1.lab.xyz = function (lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert$1.lab.lch = function (lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = (hr * 360) / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert$1.lch.lab = function (lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = (h / 360) * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert$1.rgb.ansi16 = function (args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert$1.rgb.hsv(args)[2]; // hsv -> ansi16 optimization
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi =
        30 +
        ((Math.round(b / 255) << 2) |
          (Math.round(g / 255) << 1) |
          Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert$1.hsv.ansi16 = function (args) {
      // optimization here; we already know the value and don't need to get
      // it converted for us.
      return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
    };
    convert$1.rgb.ansi256 = function (args) {
      var r = args[0];
      var g = args[1];
      var b = args[2]; // we use the extended greyscale palette here, with the exception of
      // black and white. normal palette only has 4 greyscale shades.
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round(((r - 8) / 247) * 24) + 232;
      }
      var ansi =
        16 +
        36 * Math.round((r / 255) * 5) +
        6 * Math.round((g / 255) * 5) +
        Math.round((b / 255) * 5);
      return ansi;
    };
    convert$1.ansi16.rgb = function (args) {
      var color = args % 10; // handle greyscale
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = (color / 10.5) * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = ((color >> 1) & 1) * mult * 255;
      var b = ((color >> 2) & 1) * mult * 255;
      return [r, g, b];
    };
    convert$1.ansi256.rgb = function (args) {
      // handle greyscale
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = (Math.floor(args / 36) / 5) * 255;
      var g = (Math.floor((rem = args % 36) / 6) / 5) * 255;
      var b = ((rem % 6) / 5) * 255;
      return [r, g, b];
    };
    convert$1.rgb.hex = function (args) {
      var integer =
        ((Math.round(args[0]) & 0xff) << 16) +
        ((Math.round(args[1]) & 0xff) << 8) +
        (Math.round(args[2]) & 0xff);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert$1.hex.rgb = function (args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString
          .split("")
          .map(function (_char) {
            return _char + _char;
          })
          .join("");
      }
      var integer = parseInt(colorString, 16);
      var r = (integer >> 16) & 0xff;
      var g = (integer >> 8) & 0xff;
      var b = integer & 0xff;
      return [r, g, b];
    };
    convert$1.rgb.hcg = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = ((g - b) / chroma) % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert$1.hsl.hcg = function (hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2.0 * s * l;
      } else {
        c = 2.0 * s * (1.0 - l);
      }
      if (c < 1.0) {
        f = (l - 0.5 * c) / (1.0 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert$1.hsv.hcg = function (hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1.0) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert$1.hcg.rgb = function (hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0.0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = (h % 1) * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1.0 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert$1.hcg.hsv = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      var f = 0;
      if (v > 0.0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert$1.hcg.hsl = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1.0 - c) + 0.5 * c;
      var s = 0;
      if (l > 0.0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1.0) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert$1.hcg.hwb = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert$1.hwb.hcg = function (hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert$1.apple.rgb = function (apple) {
      return [
        (apple[0] / 65535) * 255,
        (apple[1] / 65535) * 255,
        (apple[2] / 65535) * 255
      ];
    };
    convert$1.rgb.apple = function (rgb) {
      return [
        (rgb[0] / 255) * 65535,
        (rgb[1] / 255) * 65535,
        (rgb[2] / 255) * 65535
      ];
    };
    convert$1.gray.rgb = function (args) {
      return [
        (args[0] / 100) * 255,
        (args[0] / 100) * 255,
        (args[0] / 100) * 255
      ];
    };
    convert$1.gray.hsl = convert$1.gray.hsv = function (args) {
      return [0, 0, args[0]];
    };
    convert$1.gray.hwb = function (gray) {
      return [0, 100, gray[0]];
    };
    convert$1.gray.cmyk = function (gray) {
      return [0, 0, 0, gray[0]];
    };
    convert$1.gray.lab = function (gray) {
      return [gray[0], 0, 0];
    };
    convert$1.gray.hex = function (gray) {
      var val = Math.round((gray[0] / 100) * 255) & 0xff;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert$1.rgb.gray = function (rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [(val / 255) * 100];
    };
    var conversions$1 = conversionsExports;
    /*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/ function buildGraph() {
      var graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3
      var models = Object.keys(conversions$1);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    } // https://en.wikipedia.org/wiki/Breadth-first_search
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel]; // unshift -> queue -> pop
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions$1[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function (args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions$1[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions$1[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    var route$1 = function route$1(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          // no possible conversion, or this node is the source model.
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
    var conversions = conversionsExports;
    var route = route$1;
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function wrappedFn(args) {
        if (args === undefined || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      }; // preserve .conversion property if there is one
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function wrappedFn(args) {
        if (args === undefined || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args); // we're assuming the result is an array here.
        // see notice in conversions.js; don't use box types
        // in conversion functions.
        if (_typeof(result) === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      }; // preserve .conversion property if there is one
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function (fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", {
        value: conversions[fromModel].channels
      });
      Object.defineProperty(convert[fromModel], "labels", {
        value: conversions[fromModel].labels
      });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function (toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    var colorConvert = convert;
    (function (module) {
      var colorConvert$1 = colorConvert;
      var wrapAnsi16 = function wrapAnsi16(fn, offset) {
        return function () {
          var code = fn.apply(colorConvert$1, arguments);
          return "\x1B[".concat(code + offset, "m");
        };
      };
      var wrapAnsi256 = function wrapAnsi256(fn, offset) {
        return function () {
          var code = fn.apply(colorConvert$1, arguments);
          return "\x1B[".concat(38 + offset, ";5;").concat(code, "m");
        };
      };
      var wrapAnsi16m = function wrapAnsi16m(fn, offset) {
        return function () {
          var rgb = fn.apply(colorConvert$1, arguments);
          return "\x1B["
            .concat(38 + offset, ";2;")
            .concat(rgb[0], ";")
            .concat(rgb[1], ";")
            .concat(rgb[2], "m");
        };
      };
      function assembleStyles() {
        var codes = new Map();
        var styles = {
          modifier: {
            reset: [0, 0], // 21 isn't widely supported and 22 does the same thing
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            gray: [90, 39], // Bright color
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49], // Bright color
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        }; // Fix humans
        styles.color.grey = styles.color.gray;
        for (
          var _i26 = 0, _Object$keys12 = Object.keys(styles);
          _i26 < _Object$keys12.length;
          _i26++
        ) {
          var groupName = _Object$keys12[_i26];
          var group = styles[groupName];
          for (
            var _i27 = 0, _Object$keys13 = Object.keys(group);
            _i27 < _Object$keys13.length;
            _i27++
          ) {
            var styleName = _Object$keys13[_i27];
            var style = group[styleName];
            styles[styleName] = {
              open: "\x1B[".concat(style[0], "m"),
              close: "\x1B[".concat(style[1], "m")
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
          }
          Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
          });
          Object.defineProperty(styles, "codes", {
            value: codes,
            enumerable: false
          });
        }
        var ansi2ansi = function ansi2ansi(n) {
          return n;
        };
        var rgb2rgb = function rgb2rgb(r, g, b) {
          return [r, g, b];
        };
        styles.color.close = "\x1B[39m";
        styles.bgColor.close = "\x1B[49m";
        styles.color.ansi = { ansi: wrapAnsi16(ansi2ansi, 0) };
        styles.color.ansi256 = { ansi256: wrapAnsi256(ansi2ansi, 0) };
        styles.color.ansi16m = { rgb: wrapAnsi16m(rgb2rgb, 0) };
        styles.bgColor.ansi = { ansi: wrapAnsi16(ansi2ansi, 10) };
        styles.bgColor.ansi256 = { ansi256: wrapAnsi256(ansi2ansi, 10) };
        styles.bgColor.ansi16m = { rgb: wrapAnsi16m(rgb2rgb, 10) };
        for (
          var _i28 = 0, _Object$keys14 = Object.keys(colorConvert$1);
          _i28 < _Object$keys14.length;
          _i28++
        ) {
          var _key27 = _Object$keys14[_i28];
          if (_typeof(colorConvert$1[_key27]) !== "object") {
            continue;
          }
          var suite = colorConvert$1[_key27];
          if (_key27 === "ansi16") {
            _key27 = "ansi";
          }
          if ("ansi16" in suite) {
            styles.color.ansi[_key27] = wrapAnsi16(suite.ansi16, 0);
            styles.bgColor.ansi[_key27] = wrapAnsi16(suite.ansi16, 10);
          }
          if ("ansi256" in suite) {
            styles.color.ansi256[_key27] = wrapAnsi256(suite.ansi256, 0);
            styles.bgColor.ansi256[_key27] = wrapAnsi256(suite.ansi256, 10);
          }
          if ("rgb" in suite) {
            styles.color.ansi16m[_key27] = wrapAnsi16m(suite.rgb, 0);
            styles.bgColor.ansi16m[_key27] = wrapAnsi16m(suite.rgb, 10);
          }
        }
        return styles;
      } // Make the export immutable
      Object.defineProperty(module, "exports", {
        enumerable: true,
        get: assembleStyles
      });
    })(ansiStyles);
    var collections = {};
    Object.defineProperty(collections, "__esModule", { value: true });
    collections.printIteratorEntries = printIteratorEntries;
    collections.printIteratorValues = printIteratorValues;
    collections.printListItems = printListItems;
    collections.printObjectProperties = printObjectProperties;
    /**
     * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
 *
 * @noformat
 * @nolint
 * @lightSyntaxTransform
 * @preventMunge
 * @oncall react_core
     *
     */ var getKeysOfEnumerableProperties =
      function getKeysOfEnumerableProperties(object) {
        var keys = Object.keys(object).sort();
        if (Object.getOwnPropertySymbols) {
          Object.getOwnPropertySymbols(object).forEach(function (symbol) {
            if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
              keys.push(symbol);
            }
          });
        }
        return keys;
      };
    /**
     * Return entries (for example, of a map)
     * with spacing, indentation, and comma
     * without surrounding punctuation (for example, braces)
     */ function printIteratorEntries( // Flow 0.51.0: property `@@iterator` of $Iterator not found in Object
      // To allow simplistic getRecordIterator in immutable.js
      iterator,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      var separator =
        arguments.length > 6 && arguments[6] !== undefined
          ? arguments[6]
          : ": ";
      var result = "";
      var current = iterator.next();
      if (!current.done) {
        result += config.spacingOuter;
        var indentationNext = indentation + config.indent;
        while (!current.done) {
          var name = printer(
            current.value[0],
            config,
            indentationNext,
            depth,
            refs
          );
          var value = printer(
            current.value[1],
            config,
            indentationNext,
            depth,
            refs
          );
          result += indentationNext + name + separator + value;
          current = iterator.next();
          if (!current.done) {
            result += "," + config.spacingInner;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    /**
     * Return values (for example, of a set)
     * with spacing, indentation, and comma
     * without surrounding punctuation (braces or brackets)
     */ function printIteratorValues(
      iterator,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      var result = "";
      var current = iterator.next();
      if (!current.done) {
        result += config.spacingOuter;
        var indentationNext = indentation + config.indent;
        while (!current.done) {
          result +=
            indentationNext +
            printer(current.value, config, indentationNext, depth, refs);
          current = iterator.next();
          if (!current.done) {
            result += "," + config.spacingInner;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    /**
     * Return items (for example, of an array)
     * with spacing, indentation, and comma
     * without surrounding punctuation (for example, brackets)
     **/ function printListItems(
      list,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      var result = "";
      if (list.length) {
        result += config.spacingOuter;
        var indentationNext = indentation + config.indent;
        for (var i = 0; i < list.length; i++) {
          result +=
            indentationNext +
            printer(list[i], config, indentationNext, depth, refs);
          if (i < list.length - 1) {
            result += "," + config.spacingInner;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    /**
     * Return properties of an object
     * with spacing, indentation, and comma
     * without surrounding punctuation (for example, braces)
     */ function printObjectProperties(
      val,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      var result = "";
      var keys = getKeysOfEnumerableProperties(val);
      if (keys.length) {
        result += config.spacingOuter;
        var indentationNext = indentation + config.indent;
        for (var i = 0; i < keys.length; i++) {
          var _key28 = keys[i];
          var name = printer(_key28, config, indentationNext, depth, refs);
          var value = printer(
            val[_key28],
            config,
            indentationNext,
            depth,
            refs
          );
          result += indentationNext + name + ": " + value;
          if (i < keys.length - 1) {
            result += "," + config.spacingInner;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    var AsymmetricMatcher = {};
    Object.defineProperty(AsymmetricMatcher, "__esModule", { value: true });
    AsymmetricMatcher["default"] =
      AsymmetricMatcher.test =
      AsymmetricMatcher.serialize =
        void 0;
    var _collections$3 = collections;
    var Symbol$3 =
      commonjsGlobal["jest-symbol-do-not-touch"] || commonjsGlobal.Symbol;
    var asymmetricMatcher = Symbol$3["for"]("jest.asymmetricMatcher");
    var SPACE$2 = " ";
    var serialize$6 = function serialize$6(
      val,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      var stringedValue = val.toString();
      if (
        stringedValue === "ArrayContaining" ||
        stringedValue === "ArrayNotContaining"
      ) {
        if (++depth > config.maxDepth) {
          return "[" + stringedValue + "]";
        }
        return (
          stringedValue +
          SPACE$2 +
          "[" +
          (0, _collections$3.printListItems)(
            val.sample,
            config,
            indentation,
            depth,
            refs,
            printer
          ) +
          "]"
        );
      }
      if (
        stringedValue === "ObjectContaining" ||
        stringedValue === "ObjectNotContaining"
      ) {
        if (++depth > config.maxDepth) {
          return "[" + stringedValue + "]";
        }
        return (
          stringedValue +
          SPACE$2 +
          "{" +
          (0, _collections$3.printObjectProperties)(
            val.sample,
            config,
            indentation,
            depth,
            refs,
            printer
          ) +
          "}"
        );
      }
      if (
        stringedValue === "StringMatching" ||
        stringedValue === "StringNotMatching"
      ) {
        return (
          stringedValue +
          SPACE$2 +
          printer(val.sample, config, indentation, depth, refs)
        );
      }
      if (
        stringedValue === "StringContaining" ||
        stringedValue === "StringNotContaining"
      ) {
        return (
          stringedValue +
          SPACE$2 +
          printer(val.sample, config, indentation, depth, refs)
        );
      }
      return val.toAsymmetricMatcher();
    };
    AsymmetricMatcher.serialize = serialize$6;
    var test$6 = function test$6(val) {
      return val && val.$$typeof === asymmetricMatcher;
    };
    AsymmetricMatcher.test = test$6;
    var plugin$7 = { serialize: serialize$6, test: test$6 };
    var _default$6 = plugin$7;
    AsymmetricMatcher["default"] = _default$6;
    var ConvertAnsi = {};
    var ansiRegex = function ansiRegex(options) {
      options = Object.assign({ onlyFirst: false }, options);
      var pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, options.onlyFirst ? undefined : "g");
    };
    Object.defineProperty(ConvertAnsi, "__esModule", { value: true });
    ConvertAnsi["default"] = ConvertAnsi.serialize = ConvertAnsi.test = void 0;
    var _ansiRegex = _interopRequireDefault$2(ansiRegex);
    var _ansiStyles$1 = _interopRequireDefault$2(ansiStylesExports);
    function _interopRequireDefault$2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    /**
     * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
 *
 * @noformat
 * @nolint
 * @lightSyntaxTransform
 * @preventMunge
 * @oncall react_core
     */ var toHumanReadableAnsi = function toHumanReadableAnsi(text) {
      return text.replace((0, _ansiRegex["default"])(), function (match) {
        switch (match) {
          case _ansiStyles$1["default"].red.close:
          case _ansiStyles$1["default"].green.close:
          case _ansiStyles$1["default"].cyan.close:
          case _ansiStyles$1["default"].gray.close:
          case _ansiStyles$1["default"].white.close:
          case _ansiStyles$1["default"].yellow.close:
          case _ansiStyles$1["default"].bgRed.close:
          case _ansiStyles$1["default"].bgGreen.close:
          case _ansiStyles$1["default"].bgYellow.close:
          case _ansiStyles$1["default"].inverse.close:
          case _ansiStyles$1["default"].dim.close:
          case _ansiStyles$1["default"].bold.close:
          case _ansiStyles$1["default"].reset.open:
          case _ansiStyles$1["default"].reset.close:
            return "</>";
          case _ansiStyles$1["default"].red.open:
            return "<red>";
          case _ansiStyles$1["default"].green.open:
            return "<green>";
          case _ansiStyles$1["default"].cyan.open:
            return "<cyan>";
          case _ansiStyles$1["default"].gray.open:
            return "<gray>";
          case _ansiStyles$1["default"].white.open:
            return "<white>";
          case _ansiStyles$1["default"].yellow.open:
            return "<yellow>";
          case _ansiStyles$1["default"].bgRed.open:
            return "<bgRed>";
          case _ansiStyles$1["default"].bgGreen.open:
            return "<bgGreen>";
          case _ansiStyles$1["default"].bgYellow.open:
            return "<bgYellow>";
          case _ansiStyles$1["default"].inverse.open:
            return "<inverse>";
          case _ansiStyles$1["default"].dim.open:
            return "<dim>";
          case _ansiStyles$1["default"].bold.open:
            return "<bold>";
          default:
            return "";
        }
      });
    };
    var test$5 = function test$5(val) {
      return (
        typeof val === "string" && !!val.match((0, _ansiRegex["default"])())
      );
    };
    ConvertAnsi.test = test$5;
    var serialize$5 = function serialize$5(
      val,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      return printer(
        toHumanReadableAnsi(val),
        config,
        indentation,
        depth,
        refs
      );
    };
    ConvertAnsi.serialize = serialize$5;
    var plugin$6 = { serialize: serialize$5, test: test$5 };
    var _default$5 = plugin$6;
    ConvertAnsi["default"] = _default$5;
    var DOMCollection = {};
    Object.defineProperty(DOMCollection, "__esModule", { value: true });
    DOMCollection["default"] =
      DOMCollection.serialize =
      DOMCollection.test =
        void 0;
    var _collections$2 = collections;
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys = ownKeys.concat(
            Object.getOwnPropertySymbols(source).filter(function (sym) {
              return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            })
          );
        }
        ownKeys.forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var SPACE$1 = " ";
    var OBJECT_NAMES = ["DOMStringMap", "NamedNodeMap"];
    var ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
    var testName = function testName(name) {
      return OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
    };
    var test$4 = function test$4(val) {
      return (
        val &&
        val.constructor &&
        val.constructor.name &&
        testName(val.constructor.name)
      );
    }; // Convert array of attribute objects to props object.
    DOMCollection.test = test$4;
    var propsReducer = function propsReducer(props, attribute) {
      props[attribute.name] = attribute.value;
      return props;
    };
    var serialize$4 = function serialize$4(
      collection,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      var name = collection.constructor.name;
      if (++depth > config.maxDepth) {
        return "[" + name + "]";
      }
      return (
        (config.min ? "" : name + SPACE$1) +
        (OBJECT_NAMES.indexOf(name) !== -1
          ? "{" +
            (0, _collections$2.printObjectProperties)(
              name === "NamedNodeMap"
                ? Array.prototype.reduce.call(collection, propsReducer, {})
                : _objectSpread({}, collection),
              config,
              indentation,
              depth,
              refs,
              printer
            ) +
            "}"
          : "[" +
            (0, _collections$2.printListItems)(
              Array.from(collection),
              config,
              indentation,
              depth,
              refs,
              printer
            ) +
            "]")
      );
    };
    DOMCollection.serialize = serialize$4;
    var plugin$5 = { serialize: serialize$4, test: test$4 };
    var _default$4 = plugin$5;
    DOMCollection["default"] = _default$4;
    var DOMElement = {};
    var markup = {};
    var escapeHTML$1 = {};
    Object.defineProperty(escapeHTML$1, "__esModule", { value: true });
    escapeHTML$1["default"] = escapeHTML;
    /**
     * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
 *
 * @noformat
 * @nolint
 * @lightSyntaxTransform
 * @preventMunge
 * @oncall react_core
     */ function escapeHTML(str) {
      return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    Object.defineProperty(markup, "__esModule", { value: true });
    markup.printElementAsLeaf =
      markup.printElement =
      markup.printComment =
      markup.printText =
      markup.printChildren =
      markup.printProps =
        void 0;
    var _escapeHTML = _interopRequireDefault$1(escapeHTML$1);
    function _interopRequireDefault$1(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    } /**
     * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
 *
 * @noformat
 * @nolint
 * @lightSyntaxTransform
 * @preventMunge
 * @oncall react_core
     */ // Return empty string if keys is empty.
    var printProps = function printProps(
      keys,
      props,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      var indentationNext = indentation + config.indent;
      var colors = config.colors;
      return keys
        .map(function (key) {
          var value = props[key];
          var printed = printer(value, config, indentationNext, depth, refs);
          if (typeof value !== "string") {
            if (printed.indexOf("\n") !== -1) {
              printed =
                config.spacingOuter +
                indentationNext +
                printed +
                config.spacingOuter +
                indentation;
            }
            printed = "{" + printed + "}";
          }
          return (
            config.spacingInner +
            indentation +
            colors.prop.open +
            key +
            colors.prop.close +
            "=" +
            colors.value.open +
            printed +
            colors.value.close
          );
        })
        .join("");
    }; // Return empty string if children is empty.
    markup.printProps = printProps;
    var printChildren = function printChildren(
      children,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      return children
        .map(function (child) {
          return (
            config.spacingOuter +
            indentation +
            (typeof child === "string"
              ? printText(child, config)
              : printer(child, config, indentation, depth, refs))
          );
        })
        .join("");
    };
    markup.printChildren = printChildren;
    var printText = function printText(text, config) {
      var contentColor = config.colors.content;
      return (
        contentColor.open +
        (0, _escapeHTML["default"])(text) +
        contentColor.close
      );
    };
    markup.printText = printText;
    var printComment = function printComment(comment, config) {
      var commentColor = config.colors.comment;
      return (
        commentColor.open +
        "<!--" +
        (0, _escapeHTML["default"])(comment) +
        "-->" +
        commentColor.close
      );
    }; // Separate the functions to format props, children, and element,
    // so a plugin could override a particular function, if needed.
    // Too bad, so sad: the traditional (but unnecessary) space
    // in a self-closing tagColor requires a second test of printedProps.
    markup.printComment = printComment;
    var printElement = function printElement(
      type,
      printedProps,
      printedChildren,
      config,
      indentation
    ) {
      var tagColor = config.colors.tag;
      return (
        tagColor.open +
        "<" +
        type +
        (printedProps &&
          tagColor.close +
            printedProps +
            config.spacingOuter +
            indentation +
            tagColor.open) +
        (printedChildren
          ? ">" +
            tagColor.close +
            printedChildren +
            config.spacingOuter +
            indentation +
            tagColor.open +
            "</" +
            type
          : (printedProps && !config.min ? "" : " ") + "/") +
        ">" +
        tagColor.close
      );
    };
    markup.printElement = printElement;
    var printElementAsLeaf = function printElementAsLeaf(type, config) {
      var tagColor = config.colors.tag;
      return (
        tagColor.open +
        "<" +
        type +
        tagColor.close +
        " …" +
        tagColor.open +
        " />" +
        tagColor.close
      );
    };
    markup.printElementAsLeaf = printElementAsLeaf;
    Object.defineProperty(DOMElement, "__esModule", { value: true });
    DOMElement["default"] = DOMElement.serialize = DOMElement.test = void 0;
    var _markup$2 = markup;
    /**
     * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
 *
 * @noformat
 * @nolint
 * @lightSyntaxTransform
 * @preventMunge
 * @oncall react_core
     */ var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var COMMENT_NODE = 8;
    var FRAGMENT_NODE = 11;
    var ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
    var testNode = function testNode(nodeType, name) {
      return (
        (nodeType === ELEMENT_NODE && ELEMENT_REGEXP.test(name)) ||
        (nodeType === TEXT_NODE && name === "Text") ||
        (nodeType === COMMENT_NODE && name === "Comment") ||
        (nodeType === FRAGMENT_NODE && name === "DocumentFragment")
      );
    };
    var test$3 = function test$3(val) {
      return (
        val &&
        val.constructor &&
        val.constructor.name &&
        testNode(val.nodeType, val.constructor.name)
      );
    };
    DOMElement.test = test$3;
    function nodeIsText(node) {
      return node.nodeType === TEXT_NODE;
    }
    function nodeIsComment(node) {
      return node.nodeType === COMMENT_NODE;
    }
    function nodeIsFragment(node) {
      return node.nodeType === FRAGMENT_NODE;
    }
    var serialize$3 = function serialize$3(
      node,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      if (nodeIsText(node)) {
        return (0, _markup$2.printText)(node.data, config);
      }
      if (nodeIsComment(node)) {
        return (0, _markup$2.printComment)(node.data, config);
      }
      var type = nodeIsFragment(node)
        ? "DocumentFragment"
        : node.tagName.toLowerCase();
      if (++depth > config.maxDepth) {
        return (0, _markup$2.printElementAsLeaf)(type, config);
      }
      return (0, _markup$2.printElement)(
        type,
        (0, _markup$2.printProps)(
          nodeIsFragment(node)
            ? []
            : Array.from(node.attributes)
                .map(function (attr) {
                  return attr.name;
                })
                .sort(),
          nodeIsFragment(node)
            ? []
            : Array.from(node.attributes).reduce(function (props, attribute) {
                props[attribute.name] = attribute.value;
                return props;
              }, {}),
          config,
          indentation + config.indent,
          depth,
          refs,
          printer
        ),
        (0, _markup$2.printChildren)(
          Array.prototype.slice.call(node.childNodes || node.children),
          config,
          indentation + config.indent,
          depth,
          refs,
          printer
        ),
        config,
        indentation
      );
    };
    DOMElement.serialize = serialize$3;
    var plugin$4 = { serialize: serialize$3, test: test$3 };
    var _default$3 = plugin$4;
    DOMElement["default"] = _default$3;
    var Immutable = {};
    Object.defineProperty(Immutable, "__esModule", { value: true });
    Immutable["default"] = Immutable.test = Immutable.serialize = void 0;
    var _collections$1 = collections; /**
     * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
 *
 * @noformat
 * @nolint
 * @lightSyntaxTransform
 * @preventMunge
 * @oncall react_core
     */ // SENTINEL constants are from https://github.com/facebook/immutable-js
    var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
    var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
    var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
    var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
    var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
    var IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@"; // immutable v4
    var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
    var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
    var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
    var getImmutableName = function getImmutableName(name) {
      return "Immutable." + name;
    };
    var printAsLeaf = function printAsLeaf(name) {
      return "[" + name + "]";
    };
    var SPACE = " ";
    var LAZY = "…"; // Seq is lazy if it calls a method like filter
    var printImmutableEntries = function printImmutableEntries(
      val,
      config,
      indentation,
      depth,
      refs,
      printer,
      type
    ) {
      return ++depth > config.maxDepth
        ? printAsLeaf(getImmutableName(type))
        : getImmutableName(type) +
            SPACE +
            "{" +
            (0, _collections$1.printIteratorEntries)(
              val.entries(),
              config,
              indentation,
              depth,
              refs,
              printer
            ) +
            "}";
    }; // Record has an entries method because it is a collection in immutable v3.
    // Return an iterator for Immutable Record from version v3 or v4.
    var getRecordEntries = function getRecordEntries(val) {
      var i = 0;
      return {
        next: function next() {
          if (i < val._keys.length) {
            var _key29 = val._keys[i++];
            return { done: false, value: [_key29, val.get(_key29)] };
          }
          return { done: true };
        }
      };
    };
    var printImmutableRecord = function printImmutableRecord(
      val,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      // _name property is defined only for an Immutable Record instance
      // which was constructed with a second optional descriptive name arg
      var name = getImmutableName(val._name || "Record");
      return ++depth > config.maxDepth
        ? printAsLeaf(name)
        : name +
            SPACE +
            "{" +
            (0, _collections$1.printIteratorEntries)(
              getRecordEntries(val),
              config,
              indentation,
              depth,
              refs,
              printer
            ) +
            "}";
    };
    var printImmutableSeq = function printImmutableSeq(
      val,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      var name = getImmutableName("Seq");
      if (++depth > config.maxDepth) {
        return printAsLeaf(name);
      }
      if (val[IS_KEYED_SENTINEL]) {
        return (
          name +
          SPACE +
          "{" + // from Immutable collection of entries or from ECMAScript object
          (val._iter || val._object
            ? (0, _collections$1.printIteratorEntries)(
                val.entries(),
                config,
                indentation,
                depth,
                refs,
                printer
              )
            : LAZY) +
          "}"
        );
      }
      return (
        name +
        SPACE +
        "[" +
        (val._iter || // from Immutable collection of values
        val._array || // from ECMAScript array
        val._collection || // from ECMAScript collection in immutable v4
        val._iterable // from ECMAScript collection in immutable v3
          ? (0, _collections$1.printIteratorValues)(
              val.values(),
              config,
              indentation,
              depth,
              refs,
              printer
            )
          : LAZY) +
        "]"
      );
    };
    var printImmutableValues = function printImmutableValues(
      val,
      config,
      indentation,
      depth,
      refs,
      printer,
      type
    ) {
      return ++depth > config.maxDepth
        ? printAsLeaf(getImmutableName(type))
        : getImmutableName(type) +
            SPACE +
            "[" +
            (0, _collections$1.printIteratorValues)(
              val.values(),
              config,
              indentation,
              depth,
              refs,
              printer
            ) +
            "]";
    };
    var serialize$2 = function serialize$2(
      val,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      if (val[IS_MAP_SENTINEL]) {
        return printImmutableEntries(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map"
        );
      }
      if (val[IS_LIST_SENTINEL]) {
        return printImmutableValues(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          "List"
        );
      }
      if (val[IS_SET_SENTINEL]) {
        return printImmutableValues(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set"
        );
      }
      if (val[IS_STACK_SENTINEL]) {
        return printImmutableValues(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          "Stack"
        );
      }
      if (val[IS_SEQ_SENTINEL]) {
        return printImmutableSeq(
          val,
          config,
          indentation,
          depth,
          refs,
          printer
        );
      } // For compatibility with immutable v3 and v4, let record be the default.
      return printImmutableRecord(
        val,
        config,
        indentation,
        depth,
        refs,
        printer
      );
    }; // Explicitly comparing sentinel properties to true avoids false positive
    // when mock identity-obj-proxy returns the key as the value for any key.
    Immutable.serialize = serialize$2;
    var test$2 = function test$2(val) {
      return (
        val &&
        (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true)
      );
    };
    Immutable.test = test$2;
    var plugin$3 = { serialize: serialize$2, test: test$2 };
    var _default$2 = plugin$3;
    Immutable["default"] = _default$2;
    var ReactElement = {};
    var reactIsExports = {};
    var reactIs = {
      get exports() {
        return reactIsExports;
      },
      set exports(v) {
        reactIsExports = v;
      }
    };
    var reactIs_development = {};
    var hasRequiredReactIs_development;
    function requireReactIs_development() {
      if (hasRequiredReactIs_development) return reactIs_development;
      hasRequiredReactIs_development = 1;
      {
        (function () {
          // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
          // nor polyfill, then a plain number is used for performance.
          var hasSymbol = typeof Symbol === "function" && Symbol["for"];
          var REACT_ELEMENT_TYPE = hasSymbol
            ? Symbol["for"]("react.element")
            : 0xeac7;
          var REACT_PORTAL_TYPE = hasSymbol
            ? Symbol["for"]("react.portal")
            : 0xeaca;
          var REACT_FRAGMENT_TYPE = hasSymbol
            ? Symbol["for"]("react.fragment")
            : 0xeacb;
          var REACT_STRICT_MODE_TYPE = hasSymbol
            ? Symbol["for"]("react.strict_mode")
            : 0xeacc;
          var REACT_PROFILER_TYPE = hasSymbol
            ? Symbol["for"]("react.profiler")
            : 0xead2;
          var REACT_PROVIDER_TYPE = hasSymbol
            ? Symbol["for"]("react.provider")
            : 0xeacd;
          var REACT_CONTEXT_TYPE = hasSymbol
            ? Symbol["for"]("react.context")
            : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
          // (unstable) APIs that have been removed. Can we remove the symbols?
          var REACT_ASYNC_MODE_TYPE = hasSymbol
            ? Symbol["for"]("react.async_mode")
            : 0xeacf;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol
            ? Symbol["for"]("react.concurrent_mode")
            : 0xeacf;
          var REACT_FORWARD_REF_TYPE = hasSymbol
            ? Symbol["for"]("react.forward_ref")
            : 0xead0;
          var REACT_SUSPENSE_TYPE = hasSymbol
            ? Symbol["for"]("react.suspense")
            : 0xead1;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol
            ? Symbol["for"]("react.suspense_list")
            : 0xead8;
          var REACT_MEMO_TYPE = hasSymbol
            ? Symbol["for"]("react.memo")
            : 0xead3;
          var REACT_LAZY_TYPE = hasSymbol
            ? Symbol["for"]("react.lazy")
            : 0xead4;
          var REACT_BLOCK_TYPE = hasSymbol
            ? Symbol["for"]("react.block")
            : 0xead9;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol
            ? Symbol["for"]("react.fundamental")
            : 0xead5;
          var REACT_RESPONDER_TYPE = hasSymbol
            ? Symbol["for"]("react.responder")
            : 0xead6;
          var REACT_SCOPE_TYPE = hasSymbol
            ? Symbol["for"]("react.scope")
            : 0xead7;
          function isValidElementType(type) {
            return (
              typeof type === "string" ||
              typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
              type === REACT_FRAGMENT_TYPE ||
              type === REACT_CONCURRENT_MODE_TYPE ||
              type === REACT_PROFILER_TYPE ||
              type === REACT_STRICT_MODE_TYPE ||
              type === REACT_SUSPENSE_TYPE ||
              type === REACT_SUSPENSE_LIST_TYPE ||
              (_typeof(type) === "object" &&
                type !== null &&
                (type.$$typeof === REACT_LAZY_TYPE ||
                  type.$$typeof === REACT_MEMO_TYPE ||
                  type.$$typeof === REACT_PROVIDER_TYPE ||
                  type.$$typeof === REACT_CONTEXT_TYPE ||
                  type.$$typeof === REACT_FORWARD_REF_TYPE ||
                  type.$$typeof === REACT_FUNDAMENTAL_TYPE ||
                  type.$$typeof === REACT_RESPONDER_TYPE ||
                  type.$$typeof === REACT_SCOPE_TYPE ||
                  type.$$typeof === REACT_BLOCK_TYPE))
            );
          }
          function typeOf(object) {
            if (_typeof(object) === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return undefined;
          } // AsyncMode is deprecated along with isAsyncMode
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint
                console["warn"](
                  "The ReactIs.isAsyncMode() alias has been deprecated, " +
                    "and will be removed in React 17+. Update your code to use " +
                    "ReactIs.isConcurrentMode() instead. It has the exact same API."
                );
              }
            }
            return (
              isConcurrentMode(object) ||
              typeOf(object) === REACT_ASYNC_MODE_TYPE
            );
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement(object) {
            return (
              _typeof(object) === "object" &&
              object !== null &&
              object.$$typeof === REACT_ELEMENT_TYPE
            );
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          reactIs_development.AsyncMode = AsyncMode;
          reactIs_development.ConcurrentMode = ConcurrentMode;
          reactIs_development.ContextConsumer = ContextConsumer;
          reactIs_development.ContextProvider = ContextProvider;
          reactIs_development.Element = Element;
          reactIs_development.ForwardRef = ForwardRef;
          reactIs_development.Fragment = Fragment;
          reactIs_development.Lazy = Lazy;
          reactIs_development.Memo = Memo;
          reactIs_development.Portal = Portal;
          reactIs_development.Profiler = Profiler;
          reactIs_development.StrictMode = StrictMode;
          reactIs_development.Suspense = Suspense;
          reactIs_development.isAsyncMode = isAsyncMode;
          reactIs_development.isConcurrentMode = isConcurrentMode;
          reactIs_development.isContextConsumer = isContextConsumer;
          reactIs_development.isContextProvider = isContextProvider;
          reactIs_development.isElement = isElement;
          reactIs_development.isForwardRef = isForwardRef;
          reactIs_development.isFragment = isFragment;
          reactIs_development.isLazy = isLazy;
          reactIs_development.isMemo = isMemo;
          reactIs_development.isPortal = isPortal;
          reactIs_development.isProfiler = isProfiler;
          reactIs_development.isStrictMode = isStrictMode;
          reactIs_development.isSuspense = isSuspense;
          reactIs_development.isValidElementType = isValidElementType;
          reactIs_development.typeOf = typeOf;
        })();
      }
      return reactIs_development;
    }
    (function (module) {
      {
        module.exports = requireReactIs_development();
      }
    })(reactIs);
    Object.defineProperty(ReactElement, "__esModule", { value: true });
    ReactElement["default"] =
      ReactElement.test =
      ReactElement.serialize =
        void 0;
    var ReactIs = _interopRequireWildcard(reactIsExports);
    var _markup$1 = markup;
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(obj, key)
                  : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    } /**
     * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
 *
 * @noformat
 * @nolint
 * @lightSyntaxTransform
 * @preventMunge
 * @oncall react_core
     */ // Given element.props.children, or subtree during recursive traversal,
    // return flattened array of children.
    var _getChildren = function getChildren(arg) {
      var children =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      if (Array.isArray(arg)) {
        arg.forEach(function (item) {
          _getChildren(item, children);
        });
      } else if (arg != null && arg !== false) {
        children.push(arg);
      }
      return children;
    };
    var getType = function getType(element) {
      var type = element.type;
      if (typeof type === "string") {
        return type;
      }
      if (typeof type === "function") {
        return type.displayName || type.name || "Unknown";
      }
      if (ReactIs.isFragment(element)) {
        return "React.Fragment";
      }
      if (ReactIs.isSuspense(element)) {
        return "React.Suspense";
      }
      if (_typeof(type) === "object" && type !== null) {
        if (ReactIs.isContextProvider(element)) {
          return "Context.Provider";
        }
        if (ReactIs.isContextConsumer(element)) {
          return "Context.Consumer";
        }
        if (ReactIs.isForwardRef(element)) {
          var functionName = type.render.displayName || type.render.name || "";
          return functionName !== ""
            ? "ForwardRef(" + functionName + ")"
            : "ForwardRef";
        }
        if (ReactIs.isMemo(type)) {
          var _functionName =
            type.displayName || type.type.displayName || type.type.name || "";
          return _functionName !== "" ? "Memo(" + _functionName + ")" : "Memo";
        }
      }
      return "UNDEFINED";
    };
    var getPropKeys$1 = function getPropKeys$1(element) {
      var props = element.props;
      return Object.keys(props)
        .filter(function (key) {
          return key !== "children" && props[key] !== undefined;
        })
        .sort();
    };
    var serialize$1 = function serialize$1(
      element,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      return ++depth > config.maxDepth
        ? (0, _markup$1.printElementAsLeaf)(getType(element), config)
        : (0, _markup$1.printElement)(
            getType(element),
            (0, _markup$1.printProps)(
              getPropKeys$1(element),
              element.props,
              config,
              indentation + config.indent,
              depth,
              refs,
              printer
            ),
            (0, _markup$1.printChildren)(
              _getChildren(element.props.children),
              config,
              indentation + config.indent,
              depth,
              refs,
              printer
            ),
            config,
            indentation
          );
    };
    ReactElement.serialize = serialize$1;
    var test$1 = function test$1(val) {
      return val && ReactIs.isElement(val);
    };
    ReactElement.test = test$1;
    var plugin$2 = { serialize: serialize$1, test: test$1 };
    var _default$1 = plugin$2;
    ReactElement["default"] = _default$1;
    var ReactTestComponent = {};
    Object.defineProperty(ReactTestComponent, "__esModule", { value: true });
    ReactTestComponent["default"] =
      ReactTestComponent.test =
      ReactTestComponent.serialize =
        void 0;
    var _markup = markup;
    var Symbol$2 =
      commonjsGlobal["jest-symbol-do-not-touch"] || commonjsGlobal.Symbol;
    var testSymbol = Symbol$2["for"]("react.test.json");
    var getPropKeys = function getPropKeys(object) {
      var props = object.props;
      return props
        ? Object.keys(props)
            .filter(function (key) {
              return props[key] !== undefined;
            })
            .sort()
        : [];
    };
    var serialize = function serialize(
      object,
      config,
      indentation,
      depth,
      refs,
      printer
    ) {
      return ++depth > config.maxDepth
        ? (0, _markup.printElementAsLeaf)(object.type, config)
        : (0, _markup.printElement)(
            object.type,
            object.props
              ? (0, _markup.printProps)(
                  getPropKeys(object),
                  object.props,
                  config,
                  indentation + config.indent,
                  depth,
                  refs,
                  printer
                )
              : "",
            object.children
              ? (0, _markup.printChildren)(
                  object.children,
                  config,
                  indentation + config.indent,
                  depth,
                  refs,
                  printer
                )
              : "",
            config,
            indentation
          );
    };
    ReactTestComponent.serialize = serialize;
    var test = function test(val) {
      return val && val.$$typeof === testSymbol;
    };
    ReactTestComponent.test = test;
    var plugin$1 = { serialize: serialize, test: test };
    var _default = plugin$1;
    ReactTestComponent["default"] = _default;
    var _ansiStyles = _interopRequireDefault(ansiStylesExports);
    var _collections = collections;
    var _AsymmetricMatcher = _interopRequireDefault(AsymmetricMatcher);
    var _ConvertAnsi = _interopRequireDefault(ConvertAnsi);
    var _DOMCollection = _interopRequireDefault(DOMCollection);
    var _DOMElement = _interopRequireDefault(DOMElement);
    var _Immutable = _interopRequireDefault(Immutable);
    var _ReactElement = _interopRequireDefault(ReactElement);
    var _ReactTestComponent = _interopRequireDefault(ReactTestComponent);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Symbol$1 =
      commonjsGlobal["jest-symbol-do-not-touch"] || commonjsGlobal.Symbol;
    var toString = Object.prototype.toString;
    var toISOString = Date.prototype.toISOString;
    var errorToString = Error.prototype.toString;
    var regExpToString = RegExp.prototype.toString;
    var symbolToString = Symbol$1.prototype.toString;
    /**
     * Explicitly comparing typeof constructor to function avoids undefined as name
     * when mock identity-obj-proxy returns the key as the value for any key.
     */ var getConstructorName = function getConstructorName(val) {
      return (
        (typeof val.constructor === "function" && val.constructor.name) ||
        "Object"
      );
    };
    /* global window */ /** Is val is equal to global window object? Works even if it does not exist :) */ var isWindow =
      function isWindow(val) {
        return typeof window !== "undefined" && val === window;
      };
    var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
    var NEWLINE_REGEXP = /\n/gi;
    var PrettyFormatPluginError = /*#__PURE__*/ (function (_Error2) {
      function PrettyFormatPluginError(message, stack) {
        var _this7;
        _classCallCheck(this, PrettyFormatPluginError);
        _this7 = _callSuper(this, PrettyFormatPluginError, [message]);
        _this7.stack = stack;
        _this7.name = _this7.constructor.name;
        return _this7;
      }
      _inherits2(PrettyFormatPluginError, _Error2);
      return _createClass(PrettyFormatPluginError);
    })(/*#__PURE__*/ _wrapNativeSuper(Error));
    function isToStringedArrayType(toStringed) {
      return (
        toStringed === "[object Array]" ||
        toStringed === "[object ArrayBuffer]" ||
        toStringed === "[object DataView]" ||
        toStringed === "[object Float32Array]" ||
        toStringed === "[object Float64Array]" ||
        toStringed === "[object Int8Array]" ||
        toStringed === "[object Int16Array]" ||
        toStringed === "[object Int32Array]" ||
        toStringed === "[object Uint8Array]" ||
        toStringed === "[object Uint8ClampedArray]" ||
        toStringed === "[object Uint16Array]" ||
        toStringed === "[object Uint32Array]"
      );
    }
    function printNumber(val) {
      return Object.is(val, -0) ? "-0" : String(val);
    }
    function printBigInt(val) {
      return String("".concat(val, "n"));
    }
    function printFunction(val, printFunctionName) {
      if (!printFunctionName) {
        return "[Function]";
      }
      return "[Function " + (val.name || "anonymous") + "]";
    }
    function printSymbol(val) {
      return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
    }
    function printError(val) {
      return "[" + errorToString.call(val) + "]";
    }
    /**
     * The first port of call for printing an object, handles most of the
     * data-types in JS.
     */ function printBasicValue(
      val,
      printFunctionName,
      escapeRegex,
      escapeString
    ) {
      if (val === true || val === false) {
        return "" + val;
      }
      if (val === undefined) {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      var typeOf = _typeof(val);
      if (typeOf === "number") {
        return printNumber(val);
      }
      if (typeOf === "bigint") {
        return printBigInt(val);
      }
      if (typeOf === "string") {
        if (escapeString) {
          return '"' + val.replace(/"|\\/g, "\\$&") + '"';
        }
        return '"' + val + '"';
      }
      if (typeOf === "function") {
        return printFunction(val, printFunctionName);
      }
      if (typeOf === "symbol") {
        return printSymbol(val);
      }
      var toStringed = toString.call(val);
      if (toStringed === "[object WeakMap]") {
        return "WeakMap {}";
      }
      if (toStringed === "[object WeakSet]") {
        return "WeakSet {}";
      }
      if (
        toStringed === "[object Function]" ||
        toStringed === "[object GeneratorFunction]"
      ) {
        return printFunction(val, printFunctionName);
      }
      if (toStringed === "[object Symbol]") {
        return printSymbol(val);
      }
      if (toStringed === "[object Date]") {
        return isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
      }
      if (toStringed === "[object Error]") {
        return printError(val);
      }
      if (toStringed === "[object RegExp]") {
        if (escapeRegex) {
          // https://github.com/benjamingr/RegExp.escape/blob/master/polyfill.js
          return regExpToString
            .call(val)
            .replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        return regExpToString.call(val);
      }
      if (val instanceof Error) {
        return printError(val);
      }
      return null;
    }
    /**
     * Handles more complex objects ( such as objects with circular references.
     * maps and sets etc )
     */ function printComplexValue(
      val,
      config,
      indentation,
      depth,
      refs,
      hasCalledToJSON
    ) {
      if (refs.indexOf(val) !== -1) {
        return "[Circular]";
      }
      refs = refs.slice();
      refs.push(val);
      var hitMaxDepth = ++depth > config.maxDepth;
      var min = config.min;
      if (
        config.callToJSON &&
        !hitMaxDepth &&
        val.toJSON &&
        typeof val.toJSON === "function" &&
        !hasCalledToJSON
      ) {
        return printer(val.toJSON(), config, indentation, depth, refs, true);
      }
      var toStringed = toString.call(val);
      if (toStringed === "[object Arguments]") {
        return hitMaxDepth
          ? "[Arguments]"
          : (min ? "" : "Arguments ") +
              "[" +
              (0, _collections.printListItems)(
                val,
                config,
                indentation,
                depth,
                refs,
                printer
              ) +
              "]";
      }
      if (isToStringedArrayType(toStringed)) {
        return hitMaxDepth
          ? "[" + val.constructor.name + "]"
          : (min ? "" : val.constructor.name + " ") +
              "[" +
              (0, _collections.printListItems)(
                val,
                config,
                indentation,
                depth,
                refs,
                printer
              ) +
              "]";
      }
      if (toStringed === "[object Map]") {
        return hitMaxDepth
          ? "[Map]"
          : "Map {" +
              (0, _collections.printIteratorEntries)(
                val.entries(),
                config,
                indentation,
                depth,
                refs,
                printer,
                " => "
              ) +
              "}";
      }
      if (toStringed === "[object Set]") {
        return hitMaxDepth
          ? "[Set]"
          : "Set {" +
              (0, _collections.printIteratorValues)(
                val.values(),
                config,
                indentation,
                depth,
                refs,
                printer
              ) +
              "}";
      } // Avoid failure to serialize global window object in jsdom test environment.
      // For example, not even relevant if window is prop of React element.
      return hitMaxDepth || isWindow(val)
        ? "[" + getConstructorName(val) + "]"
        : (min ? "" : getConstructorName(val) + " ") +
            "{" +
            (0, _collections.printObjectProperties)(
              val,
              config,
              indentation,
              depth,
              refs,
              printer
            ) +
            "}";
    }
    function isNewPlugin(plugin) {
      return plugin.serialize != null;
    }
    function printPlugin(plugin, val, config, indentation, depth, refs) {
      var printed;
      try {
        printed = isNewPlugin(plugin)
          ? plugin.serialize(val, config, indentation, depth, refs, printer)
          : plugin.print(
              val,
              function (valChild) {
                return printer(valChild, config, indentation, depth, refs);
              },
              function (str) {
                var indentationNext = indentation + config.indent;
                return (
                  indentationNext +
                  str.replace(NEWLINE_REGEXP, "\n" + indentationNext)
                );
              },
              {
                edgeSpacing: config.spacingOuter,
                min: config.min,
                spacing: config.spacingInner
              },
              config.colors
            );
      } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
      }
      if (typeof printed !== "string") {
        throw new Error(
          'pretty-format: Plugin must return type "string" but instead returned "'.concat(
            _typeof(printed),
            '".'
          )
        );
      }
      return printed;
    }
    function findPlugin(plugins, val) {
      for (var p = 0; p < plugins.length; p++) {
        try {
          if (plugins[p].test(val)) {
            return plugins[p];
          }
        } catch (error) {
          throw new PrettyFormatPluginError(error.message, error.stack);
        }
      }
      return null;
    }
    function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
      var plugin = findPlugin(config.plugins, val);
      if (plugin !== null) {
        return printPlugin(plugin, val, config, indentation, depth, refs);
      }
      var basicResult = printBasicValue(
        val,
        config.printFunctionName,
        config.escapeRegex,
        config.escapeString
      );
      if (basicResult !== null) {
        return basicResult;
      }
      return printComplexValue(
        val,
        config,
        indentation,
        depth,
        refs,
        hasCalledToJSON
      );
    }
    var DEFAULT_THEME = {
      comment: "gray",
      content: "reset",
      prop: "yellow",
      tag: "cyan",
      value: "green"
    };
    var DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
    var DEFAULT_OPTIONS = {
      callToJSON: true,
      escapeRegex: false,
      escapeString: true,
      highlight: false,
      indent: 2,
      maxDepth: Infinity,
      min: false,
      plugins: [],
      printFunctionName: true,
      theme: DEFAULT_THEME
    };
    function validateOptions(options) {
      Object.keys(options).forEach(function (key) {
        if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
          throw new Error('pretty-format: Unknown option "'.concat(key, '".'));
        }
      });
      if (options.min && options.indent !== undefined && options.indent !== 0) {
        throw new Error(
          'pretty-format: Options "min" and "indent" cannot be used together.'
        );
      }
      if (options.theme !== undefined) {
        if (options.theme === null) {
          throw new Error('pretty-format: Option "theme" must not be null.');
        }
        if (_typeof(options.theme) !== "object") {
          throw new Error(
            'pretty-format: Option "theme" must be of type "object" but instead received "'.concat(
              _typeof(options.theme),
              '".'
            )
          );
        }
      }
    }
    var getColorsHighlight = function getColorsHighlight(options) {
      return DEFAULT_THEME_KEYS.reduce(function (colors, key) {
        var value =
          options.theme && options.theme[key] !== undefined
            ? options.theme[key]
            : DEFAULT_THEME[key];
        var color = value && _ansiStyles["default"][value];
        if (
          color &&
          typeof color.close === "string" &&
          typeof color.open === "string"
        ) {
          colors[key] = color;
        } else {
          throw new Error(
            'pretty-format: Option "theme" has a key "'
              .concat(key, '" whose value "')
              .concat(value, '" is undefined in ansi-styles.')
          );
        }
        return colors;
      }, Object.create(null));
    };
    var getColorsEmpty = function getColorsEmpty() {
      return DEFAULT_THEME_KEYS.reduce(function (colors, key) {
        colors[key] = { close: "", open: "" };
        return colors;
      }, Object.create(null));
    };
    var getPrintFunctionName = function getPrintFunctionName(options) {
      return options && options.printFunctionName !== undefined
        ? options.printFunctionName
        : DEFAULT_OPTIONS.printFunctionName;
    };
    var getEscapeRegex = function getEscapeRegex(options) {
      return options && options.escapeRegex !== undefined
        ? options.escapeRegex
        : DEFAULT_OPTIONS.escapeRegex;
    };
    var getEscapeString = function getEscapeString(options) {
      return options && options.escapeString !== undefined
        ? options.escapeString
        : DEFAULT_OPTIONS.escapeString;
    };
    var getConfig = function getConfig(options) {
      return {
        callToJSON:
          options && options.callToJSON !== undefined
            ? options.callToJSON
            : DEFAULT_OPTIONS.callToJSON,
        colors:
          options && options.highlight
            ? getColorsHighlight(options)
            : getColorsEmpty(),
        escapeRegex: getEscapeRegex(options),
        escapeString: getEscapeString(options),
        indent:
          options && options.min
            ? ""
            : createIndent(
                options && options.indent !== undefined
                  ? options.indent
                  : DEFAULT_OPTIONS.indent
              ),
        maxDepth:
          options && options.maxDepth !== undefined
            ? options.maxDepth
            : DEFAULT_OPTIONS.maxDepth,
        min:
          options && options.min !== undefined
            ? options.min
            : DEFAULT_OPTIONS.min,
        plugins:
          options && options.plugins !== undefined
            ? options.plugins
            : DEFAULT_OPTIONS.plugins,
        printFunctionName: getPrintFunctionName(options),
        spacingInner: options && options.min ? " " : "\n",
        spacingOuter: options && options.min ? "" : "\n"
      };
    };
    function createIndent(indent) {
      return new Array(indent + 1).join(" ");
    }
    /**
     * Returns a presentation string of your `val` object
     * @param val any potential JavaScript object
     * @param options Custom settings
     */ function prettyFormat(val, options) {
      if (options) {
        validateOptions(options);
        if (options.plugins) {
          var _plugin = findPlugin(options.plugins, val);
          if (_plugin !== null) {
            return printPlugin(_plugin, val, getConfig(options), "", 0, []);
          }
        }
      }
      var basicResult = printBasicValue(
        val,
        getPrintFunctionName(options),
        getEscapeRegex(options),
        getEscapeString(options)
      );
      if (basicResult !== null) {
        return basicResult;
      }
      return printComplexValue(val, getConfig(options), "", 0, []);
    }
    prettyFormat.plugins = {
      AsymmetricMatcher: _AsymmetricMatcher["default"],
      ConvertAnsi: _ConvertAnsi["default"],
      DOMCollection: _DOMCollection["default"],
      DOMElement: _DOMElement["default"],
      Immutable: _Immutable["default"],
      ReactElement: _ReactElement["default"],
      ReactTestComponent: _ReactTestComponent["default"]
    };
    /* eslint-disable-next-line no-redeclare */ var build = prettyFormat;
    var _PostDominator_exit, _PostDominator_nodes;
    function computePostDominatorTree(fn, options) {
      var graph = buildReverseGraph(fn, options.includeThrowsAsExitNode);
      var nodes = computeImmediateDominators(graph);
      if (!options.includeThrowsAsExitNode) {
        var _iterator121 = _createForOfIteratorHelper(fn.body.blocks),
          _step121;
        try {
          for (_iterator121.s(); !(_step121 = _iterator121.n()).done; ) {
            var _step121$value = _slicedToArray(_step121.value, 1),
              id = _step121$value[0];
            if (!nodes.has(id)) {
              nodes.set(id, id);
            }
          }
        } catch (err) {
          _iterator121.e(err);
        } finally {
          _iterator121.f();
        }
      }
      return new PostDominator(graph.entry, nodes);
    }
    var PostDominator = /*#__PURE__*/ (function () {
      function PostDominator(exit, nodes) {
        _classCallCheck(this, PostDominator);
        _PostDominator_exit.set(this, void 0);
        _PostDominator_nodes.set(this, void 0);
        __classPrivateFieldSet(this, _PostDominator_exit, exit, "f");
        __classPrivateFieldSet(this, _PostDominator_nodes, nodes, "f");
      }
      return _createClass(PostDominator, [
        {
          key: "exit",
          get: function get() {
            return __classPrivateFieldGet(this, _PostDominator_exit, "f");
          }
        },
        {
          key: "get",
          value: function get(id) {
            var dominator = __classPrivateFieldGet(
              this,
              _PostDominator_nodes,
              "f"
            ).get(id);
            CompilerError.invariant(dominator !== undefined, {
              reason: "Unknown node",
              description: null,
              loc: null,
              suggestions: null
            });
            return dominator === id ? null : dominator;
          }
        },
        {
          key: "debug",
          value: function debug() {
            var postDominators = new Map();
            var _iterator122 = _createForOfIteratorHelper(
                __classPrivateFieldGet(this, _PostDominator_nodes, "f")
              ),
              _step122;
            try {
              for (_iterator122.s(); !(_step122 = _iterator122.n()).done; ) {
                var _step122$value = _slicedToArray(_step122.value, 2),
                  _key30 = _step122$value[0],
                  value = _step122$value[1];
                postDominators.set("bb".concat(_key30), "bb".concat(value));
              }
            } catch (err) {
              _iterator122.e(err);
            } finally {
              _iterator122.f();
            }
            return build({
              exit: "bb".concat(this.exit),
              postDominators: postDominators
            });
          }
        }
      ]);
    })();
    (_PostDominator_exit = new WeakMap()),
      (_PostDominator_nodes = new WeakMap());
    function computeImmediateDominators(graph) {
      var nodes = new Map();
      nodes.set(graph.entry, graph.entry);
      var changed = true;
      while (changed) {
        changed = false;
        var _iterator123 = _createForOfIteratorHelper(graph.nodes),
          _step123;
        try {
          for (_iterator123.s(); !(_step123 = _iterator123.n()).done; ) {
            var _step123$value = _slicedToArray(_step123.value, 2),
              id = _step123$value[0],
              _node7 = _step123$value[1];
            if (_node7.id === graph.entry) {
              continue;
            }
            var newIdom = null;
            var _iterator124 = _createForOfIteratorHelper(_node7.preds),
              _step124;
            try {
              for (_iterator124.s(); !(_step124 = _iterator124.n()).done; ) {
                var pred = _step124.value;
                if (nodes.has(pred)) {
                  newIdom = pred;
                  break;
                }
              }
            } catch (err) {
              _iterator124.e(err);
            } finally {
              _iterator124.f();
            }
            CompilerError.invariant(newIdom !== null, {
              reason:
                "At least one predecessor must have been visited for block ".concat(
                  id
                ),
              description: null,
              loc: null,
              suggestions: null
            });
            var _iterator125 = _createForOfIteratorHelper(_node7.preds),
              _step125;
            try {
              for (_iterator125.s(); !(_step125 = _iterator125.n()).done; ) {
                var _pred2 = _step125.value;
                if (_pred2 === newIdom) {
                  continue;
                }
                var predDom = nodes.get(_pred2);
                if (predDom !== undefined) {
                  newIdom = intersect(_pred2, newIdom, graph, nodes);
                }
              }
            } catch (err) {
              _iterator125.e(err);
            } finally {
              _iterator125.f();
            }
            if (nodes.get(id) !== newIdom) {
              nodes.set(id, newIdom);
              changed = true;
            }
          }
        } catch (err) {
          _iterator123.e(err);
        } finally {
          _iterator123.f();
        }
      }
      return nodes;
    }
    function intersect(a, b, graph, nodes) {
      var block1 = graph.nodes.get(a);
      var block2 = graph.nodes.get(b);
      while (block1 !== block2) {
        while (block1.index > block2.index) {
          var dom = nodes.get(block1.id);
          block1 = graph.nodes.get(dom);
        }
        while (block2.index > block1.index) {
          var _dom = nodes.get(block2.id);
          block2 = graph.nodes.get(_dom);
        }
      }
      return block1.id;
    }
    function buildReverseGraph(fn, includeThrowsAsExitNode) {
      var nodes = new Map();
      var exitId = fn.env.nextBlockId;
      var exit = { id: exitId, index: 0, preds: new Set(), succs: new Set() };
      nodes.set(exitId, exit);
      var _iterator126 = _createForOfIteratorHelper(fn.body.blocks),
        _step126;
      try {
        for (_iterator126.s(); !(_step126 = _iterator126.n()).done; ) {
          var _step126$value = _slicedToArray(_step126.value, 2),
            id = _step126$value[0],
            block = _step126$value[1];
          var _node8 = {
            id: id,
            index: 0,
            preds: new Set(eachTerminalSuccessor(block.terminal)),
            succs: new Set(block.preds)
          };
          if (block.terminal.kind === "return") {
            _node8.preds.add(exitId);
            exit.succs.add(id);
          } else if (
            block.terminal.kind === "throw" &&
            includeThrowsAsExitNode
          ) {
            _node8.preds.add(exitId);
            exit.succs.add(id);
          }
          nodes.set(id, _node8);
        }
      } catch (err) {
        _iterator126.e(err);
      } finally {
        _iterator126.f();
      }
      var visited = new Set();
      var postorder = [];
      function visit(id) {
        if (visited.has(id)) {
          return;
        }
        visited.add(id);
        var node = nodes.get(id);
        var _iterator127 = _createForOfIteratorHelper(node.succs),
          _step127;
        try {
          for (_iterator127.s(); !(_step127 = _iterator127.n()).done; ) {
            var successor = _step127.value;
            visit(successor);
          }
        } catch (err) {
          _iterator127.e(err);
        } finally {
          _iterator127.f();
        }
        postorder.push(id);
      }
      visit(exitId);
      var rpo = { entry: exitId, nodes: new Map() };
      var index = 0;
      var _iterator128 = _createForOfIteratorHelper(postorder.reverse()),
        _step128;
      try {
        for (_iterator128.s(); !(_step128 = _iterator128.n()).done; ) {
          var _id6 = _step128.value;
          var _node9 = nodes.get(_id6);
          _node9.index = index++;
          rpo.nodes.set(_id6, _node9);
        }
      } catch (err) {
        _iterator128.e(err);
      } finally {
        _iterator128.f();
      }
      return rpo;
    }
    var DEFAULT_SHAPES = new Map(BUILTIN_SHAPES);
    var UNTYPED_GLOBALS = new Set([
      "String",
      "Object",
      "Function",
      "Number",
      "RegExp",
      "Date",
      "Error",
      "Function",
      "TypeError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "URIError",
      "EvalError",
      "Boolean",
      "DataView",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Set",
      "WeakMap",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "ArrayBuffer",
      "JSON",
      "parseFloat",
      "parseInt",
      "console",
      "isNaN",
      "eval",
      "isFinite",
      "encodeURI",
      "decodeURI",
      "encodeURIComponent",
      "decodeURIComponent"
    ]);
    var TYPED_GLOBALS = [
      [
        "Object",
        addObject(DEFAULT_SHAPES, "Object", [
          [
            "keys",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [Effect.Read],
              restParam: null,
              returnType: { kind: "Object", shapeId: BuiltInArrayId },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Mutable
            })
          ]
        ])
      ],
      [
        "Array",
        addObject(DEFAULT_SHAPES, "Array", [
          [
            "isArray",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [Effect.Read],
              restParam: null,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ],
          [
            "from",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [
                Effect.ConditionallyMutate,
                Effect.ConditionallyMutate,
                Effect.ConditionallyMutate
              ],
              restParam: Effect.Read,
              returnType: { kind: "Object", shapeId: BuiltInArrayId },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Mutable
            })
          ],
          [
            "of",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Object", shapeId: BuiltInArrayId },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Mutable
            })
          ]
        ])
      ],
      [
        "performance",
        addObject(DEFAULT_SHAPES, "performance", [
          [
            "now",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Poly" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Mutable,
              impure: true,
              canonicalName: "performance.now"
            })
          ]
        ])
      ],
      [
        "Date",
        addObject(DEFAULT_SHAPES, "Date", [
          [
            "now",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Poly" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Mutable,
              impure: true,
              canonicalName: "Date.now"
            })
          ]
        ])
      ],
      [
        "Math",
        addObject(DEFAULT_SHAPES, "Math", [
          ["PI", { kind: "Primitive" }],
          [
            "max",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ],
          [
            "min",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ],
          [
            "trunc",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ],
          [
            "ceil",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ],
          [
            "floor",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ],
          [
            "pow",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ],
          [
            "random",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Poly" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Mutable,
              impure: true,
              canonicalName: "Math.random"
            })
          ]
        ])
      ],
      ["Infinity", { kind: "Primitive" }],
      ["NaN", { kind: "Primitive" }],
      [
        "console",
        addObject(DEFAULT_SHAPES, "console", [
          [
            "error",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ],
          [
            "info",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ],
          [
            "log",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ],
          [
            "table",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ],
          [
            "trace",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ],
          [
            "warn",
            addFunction(DEFAULT_SHAPES, [], {
              positionalParams: [],
              restParam: Effect.Read,
              returnType: { kind: "Primitive" },
              calleeEffect: Effect.Read,
              returnValueKind: ValueKind.Primitive
            })
          ]
        ])
      ],
      [
        "Boolean",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive
        })
      ],
      [
        "Number",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive
        })
      ],
      [
        "String",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive
        })
      ]
    ];
    var REACT_APIS = [
      [
        "useContext",
        addHook(
          DEFAULT_SHAPES,
          {
            positionalParams: [],
            restParam: Effect.Read,
            returnType: { kind: "Poly" },
            calleeEffect: Effect.Read,
            hookKind: "useContext",
            returnValueKind: ValueKind.Frozen,
            returnValueReason: ValueReason.Context
          },
          BuiltInUseContextHookId
        )
      ],
      [
        "useState",
        addHook(DEFAULT_SHAPES, {
          positionalParams: [],
          restParam: Effect.Freeze,
          returnType: { kind: "Object", shapeId: BuiltInUseStateId },
          calleeEffect: Effect.Read,
          hookKind: "useState",
          returnValueKind: ValueKind.Frozen,
          returnValueReason: ValueReason.State
        })
      ],
      [
        "useActionState",
        addHook(DEFAULT_SHAPES, {
          positionalParams: [],
          restParam: Effect.Freeze,
          returnType: { kind: "Object", shapeId: BuiltInUseActionStateId },
          calleeEffect: Effect.Read,
          hookKind: "useActionState",
          returnValueKind: ValueKind.Frozen,
          returnValueReason: ValueReason.State
        })
      ],
      [
        "useReducer",
        addHook(DEFAULT_SHAPES, {
          positionalParams: [],
          restParam: Effect.Freeze,
          returnType: { kind: "Object", shapeId: BuiltInUseReducerId },
          calleeEffect: Effect.Read,
          hookKind: "useReducer",
          returnValueKind: ValueKind.Frozen,
          returnValueReason: ValueReason.ReducerState
        })
      ],
      [
        "useRef",
        addHook(DEFAULT_SHAPES, {
          positionalParams: [],
          restParam: Effect.Capture,
          returnType: { kind: "Object", shapeId: BuiltInUseRefId },
          calleeEffect: Effect.Read,
          hookKind: "useRef",
          returnValueKind: ValueKind.Mutable
        })
      ],
      [
        "useImperativeHandle",
        addHook(DEFAULT_SHAPES, {
          positionalParams: [],
          restParam: Effect.Freeze,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          hookKind: "useImperativeHandle",
          returnValueKind: ValueKind.Frozen
        })
      ],
      [
        "useMemo",
        addHook(DEFAULT_SHAPES, {
          positionalParams: [],
          restParam: Effect.Freeze,
          returnType: { kind: "Poly" },
          calleeEffect: Effect.Read,
          hookKind: "useMemo",
          returnValueKind: ValueKind.Frozen
        })
      ],
      [
        "useCallback",
        addHook(DEFAULT_SHAPES, {
          positionalParams: [],
          restParam: Effect.Freeze,
          returnType: { kind: "Poly" },
          calleeEffect: Effect.Read,
          hookKind: "useCallback",
          returnValueKind: ValueKind.Frozen
        })
      ],
      [
        "useEffect",
        addHook(
          DEFAULT_SHAPES,
          {
            positionalParams: [],
            restParam: Effect.Freeze,
            returnType: { kind: "Primitive" },
            calleeEffect: Effect.Read,
            hookKind: "useEffect",
            returnValueKind: ValueKind.Frozen
          },
          BuiltInUseEffectHookId
        )
      ],
      [
        "useLayoutEffect",
        addHook(
          DEFAULT_SHAPES,
          {
            positionalParams: [],
            restParam: Effect.Freeze,
            returnType: { kind: "Poly" },
            calleeEffect: Effect.Read,
            hookKind: "useLayoutEffect",
            returnValueKind: ValueKind.Frozen
          },
          BuiltInUseLayoutEffectHookId
        )
      ],
      [
        "useInsertionEffect",
        addHook(
          DEFAULT_SHAPES,
          {
            positionalParams: [],
            restParam: Effect.Freeze,
            returnType: { kind: "Poly" },
            calleeEffect: Effect.Read,
            hookKind: "useInsertionEffect",
            returnValueKind: ValueKind.Frozen
          },
          BuiltInUseInsertionEffectHookId
        )
      ],
      [
        "useTransition",
        addHook(DEFAULT_SHAPES, {
          positionalParams: [],
          restParam: null,
          returnType: { kind: "Object", shapeId: BuiltInUseTransitionId },
          calleeEffect: Effect.Read,
          hookKind: "useTransition",
          returnValueKind: ValueKind.Frozen
        })
      ],
      [
        "use",
        addFunction(
          DEFAULT_SHAPES,
          [],
          {
            positionalParams: [],
            restParam: Effect.Freeze,
            returnType: { kind: "Poly" },
            calleeEffect: Effect.Read,
            returnValueKind: ValueKind.Frozen
          },
          BuiltInUseOperatorId
        )
      ],
      [
        "fire",
        addFunction(
          DEFAULT_SHAPES,
          [],
          {
            positionalParams: [],
            restParam: null,
            returnType: { kind: "Primitive" },
            calleeEffect: Effect.Read,
            returnValueKind: ValueKind.Frozen
          },
          BuiltInFireId
        )
      ]
    ];
    TYPED_GLOBALS.push(
      [
        "React",
        addObject(
          DEFAULT_SHAPES,
          null,
          [].concat(REACT_APIS, [
            [
              "createElement",
              addFunction(DEFAULT_SHAPES, [], {
                positionalParams: [],
                restParam: Effect.Freeze,
                returnType: { kind: "Poly" },
                calleeEffect: Effect.Read,
                returnValueKind: ValueKind.Frozen
              })
            ],
            [
              "cloneElement",
              addFunction(DEFAULT_SHAPES, [], {
                positionalParams: [],
                restParam: Effect.Freeze,
                returnType: { kind: "Poly" },
                calleeEffect: Effect.Read,
                returnValueKind: ValueKind.Frozen
              })
            ],
            [
              "createRef",
              addFunction(DEFAULT_SHAPES, [], {
                positionalParams: [],
                restParam: Effect.Capture,
                returnType: { kind: "Object", shapeId: BuiltInUseRefId },
                calleeEffect: Effect.Read,
                returnValueKind: ValueKind.Mutable
              })
            ]
          ])
        )
      ],
      [
        "_jsx",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Freeze,
          returnType: { kind: "Poly" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Frozen
        })
      ]
    );
    var DEFAULT_GLOBALS = new Map(REACT_APIS);
    var _iterator129 = _createForOfIteratorHelper(UNTYPED_GLOBALS),
      _step129;
    try {
      for (_iterator129.s(); !(_step129 = _iterator129.n()).done; ) {
        var _name15 = _step129.value;
        DEFAULT_GLOBALS.set(_name15, { kind: "Poly" });
      }
    } catch (err) {
      _iterator129.e(err);
    } finally {
      _iterator129.f();
    }
    for (
      var _i29 = 0, _TYPED_GLOBALS = TYPED_GLOBALS;
      _i29 < _TYPED_GLOBALS.length;
      _i29++
    ) {
      var _TYPED_GLOBALS$_i = _slicedToArray(_TYPED_GLOBALS[_i29], 2),
        name = _TYPED_GLOBALS$_i[0],
        type_ = _TYPED_GLOBALS$_i[1];
      DEFAULT_GLOBALS.set(name, type_);
    }
    DEFAULT_GLOBALS.set(
      "globalThis",
      addObject(DEFAULT_SHAPES, "globalThis", TYPED_GLOBALS)
    );
    DEFAULT_GLOBALS.set(
      "global",
      addObject(DEFAULT_SHAPES, "global", TYPED_GLOBALS)
    );
    function installTypeConfig(globals, shapes, typeConfig, moduleName, loc) {
      var _a, _b, _c, _d;
      switch (typeConfig.kind) {
        case "type": {
          switch (typeConfig.name) {
            case "Array": {
              return { kind: "Object", shapeId: BuiltInArrayId };
            }
            case "MixedReadonly": {
              return { kind: "Object", shapeId: BuiltInMixedReadonlyId };
            }
            case "Primitive": {
              return { kind: "Primitive" };
            }
            case "Ref": {
              return { kind: "Object", shapeId: BuiltInUseRefId };
            }
            case "Any": {
              return { kind: "Poly" };
            }
            default: {
              assertExhaustive$1(
                typeConfig.name,
                "Unexpected type '".concat(typeConfig.name, "'")
              );
            }
          }
        }
        case "function": {
          return addFunction(shapes, [], {
            positionalParams: typeConfig.positionalParams,
            restParam: typeConfig.restParam,
            calleeEffect: typeConfig.calleeEffect,
            returnType: installTypeConfig(
              globals,
              shapes,
              typeConfig.returnType,
              moduleName,
              loc
            ),
            returnValueKind: typeConfig.returnValueKind,
            noAlias: typeConfig.noAlias === true,
            mutableOnlyIfOperandsAreMutable:
              typeConfig.mutableOnlyIfOperandsAreMutable === true
          });
        }
        case "hook": {
          return addHook(shapes, {
            hookKind: "Custom",
            positionalParams:
              (_a = typeConfig.positionalParams) !== null && _a !== void 0
                ? _a
                : [],
            restParam:
              (_b = typeConfig.restParam) !== null && _b !== void 0
                ? _b
                : Effect.Freeze,
            calleeEffect: Effect.Read,
            returnType: installTypeConfig(
              globals,
              shapes,
              typeConfig.returnType,
              moduleName,
              loc
            ),
            returnValueKind:
              (_c = typeConfig.returnValueKind) !== null && _c !== void 0
                ? _c
                : ValueKind.Frozen,
            noAlias: typeConfig.noAlias === true
          });
        }
        case "object": {
          return addObject(
            shapes,
            null,
            Object.entries(
              (_d = typeConfig.properties) !== null && _d !== void 0 ? _d : {}
            ).map(function (_ref21) {
              var _ref22 = _slicedToArray(_ref21, 2),
                key = _ref22[0],
                value = _ref22[1];
              var _a;
              var type = installTypeConfig(
                globals,
                shapes,
                value,
                moduleName,
                loc
              );
              var expectHook = isHookName$2(key);
              var isHook = false;
              if (type.kind === "Function" && type.shapeId !== null) {
                var functionType = shapes.get(type.shapeId);
                if (
                  ((_a =
                    functionType === null || functionType === void 0
                      ? void 0
                      : functionType.functionType) === null || _a === void 0
                    ? void 0
                    : _a.hookKind) !== null
                ) {
                  isHook = true;
                }
              }
              if (expectHook !== isHook) {
                CompilerError.throwInvalidConfig({
                  reason: "Invalid type configuration for module",
                  description: "Expected type for object property '"
                    .concat(key, "' from module '")
                    .concat(moduleName, "' ")
                    .concat(
                      expectHook ? "to be a hook" : "not to be a hook",
                      " based on the property name"
                    ),
                  loc: loc
                });
              }
              return [key, type];
            })
          );
        }
        default: {
          assertExhaustive$1(
            typeConfig,
            "Unexpected type kind '".concat(typeConfig.kind, "'")
          );
        }
      }
    }
    function getReanimatedModuleType(registry) {
      var frozenHooks = [
        "useFrameCallback",
        "useAnimatedStyle",
        "useAnimatedProps",
        "useAnimatedScrollHandler",
        "useAnimatedReaction",
        "useWorkletCallback"
      ];
      var reanimatedType = [];
      for (
        var _i30 = 0, _frozenHooks = frozenHooks;
        _i30 < _frozenHooks.length;
        _i30++
      ) {
        var hook = _frozenHooks[_i30];
        reanimatedType.push([
          hook,
          addHook(registry, {
            positionalParams: [],
            restParam: Effect.Freeze,
            returnType: { kind: "Poly" },
            returnValueKind: ValueKind.Frozen,
            noAlias: true,
            calleeEffect: Effect.Read,
            hookKind: "Custom"
          })
        ]);
      }
      var mutableHooks = ["useSharedValue", "useDerivedValue"];
      for (
        var _i31 = 0, _mutableHooks = mutableHooks;
        _i31 < _mutableHooks.length;
        _i31++
      ) {
        var _hook = _mutableHooks[_i31];
        reanimatedType.push([
          _hook,
          addHook(registry, {
            positionalParams: [],
            restParam: Effect.Freeze,
            returnType: { kind: "Poly" },
            returnValueKind: ValueKind.Mutable,
            noAlias: true,
            calleeEffect: Effect.Read,
            hookKind: "Custom"
          })
        ]);
      }
      var funcs = [
        "withTiming",
        "withSpring",
        "createAnimatedPropAdapter",
        "withDecay",
        "withRepeat",
        "runOnUI",
        "executeOnUIRuntimeSync"
      ];
      for (var _i32 = 0, _funcs = funcs; _i32 < _funcs.length; _i32++) {
        var fn = _funcs[_i32];
        reanimatedType.push([
          fn,
          addFunction(registry, [], {
            positionalParams: [],
            restParam: Effect.Read,
            returnType: { kind: "Poly" },
            calleeEffect: Effect.Read,
            returnValueKind: ValueKind.Mutable,
            noAlias: true
          })
        ]);
      }
      return addObject(registry, null, reanimatedType);
    }
    var ObjectPropertiesSchema = zod.z
      .record(
        zod.z.string(),
        zod.z.lazy(function () {
          return TypeSchema;
        })
      )
      .refine(function (record) {
        return Object.keys(record).every(function (key) {
          return (
            key === "*" ||
            key === "default" ||
            libExports.isValidIdentifier(key)
          );
        });
      }, 'Expected all "object" property names to be valid identifier, `*` to match any property, of `default` to define a module default export');
    var ObjectTypeSchema = zod.z.object({
      kind: zod.z.literal("object"),
      properties: ObjectPropertiesSchema.nullable()
    });
    var FunctionTypeSchema = zod.z.object({
      kind: zod.z.literal("function"),
      positionalParams: zod.z.array(EffectSchema),
      restParam: EffectSchema.nullable(),
      calleeEffect: EffectSchema,
      returnType: zod.z.lazy(function () {
        return TypeSchema;
      }),
      returnValueKind: ValueKindSchema,
      noAlias: zod.z["boolean"]().nullable().optional(),
      mutableOnlyIfOperandsAreMutable: zod.z["boolean"]().nullable().optional(),
      impure: zod.z["boolean"]().nullable().optional(),
      canonicalName: zod.z.string().nullable().optional()
    });
    var HookTypeSchema = zod.z.object({
      kind: zod.z.literal("hook"),
      positionalParams: zod.z.array(EffectSchema).nullable().optional(),
      restParam: EffectSchema.nullable().optional(),
      returnType: zod.z.lazy(function () {
        return TypeSchema;
      }),
      returnValueKind: ValueKindSchema.nullable().optional(),
      noAlias: zod.z["boolean"]().nullable().optional()
    });
    var BuiltInTypeSchema = zod.z.union([
      zod.z.literal("Any"),
      zod.z.literal("Ref"),
      zod.z.literal("Array"),
      zod.z.literal("Primitive"),
      zod.z.literal("MixedReadonly")
    ]);
    var TypeReferenceSchema = zod.z.object({
      kind: zod.z.literal("type"),
      name: BuiltInTypeSchema
    });
    var TypeSchema = zod.z.union([
      ObjectTypeSchema,
      FunctionTypeSchema,
      HookTypeSchema,
      TypeReferenceSchema
    ]);
    var _Environment_instances,
      _Environment_globals,
      _Environment_shapes,
      _Environment_moduleTypes,
      _Environment_nextIdentifer,
      _Environment_nextBlock,
      _Environment_nextScope,
      _Environment_scope,
      _Environment_outlinedFunctions,
      _Environment_contextIdentifiers,
      _Environment_hoistedIdentifiers,
      _Environment_resolveModuleType,
      _Environment_isKnownReactModule,
      _Environment_getCustomHookType;
    var ReactElementSymbolSchema = zod.z.object({
      elementSymbol: zod.z.union([
        zod.z.literal("react.element"),
        zod.z.literal("react.transitional.element")
      ]),
      globalDevVar: zod.z.string()
    });
    var ExternalFunctionSchema = zod.z.object({
      source: zod.z.string(),
      importSpecifierName: zod.z.string()
    });
    var InstrumentationSchema = zod.z
      .object({
        fn: ExternalFunctionSchema,
        gating: ExternalFunctionSchema.nullable(),
        globalGating: zod.z.string().nullable()
      })
      .refine(function (opts) {
        return opts.gating != null || opts.globalGating != null;
      }, "Expected at least one of gating or globalGating");
    var MacroMethodSchema = zod.z.union([
      zod.z.object({ type: zod.z.literal("wildcard") }),
      zod.z.object({ type: zod.z.literal("name"), name: zod.z.string() })
    ]);
    var MacroSchema = zod.z.union([
      zod.z.string(),
      zod.z.tuple([zod.z.string(), zod.z.array(MacroMethodSchema)])
    ]);
    var HookSchema = zod.z.object({
      effectKind: zod.z.nativeEnum(Effect),
      valueKind: zod.z.nativeEnum(ValueKind),
      noAlias: zod.z["boolean"]()["default"](false),
      transitiveMixedData: zod.z["boolean"]()["default"](false)
    });
    var EnvironmentConfigSchema = zod.z.object({
      customHooks: zod.z.map(zod.z.string(), HookSchema)["default"](new Map()),
      moduleTypeProvider: zod.z
        .nullable(zod.z["function"]().args(zod.z.string()))
        ["default"](null),
      customMacros: zod.z.nullable(zod.z.array(MacroSchema))["default"](null),
      enableResetCacheOnSourceFileChanges: zod.z
        .nullable(zod.z["boolean"]())
        ["default"](null),
      enablePreserveExistingMemoizationGuarantees:
        zod.z["boolean"]()["default"](false),
      validatePreserveExistingMemoizationGuarantees:
        zod.z["boolean"]()["default"](true),
      enablePreserveExistingManualUseMemo: zod.z["boolean"]()["default"](false),
      enableForest: zod.z["boolean"]()["default"](false),
      enableUseTypeAnnotations: zod.z["boolean"]()["default"](false),
      enableOptionalDependencies: zod.z["boolean"]()["default"](true),
      enableFire: zod.z["boolean"]()["default"](false),
      inferEffectDependencies: zod.z
        .nullable(
          zod.z.array(
            zod.z.object({
              function: ExternalFunctionSchema,
              numRequiredArgs: zod.z
                .number()
                .min(1, "numRequiredArgs must be > 0")
            })
          )
        )
        ["default"](null),
      inlineJsxTransform: ReactElementSymbolSchema.nullable()["default"](null),
      validateHooksUsage: zod.z["boolean"]()["default"](true),
      validateRefAccessDuringRender: zod.z["boolean"]()["default"](true),
      validateNoSetStateInRender: zod.z["boolean"]()["default"](true),
      validateNoSetStateInPassiveEffects: zod.z["boolean"]()["default"](false),
      validateNoJSXInTryStatements: zod.z["boolean"]()["default"](false),
      validateMemoizedEffectDependencies: zod.z["boolean"]()["default"](false),
      validateNoCapitalizedCalls: zod.z
        .nullable(zod.z.array(zod.z.string()))
        ["default"](null),
      validateBlocklistedImports: zod.z
        .nullable(zod.z.array(zod.z.string()))
        ["default"](null),
      validateNoImpureFunctionsInRender: zod.z["boolean"]()["default"](false),
      enableAssumeHooksFollowRulesOfReact: zod.z["boolean"]()["default"](true),
      enableTransitivelyFreezeFunctionExpressions:
        zod.z["boolean"]()["default"](true),
      enableEmitFreeze: ExternalFunctionSchema.nullable()["default"](null),
      enableEmitHookGuards: ExternalFunctionSchema.nullable()["default"](null),
      enableInstructionReordering: zod.z["boolean"]()["default"](false),
      enableFunctionOutlining: zod.z["boolean"]()["default"](true),
      enableJsxOutlining: zod.z["boolean"]()["default"](false),
      enableEmitInstrumentForget:
        InstrumentationSchema.nullable()["default"](null),
      assertValidMutableRanges: zod.z["boolean"]()["default"](false),
      enableChangeVariableCodegen: zod.z["boolean"]()["default"](false),
      enableMemoizationComments: zod.z["boolean"]()["default"](false),
      throwUnknownException__testonly: zod.z["boolean"]()["default"](false),
      enableTreatFunctionDepsAsConditional:
        zod.z["boolean"]()["default"](false),
      disableMemoizationForDebugging: zod.z["boolean"]()["default"](false),
      enableChangeDetectionForDebugging:
        ExternalFunctionSchema.nullable()["default"](null),
      enableCustomTypeDefinitionForReanimated:
        zod.z["boolean"]()["default"](false),
      hookPattern: zod.z.string().nullable()["default"](null),
      enableTreatRefLikeIdentifiersAsRefs: zod.z["boolean"]()["default"](false),
      lowerContextAccess: ExternalFunctionSchema.nullable()["default"](null)
    });
    var Environment = /*#__PURE__*/ (function () {
      function Environment(
        scope,
        fnType,
        compilerMode,
        config,
        contextIdentifiers,
        logger,
        filename,
        code,
        useMemoCacheIdentifier
      ) {
        _classCallCheck(this, Environment);
        _Environment_instances.add(this);
        _Environment_globals.set(this, void 0);
        _Environment_shapes.set(this, void 0);
        _Environment_moduleTypes.set(this, new Map());
        _Environment_nextIdentifer.set(this, 0);
        _Environment_nextBlock.set(this, 0);
        _Environment_nextScope.set(this, 0);
        _Environment_scope.set(this, void 0);
        _Environment_outlinedFunctions.set(this, []);
        _Environment_contextIdentifiers.set(this, void 0);
        _Environment_hoistedIdentifiers.set(this, void 0);
        __classPrivateFieldSet(this, _Environment_scope, scope, "f");
        this.fnType = fnType;
        this.compilerMode = compilerMode;
        this.config = config;
        this.filename = filename;
        this.code = code;
        this.logger = logger;
        this.useMemoCacheIdentifier = useMemoCacheIdentifier;
        __classPrivateFieldSet(
          this,
          _Environment_shapes,
          new Map(DEFAULT_SHAPES),
          "f"
        );
        __classPrivateFieldSet(
          this,
          _Environment_globals,
          new Map(DEFAULT_GLOBALS),
          "f"
        );
        this.hasLoweredContextAccess = false;
        this.hasFireRewrite = false;
        if (
          config.disableMemoizationForDebugging &&
          config.enableChangeDetectionForDebugging != null
        ) {
          CompilerError.throwInvalidConfig({
            reason:
              "Invalid environment config: the 'disableMemoizationForDebugging' and 'enableChangeDetectionForDebugging' options cannot be used together",
            description: null,
            loc: null,
            suggestions: null
          });
        }
        var _iterator130 = _createForOfIteratorHelper(this.config.customHooks),
          _step130;
        try {
          for (_iterator130.s(); !(_step130 = _iterator130.n()).done; ) {
            var _step130$value = _slicedToArray(_step130.value, 2),
              hookName = _step130$value[0],
              hook = _step130$value[1];
            CompilerError.invariant(
              !__classPrivateFieldGet(this, _Environment_globals, "f").has(
                hookName
              ),
              {
                reason:
                  "[Globals] Found existing definition in global registry for custom hook ".concat(
                    hookName
                  ),
                description: null,
                loc: null,
                suggestions: null
              }
            );
            __classPrivateFieldGet(this, _Environment_globals, "f").set(
              hookName,
              addHook(__classPrivateFieldGet(this, _Environment_shapes, "f"), {
                positionalParams: [],
                restParam: hook.effectKind,
                returnType: hook.transitiveMixedData
                  ? { kind: "Object", shapeId: BuiltInMixedReadonlyId }
                  : { kind: "Poly" },
                returnValueKind: hook.valueKind,
                calleeEffect: Effect.Read,
                hookKind: "Custom",
                noAlias: hook.noAlias
              })
            );
          }
        } catch (err) {
          _iterator130.e(err);
        } finally {
          _iterator130.f();
        }
        if (config.enableCustomTypeDefinitionForReanimated) {
          var reanimatedModuleType = getReanimatedModuleType(
            __classPrivateFieldGet(this, _Environment_shapes, "f")
          );
          __classPrivateFieldGet(this, _Environment_moduleTypes, "f").set(
            REANIMATED_MODULE_NAME,
            reanimatedModuleType
          );
        }
        __classPrivateFieldSet(
          this,
          _Environment_contextIdentifiers,
          contextIdentifiers,
          "f"
        );
        __classPrivateFieldSet(
          this,
          _Environment_hoistedIdentifiers,
          new Set(),
          "f"
        );
      }
      return _createClass(Environment, [
        {
          key: "isInferredMemoEnabled",
          get: function get() {
            return this.compilerMode !== "no_inferred_memo";
          }
        },
        {
          key: "nextIdentifierId",
          get: function get() {
            var _a, _b;
            return makeIdentifierId(
              (__classPrivateFieldSet(
                this,
                _Environment_nextIdentifer,
                ((_b = __classPrivateFieldGet(
                  this,
                  _Environment_nextIdentifer,
                  "f"
                )),
                (_a = _b++),
                _b),
                "f"
              ),
              _a)
            );
          }
        },
        {
          key: "nextBlockId",
          get: function get() {
            var _a, _b;
            return makeBlockId(
              (__classPrivateFieldSet(
                this,
                _Environment_nextBlock,
                ((_b = __classPrivateFieldGet(
                  this,
                  _Environment_nextBlock,
                  "f"
                )),
                (_a = _b++),
                _b),
                "f"
              ),
              _a)
            );
          }
        },
        {
          key: "nextScopeId",
          get: function get() {
            var _a, _b;
            return makeScopeId(
              (__classPrivateFieldSet(
                this,
                _Environment_nextScope,
                ((_b = __classPrivateFieldGet(
                  this,
                  _Environment_nextScope,
                  "f"
                )),
                (_a = _b++),
                _b),
                "f"
              ),
              _a)
            );
          }
        },
        {
          key: "isContextIdentifier",
          value: function isContextIdentifier(node) {
            return __classPrivateFieldGet(
              this,
              _Environment_contextIdentifiers,
              "f"
            ).has(node);
          }
        },
        {
          key: "isHoistedIdentifier",
          value: function isHoistedIdentifier(node) {
            return __classPrivateFieldGet(
              this,
              _Environment_hoistedIdentifiers,
              "f"
            ).has(node);
          }
        },
        {
          key: "generateGloballyUniqueIdentifierName",
          value: function generateGloballyUniqueIdentifierName(name) {
            var identifierNode = __classPrivateFieldGet(
              this,
              _Environment_scope,
              "f"
            ).generateUidIdentifier(
              name !== null && name !== void 0 ? name : undefined
            );
            return makeIdentifierName(identifierNode.name);
          }
        },
        {
          key: "outlineFunction",
          value: function outlineFunction(fn, type) {
            __classPrivateFieldGet(
              this,
              _Environment_outlinedFunctions,
              "f"
            ).push({ fn: fn, type: type });
          }
        },
        {
          key: "getOutlinedFunctions",
          value: function getOutlinedFunctions() {
            return __classPrivateFieldGet(
              this,
              _Environment_outlinedFunctions,
              "f"
            );
          }
        },
        {
          key: "getGlobalDeclaration",
          value: function getGlobalDeclaration(binding, loc) {
            var _a, _b, _c, _d;
            if (this.config.hookPattern != null) {
              var match = new RegExp(this.config.hookPattern).exec(
                binding.name
              );
              if (
                match != null &&
                typeof match[1] === "string" &&
                isHookName$2(match[1])
              ) {
                var resolvedName = match[1];
                return (_a = __classPrivateFieldGet(
                  this,
                  _Environment_globals,
                  "f"
                ).get(resolvedName)) !== null && _a !== void 0
                  ? _a
                  : __classPrivateFieldGet(
                      this,
                      _Environment_instances,
                      "m",
                      _Environment_getCustomHookType
                    ).call(this);
              }
            }
            switch (binding.kind) {
              case "ModuleLocal": {
                return isHookName$2(binding.name)
                  ? __classPrivateFieldGet(
                      this,
                      _Environment_instances,
                      "m",
                      _Environment_getCustomHookType
                    ).call(this)
                  : null;
              }
              case "Global": {
                return (_b = __classPrivateFieldGet(
                  this,
                  _Environment_globals,
                  "f"
                ).get(binding.name)) !== null && _b !== void 0
                  ? _b
                  : isHookName$2(binding.name)
                    ? __classPrivateFieldGet(
                        this,
                        _Environment_instances,
                        "m",
                        _Environment_getCustomHookType
                      ).call(this)
                    : null;
              }
              case "ImportSpecifier": {
                if (
                  __classPrivateFieldGet(
                    this,
                    _Environment_instances,
                    "m",
                    _Environment_isKnownReactModule
                  ).call(this, binding.module)
                ) {
                  return (_c = __classPrivateFieldGet(
                    this,
                    _Environment_globals,
                    "f"
                  ).get(binding.imported)) !== null && _c !== void 0
                    ? _c
                    : isHookName$2(binding.imported) ||
                        isHookName$2(binding.name)
                      ? __classPrivateFieldGet(
                          this,
                          _Environment_instances,
                          "m",
                          _Environment_getCustomHookType
                        ).call(this)
                      : null;
                } else {
                  var moduleType = __classPrivateFieldGet(
                    this,
                    _Environment_instances,
                    "m",
                    _Environment_resolveModuleType
                  ).call(this, binding.module, loc);
                  if (moduleType !== null) {
                    var importedType = this.getPropertyType(
                      moduleType,
                      binding.imported
                    );
                    if (importedType != null) {
                      var expectHook = isHookName$2(binding.imported);
                      var _isHook =
                        getHookKindForType(this, importedType) != null;
                      if (expectHook !== _isHook) {
                        CompilerError.throwInvalidConfig({
                          reason: "Invalid type configuration for module",
                          description: "Expected type for `import {"
                            .concat(binding.imported, "} from '")
                            .concat(binding.module, "'` ")
                            .concat(
                              expectHook ? "to be a hook" : "not to be a hook",
                              " based on the exported name"
                            ),
                          loc: loc
                        });
                      }
                      return importedType;
                    }
                  }
                  return isHookName$2(binding.imported) ||
                    isHookName$2(binding.name)
                    ? __classPrivateFieldGet(
                        this,
                        _Environment_instances,
                        "m",
                        _Environment_getCustomHookType
                      ).call(this)
                    : null;
                }
              }
              case "ImportDefault":
              case "ImportNamespace": {
                if (
                  __classPrivateFieldGet(
                    this,
                    _Environment_instances,
                    "m",
                    _Environment_isKnownReactModule
                  ).call(this, binding.module)
                ) {
                  return (_d = __classPrivateFieldGet(
                    this,
                    _Environment_globals,
                    "f"
                  ).get(binding.name)) !== null && _d !== void 0
                    ? _d
                    : isHookName$2(binding.name)
                      ? __classPrivateFieldGet(
                          this,
                          _Environment_instances,
                          "m",
                          _Environment_getCustomHookType
                        ).call(this)
                      : null;
                } else {
                  var _moduleType = __classPrivateFieldGet(
                    this,
                    _Environment_instances,
                    "m",
                    _Environment_resolveModuleType
                  ).call(this, binding.module, loc);
                  if (_moduleType !== null) {
                    var _importedType = null;
                    if (binding.kind === "ImportDefault") {
                      var defaultType = this.getPropertyType(
                        _moduleType,
                        "default"
                      );
                      if (defaultType !== null) {
                        _importedType = defaultType;
                      }
                    } else {
                      _importedType = _moduleType;
                    }
                    if (_importedType !== null) {
                      var _expectHook = isHookName$2(binding.module);
                      var _isHook2 =
                        getHookKindForType(this, _importedType) != null;
                      if (_expectHook !== _isHook2) {
                        CompilerError.throwInvalidConfig({
                          reason: "Invalid type configuration for module",
                          description: "Expected type for `import ... from '"
                            .concat(binding.module, "'` ")
                            .concat(
                              _expectHook ? "to be a hook" : "not to be a hook",
                              " based on the module name"
                            ),
                          loc: loc
                        });
                      }
                      return _importedType;
                    }
                  }
                  return isHookName$2(binding.name)
                    ? __classPrivateFieldGet(
                        this,
                        _Environment_instances,
                        "m",
                        _Environment_getCustomHookType
                      ).call(this)
                    : null;
                }
              }
            }
          }
        },
        {
          key: "getFallthroughPropertyType",
          value: function getFallthroughPropertyType(receiver, _property) {
            var _a;
            var shapeId = null;
            if (receiver.kind === "Object" || receiver.kind === "Function") {
              shapeId = receiver.shapeId;
            }
            if (shapeId !== null) {
              var shape = __classPrivateFieldGet(
                this,
                _Environment_shapes,
                "f"
              ).get(shapeId);
              CompilerError.invariant(shape !== undefined, {
                reason:
                  "[HIR] Forget internal error: cannot resolve shape ".concat(
                    shapeId
                  ),
                description: null,
                loc: null,
                suggestions: null
              });
              return (_a = shape.properties.get("*")) !== null && _a !== void 0
                ? _a
                : null;
            }
            return null;
          }
        },
        {
          key: "getPropertyType",
          value: function getPropertyType(receiver, property) {
            var _a, _b, _c;
            var shapeId = null;
            if (receiver.kind === "Object" || receiver.kind === "Function") {
              shapeId = receiver.shapeId;
            }
            if (shapeId !== null) {
              var shape = __classPrivateFieldGet(
                this,
                _Environment_shapes,
                "f"
              ).get(shapeId);
              CompilerError.invariant(shape !== undefined, {
                reason:
                  "[HIR] Forget internal error: cannot resolve shape ".concat(
                    shapeId
                  ),
                description: null,
                loc: null,
                suggestions: null
              });
              if (typeof property === "string") {
                return (_b =
                  (_a = shape.properties.get(property)) !== null &&
                  _a !== void 0
                    ? _a
                    : shape.properties.get("*")) !== null && _b !== void 0
                  ? _b
                  : isHookName$2(property)
                    ? __classPrivateFieldGet(
                        this,
                        _Environment_instances,
                        "m",
                        _Environment_getCustomHookType
                      ).call(this)
                    : null;
              } else {
                return (_c = shape.properties.get("*")) !== null &&
                  _c !== void 0
                  ? _c
                  : null;
              }
            } else if (typeof property === "string" && isHookName$2(property)) {
              return __classPrivateFieldGet(
                this,
                _Environment_instances,
                "m",
                _Environment_getCustomHookType
              ).call(this);
            }
            return null;
          }
        },
        {
          key: "getFunctionSignature",
          value: function getFunctionSignature(type) {
            var shapeId = type.shapeId;
            if (shapeId !== null) {
              var shape = __classPrivateFieldGet(
                this,
                _Environment_shapes,
                "f"
              ).get(shapeId);
              CompilerError.invariant(shape !== undefined, {
                reason:
                  "[HIR] Forget internal error: cannot resolve shape ".concat(
                    shapeId
                  ),
                description: null,
                loc: null,
                suggestions: null
              });
              return shape.functionType;
            }
            return null;
          }
        },
        {
          key: "addHoistedIdentifier",
          value: function addHoistedIdentifier(node) {
            __classPrivateFieldGet(
              this,
              _Environment_contextIdentifiers,
              "f"
            ).add(node);
            __classPrivateFieldGet(
              this,
              _Environment_hoistedIdentifiers,
              "f"
            ).add(node);
          }
        }
      ]);
    })();
    (_Environment_globals = new WeakMap()),
      (_Environment_shapes = new WeakMap()),
      (_Environment_moduleTypes = new WeakMap()),
      (_Environment_nextIdentifer = new WeakMap()),
      (_Environment_nextBlock = new WeakMap()),
      (_Environment_nextScope = new WeakMap()),
      (_Environment_scope = new WeakMap()),
      (_Environment_outlinedFunctions = new WeakMap()),
      (_Environment_contextIdentifiers = new WeakMap()),
      (_Environment_hoistedIdentifiers = new WeakMap()),
      (_Environment_instances = new WeakSet()),
      (_Environment_resolveModuleType = function _Environment_resolveModuleType(
        moduleName,
        loc
      ) {
        var moduleType = __classPrivateFieldGet(
          this,
          _Environment_moduleTypes,
          "f"
        ).get(moduleName);
        if (moduleType === undefined) {
          if (this.config.moduleTypeProvider == null) {
            return null;
          }
          var unparsedModuleConfig = this.config.moduleTypeProvider(moduleName);
          if (unparsedModuleConfig != null) {
            var parsedModuleConfig = TypeSchema.safeParse(unparsedModuleConfig);
            if (!parsedModuleConfig.success) {
              CompilerError.throwInvalidConfig({
                reason:
                  "Could not parse module type, the configured `moduleTypeProvider` function returned an invalid module description",
                description: parsedModuleConfig.error.toString(),
                loc: loc
              });
            }
            var moduleConfig = parsedModuleConfig.data;
            moduleType = installTypeConfig(
              __classPrivateFieldGet(this, _Environment_globals, "f"),
              __classPrivateFieldGet(this, _Environment_shapes, "f"),
              moduleConfig,
              moduleName,
              loc
            );
          } else {
            moduleType = null;
          }
          __classPrivateFieldGet(this, _Environment_moduleTypes, "f").set(
            moduleName,
            moduleType
          );
        }
        return moduleType;
      }),
      (_Environment_isKnownReactModule =
        function _Environment_isKnownReactModule(moduleName) {
          return (
            moduleName.toLowerCase() === "react" ||
            moduleName.toLowerCase() === "react-dom"
          );
        }),
      (_Environment_getCustomHookType =
        function _Environment_getCustomHookType() {
          if (this.config.enableAssumeHooksFollowRulesOfReact) {
            return DefaultNonmutatingHook;
          } else {
            return DefaultMutatingHook;
          }
        });
    Environment.knownReactModules = ["react", "react-dom"];
    var REANIMATED_MODULE_NAME = "react-native-reanimated";
    function isHookName$2(name) {
      return /^use[A-Z0-9]/.test(name);
    }
    function parseEnvironmentConfig(partialConfig) {
      var config = EnvironmentConfigSchema.safeParse(partialConfig);
      if (config.success) {
        return Ok(config.data);
      } else {
        return Err(config.error);
      }
    }
    function validateEnvironmentConfig(partialConfig) {
      var config = EnvironmentConfigSchema.safeParse(partialConfig);
      if (config.success) {
        return config.data;
      }
      CompilerError.throwInvalidConfig({
        reason:
          "Could not validate environment config. Update React Compiler config to fix the error",
        description: "".concat(zodValidationError.fromZodError(config.error)),
        loc: null,
        suggestions: null
      });
    }
    function tryParseExternalFunction(maybeExternalFunction) {
      var externalFunction = ExternalFunctionSchema.safeParse(
        maybeExternalFunction
      );
      if (externalFunction.success) {
        return externalFunction.data;
      }
      CompilerError.throwInvalidConfig({
        reason:
          "Could not parse external function. Update React Compiler config to fix the error",
        description: "".concat(
          zodValidationError.fromZodError(externalFunction.error)
        ),
        loc: null,
        suggestions: null
      });
    }
    var DEFAULT_EXPORT = "default";
    var _MergedBlocks_map;
    function mergeConsecutiveBlocks(fn) {
      var merged = new MergedBlocks();
      var fallthroughBlocks = new Set();
      var _iterator131 = _createForOfIteratorHelper(fn.body.blocks),
        _step131;
      try {
        for (_iterator131.s(); !(_step131 = _iterator131.n()).done; ) {
          var _predecessor$instruct;
          var _step131$value = _slicedToArray(_step131.value, 2),
            block = _step131$value[1];
          var fallthrough = terminalFallthrough(block.terminal);
          if (fallthrough !== null) {
            fallthroughBlocks.add(fallthrough);
          }
          var _iterator133 = _createForOfIteratorHelper(block.instructions),
            _step133;
          try {
            for (_iterator133.s(); !(_step133 = _iterator133.n()).done; ) {
              var instr = _step133.value;
              if (
                instr.value.kind === "FunctionExpression" ||
                instr.value.kind === "ObjectMethod"
              ) {
                mergeConsecutiveBlocks(instr.value.loweredFunc.func);
              }
            }
          } catch (err) {
            _iterator133.e(err);
          } finally {
            _iterator133.f();
          }
          if (
            block.preds.size !== 1 ||
            block.kind !== "block" ||
            fallthroughBlocks.has(block.id)
          ) {
            continue;
          }
          var originalPredecessorId = Array.from(block.preds)[0];
          var predecessorId = merged.get(originalPredecessorId);
          var predecessor = fn.body.blocks.get(predecessorId);
          CompilerError.invariant(predecessor !== undefined, {
            reason: "Expected predecessor ".concat(predecessorId, " to exist"),
            description: null,
            loc: null,
            suggestions: null
          });
          if (
            predecessor.terminal.kind !== "goto" ||
            predecessor.kind !== "block"
          ) {
            continue;
          }
          var _iterator134 = _createForOfIteratorHelper(block.phis),
            _step134;
          try {
            for (_iterator134.s(); !(_step134 = _iterator134.n()).done; ) {
              var phi = _step134.value;
              CompilerError.invariant(phi.operands.size === 1, {
                reason:
                  "Found a block with a single predecessor but where a phi has multiple (".concat(
                    phi.operands.size,
                    ") operands"
                  ),
                description: null,
                loc: null,
                suggestions: null
              });
              var operand = Array.from(phi.operands.values())[0];
              var _instr = {
                id: predecessor.terminal.id,
                lvalue: {
                  kind: "Identifier",
                  identifier: phi.place.identifier,
                  effect: Effect.ConditionallyMutate,
                  reactive: false,
                  loc: GeneratedSource
                },
                value: {
                  kind: "LoadLocal",
                  place: Object.assign({}, operand),
                  loc: GeneratedSource
                },
                loc: GeneratedSource
              };
              predecessor.instructions.push(_instr);
            }
          } catch (err) {
            _iterator134.e(err);
          } finally {
            _iterator134.f();
          }
          (_predecessor$instruct = predecessor.instructions).push.apply(
            _predecessor$instruct,
            _toConsumableArray(block.instructions)
          );
          predecessor.terminal = block.terminal;
          merged.merge(block.id, predecessorId);
          fn.body.blocks["delete"](block.id);
        }
      } catch (err) {
        _iterator131.e(err);
      } finally {
        _iterator131.f();
      }
      markPredecessors(fn.body);
      var _iterator132 = _createForOfIteratorHelper(fn.body.blocks),
        _step132;
      try {
        for (_iterator132.s(); !(_step132 = _iterator132.n()).done; ) {
          var _step132$value = _slicedToArray(_step132.value, 2),
            terminal = _step132$value[1].terminal;
          if (terminalHasFallthrough(terminal)) {
            terminal.fallthrough = merged.get(terminal.fallthrough);
          }
        }
      } catch (err) {
        _iterator132.e(err);
      } finally {
        _iterator132.f();
      }
    }
    var MergedBlocks = /*#__PURE__*/ (function () {
      function MergedBlocks() {
        _classCallCheck(this, MergedBlocks);
        _MergedBlocks_map.set(this, new Map());
      }
      return _createClass(MergedBlocks, [
        {
          key: "merge",
          value: function merge(block, into) {
            var target = this.get(into);
            __classPrivateFieldGet(this, _MergedBlocks_map, "f").set(
              block,
              target
            );
          }
        },
        {
          key: "get",
          value: function get(block) {
            var _a;
            var current = block;
            while (
              __classPrivateFieldGet(this, _MergedBlocks_map, "f").has(current)
            ) {
              current =
                (_a = __classPrivateFieldGet(this, _MergedBlocks_map, "f").get(
                  current
                )) !== null && _a !== void 0
                  ? _a
                  : current;
            }
            return current;
          }
        }
      ]);
    })();
    _MergedBlocks_map = new WeakMap();
    var _DisjointSet_entries;
    var DisjointSet = /*#__PURE__*/ (function () {
      function DisjointSet() {
        _classCallCheck(this, DisjointSet);
        _DisjointSet_entries.set(this, new Map());
      }
      return _createClass(DisjointSet, [
        {
          key: "union",
          value: function union(items) {
            var first = items.shift();
            CompilerError.invariant(first != null, {
              reason: "Expected set to be non-empty",
              description: null,
              loc: null,
              suggestions: null
            });
            var root = this.find(first);
            if (root == null) {
              root = first;
              __classPrivateFieldGet(this, _DisjointSet_entries, "f").set(
                first,
                first
              );
            }
            var _iterator135 = _createForOfIteratorHelper(items),
              _step135;
            try {
              for (_iterator135.s(); !(_step135 = _iterator135.n()).done; ) {
                var item = _step135.value;
                var itemParent = __classPrivateFieldGet(
                  this,
                  _DisjointSet_entries,
                  "f"
                ).get(item);
                if (itemParent == null) {
                  __classPrivateFieldGet(this, _DisjointSet_entries, "f").set(
                    item,
                    root
                  );
                  continue;
                } else if (itemParent === root) {
                  continue;
                } else {
                  var current = item;
                  while (itemParent !== root) {
                    __classPrivateFieldGet(this, _DisjointSet_entries, "f").set(
                      current,
                      root
                    );
                    current = itemParent;
                    itemParent = __classPrivateFieldGet(
                      this,
                      _DisjointSet_entries,
                      "f"
                    ).get(current);
                  }
                }
              }
            } catch (err) {
              _iterator135.e(err);
            } finally {
              _iterator135.f();
            }
          }
        },
        {
          key: "find",
          value: function find(item) {
            if (
              !__classPrivateFieldGet(this, _DisjointSet_entries, "f").has(item)
            ) {
              return null;
            }
            var parent = __classPrivateFieldGet(
              this,
              _DisjointSet_entries,
              "f"
            ).get(item);
            if (parent === item) {
              return item;
            }
            var root = this.find(parent);
            __classPrivateFieldGet(this, _DisjointSet_entries, "f").set(
              item,
              root
            );
            return root;
          }
        },
        {
          key: "canonicalize",
          value: function canonicalize() {
            var entries = new Map();
            var _iterator136 = _createForOfIteratorHelper(
                __classPrivateFieldGet(this, _DisjointSet_entries, "f").keys()
              ),
              _step136;
            try {
              for (_iterator136.s(); !(_step136 = _iterator136.n()).done; ) {
                var item = _step136.value;
                var root = this.find(item);
                entries.set(item, root);
              }
            } catch (err) {
              _iterator136.e(err);
            } finally {
              _iterator136.f();
            }
            return entries;
          }
        },
        {
          key: "forEach",
          value: function forEach(fn) {
            var _iterator137 = _createForOfIteratorHelper(
                __classPrivateFieldGet(this, _DisjointSet_entries, "f").keys()
              ),
              _step137;
            try {
              for (_iterator137.s(); !(_step137 = _iterator137.n()).done; ) {
                var item = _step137.value;
                var group = this.find(item);
                fn(item, group);
              }
            } catch (err) {
              _iterator137.e(err);
            } finally {
              _iterator137.f();
            }
          }
        },
        {
          key: "buildSets",
          value: function buildSets() {
            var ids = new Map();
            var sets = new Map();
            this.forEach(function (identifier, groupIdentifier) {
              var id = ids.get(groupIdentifier);
              if (id == null) {
                id = ids.size;
                ids.set(groupIdentifier, id);
              }
              var set = sets.get(id);
              if (set === undefined) {
                set = new Set();
                sets.set(id, set);
              }
              set.add(identifier);
            });
            return _toConsumableArray(sets.values());
          }
        },
        {
          key: "size",
          get: function get() {
            return __classPrivateFieldGet(this, _DisjointSet_entries, "f").size;
          }
        }
      ]);
    })();
    _DisjointSet_entries = new WeakMap();
    function inferReactiveScopeVariables(fn) {
      var _a, _b;
      var scopeIdentifiers = findDisjointMutableValues(fn);
      var scopes = new Map();
      scopeIdentifiers.forEach(function (identifier, groupIdentifier) {
        var scope = scopes.get(groupIdentifier);
        if (scope === undefined) {
          scope = {
            id: fn.env.nextScopeId,
            range: identifier.mutableRange,
            dependencies: new Set(),
            declarations: new Map(),
            reassignments: new Set(),
            earlyReturnValue: null,
            merged: new Set(),
            loc: identifier.loc
          };
          scopes.set(groupIdentifier, scope);
        } else {
          if (scope.range.start === 0) {
            scope.range.start = identifier.mutableRange.start;
          } else if (identifier.mutableRange.start !== 0) {
            scope.range.start = makeInstructionId(
              Math.min(scope.range.start, identifier.mutableRange.start)
            );
          }
          scope.range.end = makeInstructionId(
            Math.max(scope.range.end, identifier.mutableRange.end)
          );
          scope.loc = mergeLocation(scope.loc, identifier.loc);
        }
        identifier.scope = scope;
        identifier.mutableRange = scope.range;
      });
      var maxInstruction = 0;
      var _iterator138 = _createForOfIteratorHelper(fn.body.blocks),
        _step138;
      try {
        for (_iterator138.s(); !(_step138 = _iterator138.n()).done; ) {
          var _step138$value = _slicedToArray(_step138.value, 2),
            block = _step138$value[1];
          var _iterator140 = _createForOfIteratorHelper(block.instructions),
            _step140;
          try {
            for (_iterator140.s(); !(_step140 = _iterator140.n()).done; ) {
              var instr = _step140.value;
              maxInstruction = makeInstructionId(
                Math.max(maxInstruction, instr.id)
              );
            }
          } catch (err) {
            _iterator140.e(err);
          } finally {
            _iterator140.f();
          }
          maxInstruction = makeInstructionId(
            Math.max(maxInstruction, block.terminal.id)
          );
        }
      } catch (err) {
        _iterator138.e(err);
      } finally {
        _iterator138.f();
      }
      var _iterator139 = _createForOfIteratorHelper(scopes),
        _step139;
      try {
        for (_iterator139.s(); !(_step139 = _iterator139.n()).done; ) {
          var _step139$value = _slicedToArray(_step139.value, 2),
            scope = _step139$value[1];
          if (
            scope.range.start === 0 ||
            scope.range.end === 0 ||
            maxInstruction === 0 ||
            scope.range.end > maxInstruction + 1
          ) {
            (_b =
              (_a = fn.env.logger) === null || _a === void 0
                ? void 0
                : _a.debugLogIRs) === null || _b === void 0
              ? void 0
              : _b.call(_a, {
                  kind: "hir",
                  name: "InferReactiveScopeVariables (invalid scope)",
                  value: fn
                });
            CompilerError.invariant(false, {
              reason: "Invalid mutable range for scope",
              loc: GeneratedSource,
              description: "Scope @"
                .concat(scope.id, " has range [")
                .concat(scope.range.start, ":")
                .concat(scope.range.end, "] but the valid range is [1:")
                .concat(maxInstruction + 1, "]")
            });
          }
        }
      } catch (err) {
        _iterator139.e(err);
      } finally {
        _iterator139.f();
      }
    }
    function mergeLocation(l, r) {
      if (l === GeneratedSource) {
        return r;
      } else if (r === GeneratedSource) {
        return l;
      } else {
        return {
          filename: l.filename,
          identifierName: l.identifierName,
          start: {
            index: Math.min(l.start.index, r.start.index),
            line: Math.min(l.start.line, r.start.line),
            column: Math.min(l.start.column, r.start.column)
          },
          end: {
            index: Math.max(l.end.index, r.end.index),
            line: Math.max(l.end.line, r.end.line),
            column: Math.max(l.end.column, r.end.column)
          }
        };
      }
    }
    function isMutable(instr, place) {
      return inRange(instr, place.identifier.mutableRange);
    }
    function inRange(_ref23, range) {
      var id = _ref23.id;
      return id >= range.start && id < range.end;
    }
    function mayAllocate(_env, instruction) {
      var value = instruction.value;
      switch (value.kind) {
        case "Destructure": {
          return doesPatternContainSpreadElement(value.lvalue.pattern);
        }
        case "PostfixUpdate":
        case "PrefixUpdate":
        case "Await":
        case "DeclareLocal":
        case "DeclareContext":
        case "StoreLocal":
        case "LoadGlobal":
        case "MetaProperty":
        case "TypeCastExpression":
        case "LoadLocal":
        case "LoadContext":
        case "StoreContext":
        case "PropertyDelete":
        case "ComputedLoad":
        case "ComputedDelete":
        case "JSXText":
        case "TemplateLiteral":
        case "Primitive":
        case "GetIterator":
        case "IteratorNext":
        case "NextPropertyOf":
        case "Debugger":
        case "StartMemoize":
        case "FinishMemoize":
        case "UnaryExpression":
        case "BinaryExpression":
        case "PropertyLoad":
        case "StoreGlobal": {
          return false;
        }
        case "TaggedTemplateExpression":
        case "CallExpression":
        case "MethodCall": {
          return instruction.lvalue.identifier.type.kind !== "Primitive";
        }
        case "RegExpLiteral":
        case "PropertyStore":
        case "ComputedStore":
        case "ArrayExpression":
        case "JsxExpression":
        case "JsxFragment":
        case "NewExpression":
        case "ObjectExpression":
        case "UnsupportedNode":
        case "ObjectMethod":
        case "FunctionExpression": {
          return true;
        }
        default: {
          assertExhaustive$1(
            value,
            "Unexpected value kind `".concat(value.kind, "`")
          );
        }
      }
    }
    function findDisjointMutableValues(fn) {
      var _a, _b;
      var scopeIdentifiers = new DisjointSet();
      var declarations = new Map();
      function declareIdentifier(lvalue) {
        if (!declarations.has(lvalue.identifier.declarationId)) {
          declarations.set(lvalue.identifier.declarationId, lvalue.identifier);
        }
      }
      var _iterator141 = _createForOfIteratorHelper(fn.body.blocks),
        _step141;
      try {
        for (_iterator141.s(); !(_step141 = _iterator141.n()).done; ) {
          var _step141$value = _slicedToArray(_step141.value, 2),
            _ = _step141$value[0],
            block = _step141$value[1];
          var _iterator142 = _createForOfIteratorHelper(block.phis),
            _step142;
          try {
            for (_iterator142.s(); !(_step142 = _iterator142.n()).done; ) {
              var phi = _step142.value;
              if (
                phi.place.identifier.mutableRange.start + 1 !==
                  phi.place.identifier.mutableRange.end &&
                phi.place.identifier.mutableRange.end >
                  ((_b =
                    (_a = block.instructions.at(0)) === null || _a === void 0
                      ? void 0
                      : _a.id) !== null && _b !== void 0
                    ? _b
                    : block.terminal.id)
              ) {
                var operands = [phi.place.identifier];
                var declaration = declarations.get(
                  phi.place.identifier.declarationId
                );
                if (declaration !== undefined) {
                  operands.push(declaration);
                }
                var _iterator144 = _createForOfIteratorHelper(phi.operands),
                  _step144;
                try {
                  for (
                    _iterator144.s();
                    !(_step144 = _iterator144.n()).done;

                  ) {
                    var _step144$value = _slicedToArray(_step144.value, 2),
                      _31 = _step144$value[0],
                      phiId = _step144$value[1];
                    operands.push(phiId.identifier);
                  }
                } catch (err) {
                  _iterator144.e(err);
                } finally {
                  _iterator144.f();
                }
                scopeIdentifiers.union(operands);
              } else if (fn.env.config.enableForest) {
                var _iterator145 = _createForOfIteratorHelper(phi.operands),
                  _step145;
                try {
                  for (
                    _iterator145.s();
                    !(_step145 = _iterator145.n()).done;

                  ) {
                    var _step145$value = _slicedToArray(_step145.value, 2),
                      _phiId = _step145$value[1];
                    scopeIdentifiers.union([
                      phi.place.identifier,
                      _phiId.identifier
                    ]);
                  }
                } catch (err) {
                  _iterator145.e(err);
                } finally {
                  _iterator145.f();
                }
              }
            }
          } catch (err) {
            _iterator142.e(err);
          } finally {
            _iterator142.f();
          }
          var _iterator143 = _createForOfIteratorHelper(block.instructions),
            _step143;
          try {
            for (_iterator143.s(); !(_step143 = _iterator143.n()).done; ) {
              var instr = _step143.value;
              var _operands = [];
              var range = instr.lvalue.identifier.mutableRange;
              if (range.end > range.start + 1 || mayAllocate(fn.env, instr)) {
                _operands.push(instr.lvalue.identifier);
              }
              if (
                instr.value.kind === "DeclareLocal" ||
                instr.value.kind === "DeclareContext"
              ) {
                declareIdentifier(instr.value.lvalue.place);
              } else if (
                instr.value.kind === "StoreLocal" ||
                instr.value.kind === "StoreContext"
              ) {
                declareIdentifier(instr.value.lvalue.place);
                if (
                  instr.value.lvalue.place.identifier.mutableRange.end >
                  instr.value.lvalue.place.identifier.mutableRange.start + 1
                ) {
                  _operands.push(instr.value.lvalue.place.identifier);
                }
                if (
                  isMutable(instr, instr.value.value) &&
                  instr.value.value.identifier.mutableRange.start > 0
                ) {
                  _operands.push(instr.value.value.identifier);
                }
              } else if (instr.value.kind === "Destructure") {
                var _iterator146 = _createForOfIteratorHelper(
                    eachPatternOperand(instr.value.lvalue.pattern)
                  ),
                  _step146;
                try {
                  for (
                    _iterator146.s();
                    !(_step146 = _iterator146.n()).done;

                  ) {
                    var place = _step146.value;
                    declareIdentifier(place);
                    if (
                      place.identifier.mutableRange.end >
                      place.identifier.mutableRange.start + 1
                    ) {
                      _operands.push(place.identifier);
                    }
                  }
                } catch (err) {
                  _iterator146.e(err);
                } finally {
                  _iterator146.f();
                }
                if (
                  isMutable(instr, instr.value.value) &&
                  instr.value.value.identifier.mutableRange.start > 0
                ) {
                  _operands.push(instr.value.value.identifier);
                }
              } else if (instr.value.kind === "MethodCall") {
                var _iterator147 = _createForOfIteratorHelper(
                    eachInstructionOperand(instr)
                  ),
                  _step147;
                try {
                  for (
                    _iterator147.s();
                    !(_step147 = _iterator147.n()).done;

                  ) {
                    var operand = _step147.value;
                    if (
                      isMutable(instr, operand) &&
                      operand.identifier.mutableRange.start > 0
                    ) {
                      _operands.push(operand.identifier);
                    }
                  }
                } catch (err) {
                  _iterator147.e(err);
                } finally {
                  _iterator147.f();
                }
                _operands.push(instr.value.property.identifier);
              } else {
                var _iterator148 = _createForOfIteratorHelper(
                    eachInstructionOperand(instr)
                  ),
                  _step148;
                try {
                  for (
                    _iterator148.s();
                    !(_step148 = _iterator148.n()).done;

                  ) {
                    var _operand9 = _step148.value;
                    if (
                      isMutable(instr, _operand9) &&
                      _operand9.identifier.mutableRange.start > 0
                    ) {
                      if (
                        instr.value.kind === "FunctionExpression" ||
                        instr.value.kind === "ObjectMethod"
                      ) {
                        if (_operand9.identifier.type.kind === "Primitive") {
                          continue;
                        }
                      }
                      _operands.push(_operand9.identifier);
                    }
                  }
                } catch (err) {
                  _iterator148.e(err);
                } finally {
                  _iterator148.f();
                }
              }
              if (_operands.length !== 0) {
                scopeIdentifiers.union(_operands);
              }
            }
          } catch (err) {
            _iterator143.e(err);
          } finally {
            _iterator143.f();
          }
        }
      } catch (err) {
        _iterator141.e(err);
      } finally {
        _iterator141.f();
      }
      return scopeIdentifiers;
    }
    function mergeOverlappingReactiveScopesHIR(fn) {
      var scopesInfo = collectScopeInfo(fn);
      var joinedScopes = getOverlappingReactiveScopes(fn, scopesInfo);
      joinedScopes.forEach(function (scope, groupScope) {
        if (scope !== groupScope) {
          groupScope.range.start = makeInstructionId(
            Math.min(groupScope.range.start, scope.range.start)
          );
          groupScope.range.end = makeInstructionId(
            Math.max(groupScope.range.end, scope.range.end)
          );
        }
      });
      var _iterator149 = _createForOfIteratorHelper(scopesInfo.placeScopes),
        _step149;
      try {
        for (_iterator149.s(); !(_step149 = _iterator149.n()).done; ) {
          var _step149$value = _slicedToArray(_step149.value, 2),
            place = _step149$value[0],
            originalScope = _step149$value[1];
          var nextScope = joinedScopes.find(originalScope);
          if (nextScope !== null && nextScope !== originalScope) {
            place.identifier.scope = nextScope;
          }
        }
      } catch (err) {
        _iterator149.e(err);
      } finally {
        _iterator149.f();
      }
    }
    function collectScopeInfo(fn) {
      var scopeStarts = new Map();
      var scopeEnds = new Map();
      var placeScopes = new Map();
      function collectPlaceScope(place) {
        var scope = place.identifier.scope;
        if (scope != null) {
          placeScopes.set(place, scope);
          if (scope.range.start !== scope.range.end) {
            getOrInsertDefault(scopeStarts, scope.range.start, new Set()).add(
              scope
            );
            getOrInsertDefault(scopeEnds, scope.range.end, new Set()).add(
              scope
            );
          }
        }
      }
      var _iterator150 = _createForOfIteratorHelper(fn.body.blocks),
        _step150;
      try {
        for (_iterator150.s(); !(_step150 = _iterator150.n()).done; ) {
          var _step150$value = _slicedToArray(_step150.value, 2),
            block = _step150$value[1];
          var _iterator151 = _createForOfIteratorHelper(block.instructions),
            _step151;
          try {
            for (_iterator151.s(); !(_step151 = _iterator151.n()).done; ) {
              var instr = _step151.value;
              var _iterator153 = _createForOfIteratorHelper(
                  eachInstructionLValue(instr)
                ),
                _step153;
              try {
                for (_iterator153.s(); !(_step153 = _iterator153.n()).done; ) {
                  var operand = _step153.value;
                  collectPlaceScope(operand);
                }
              } catch (err) {
                _iterator153.e(err);
              } finally {
                _iterator153.f();
              }
              var _iterator154 = _createForOfIteratorHelper(
                  eachInstructionOperand(instr)
                ),
                _step154;
              try {
                for (_iterator154.s(); !(_step154 = _iterator154.n()).done; ) {
                  var _operand10 = _step154.value;
                  collectPlaceScope(_operand10);
                }
              } catch (err) {
                _iterator154.e(err);
              } finally {
                _iterator154.f();
              }
            }
          } catch (err) {
            _iterator151.e(err);
          } finally {
            _iterator151.f();
          }
          var _iterator152 = _createForOfIteratorHelper(
              eachTerminalOperand(block.terminal)
            ),
            _step152;
          try {
            for (_iterator152.s(); !(_step152 = _iterator152.n()).done; ) {
              var _operand11 = _step152.value;
              collectPlaceScope(_operand11);
            }
          } catch (err) {
            _iterator152.e(err);
          } finally {
            _iterator152.f();
          }
        }
      } catch (err) {
        _iterator150.e(err);
      } finally {
        _iterator150.f();
      }
      return {
        scopeStarts: _toConsumableArray(scopeStarts.entries())
          .map(function (_ref24) {
            var _ref25 = _slicedToArray(_ref24, 2),
              id = _ref25[0],
              scopes = _ref25[1];
            return { id: id, scopes: scopes };
          })
          .sort(function (a, b) {
            return b.id - a.id;
          }),
        scopeEnds: _toConsumableArray(scopeEnds.entries())
          .map(function (_ref26) {
            var _ref27 = _slicedToArray(_ref26, 2),
              id = _ref27[0],
              scopes = _ref27[1];
            return { id: id, scopes: scopes };
          })
          .sort(function (a, b) {
            return b.id - a.id;
          }),
        placeScopes: placeScopes
      };
    }
    function visitInstructionId(id, _ref28, _ref29) {
      var scopeEnds = _ref28.scopeEnds,
        scopeStarts = _ref28.scopeStarts;
      var activeScopes = _ref29.activeScopes,
        joined = _ref29.joined;
      var scopeEndTop = scopeEnds.at(-1);
      if (scopeEndTop != null && scopeEndTop.id <= id) {
        scopeEnds.pop();
        var scopesSortedStartDescending = _toConsumableArray(
          scopeEndTop.scopes
        ).sort(function (a, b) {
          return b.range.start - a.range.start;
        });
        var _iterator155 = _createForOfIteratorHelper(
            scopesSortedStartDescending
          ),
          _step155;
        try {
          for (_iterator155.s(); !(_step155 = _iterator155.n()).done; ) {
            var scope = _step155.value;
            var idx = activeScopes.indexOf(scope);
            if (idx !== -1) {
              if (idx !== activeScopes.length - 1) {
                joined.union(
                  [scope].concat(
                    _toConsumableArray(activeScopes.slice(idx + 1))
                  )
                );
              }
              activeScopes.splice(idx, 1);
            }
          }
        } catch (err) {
          _iterator155.e(err);
        } finally {
          _iterator155.f();
        }
      }
      var scopeStartTop = scopeStarts.at(-1);
      if (scopeStartTop != null && scopeStartTop.id <= id) {
        scopeStarts.pop();
        var scopesSortedEndDescending = _toConsumableArray(
          scopeStartTop.scopes
        ).sort(function (a, b) {
          return b.range.end - a.range.end;
        });
        activeScopes.push.apply(
          activeScopes,
          _toConsumableArray(scopesSortedEndDescending)
        );
        for (var i = 1; i < scopesSortedEndDescending.length; i++) {
          var prev = scopesSortedEndDescending[i - 1];
          var curr = scopesSortedEndDescending[i];
          if (prev.range.end === curr.range.end) {
            joined.union([prev, curr]);
          }
        }
      }
    }
    function visitPlace(id, place, _ref30) {
      var activeScopes = _ref30.activeScopes,
        joined = _ref30.joined;
      var placeScope = getPlaceScope(id, place);
      if (placeScope != null && isMutable({ id: id }, place)) {
        var placeScopeIdx = activeScopes.indexOf(placeScope);
        if (placeScopeIdx !== -1 && placeScopeIdx !== activeScopes.length - 1) {
          joined.union(
            [placeScope].concat(
              _toConsumableArray(activeScopes.slice(placeScopeIdx + 1))
            )
          );
        }
      }
    }
    function getOverlappingReactiveScopes(fn, context) {
      var state = { joined: new DisjointSet(), activeScopes: [] };
      var _iterator156 = _createForOfIteratorHelper(fn.body.blocks),
        _step156;
      try {
        for (_iterator156.s(); !(_step156 = _iterator156.n()).done; ) {
          var _step156$value = _slicedToArray(_step156.value, 2),
            block = _step156$value[1];
          var _iterator157 = _createForOfIteratorHelper(block.instructions),
            _step157;
          try {
            for (_iterator157.s(); !(_step157 = _iterator157.n()).done; ) {
              var instr = _step157.value;
              visitInstructionId(instr.id, context, state);
              var _iterator159 = _createForOfIteratorHelper(
                  eachInstructionOperand(instr)
                ),
                _step159;
              try {
                for (_iterator159.s(); !(_step159 = _iterator159.n()).done; ) {
                  var place = _step159.value;
                  if (
                    (instr.value.kind === "FunctionExpression" ||
                      instr.value.kind === "ObjectMethod") &&
                    place.identifier.type.kind === "Primitive"
                  ) {
                    continue;
                  }
                  visitPlace(instr.id, place, state);
                }
              } catch (err) {
                _iterator159.e(err);
              } finally {
                _iterator159.f();
              }
              var _iterator160 = _createForOfIteratorHelper(
                  eachInstructionLValue(instr)
                ),
                _step160;
              try {
                for (_iterator160.s(); !(_step160 = _iterator160.n()).done; ) {
                  var _place15 = _step160.value;
                  visitPlace(instr.id, _place15, state);
                }
              } catch (err) {
                _iterator160.e(err);
              } finally {
                _iterator160.f();
              }
            }
          } catch (err) {
            _iterator157.e(err);
          } finally {
            _iterator157.f();
          }
          visitInstructionId(block.terminal.id, context, state);
          var _iterator158 = _createForOfIteratorHelper(
              eachTerminalOperand(block.terminal)
            ),
            _step158;
          try {
            for (_iterator158.s(); !(_step158 = _iterator158.n()).done; ) {
              var _place16 = _step158.value;
              visitPlace(block.terminal.id, _place16, state);
            }
          } catch (err) {
            _iterator158.e(err);
          } finally {
            _iterator158.f();
          }
        }
      } catch (err) {
        _iterator156.e(err);
      } finally {
        _iterator156.f();
      }
      return state.joined;
    }
    function pruneUnusedLabelsHIR(fn) {
      var _a;
      var merged = [];
      var rewrites = new Map();
      var _iterator161 = _createForOfIteratorHelper(fn.body.blocks),
        _step161;
      try {
        for (_iterator161.s(); !(_step161 = _iterator161.n()).done; ) {
          var _step161$value = _slicedToArray(_step161.value, 2),
            blockId = _step161$value[0],
            block = _step161$value[1];
          var terminal = block.terminal;
          if (terminal.kind === "label") {
            var _nextId = terminal.block,
              _fallthroughId = terminal.fallthrough;
            var _next = fn.body.blocks.get(_nextId);
            var _fallthrough15 = fn.body.blocks.get(_fallthroughId);
            if (
              _next.terminal.kind === "goto" &&
              _next.terminal.variant === GotoVariant.Break &&
              _next.terminal.block === _fallthroughId
            ) {
              if (_next.kind === "block" && _fallthrough15.kind === "block") {
                merged.push({
                  label: blockId,
                  next: _nextId,
                  fallthrough: _fallthroughId
                });
              }
            }
          }
        }
      } catch (err) {
        _iterator161.e(err);
      } finally {
        _iterator161.f();
      }
      for (var _i33 = 0, _merged = merged; _i33 < _merged.length; _i33++) {
        var _label$instructions;
        var _merged$_i = _merged[_i33],
          originalLabelId = _merged$_i.label,
          nextId = _merged$_i.next,
          fallthroughId = _merged$_i.fallthrough;
        var labelId =
          (_a = rewrites.get(originalLabelId)) !== null && _a !== void 0
            ? _a
            : originalLabelId;
        var label = fn.body.blocks.get(labelId);
        var next = fn.body.blocks.get(nextId);
        var fallthrough = fn.body.blocks.get(fallthroughId);
        CompilerError.invariant(
          next.phis.size === 0 && fallthrough.phis.size === 0,
          {
            reason: "Unexpected phis when merging label blocks",
            loc: label.terminal.loc
          }
        );
        CompilerError.invariant(
          next.preds.size === 1 &&
            fallthrough.preds.size === 1 &&
            next.preds.has(originalLabelId) &&
            fallthrough.preds.has(nextId),
          {
            reason: "Unexpected block predecessors when merging label blocks",
            loc: label.terminal.loc
          }
        );
        (_label$instructions = label.instructions).push.apply(
          _label$instructions,
          _toConsumableArray(next.instructions).concat(
            _toConsumableArray(fallthrough.instructions)
          )
        );
        label.terminal = fallthrough.terminal;
        fn.body.blocks["delete"](nextId);
        fn.body.blocks["delete"](fallthroughId);
        rewrites.set(fallthroughId, labelId);
      }
      var _iterator162 = _createForOfIteratorHelper(fn.body.blocks),
        _step162;
      try {
        for (_iterator162.s(); !(_step162 = _iterator162.n()).done; ) {
          var _step162$value = _slicedToArray(_step162.value, 2),
            _ = _step162$value[0],
            _block9 = _step162$value[1];
          var _iterator163 = _createForOfIteratorHelper(_block9.preds),
            _step163;
          try {
            for (_iterator163.s(); !(_step163 = _iterator163.n()).done; ) {
              var pred = _step163.value;
              var rewritten = rewrites.get(pred);
              if (rewritten != null) {
                _block9.preds["delete"](pred);
                _block9.preds.add(rewritten);
              }
            }
          } catch (err) {
            _iterator163.e(err);
          } finally {
            _iterator163.f();
          }
        }
      } catch (err) {
        _iterator162.e(err);
      } finally {
        _iterator162.f();
      }
    }
    function validateRestrictedImports(path, _ref31) {
      var validateBlocklistedImports = _ref31.validateBlocklistedImports;
      if (
        validateBlocklistedImports == null ||
        validateBlocklistedImports.length === 0
      ) {
        return null;
      }
      var error = new CompilerError();
      var restrictedImports = new Set(validateBlocklistedImports);
      path.traverse({
        ImportDeclaration: function ImportDeclaration(importDeclPath) {
          var _a;
          if (restrictedImports.has(importDeclPath.node.source.value)) {
            error.push({
              severity: ErrorSeverity.Todo,
              reason: "Bailing out due to blocklisted import",
              description: "Import from module ".concat(
                importDeclPath.node.source.value
              ),
              loc:
                (_a = importDeclPath.node.loc) !== null && _a !== void 0
                  ? _a
                  : null
            });
          }
        }
      });
      if (error.hasErrors()) {
        return error;
      } else {
        return null;
      }
    }
    function addImportsToProgram(path, importList) {
      var identifiers = new Set();
      var sortedImports = new Map();
      var _iterator164 = _createForOfIteratorHelper(importList),
        _step164;
      try {
        for (_iterator164.s(); !(_step164 = _iterator164.n()).done; ) {
          var _step164$value = _step164.value,
            importSpecifierName = _step164$value.importSpecifierName,
            source = _step164$value.source;
          CompilerError.invariant(
            identifiers.has(importSpecifierName) === false,
            {
              reason: "Encountered conflicting import specifier for ".concat(
                importSpecifierName,
                " in Forget config."
              ),
              description: null,
              loc: GeneratedSource,
              suggestions: null
            }
          );
          CompilerError.invariant(
            path.scope.hasBinding(importSpecifierName) === false,
            {
              reason: "Encountered conflicting import specifiers for ".concat(
                importSpecifierName,
                " in generated program."
              ),
              description: null,
              loc: GeneratedSource,
              suggestions: null
            }
          );
          identifiers.add(importSpecifierName);
          var importSpecifierNameList = getOrInsertDefault(
            sortedImports,
            source,
            []
          );
          importSpecifierNameList.push(importSpecifierName);
        }
      } catch (err) {
        _iterator164.e(err);
      } finally {
        _iterator164.f();
      }
      var stmts = [];
      var _iterator165 = _createForOfIteratorHelper(sortedImports),
        _step165;
      try {
        for (_iterator165.s(); !(_step165 = _iterator165.n()).done; ) {
          var _step165$value = _slicedToArray(_step165.value, 2),
            _source = _step165$value[0],
            _importSpecifierNameList = _step165$value[1];
          var importSpecifiers = _importSpecifierNameList.map(function (name) {
            var id = libExports.identifier(name);
            return libExports.importSpecifier(id, id);
          });
          stmts.push(
            libExports.importDeclaration(
              importSpecifiers,
              libExports.stringLiteral(_source)
            )
          );
        }
      } catch (err) {
        _iterator165.e(err);
      } finally {
        _iterator165.f();
      }
      path.unshiftContainer("body", stmts);
    }
    function isNonNamespacedImport(importDeclPath, moduleName) {
      return (
        importDeclPath.get("source").node.value === moduleName &&
        importDeclPath.get("specifiers").every(function (specifier) {
          return specifier.isImportSpecifier();
        }) &&
        importDeclPath.node.importKind !== "type" &&
        importDeclPath.node.importKind !== "typeof"
      );
    }
    function hasExistingNonNamespacedImportOfModule(program, moduleName) {
      var hasExistingImport = false;
      program.traverse({
        ImportDeclaration: function ImportDeclaration(importDeclPath) {
          if (isNonNamespacedImport(importDeclPath, moduleName)) {
            hasExistingImport = true;
          }
        }
      });
      return hasExistingImport;
    }
    function addMemoCacheFunctionSpecifierToExistingImport(
      program,
      moduleName,
      identifierName
    ) {
      var didInsertUseMemoCache = false;
      program.traverse({
        ImportDeclaration: function ImportDeclaration(importDeclPath) {
          if (
            !didInsertUseMemoCache &&
            isNonNamespacedImport(importDeclPath, moduleName)
          ) {
            importDeclPath.pushContainer(
              "specifiers",
              libExports.importSpecifier(
                libExports.identifier(identifierName),
                libExports.identifier("c")
              )
            );
            didInsertUseMemoCache = true;
          }
        }
      });
      return didInsertUseMemoCache;
    }
    function updateMemoCacheFunctionImport(
      program,
      moduleName,
      useMemoCacheIdentifier
    ) {
      var hasExistingImport = hasExistingNonNamespacedImportOfModule(
        program,
        moduleName
      );
      if (hasExistingImport) {
        var didUpdateImport = addMemoCacheFunctionSpecifierToExistingImport(
          program,
          moduleName,
          useMemoCacheIdentifier
        );
        if (!didUpdateImport) {
          throw new Error(
            "Expected an ImportDeclaration of `".concat(
              moduleName,
              "` in order to update ImportSpecifiers with useMemoCache"
            )
          );
        }
      } else {
        addMemoCacheFunctionImportDeclaration(
          program,
          moduleName,
          useMemoCacheIdentifier
        );
      }
    }
    function addMemoCacheFunctionImportDeclaration(
      program,
      moduleName,
      localName
    ) {
      program.unshiftContainer(
        "body",
        libExports.importDeclaration(
          [
            libExports.importSpecifier(
              libExports.identifier(localName),
              libExports.identifier("c")
            )
          ],
          libExports.stringLiteral(moduleName)
        )
      );
    }
    zod.z["enum"](["all_errors", "critical_errors", "none"]);
    var CompilerReactTargetSchema = zod.z.union([
      zod.z.literal("17"),
      zod.z.literal("18"),
      zod.z.literal("19"),
      zod.z.object({
        kind: zod.z.literal("donotuse_meta_internal"),
        runtimeModule: zod.z.string()["default"]("react")
      })
    ]);
    zod.z["enum"](["infer", "syntax", "annotation", "all"]);
    var defaultOptions = {
      compilationMode: "infer",
      panicThreshold: "none",
      environment: parseEnvironmentConfig({}).unwrap(),
      logger: null,
      gating: null,
      noEmit: false,
      eslintSuppressionRules: null,
      flowSuppressions: true,
      ignoreUseNoForget: false,
      sources: function sources(filename) {
        return filename.indexOf("node_modules") === -1;
      },
      enableReanimatedCheck: true,
      target: "19"
    };
    function parsePluginOptions(obj) {
      if (obj == null || _typeof(obj) !== "object") {
        return defaultOptions;
      }
      var parsedOptions = Object.create(null);
      for (
        var _i34 = 0, _Object$entries4 = Object.entries(obj);
        _i34 < _Object$entries4.length;
        _i34++
      ) {
        var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i34], 2),
          _key31 = _Object$entries4$_i[0],
          value = _Object$entries4$_i[1];
        if (typeof value === "string") {
          value = value.toLowerCase();
        }
        if (isCompilerFlag(_key31)) {
          switch (_key31) {
            case "environment": {
              var environmentResult = parseEnvironmentConfig(value);
              if (environmentResult.isErr()) {
                CompilerError.throwInvalidConfig({
                  reason:
                    "Error in validating environment config. This is an advanced setting and not meant to be used directly",
                  description: environmentResult.unwrapErr().toString(),
                  suggestions: null,
                  loc: null
                });
              }
              parsedOptions[_key31] = environmentResult.unwrap();
              break;
            }
            case "target": {
              parsedOptions[_key31] = parseTargetConfig(value);
              break;
            }
            case "gating": {
              if (value == null) {
                parsedOptions[_key31] = null;
              } else {
                parsedOptions[_key31] = tryParseExternalFunction(value);
              }
              break;
            }
            default: {
              parsedOptions[_key31] = value;
            }
          }
        }
      }
      return Object.assign(Object.assign({}, defaultOptions), parsedOptions);
    }
    function parseTargetConfig(value) {
      var parsed = CompilerReactTargetSchema.safeParse(value);
      if (parsed.success) {
        return parsed.data;
      } else {
        CompilerError.throwInvalidConfig({
          reason: "Not a valid target",
          description: "".concat(zodValidationError.fromZodError(parsed.error)),
          suggestions: null,
          loc: null
        });
      }
    }
    function isCompilerFlag(s) {
      return hasOwnProperty$1(defaultOptions, s);
    }
    var DEFAULT_IDENTIFIER_INFO = {
      reassigned: false,
      reassignedByInnerFn: false,
      referencedByInnerFn: false
    };
    var withFunctionScope = {
      enter: function enter(path, state) {
        state.currentFn.push(path);
      },
      exit: function exit(_, state) {
        state.currentFn.pop();
      }
    };
    function findContextIdentifiers(func) {
      var state = { currentFn: [], identifiers: new Map() };
      func.traverse(
        {
          FunctionDeclaration: withFunctionScope,
          FunctionExpression: withFunctionScope,
          ArrowFunctionExpression: withFunctionScope,
          ObjectMethod: withFunctionScope,
          AssignmentExpression: function AssignmentExpression(path, state) {
            var _a, _b;
            var left = path.get("left");
            if (left.isLVal()) {
              var currentFn =
                (_a = state.currentFn.at(-1)) !== null && _a !== void 0
                  ? _a
                  : null;
              handleAssignment(currentFn, state.identifiers, left);
            } else {
              CompilerError.throwTodo({
                reason:
                  "Unsupported syntax on the left side of an AssignmentExpression",
                description: "Expected an LVal, got: ".concat(left.type),
                loc: (_b = left.node.loc) !== null && _b !== void 0 ? _b : null
              });
            }
          },
          UpdateExpression: function UpdateExpression(path, state) {
            var _a;
            var argument = path.get("argument");
            var currentFn =
              (_a = state.currentFn.at(-1)) !== null && _a !== void 0
                ? _a
                : null;
            if (argument.isLVal()) {
              handleAssignment(currentFn, state.identifiers, argument);
            }
          },
          Identifier: function Identifier(path, state) {
            var _a;
            var currentFn =
              (_a = state.currentFn.at(-1)) !== null && _a !== void 0
                ? _a
                : null;
            if (path.isReferencedIdentifier()) {
              handleIdentifier$1(currentFn, state.identifiers, path);
            }
          }
        },
        state
      );
      var result = new Set();
      var _iterator166 = _createForOfIteratorHelper(
          state.identifiers.entries()
        ),
        _step166;
      try {
        for (_iterator166.s(); !(_step166 = _iterator166.n()).done; ) {
          var _step166$value = _slicedToArray(_step166.value, 2),
            id = _step166$value[0],
            info = _step166$value[1];
          if (info.reassignedByInnerFn) {
            result.add(id);
          } else if (info.reassigned && info.referencedByInnerFn) {
            result.add(id);
          }
        }
      } catch (err) {
        _iterator166.e(err);
      } finally {
        _iterator166.f();
      }
      return result;
    }
    function handleIdentifier$1(currentFn, identifiers, path) {
      var name = path.node.name;
      var binding = path.scope.getBinding(name);
      if (binding == null) {
        return;
      }
      var identifier = getOrInsertDefault(
        identifiers,
        binding.identifier,
        Object.assign({}, DEFAULT_IDENTIFIER_INFO)
      );
      if (currentFn != null) {
        var bindingAboveLambdaScope = currentFn.scope.parent.getBinding(name);
        if (binding === bindingAboveLambdaScope) {
          identifier.referencedByInnerFn = true;
        }
      }
    }
    function handleAssignment(currentFn, identifiers, lvalPath) {
      var _a, _b, _c;
      var lvalNode = lvalPath.node;
      switch (lvalNode.type) {
        case "Identifier": {
          var path = lvalPath;
          var _name2 = path.node.name;
          var binding = path.scope.getBinding(_name2);
          if (binding == null) {
            break;
          }
          var state = getOrInsertDefault(
            identifiers,
            binding.identifier,
            Object.assign({}, DEFAULT_IDENTIFIER_INFO)
          );
          state.reassigned = true;
          if (currentFn != null) {
            var bindingAboveLambdaScope =
              currentFn.scope.parent.getBinding(_name2);
            if (binding === bindingAboveLambdaScope) {
              state.reassignedByInnerFn = true;
            }
          }
          break;
        }
        case "ArrayPattern": {
          var _path3 = lvalPath;
          var _iterator167 = _createForOfIteratorHelper(_path3.get("elements")),
            _step167;
          try {
            for (_iterator167.s(); !(_step167 = _iterator167.n()).done; ) {
              var element = _step167.value;
              if (nonNull(element)) {
                handleAssignment(currentFn, identifiers, element);
              }
            }
          } catch (err) {
            _iterator167.e(err);
          } finally {
            _iterator167.f();
          }
          break;
        }
        case "ObjectPattern": {
          var _path4 = lvalPath;
          var _iterator168 = _createForOfIteratorHelper(
              _path4.get("properties")
            ),
            _step168;
          try {
            for (_iterator168.s(); !(_step168 = _iterator168.n()).done; ) {
              var property = _step168.value;
              if (property.isObjectProperty()) {
                var valuePath = property.get("value");
                CompilerError.invariant(valuePath.isLVal(), {
                  reason:
                    "[FindContextIdentifiers] Expected object property value to be an LVal, got: ".concat(
                      valuePath.type
                    ),
                  description: null,
                  loc:
                    (_a = valuePath.node.loc) !== null && _a !== void 0
                      ? _a
                      : GeneratedSource,
                  suggestions: null
                });
                handleAssignment(currentFn, identifiers, valuePath);
              } else {
                CompilerError.invariant(property.isRestElement(), {
                  reason:
                    "[FindContextIdentifiers] Invalid assumptions for babel types.",
                  description: null,
                  loc:
                    (_b = property.node.loc) !== null && _b !== void 0
                      ? _b
                      : GeneratedSource,
                  suggestions: null
                });
                handleAssignment(currentFn, identifiers, property);
              }
            }
          } catch (err) {
            _iterator168.e(err);
          } finally {
            _iterator168.f();
          }
          break;
        }
        case "AssignmentPattern": {
          var _path5 = lvalPath;
          var left = _path5.get("left");
          handleAssignment(currentFn, identifiers, left);
          break;
        }
        case "RestElement": {
          var _path6 = lvalPath;
          handleAssignment(currentFn, identifiers, _path6.get("argument"));
          break;
        }
        case "MemberExpression": {
          break;
        }
        default: {
          CompilerError.throwTodo({
            reason:
              "[FindContextIdentifiers] Cannot handle Object destructuring assignment target ".concat(
                lvalNode.type
              ),
            description: null,
            loc:
              (_c = lvalNode.loc) !== null && _c !== void 0
                ? _c
                : GeneratedSource,
            suggestions: null
          });
        }
      }
    }
    function nonNull(t) {
      return t.node != null;
    }
    function eliminateRedundantPhi(fn, sharedRewrites) {
      var ir = fn.body;
      var rewrites = sharedRewrites != null ? sharedRewrites : new Map();
      var hasBackEdge = false;
      var visited = new Set();
      var size = rewrites.size;
      do {
        size = rewrites.size;
        var _iterator169 = _createForOfIteratorHelper(ir.blocks),
          _step169;
        try {
          for (_iterator169.s(); !(_step169 = _iterator169.n()).done; ) {
            var _step169$value = _slicedToArray(_step169.value, 2),
              blockId = _step169$value[0],
              block = _step169$value[1];
            if (!hasBackEdge) {
              var _iterator170 = _createForOfIteratorHelper(block.preds),
                _step170;
              try {
                for (_iterator170.s(); !(_step170 = _iterator170.n()).done; ) {
                  var predId = _step170.value;
                  if (!visited.has(predId)) {
                    hasBackEdge = true;
                  }
                }
              } catch (err) {
                _iterator170.e(err);
              } finally {
                _iterator170.f();
              }
            }
            visited.add(blockId);
            var _iterator171 = _createForOfIteratorHelper(block.phis),
              _step171;
            try {
              phis: for (
                _iterator171.s();
                !(_step171 = _iterator171.n()).done;

              ) {
                var phi = _step171.value;
                phi.operands.forEach(function (place, _) {
                  return rewritePlace(place, rewrites);
                });
                var same = null;
                var _iterator174 = _createForOfIteratorHelper(phi.operands),
                  _step174;
                try {
                  for (
                    _iterator174.s();
                    !(_step174 = _iterator174.n()).done;

                  ) {
                    var _step174$value = _slicedToArray(_step174.value, 2),
                      _ = _step174$value[0],
                      operand = _step174$value[1];
                    if (
                      (same !== null && operand.identifier.id === same.id) ||
                      operand.identifier.id === phi.place.identifier.id
                    ) {
                      continue;
                    } else if (same !== null) {
                      continue phis;
                    } else {
                      same = operand.identifier;
                    }
                  }
                } catch (err) {
                  _iterator174.e(err);
                } finally {
                  _iterator174.f();
                }
                CompilerError.invariant(same !== null, {
                  reason: "Expected phis to be non-empty",
                  description: null,
                  loc: null,
                  suggestions: null
                });
                rewrites.set(phi.place.identifier, same);
                block.phis["delete"](phi);
              }
            } catch (err) {
              _iterator171.e(err);
            } finally {
              _iterator171.f();
            }
            var _iterator172 = _createForOfIteratorHelper(block.instructions),
              _step172;
            try {
              for (_iterator172.s(); !(_step172 = _iterator172.n()).done; ) {
                var instr = _step172.value;
                var _iterator175 = _createForOfIteratorHelper(
                    eachInstructionLValue(instr)
                  ),
                  _step175;
                try {
                  for (
                    _iterator175.s();
                    !(_step175 = _iterator175.n()).done;

                  ) {
                    var _place17 = _step175.value;
                    rewritePlace(_place17, rewrites);
                  }
                } catch (err) {
                  _iterator175.e(err);
                } finally {
                  _iterator175.f();
                }
                var _iterator176 = _createForOfIteratorHelper(
                    eachInstructionOperand(instr)
                  ),
                  _step176;
                try {
                  for (
                    _iterator176.s();
                    !(_step176 = _iterator176.n()).done;

                  ) {
                    var _place18 = _step176.value;
                    rewritePlace(_place18, rewrites);
                  }
                } catch (err) {
                  _iterator176.e(err);
                } finally {
                  _iterator176.f();
                }
                if (
                  instr.value.kind === "FunctionExpression" ||
                  instr.value.kind === "ObjectMethod"
                ) {
                  var context = instr.value.loweredFunc.func.context;
                  var _iterator177 = _createForOfIteratorHelper(context),
                    _step177;
                  try {
                    for (
                      _iterator177.s();
                      !(_step177 = _iterator177.n()).done;

                    ) {
                      var place = _step177.value;
                      rewritePlace(place, rewrites);
                    }
                  } catch (err) {
                    _iterator177.e(err);
                  } finally {
                    _iterator177.f();
                  }
                  eliminateRedundantPhi(instr.value.loweredFunc.func, rewrites);
                }
              }
            } catch (err) {
              _iterator172.e(err);
            } finally {
              _iterator172.f();
            }
            var terminal = block.terminal;
            var _iterator173 = _createForOfIteratorHelper(
                eachTerminalOperand(terminal)
              ),
              _step173;
            try {
              for (_iterator173.s(); !(_step173 = _iterator173.n()).done; ) {
                var _place19 = _step173.value;
                rewritePlace(_place19, rewrites);
              }
            } catch (err) {
              _iterator173.e(err);
            } finally {
              _iterator173.f();
            }
          }
        } catch (err) {
          _iterator169.e(err);
        } finally {
          _iterator169.f();
        }
      } while (rewrites.size > size && hasBackEdge);
    }
    function rewritePlace(place, rewrites) {
      var rewrite = rewrites.get(place.identifier);
      if (rewrite != null) {
        place.identifier = rewrite;
      }
    }
    var _SSABuilder_states,
      _SSABuilder_current,
      _SSABuilder_blocks,
      _SSABuilder_env,
      _SSABuilder_unknown,
      _SSABuilder_context;
    var SSABuilder = /*#__PURE__*/ (function () {
      function SSABuilder(env, blocks) {
        _classCallCheck(this, SSABuilder);
        _SSABuilder_states.set(this, new Map());
        _SSABuilder_current.set(this, null);
        this.unsealedPreds = new Map();
        _SSABuilder_blocks.set(this, void 0);
        _SSABuilder_env.set(this, void 0);
        _SSABuilder_unknown.set(this, new Set());
        _SSABuilder_context.set(this, new Set());
        __classPrivateFieldSet(this, _SSABuilder_blocks, new Map(blocks), "f");
        __classPrivateFieldSet(this, _SSABuilder_env, env, "f");
      }
      return _createClass(SSABuilder, [
        {
          key: "nextSsaId",
          get: function get() {
            return __classPrivateFieldGet(this, _SSABuilder_env, "f")
              .nextIdentifierId;
          }
        },
        {
          key: "defineFunction",
          value: function defineFunction(func) {
            var _iterator178 = _createForOfIteratorHelper(func.body.blocks),
              _step178;
            try {
              for (_iterator178.s(); !(_step178 = _iterator178.n()).done; ) {
                var _step178$value = _slicedToArray(_step178.value, 2),
                  id = _step178$value[0],
                  block = _step178$value[1];
                __classPrivateFieldGet(this, _SSABuilder_blocks, "f").set(
                  id,
                  block
                );
              }
            } catch (err) {
              _iterator178.e(err);
            } finally {
              _iterator178.f();
            }
          }
        },
        {
          key: "enter",
          value: function enter(fn) {
            var current = __classPrivateFieldGet(
              this,
              _SSABuilder_current,
              "f"
            );
            fn();
            __classPrivateFieldSet(this, _SSABuilder_current, current, "f");
          }
        },
        {
          key: "state",
          value: function state() {
            CompilerError.invariant(
              __classPrivateFieldGet(this, _SSABuilder_current, "f") !== null,
              {
                reason: "we need to be in a block to access state!",
                description: null,
                loc: null,
                suggestions: null
              }
            );
            return __classPrivateFieldGet(this, _SSABuilder_states, "f").get(
              __classPrivateFieldGet(this, _SSABuilder_current, "f")
            );
          }
        },
        {
          key: "makeId",
          value: function makeId(oldId) {
            return {
              id: this.nextSsaId,
              declarationId: oldId.declarationId,
              name: oldId.name,
              mutableRange: {
                start: makeInstructionId(0),
                end: makeInstructionId(0)
              },
              scope: null,
              type: makeType(),
              loc: oldId.loc
            };
          }
        },
        {
          key: "defineContext",
          value: function defineContext(oldPlace) {
            var newPlace = this.definePlace(oldPlace);
            __classPrivateFieldGet(this, _SSABuilder_context, "f").add(
              oldPlace.identifier
            );
            return newPlace;
          }
        },
        {
          key: "definePlace",
          value: function definePlace(oldPlace) {
            var oldId = oldPlace.identifier;
            if (
              __classPrivateFieldGet(this, _SSABuilder_unknown, "f").has(oldId)
            ) {
              CompilerError.throwTodo({
                reason:
                  "[hoisting] EnterSSA: Expected identifier to be defined before being used",
                description: "Identifier ".concat(
                  printIdentifier(oldId),
                  " is undefined"
                ),
                loc: oldPlace.loc,
                suggestions: null
              });
            }
            if (
              __classPrivateFieldGet(this, _SSABuilder_context, "f").has(oldId)
            ) {
              return this.getPlace(oldPlace);
            }
            var newId = this.makeId(oldId);
            this.state().defs.set(oldId, newId);
            return Object.assign(Object.assign({}, oldPlace), {
              identifier: newId
            });
          }
        },
        {
          key: "getPlace",
          value: function getPlace(oldPlace) {
            var newId = this.getIdAt(
              oldPlace,
              __classPrivateFieldGet(this, _SSABuilder_current, "f").id
            );
            return Object.assign(Object.assign({}, oldPlace), {
              identifier: newId
            });
          }
        },
        {
          key: "getIdAt",
          value: function getIdAt(oldPlace, blockId) {
            var block = __classPrivateFieldGet(
              this,
              _SSABuilder_blocks,
              "f"
            ).get(blockId);
            var state = __classPrivateFieldGet(
              this,
              _SSABuilder_states,
              "f"
            ).get(block);
            if (state.defs.has(oldPlace.identifier)) {
              return state.defs.get(oldPlace.identifier);
            }
            if (block.preds.size == 0) {
              __classPrivateFieldGet(this, _SSABuilder_unknown, "f").add(
                oldPlace.identifier
              );
              return oldPlace.identifier;
            }
            if (this.unsealedPreds.get(block) > 0) {
              var _newId = this.makeId(oldPlace.identifier);
              state.incompletePhis.push({
                oldPlace: oldPlace,
                newPlace: Object.assign(Object.assign({}, oldPlace), {
                  identifier: _newId
                })
              });
              state.defs.set(oldPlace.identifier, _newId);
              return _newId;
            }
            if (block.preds.size == 1) {
              var _block$preds = _slicedToArray(block.preds, 1),
                pred = _block$preds[0];
              var _newId2 = this.getIdAt(oldPlace, pred);
              state.defs.set(oldPlace.identifier, _newId2);
              return _newId2;
            }
            var newId = this.makeId(oldPlace.identifier);
            state.defs.set(oldPlace.identifier, newId);
            return this.addPhi(
              block,
              oldPlace,
              Object.assign(Object.assign({}, oldPlace), { identifier: newId })
            );
          }
        },
        {
          key: "addPhi",
          value: function addPhi(block, oldPlace, newPlace) {
            var predDefs = new Map();
            var _iterator179 = _createForOfIteratorHelper(block.preds),
              _step179;
            try {
              for (_iterator179.s(); !(_step179 = _iterator179.n()).done; ) {
                var predBlockId = _step179.value;
                var predId = this.getIdAt(oldPlace, predBlockId);
                predDefs.set(
                  predBlockId,
                  Object.assign(Object.assign({}, oldPlace), {
                    identifier: predId
                  })
                );
              }
            } catch (err) {
              _iterator179.e(err);
            } finally {
              _iterator179.f();
            }
            var phi = { kind: "Phi", place: newPlace, operands: predDefs };
            block.phis.add(phi);
            return newPlace.identifier;
          }
        },
        {
          key: "fixIncompletePhis",
          value: function fixIncompletePhis(block) {
            var state = __classPrivateFieldGet(
              this,
              _SSABuilder_states,
              "f"
            ).get(block);
            var _iterator180 = _createForOfIteratorHelper(state.incompletePhis),
              _step180;
            try {
              for (_iterator180.s(); !(_step180 = _iterator180.n()).done; ) {
                var phi = _step180.value;
                this.addPhi(block, phi.oldPlace, phi.newPlace);
              }
            } catch (err) {
              _iterator180.e(err);
            } finally {
              _iterator180.f();
            }
          }
        },
        {
          key: "startBlock",
          value: function startBlock(block) {
            __classPrivateFieldSet(this, _SSABuilder_current, block, "f");
            __classPrivateFieldGet(this, _SSABuilder_states, "f").set(block, {
              defs: new Map(),
              incompletePhis: []
            });
          }
        },
        {
          key: "print",
          value: function print() {
            var _a;
            var text = [];
            var _iterator181 = _createForOfIteratorHelper(
                __classPrivateFieldGet(this, _SSABuilder_states, "f")
              ),
              _step181;
            try {
              for (_iterator181.s(); !(_step181 = _iterator181.n()).done; ) {
                var _step181$value = _slicedToArray(_step181.value, 2),
                  block = _step181$value[0],
                  state = _step181$value[1];
                text.push("bb".concat(block.id, ":"));
                var _iterator182 = _createForOfIteratorHelper(state.defs),
                  _step182;
                try {
                  for (
                    _iterator182.s();
                    !(_step182 = _iterator182.n()).done;

                  ) {
                    var _step182$value = _slicedToArray(_step182.value, 2),
                      oldId = _step182$value[0],
                      newId = _step182$value[1];
                    text.push(
                      "  $"
                        .concat(printIdentifier(oldId), ": $")
                        .concat(printIdentifier(newId))
                    );
                  }
                } catch (err) {
                  _iterator182.e(err);
                } finally {
                  _iterator182.f();
                }
                var _iterator183 = _createForOfIteratorHelper(
                    state.incompletePhis
                  ),
                  _step183;
                try {
                  for (
                    _iterator183.s();
                    !(_step183 = _iterator183.n()).done;

                  ) {
                    var incompletePhi = _step183.value;
                    text.push(
                      "  iphi $"
                        .concat(printPlace(incompletePhi.newPlace), " = $")
                        .concat(printPlace(incompletePhi.oldPlace))
                    );
                  }
                } catch (err) {
                  _iterator183.e(err);
                } finally {
                  _iterator183.f();
                }
              }
            } catch (err) {
              _iterator181.e(err);
            } finally {
              _iterator181.f();
            }
            text.push(
              "current block: bb".concat(
                (_a = __classPrivateFieldGet(
                  this,
                  _SSABuilder_current,
                  "f"
                )) === null || _a === void 0
                  ? void 0
                  : _a.id
              )
            );
            console.log(text.join("\n"));
          }
        }
      ]);
    })();
    (_SSABuilder_states = new WeakMap()),
      (_SSABuilder_current = new WeakMap()),
      (_SSABuilder_blocks = new WeakMap()),
      (_SSABuilder_env = new WeakMap()),
      (_SSABuilder_unknown = new WeakMap()),
      (_SSABuilder_context = new WeakMap());
    function enterSSA(func) {
      var builder = new SSABuilder(func.env, func.body.blocks);
      enterSSAImpl(func, builder, func.body.entry);
    }
    function enterSSAImpl(func, builder, rootEntry) {
      var visitedBlocks = new Set();
      var _iterator184 = _createForOfIteratorHelper(func.body.blocks),
        _step184;
      try {
        for (_iterator184.s(); !(_step184 = _iterator184.n()).done; ) {
          var _step184$value = _slicedToArray(_step184.value, 2),
            blockId = _step184$value[0],
            block = _step184$value[1];
          CompilerError.invariant(!visitedBlocks.has(block), {
            reason: "found a cycle! visiting bb".concat(block.id, " again"),
            description: null,
            loc: null,
            suggestions: null
          });
          visitedBlocks.add(block);
          builder.startBlock(block);
          if (blockId === rootEntry) {
            CompilerError.invariant(func.context.length === 0, {
              reason:
                "Expected function context to be empty for outer function declarations",
              description: null,
              loc: func.loc,
              suggestions: null
            });
            func.params = func.params.map(function (param) {
              if (param.kind === "Identifier") {
                return builder.definePlace(param);
              } else {
                return {
                  kind: "Spread",
                  place: builder.definePlace(param.place)
                };
              }
            });
          }
          var _iterator185 = _createForOfIteratorHelper(block.instructions),
            _step185;
          try {
            var _loop9 = function _loop9() {
              var instr = _step185.value;
              mapInstructionOperands(instr, function (place) {
                return builder.getPlace(place);
              });
              mapInstructionLValues(instr, function (lvalue) {
                return builder.definePlace(lvalue);
              });
              if (
                instr.value.kind === "FunctionExpression" ||
                instr.value.kind === "ObjectMethod"
              ) {
                var loweredFunc = instr.value.loweredFunc.func;
                var entry = loweredFunc.body.blocks.get(loweredFunc.body.entry);
                CompilerError.invariant(entry.preds.size === 0, {
                  reason:
                    "Expected function expression entry block to have zero predecessors",
                  description: null,
                  loc: null,
                  suggestions: null
                });
                entry.preds.add(blockId);
                builder.defineFunction(loweredFunc);
                builder.enter(function () {
                  loweredFunc.params = loweredFunc.params.map(function (param) {
                    if (param.kind === "Identifier") {
                      return builder.definePlace(param);
                    } else {
                      return {
                        kind: "Spread",
                        place: builder.definePlace(param.place)
                      };
                    }
                  });
                  enterSSAImpl(loweredFunc, builder, rootEntry);
                });
                entry.preds.clear();
              }
            };
            for (_iterator185.s(); !(_step185 = _iterator185.n()).done; ) {
              _loop9();
            }
          } catch (err) {
            _iterator185.e(err);
          } finally {
            _iterator185.f();
          }
          mapTerminalOperands(block.terminal, function (place) {
            return builder.getPlace(place);
          });
          var _iterator186 = _createForOfIteratorHelper(
              eachTerminalSuccessor(block.terminal)
            ),
            _step186;
          try {
            for (_iterator186.s(); !(_step186 = _iterator186.n()).done; ) {
              var outputId = _step186.value;
              var output = func.body.blocks.get(outputId);
              var count = void 0;
              if (builder.unsealedPreds.has(output)) {
                count = builder.unsealedPreds.get(output) - 1;
              } else {
                count = output.preds.size - 1;
              }
              builder.unsealedPreds.set(output, count);
              if (count === 0 && visitedBlocks.has(output)) {
                builder.fixIncompletePhis(output);
              }
            }
          } catch (err) {
            _iterator186.e(err);
          } finally {
            _iterator186.f();
          }
        }
      } catch (err) {
        _iterator184.e(err);
      } finally {
        _iterator184.f();
      }
    }
    function rewriteInstructionKindsBasedOnReassignment(fn) {
      var declarations = new Map();
      var _iterator187 = _createForOfIteratorHelper(fn.params),
        _step187;
      try {
        for (_iterator187.s(); !(_step187 = _iterator187.n()).done; ) {
          var param = _step187.value;
          var place = param.kind === "Identifier" ? param : param.place;
          if (place.identifier.name !== null) {
            declarations.set(place.identifier.declarationId, {
              kind: InstructionKind.Let,
              place: place
            });
          }
        }
      } catch (err) {
        _iterator187.e(err);
      } finally {
        _iterator187.f();
      }
      var _iterator188 = _createForOfIteratorHelper(fn.context),
        _step188;
      try {
        for (_iterator188.s(); !(_step188 = _iterator188.n()).done; ) {
          var _place20 = _step188.value;
          if (_place20.identifier.name !== null) {
            declarations.set(_place20.identifier.declarationId, {
              kind: InstructionKind.Let,
              place: _place20
            });
          }
        }
      } catch (err) {
        _iterator188.e(err);
      } finally {
        _iterator188.f();
      }
      var _iterator189 = _createForOfIteratorHelper(fn.body.blocks),
        _step189;
      try {
        for (_iterator189.s(); !(_step189 = _iterator189.n()).done; ) {
          var _step189$value = _slicedToArray(_step189.value, 2),
            block = _step189$value[1];
          var _iterator190 = _createForOfIteratorHelper(block.instructions),
            _step190;
          try {
            for (_iterator190.s(); !(_step190 = _iterator190.n()).done; ) {
              var instr = _step190.value;
              var value = instr.value;
              switch (value.kind) {
                case "DeclareLocal": {
                  var lvalue = value.lvalue;
                  CompilerError.invariant(
                    !declarations.has(lvalue.place.identifier.declarationId),
                    {
                      reason:
                        "Expected variable not to be defined prior to declaration",
                      description: "".concat(
                        printPlace(lvalue.place),
                        " was already defined"
                      ),
                      loc: lvalue.place.loc
                    }
                  );
                  declarations.set(
                    lvalue.place.identifier.declarationId,
                    lvalue
                  );
                  break;
                }
                case "StoreLocal": {
                  var _lvalue6 = value.lvalue;
                  if (_lvalue6.place.identifier.name !== null) {
                    var declaration = declarations.get(
                      _lvalue6.place.identifier.declarationId
                    );
                    if (declaration === undefined) {
                      CompilerError.invariant(
                        !declarations.has(
                          _lvalue6.place.identifier.declarationId
                        ),
                        {
                          reason:
                            "Expected variable not to be defined prior to declaration",
                          description: "".concat(
                            printPlace(_lvalue6.place),
                            " was already defined"
                          ),
                          loc: _lvalue6.place.loc
                        }
                      );
                      declarations.set(
                        _lvalue6.place.identifier.declarationId,
                        _lvalue6
                      );
                      _lvalue6.kind = InstructionKind.Const;
                    } else {
                      declaration.kind = InstructionKind.Let;
                      _lvalue6.kind = InstructionKind.Reassign;
                    }
                  }
                  break;
                }
                case "Destructure": {
                  var _lvalue7 = value.lvalue;
                  var kind = null;
                  var _iterator191 = _createForOfIteratorHelper(
                      eachPatternOperand(_lvalue7.pattern)
                    ),
                    _step191;
                  try {
                    for (
                      _iterator191.s();
                      !(_step191 = _iterator191.n()).done;

                    ) {
                      var _place21 = _step191.value;
                      if (_place21.identifier.name === null) {
                        CompilerError.invariant(
                          kind === null || kind === InstructionKind.Const,
                          {
                            reason:
                              "Expected consistent kind for destructuring",
                            description: "other places were `"
                              .concat(kind, "` but '")
                              .concat(printPlace(_place21), "' is const"),
                            loc: _place21.loc,
                            suggestions: null
                          }
                        );
                        kind = InstructionKind.Const;
                      } else {
                        var _declaration = declarations.get(
                          _place21.identifier.declarationId
                        );
                        if (_declaration === undefined) {
                          CompilerError.invariant(block.kind !== "value", {
                            reason:
                              "TODO: Handle reassignment in a value block where the original declaration was removed by dead code elimination (DCE)",
                            description: null,
                            loc: _place21.loc,
                            suggestions: null
                          });
                          declarations.set(
                            _place21.identifier.declarationId,
                            _lvalue7
                          );
                          CompilerError.invariant(
                            kind === null || kind === InstructionKind.Const,
                            {
                              reason:
                                "Expected consistent kind for destructuring",
                              description: "Other places were `"
                                .concat(kind, "` but '")
                                .concat(printPlace(_place21), "' is const"),
                              loc: _place21.loc,
                              suggestions: null
                            }
                          );
                          kind = InstructionKind.Const;
                        } else {
                          CompilerError.invariant(
                            kind === null || kind === InstructionKind.Reassign,
                            {
                              reason:
                                "Expected consistent kind for destructuring",
                              description: "Other places were `"
                                .concat(kind, "` but '")
                                .concat(
                                  printPlace(_place21),
                                  "' is reassigned"
                                ),
                              loc: _place21.loc,
                              suggestions: null
                            }
                          );
                          kind = InstructionKind.Reassign;
                          _declaration.kind = InstructionKind.Let;
                        }
                      }
                    }
                  } catch (err) {
                    _iterator191.e(err);
                  } finally {
                    _iterator191.f();
                  }
                  CompilerError.invariant(kind !== null, {
                    reason: "Expected at least one operand",
                    description: null,
                    loc: null,
                    suggestions: null
                  });
                  _lvalue7.kind = kind;
                  break;
                }
                case "PostfixUpdate":
                case "PrefixUpdate": {
                  var _lvalue8 = value.lvalue;
                  var _declaration2 = declarations.get(
                    _lvalue8.identifier.declarationId
                  );
                  CompilerError.invariant(_declaration2 !== undefined, {
                    reason: "Expected variable to have been defined",
                    description: "No declaration for ".concat(
                      printPlace(_lvalue8)
                    ),
                    loc: _lvalue8.loc
                  });
                  _declaration2.kind = InstructionKind.Let;
                  break;
                }
              }
            }
          } catch (err) {
            _iterator190.e(err);
          } finally {
            _iterator190.f();
          }
        }
      } catch (err) {
        _iterator189.e(err);
      } finally {
        _iterator189.f();
      }
    }
    function constantPropagation(fn) {
      var constants = new Map();
      constantPropagationImpl(fn, constants);
    }
    function constantPropagationImpl(fn, constants) {
      while (true) {
        var haveTerminalsChanged = applyConstantPropagation(fn, constants);
        if (!haveTerminalsChanged) {
          break;
        }
        reversePostorderBlocks(fn.body);
        removeUnreachableForUpdates(fn.body);
        removeDeadDoWhileStatements(fn.body);
        removeUnnecessaryTryCatch(fn.body);
        markInstructionIds(fn.body);
        markPredecessors(fn.body);
        var _iterator192 = _createForOfIteratorHelper(fn.body.blocks),
          _step192;
        try {
          for (_iterator192.s(); !(_step192 = _iterator192.n()).done; ) {
            var _step192$value = _slicedToArray(_step192.value, 2),
              block = _step192$value[1];
            var _iterator193 = _createForOfIteratorHelper(block.phis),
              _step193;
            try {
              for (_iterator193.s(); !(_step193 = _iterator193.n()).done; ) {
                var phi = _step193.value;
                var _iterator194 = _createForOfIteratorHelper(phi.operands),
                  _step194;
                try {
                  for (
                    _iterator194.s();
                    !(_step194 = _iterator194.n()).done;

                  ) {
                    var _step194$value = _slicedToArray(_step194.value, 1),
                      predecessor = _step194$value[0];
                    if (!block.preds.has(predecessor)) {
                      phi.operands["delete"](predecessor);
                    }
                  }
                } catch (err) {
                  _iterator194.e(err);
                } finally {
                  _iterator194.f();
                }
              }
            } catch (err) {
              _iterator193.e(err);
            } finally {
              _iterator193.f();
            }
          }
        } catch (err) {
          _iterator192.e(err);
        } finally {
          _iterator192.f();
        }
        eliminateRedundantPhi(fn);
        mergeConsecutiveBlocks(fn);
        assertConsistentIdentifiers(fn);
        assertTerminalSuccessorsExist(fn);
      }
    }
    function applyConstantPropagation(fn, constants) {
      var hasChanges = false;
      var _iterator195 = _createForOfIteratorHelper(fn.body.blocks),
        _step195;
      try {
        for (_iterator195.s(); !(_step195 = _iterator195.n()).done; ) {
          var _step195$value = _slicedToArray(_step195.value, 2),
            block = _step195$value[1];
          var _iterator196 = _createForOfIteratorHelper(block.phis),
            _step196;
          try {
            for (_iterator196.s(); !(_step196 = _iterator196.n()).done; ) {
              var phi = _step196.value;
              var _value17 = evaluatePhi(phi, constants);
              if (_value17 !== null) {
                constants.set(phi.place.identifier.id, _value17);
              }
            }
          } catch (err) {
            _iterator196.e(err);
          } finally {
            _iterator196.f();
          }
          for (var i = 0; i < block.instructions.length; i++) {
            if (
              block.kind === "sequence" &&
              i === block.instructions.length - 1
            ) {
              continue;
            }
            var instr = block.instructions[i];
            var value = evaluateInstruction(constants, instr);
            if (value !== null) {
              constants.set(instr.lvalue.identifier.id, value);
            }
          }
          var terminal = block.terminal;
          switch (terminal.kind) {
            case "if": {
              var testValue = read(constants, terminal.test);
              if (testValue !== null && testValue.kind === "Primitive") {
                hasChanges = true;
                var targetBlockId = testValue.value
                  ? terminal.consequent
                  : terminal.alternate;
                block.terminal = {
                  kind: "goto",
                  variant: GotoVariant.Break,
                  block: targetBlockId,
                  id: terminal.id,
                  loc: terminal.loc
                };
              }
              break;
            }
          }
        }
      } catch (err) {
        _iterator195.e(err);
      } finally {
        _iterator195.f();
      }
      return hasChanges;
    }
    function evaluatePhi(phi, constants) {
      var _a;
      var value = null;
      var _iterator197 = _createForOfIteratorHelper(phi.operands),
        _step197;
      try {
        for (_iterator197.s(); !(_step197 = _iterator197.n()).done; ) {
          var _step197$value = _slicedToArray(_step197.value, 2),
            operand = _step197$value[1];
          var operandValue =
            (_a = constants.get(operand.identifier.id)) !== null &&
            _a !== void 0
              ? _a
              : null;
          if (operandValue === null) {
            return null;
          }
          if (value === null) {
            value = operandValue;
            continue;
          }
          if (operandValue.kind !== value.kind) {
            return null;
          }
          switch (operandValue.kind) {
            case "Primitive": {
              CompilerError.invariant(value.kind === "Primitive", {
                reason: "value kind expected to be Primitive",
                loc: null,
                suggestions: null
              });
              if (operandValue.value !== value.value) {
                return null;
              }
              break;
            }
            case "LoadGlobal": {
              CompilerError.invariant(value.kind === "LoadGlobal", {
                reason: "value kind expected to be LoadGlobal",
                loc: null,
                suggestions: null
              });
              if (operandValue.binding.name !== value.binding.name) {
                return null;
              }
              break;
            }
            default:
              return null;
          }
        }
      } catch (err) {
        _iterator197.e(err);
      } finally {
        _iterator197.f();
      }
      return value;
    }
    function evaluateInstruction(constants, instr) {
      var value = instr.value;
      switch (value.kind) {
        case "Primitive": {
          return value;
        }
        case "LoadGlobal": {
          return value;
        }
        case "ComputedLoad": {
          var property = read(constants, value.property);
          if (
            property !== null &&
            property.kind === "Primitive" &&
            ((typeof property.value === "string" &&
              libExports.isValidIdentifier(property.value)) ||
              typeof property.value === "number")
          ) {
            var nextValue = {
              kind: "PropertyLoad",
              loc: value.loc,
              property: makePropertyLiteral(property.value),
              object: value.object
            };
            instr.value = nextValue;
          }
          return null;
        }
        case "ComputedStore": {
          var _property8 = read(constants, value.property);
          if (
            _property8 !== null &&
            _property8.kind === "Primitive" &&
            ((typeof _property8.value === "string" &&
              libExports.isValidIdentifier(_property8.value)) ||
              typeof _property8.value === "number")
          ) {
            var _nextValue = {
              kind: "PropertyStore",
              loc: value.loc,
              property: makePropertyLiteral(_property8.value),
              object: value.object,
              value: value.value
            };
            instr.value = _nextValue;
          }
          return null;
        }
        case "PostfixUpdate": {
          var previous = read(constants, value.value);
          if (
            previous !== null &&
            previous.kind === "Primitive" &&
            typeof previous.value === "number"
          ) {
            var next =
              value.operation === "++"
                ? previous.value + 1
                : previous.value - 1;
            constants.set(value.lvalue.identifier.id, {
              kind: "Primitive",
              value: next,
              loc: value.loc
            });
            return previous;
          }
          return null;
        }
        case "PrefixUpdate": {
          var _previous = read(constants, value.value);
          if (
            _previous !== null &&
            _previous.kind === "Primitive" &&
            typeof _previous.value === "number"
          ) {
            var _next2 = {
              kind: "Primitive",
              value:
                value.operation === "++"
                  ? _previous.value + 1
                  : _previous.value - 1,
              loc: value.loc
            };
            constants.set(value.lvalue.identifier.id, _next2);
            return _next2;
          }
          return null;
        }
        case "UnaryExpression": {
          switch (value.operator) {
            case "!": {
              var operand = read(constants, value.value);
              if (operand !== null && operand.kind === "Primitive") {
                var result = {
                  kind: "Primitive",
                  value: !operand.value,
                  loc: value.loc
                };
                instr.value = result;
                return result;
              }
              return null;
            }
            default:
              return null;
          }
        }
        case "BinaryExpression": {
          var lhsValue = read(constants, value.left);
          var rhsValue = read(constants, value.right);
          if (
            lhsValue !== null &&
            rhsValue !== null &&
            lhsValue.kind === "Primitive" &&
            rhsValue.kind === "Primitive"
          ) {
            var lhs = lhsValue.value;
            var rhs = rhsValue.value;
            var _result4 = null;
            switch (value.operator) {
              case "+": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs + rhs,
                    loc: value.loc
                  };
                } else if (typeof lhs === "string" && typeof rhs === "string") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs + rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case "-": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs - rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case "*": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs * rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case "/": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs / rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case "|": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs | rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case "&": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs & rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case "^": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs ^ rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case "<<": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs << rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case ">>": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs >> rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case ">>>": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs >>> rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case "%": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs % rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case "**": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: Math.pow(lhs, rhs),
                    loc: value.loc
                  };
                }
                break;
              }
              case "<": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs < rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case "<=": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs <= rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case ">": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs > rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case ">=": {
                if (typeof lhs === "number" && typeof rhs === "number") {
                  _result4 = {
                    kind: "Primitive",
                    value: lhs >= rhs,
                    loc: value.loc
                  };
                }
                break;
              }
              case "==": {
                _result4 = {
                  kind: "Primitive",
                  value: lhs == rhs,
                  loc: value.loc
                };
                break;
              }
              case "===": {
                _result4 = {
                  kind: "Primitive",
                  value: lhs === rhs,
                  loc: value.loc
                };
                break;
              }
              case "!=": {
                _result4 = {
                  kind: "Primitive",
                  value: lhs != rhs,
                  loc: value.loc
                };
                break;
              }
              case "!==": {
                _result4 = {
                  kind: "Primitive",
                  value: lhs !== rhs,
                  loc: value.loc
                };
                break;
              }
            }
            if (_result4 !== null) {
              instr.value = _result4;
              return _result4;
            }
          }
          return null;
        }
        case "PropertyLoad": {
          var objectValue = read(constants, value.object);
          if (objectValue !== null) {
            if (
              objectValue.kind === "Primitive" &&
              typeof objectValue.value === "string" &&
              value.property === "length"
            ) {
              var _result5 = {
                kind: "Primitive",
                value: objectValue.value.length,
                loc: value.loc
              };
              instr.value = _result5;
              return _result5;
            }
          }
          return null;
        }
        case "LoadLocal": {
          var placeValue = read(constants, value.place);
          if (placeValue !== null) {
            instr.value = placeValue;
          }
          return placeValue;
        }
        case "StoreLocal": {
          var _placeValue = read(constants, value.value);
          if (_placeValue !== null) {
            constants.set(value.lvalue.place.identifier.id, _placeValue);
          }
          return _placeValue;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          constantPropagationImpl(value.loweredFunc.func, constants);
          return null;
        }
        default: {
          return null;
        }
      }
    }
    function read(constants, place) {
      var _a;
      return (_a = constants.get(place.identifier.id)) !== null && _a !== void 0
        ? _a
        : null;
    }
    function deadCodeElimination(fn) {
      var state = findReferencedIdentifiers(fn);
      var _iterator198 = _createForOfIteratorHelper(fn.body.blocks),
        _step198;
      try {
        for (_iterator198.s(); !(_step198 = _iterator198.n()).done; ) {
          var _step198$value = _slicedToArray(_step198.value, 2),
            block = _step198$value[1];
          var _iterator199 = _createForOfIteratorHelper(block.phis),
            _step199;
          try {
            for (_iterator199.s(); !(_step199 = _iterator199.n()).done; ) {
              var phi = _step199.value;
              if (!state.isIdOrNameUsed(phi.place.identifier)) {
                block.phis["delete"](phi);
              }
            }
          } catch (err) {
            _iterator199.e(err);
          } finally {
            _iterator199.f();
          }
          retainWhere(block.instructions, function (instr) {
            return state.isIdOrNameUsed(instr.lvalue.identifier);
          });
          for (var i = 0; i < block.instructions.length; i++) {
            var isBlockValue =
              block.kind !== "block" && i === block.instructions.length - 1;
            if (!isBlockValue) {
              rewriteInstruction(block.instructions[i], state);
            }
          }
        }
      } catch (err) {
        _iterator198.e(err);
      } finally {
        _iterator198.f();
      }
      retainWhere(fn.context, function (contextVar) {
        return state.isIdOrNameUsed(contextVar.identifier);
      });
    }
    var State$2 = /*#__PURE__*/ (function () {
      function State() {
        _classCallCheck(this, State);
        this.named = new Set();
        this.identifiers = new Set();
      }
      return _createClass(State, [
        {
          key: "reference",
          value: function reference(identifier) {
            this.identifiers.add(identifier.id);
            if (identifier.name !== null) {
              this.named.add(identifier.name.value);
            }
          }
        },
        {
          key: "isIdOrNameUsed",
          value: function isIdOrNameUsed(identifier) {
            return (
              this.identifiers.has(identifier.id) ||
              (identifier.name !== null &&
                this.named.has(identifier.name.value))
            );
          }
        },
        {
          key: "isIdUsed",
          value: function isIdUsed(identifier) {
            return this.identifiers.has(identifier.id);
          }
        },
        {
          key: "count",
          get: function get() {
            return this.identifiers.size;
          }
        }
      ]);
    })();
    function findReferencedIdentifiers(fn) {
      var hasLoop = hasBackEdge(fn);
      var reversedBlocks = _toConsumableArray(
        fn.body.blocks.values()
      ).reverse();
      var state = new State$2();
      var size = state.count;
      do {
        size = state.count;
        var _iterator200 = _createForOfIteratorHelper(reversedBlocks),
          _step200;
        try {
          for (_iterator200.s(); !(_step200 = _iterator200.n()).done; ) {
            var block = _step200.value;
            var _iterator201 = _createForOfIteratorHelper(
                eachTerminalOperand(block.terminal)
              ),
              _step201;
            try {
              for (_iterator201.s(); !(_step201 = _iterator201.n()).done; ) {
                var _operand12 = _step201.value;
                state.reference(_operand12.identifier);
              }
            } catch (err) {
              _iterator201.e(err);
            } finally {
              _iterator201.f();
            }
            for (var i = block.instructions.length - 1; i >= 0; i--) {
              var instr = block.instructions[i];
              var isBlockValue =
                block.kind !== "block" && i === block.instructions.length - 1;
              if (isBlockValue) {
                state.reference(instr.lvalue.identifier);
                var _iterator202 = _createForOfIteratorHelper(
                    eachInstructionValueOperand(instr.value)
                  ),
                  _step202;
                try {
                  for (
                    _iterator202.s();
                    !(_step202 = _iterator202.n()).done;

                  ) {
                    var place = _step202.value;
                    state.reference(place.identifier);
                  }
                } catch (err) {
                  _iterator202.e(err);
                } finally {
                  _iterator202.f();
                }
              } else if (
                state.isIdOrNameUsed(instr.lvalue.identifier) ||
                !pruneableValue(instr.value, state)
              ) {
                state.reference(instr.lvalue.identifier);
                if (instr.value.kind === "StoreLocal") {
                  if (
                    instr.value.lvalue.kind === InstructionKind.Reassign ||
                    state.isIdUsed(instr.value.lvalue.place.identifier)
                  ) {
                    state.reference(instr.value.value.identifier);
                  }
                } else {
                  var _iterator203 = _createForOfIteratorHelper(
                      eachInstructionValueOperand(instr.value)
                    ),
                    _step203;
                  try {
                    for (
                      _iterator203.s();
                      !(_step203 = _iterator203.n()).done;

                    ) {
                      var operand = _step203.value;
                      state.reference(operand.identifier);
                    }
                  } catch (err) {
                    _iterator203.e(err);
                  } finally {
                    _iterator203.f();
                  }
                }
              }
            }
            var _iterator204 = _createForOfIteratorHelper(block.phis),
              _step204;
            try {
              for (_iterator204.s(); !(_step204 = _iterator204.n()).done; ) {
                var phi = _step204.value;
                if (state.isIdOrNameUsed(phi.place.identifier)) {
                  var _iterator205 = _createForOfIteratorHelper(phi.operands),
                    _step205;
                  try {
                    for (
                      _iterator205.s();
                      !(_step205 = _iterator205.n()).done;

                    ) {
                      var _step205$value = _slicedToArray(_step205.value, 2),
                        _pred = _step205$value[0],
                        _operand13 = _step205$value[1];
                      state.reference(_operand13.identifier);
                    }
                  } catch (err) {
                    _iterator205.e(err);
                  } finally {
                    _iterator205.f();
                  }
                }
              }
            } catch (err) {
              _iterator204.e(err);
            } finally {
              _iterator204.f();
            }
          }
        } catch (err) {
          _iterator200.e(err);
        } finally {
          _iterator200.f();
        }
      } while (state.count > size && hasLoop);
      return state;
    }
    function rewriteInstruction(instr, state) {
      if (instr.value.kind === "Destructure") {
        switch (instr.value.lvalue.pattern.kind) {
          case "ArrayPattern": {
            var lastEntryIndex = 0;
            var items = instr.value.lvalue.pattern.items;
            for (var i = 0; i < items.length; i++) {
              var item = items[i];
              if (item.kind === "Identifier") {
                if (!state.isIdOrNameUsed(item.identifier)) {
                  items[i] = { kind: "Hole" };
                } else {
                  lastEntryIndex = i;
                }
              } else if (item.kind === "Spread") {
                if (!state.isIdOrNameUsed(item.place.identifier)) {
                  items[i] = { kind: "Hole" };
                } else {
                  lastEntryIndex = i;
                }
              }
            }
            items.length = lastEntryIndex + 1;
            break;
          }
          case "ObjectPattern": {
            var nextProperties = null;
            var _iterator206 = _createForOfIteratorHelper(
                instr.value.lvalue.pattern.properties
              ),
              _step206;
            try {
              for (_iterator206.s(); !(_step206 = _iterator206.n()).done; ) {
                var property = _step206.value;
                if (property.kind === "ObjectProperty") {
                  if (state.isIdOrNameUsed(property.place.identifier)) {
                    nextProperties !== null && nextProperties !== void 0
                      ? nextProperties
                      : (nextProperties = []);
                    nextProperties.push(property);
                  }
                } else {
                  if (state.isIdOrNameUsed(property.place.identifier)) {
                    nextProperties = null;
                    break;
                  }
                }
              }
            } catch (err) {
              _iterator206.e(err);
            } finally {
              _iterator206.f();
            }
            if (nextProperties !== null) {
              instr.value.lvalue.pattern.properties = nextProperties;
            }
            break;
          }
          default: {
            assertExhaustive$1(
              instr.value.lvalue.pattern,
              "Unexpected pattern kind '".concat(
                instr.value.lvalue.pattern.kind,
                "'"
              )
            );
          }
        }
      } else if (instr.value.kind === "StoreLocal") {
        if (
          instr.value.lvalue.kind !== InstructionKind.Reassign &&
          !state.isIdUsed(instr.value.lvalue.place.identifier)
        ) {
          instr.value = {
            kind: "DeclareLocal",
            lvalue: instr.value.lvalue,
            type: instr.value.type,
            loc: instr.value.loc
          };
        }
      }
    }
    function pruneableValue(value, state) {
      switch (value.kind) {
        case "DeclareLocal": {
          return !state.isIdOrNameUsed(value.lvalue.place.identifier);
        }
        case "StoreLocal": {
          if (value.lvalue.kind === InstructionKind.Reassign) {
            return !state.isIdUsed(value.lvalue.place.identifier);
          }
          return !state.isIdOrNameUsed(value.lvalue.place.identifier);
        }
        case "Destructure": {
          var isIdOrNameUsed = false;
          var isIdUsed = false;
          var _iterator207 = _createForOfIteratorHelper(
              eachPatternOperand(value.lvalue.pattern)
            ),
            _step207;
          try {
            for (_iterator207.s(); !(_step207 = _iterator207.n()).done; ) {
              var place = _step207.value;
              if (state.isIdUsed(place.identifier)) {
                isIdOrNameUsed = true;
                isIdUsed = true;
              } else if (state.isIdOrNameUsed(place.identifier)) {
                isIdOrNameUsed = true;
              }
            }
          } catch (err) {
            _iterator207.e(err);
          } finally {
            _iterator207.f();
          }
          if (value.lvalue.kind === InstructionKind.Reassign) {
            return !isIdUsed;
          } else {
            return !isIdOrNameUsed;
          }
        }
        case "PostfixUpdate":
        case "PrefixUpdate": {
          return !state.isIdUsed(value.lvalue.identifier);
        }
        case "Debugger": {
          return false;
        }
        case "Await":
        case "CallExpression":
        case "ComputedDelete":
        case "ComputedStore":
        case "PropertyDelete":
        case "MethodCall":
        case "PropertyStore":
        case "StoreGlobal": {
          return false;
        }
        case "NewExpression":
        case "UnsupportedNode":
        case "TaggedTemplateExpression": {
          return false;
        }
        case "GetIterator":
        case "NextPropertyOf":
        case "IteratorNext": {
          return false;
        }
        case "LoadContext":
        case "DeclareContext":
        case "StoreContext": {
          return false;
        }
        case "StartMemoize":
        case "FinishMemoize": {
          return false;
        }
        case "RegExpLiteral":
        case "MetaProperty":
        case "LoadGlobal":
        case "ArrayExpression":
        case "BinaryExpression":
        case "ComputedLoad":
        case "ObjectMethod":
        case "FunctionExpression":
        case "LoadLocal":
        case "JsxExpression":
        case "JsxFragment":
        case "JSXText":
        case "ObjectExpression":
        case "Primitive":
        case "PropertyLoad":
        case "TemplateLiteral":
        case "TypeCastExpression":
        case "UnaryExpression": {
          return true;
        }
        default: {
          assertExhaustive$1(
            value,
            "Unexepcted value kind `".concat(value.kind, "`")
          );
        }
      }
    }
    function hasBackEdge(fn) {
      return findBlocksWithBackEdges(fn).size > 0;
    }
    function findBlocksWithBackEdges(fn) {
      var visited = new Set();
      var blocks = new Set();
      var _iterator208 = _createForOfIteratorHelper(fn.body.blocks),
        _step208;
      try {
        for (_iterator208.s(); !(_step208 = _iterator208.n()).done; ) {
          var _step208$value = _slicedToArray(_step208.value, 2),
            blockId = _step208$value[0],
            block = _step208$value[1];
          var _iterator209 = _createForOfIteratorHelper(block.preds),
            _step209;
          try {
            for (_iterator209.s(); !(_step209 = _iterator209.n()).done; ) {
              var predId = _step209.value;
              if (!visited.has(predId)) {
                blocks.add(blockId);
              }
            }
          } catch (err) {
            _iterator209.e(err);
          } finally {
            _iterator209.f();
          }
          visited.add(blockId);
        }
      } catch (err) {
        _iterator208.e(err);
      } finally {
        _iterator208.f();
      }
      return blocks;
    }
    function pruneMaybeThrows(fn) {
      var terminalMapping = pruneMaybeThrowsImpl(fn);
      if (terminalMapping) {
        reversePostorderBlocks(fn.body);
        removeUnreachableForUpdates(fn.body);
        removeDeadDoWhileStatements(fn.body);
        removeUnnecessaryTryCatch(fn.body);
        markInstructionIds(fn.body);
        mergeConsecutiveBlocks(fn);
        var _iterator210 = _createForOfIteratorHelper(fn.body.blocks),
          _step210;
        try {
          for (_iterator210.s(); !(_step210 = _iterator210.n()).done; ) {
            var _step210$value = _slicedToArray(_step210.value, 2),
              block = _step210$value[1];
            var _iterator211 = _createForOfIteratorHelper(block.phis),
              _step211;
            try {
              for (_iterator211.s(); !(_step211 = _iterator211.n()).done; ) {
                var phi = _step211.value;
                var _iterator212 = _createForOfIteratorHelper(phi.operands),
                  _step212;
                try {
                  for (
                    _iterator212.s();
                    !(_step212 = _iterator212.n()).done;

                  ) {
                    var _step212$value = _slicedToArray(_step212.value, 2),
                      predecessor = _step212$value[0],
                      operand = _step212$value[1];
                    if (!block.preds.has(predecessor)) {
                      var mappedTerminal = terminalMapping.get(predecessor);
                      CompilerError.invariant(mappedTerminal != null, {
                        reason:
                          "Expected non-existing phi operand's predecessor to have been mapped to a new terminal",
                        loc: GeneratedSource,
                        description: "Could not find mapping for predecessor bb"
                          .concat(predecessor, " in block bb")
                          .concat(block.id, " for phi ")
                          .concat(printPlace(phi.place)),
                        suggestions: null
                      });
                      phi.operands["delete"](predecessor);
                      phi.operands.set(mappedTerminal, operand);
                    }
                  }
                } catch (err) {
                  _iterator212.e(err);
                } finally {
                  _iterator212.f();
                }
              }
            } catch (err) {
              _iterator211.e(err);
            } finally {
              _iterator211.f();
            }
          }
        } catch (err) {
          _iterator210.e(err);
        } finally {
          _iterator210.f();
        }
        assertConsistentIdentifiers(fn);
        assertTerminalSuccessorsExist(fn);
      }
    }
    function pruneMaybeThrowsImpl(fn) {
      var _a;
      var terminalMapping = new Map();
      var _iterator213 = _createForOfIteratorHelper(fn.body.blocks),
        _step213;
      try {
        for (_iterator213.s(); !(_step213 = _iterator213.n()).done; ) {
          var _step213$value = _slicedToArray(_step213.value, 2),
            _ = _step213$value[0],
            block = _step213$value[1];
          var terminal = block.terminal;
          if (terminal.kind !== "maybe-throw") {
            continue;
          }
          var canThrow = block.instructions.some(function (instr) {
            return instructionMayThrow(instr);
          });
          if (!canThrow) {
            var source =
              (_a = terminalMapping.get(block.id)) !== null && _a !== void 0
                ? _a
                : block.id;
            terminalMapping.set(terminal.continuation, source);
            block.terminal = {
              kind: "goto",
              block: terminal.continuation,
              variant: GotoVariant.Break,
              id: terminal.id,
              loc: terminal.loc
            };
          }
        }
      } catch (err) {
        _iterator213.e(err);
      } finally {
        _iterator213.f();
      }
      return terminalMapping.size > 0 ? terminalMapping : null;
    }
    function instructionMayThrow(instr) {
      switch (instr.value.kind) {
        case "Primitive":
        case "ArrayExpression":
        case "ObjectExpression": {
          return false;
        }
        default: {
          return true;
        }
      }
    }
    function inlineJsxTransform(fn, inlineJsxTransformConfig) {
      var _a;
      var inlinedJsxDeclarations = new Map();
      for (
        var _i35 = 0, _arr = _toConsumableArray(fn.body.blocks);
        _i35 < _arr.length;
        _i35++
      ) {
        var _arr$_i = _slicedToArray(_arr[_i35], 2),
          _ = _arr$_i[0],
          currentBlock = _arr$_i[1];
        var fallthroughBlockInstructions = null;
        var instructionCount = currentBlock.instructions.length;
        for (var i = 0; i < instructionCount; i++) {
          var instr = currentBlock.instructions[i];
          if (currentBlock.kind === "value") {
            (_a = fn.env.logger) === null || _a === void 0
              ? void 0
              : _a.logEvent(fn.env.filename, {
                  kind: "CompileDiagnostic",
                  fnLoc: null,
                  detail: {
                    reason: "JSX Inlining is not supported on value blocks",
                    loc: instr.loc
                  }
                });
            continue;
          }
          switch (instr.value.kind) {
            case "JsxExpression":
            case "JsxFragment": {
              var currentBlockInstructions = currentBlock.instructions.slice(
                0,
                i
              );
              var thenBlockInstructions = currentBlock.instructions.slice(
                i,
                i + 1
              );
              var elseBlockInstructions = [];
              fallthroughBlockInstructions !== null &&
              fallthroughBlockInstructions !== void 0
                ? fallthroughBlockInstructions
                : (fallthroughBlockInstructions =
                    currentBlock.instructions.slice(i + 1));
              var fallthroughBlockId = fn.env.nextBlockId;
              var fallthroughBlock = {
                kind: currentBlock.kind,
                id: fallthroughBlockId,
                instructions: fallthroughBlockInstructions,
                terminal: currentBlock.terminal,
                preds: new Set(),
                phis: new Set()
              };
              var varPlace = createTemporaryPlace(fn.env, instr.value.loc);
              promoteTemporary(varPlace.identifier);
              var varLValuePlace = createTemporaryPlace(
                fn.env,
                instr.value.loc
              );
              var thenVarPlace = Object.assign(Object.assign({}, varPlace), {
                identifier: forkTemporaryIdentifier(
                  fn.env.nextIdentifierId,
                  varPlace.identifier
                )
              });
              var elseVarPlace = Object.assign(Object.assign({}, varPlace), {
                identifier: forkTemporaryIdentifier(
                  fn.env.nextIdentifierId,
                  varPlace.identifier
                )
              });
              var varInstruction = {
                id: makeInstructionId(0),
                lvalue: Object.assign({}, varLValuePlace),
                value: {
                  kind: "DeclareLocal",
                  lvalue: {
                    place: Object.assign({}, varPlace),
                    kind: InstructionKind.Let
                  },
                  type: null,
                  loc: instr.value.loc
                },
                loc: instr.loc
              };
              currentBlockInstructions.push(varInstruction);
              var devGlobalPlace = createTemporaryPlace(
                fn.env,
                instr.value.loc
              );
              var devGlobalInstruction = {
                id: makeInstructionId(0),
                lvalue: Object.assign(Object.assign({}, devGlobalPlace), {
                  effect: Effect.Mutate
                }),
                value: {
                  kind: "LoadGlobal",
                  binding: {
                    kind: "Global",
                    name: inlineJsxTransformConfig.globalDevVar
                  },
                  loc: instr.value.loc
                },
                loc: instr.loc
              };
              currentBlockInstructions.push(devGlobalInstruction);
              var thenBlockId = fn.env.nextBlockId;
              var elseBlockId = fn.env.nextBlockId;
              var ifTerminal = {
                kind: "if",
                test: Object.assign(Object.assign({}, devGlobalPlace), {
                  effect: Effect.Read
                }),
                consequent: thenBlockId,
                alternate: elseBlockId,
                fallthrough: fallthroughBlockId,
                loc: instr.loc,
                id: makeInstructionId(0)
              };
              currentBlock.instructions = currentBlockInstructions;
              currentBlock.terminal = ifTerminal;
              var thenBlock = {
                id: thenBlockId,
                instructions: thenBlockInstructions,
                kind: "block",
                phis: new Set(),
                preds: new Set(),
                terminal: {
                  kind: "goto",
                  block: fallthroughBlockId,
                  variant: GotoVariant.Break,
                  id: makeInstructionId(0),
                  loc: instr.loc
                }
              };
              fn.body.blocks.set(thenBlockId, thenBlock);
              var resassignElsePlace = createTemporaryPlace(
                fn.env,
                instr.value.loc
              );
              var reassignElseInstruction = {
                id: makeInstructionId(0),
                lvalue: Object.assign({}, resassignElsePlace),
                value: {
                  kind: "StoreLocal",
                  lvalue: {
                    place: elseVarPlace,
                    kind: InstructionKind.Reassign
                  },
                  value: Object.assign({}, instr.lvalue),
                  type: null,
                  loc: instr.value.loc
                },
                loc: instr.loc
              };
              thenBlockInstructions.push(reassignElseInstruction);
              var elseBlockTerminal = {
                kind: "goto",
                block: fallthroughBlockId,
                variant: GotoVariant.Break,
                id: makeInstructionId(0),
                loc: instr.loc
              };
              var elseBlock = {
                id: elseBlockId,
                instructions: elseBlockInstructions,
                kind: "block",
                phis: new Set(),
                preds: new Set(),
                terminal: elseBlockTerminal
              };
              fn.body.blocks.set(elseBlockId, elseBlock);
              var _createPropsPropertie = createPropsProperties(
                  fn,
                  instr,
                  elseBlockInstructions,
                  instr.value.kind === "JsxExpression" ? instr.value.props : [],
                  instr.value.children
                ),
                refProperty = _createPropsPropertie.refProperty,
                keyProperty = _createPropsPropertie.keyProperty,
                propsProperty = _createPropsPropertie.propsProperty;
              var reactElementInstructionPlace = createTemporaryPlace(
                fn.env,
                instr.value.loc
              );
              var reactElementInstruction = {
                id: makeInstructionId(0),
                lvalue: Object.assign(
                  Object.assign({}, reactElementInstructionPlace),
                  { effect: Effect.Store }
                ),
                value: {
                  kind: "ObjectExpression",
                  properties: [
                    createSymbolProperty(
                      fn,
                      instr,
                      elseBlockInstructions,
                      "$$typeof",
                      inlineJsxTransformConfig.elementSymbol
                    ),
                    instr.value.kind === "JsxExpression"
                      ? createTagProperty(
                          fn,
                          instr,
                          elseBlockInstructions,
                          instr.value.tag
                        )
                      : createSymbolProperty(
                          fn,
                          instr,
                          elseBlockInstructions,
                          "type",
                          "react.fragment"
                        ),
                    refProperty,
                    keyProperty,
                    propsProperty
                  ],
                  loc: instr.value.loc
                },
                loc: instr.loc
              };
              elseBlockInstructions.push(reactElementInstruction);
              var reassignConditionalInstruction = {
                id: makeInstructionId(0),
                lvalue: Object.assign(
                  {},
                  createTemporaryPlace(fn.env, instr.value.loc)
                ),
                value: {
                  kind: "StoreLocal",
                  lvalue: {
                    place: Object.assign({}, elseVarPlace),
                    kind: InstructionKind.Reassign
                  },
                  value: Object.assign({}, reactElementInstruction.lvalue),
                  type: null,
                  loc: instr.value.loc
                },
                loc: instr.loc
              };
              elseBlockInstructions.push(reassignConditionalInstruction);
              var operands = new Map();
              operands.set(thenBlockId, Object.assign({}, elseVarPlace));
              operands.set(elseBlockId, Object.assign({}, thenVarPlace));
              var phiIdentifier = forkTemporaryIdentifier(
                fn.env.nextIdentifierId,
                varPlace.identifier
              );
              var phiPlace = Object.assign(
                Object.assign(
                  {},
                  createTemporaryPlace(fn.env, instr.value.loc)
                ),
                { identifier: phiIdentifier }
              );
              var phis = new Set([
                { kind: "Phi", operands: operands, place: phiPlace }
              ]);
              fallthroughBlock.phis = phis;
              fn.body.blocks.set(fallthroughBlockId, fallthroughBlock);
              inlinedJsxDeclarations.set(
                instr.lvalue.identifier.declarationId,
                {
                  identifier: phiIdentifier,
                  blockIdsToIgnore: new Set([thenBlockId, elseBlockId])
                }
              );
              break;
            }
            case "FunctionExpression":
            case "ObjectMethod": {
              inlineJsxTransform(
                instr.value.loweredFunc.func,
                inlineJsxTransformConfig
              );
              break;
            }
          }
        }
      }
      var _iterator214 = _createForOfIteratorHelper(fn.body.blocks),
        _step214;
      try {
        var _loop10 = function _loop10() {
          var _step214$value = _slicedToArray(_step214.value, 2),
            blockId = _step214$value[0],
            block = _step214$value[1];
          var _iterator215 = _createForOfIteratorHelper(block.instructions),
            _step215;
          try {
            for (_iterator215.s(); !(_step215 = _iterator215.n()).done; ) {
              var _instr2 = _step215.value;
              mapInstructionOperands(_instr2, function (place) {
                return handlePlace(place, blockId, inlinedJsxDeclarations);
              });
              mapInstructionLValues(_instr2, function (lvalue) {
                return handlelValue(lvalue, blockId, inlinedJsxDeclarations);
              });
              mapInstructionValueOperands(_instr2.value, function (place) {
                return handlePlace(place, blockId, inlinedJsxDeclarations);
              });
            }
          } catch (err) {
            _iterator215.e(err);
          } finally {
            _iterator215.f();
          }
          mapTerminalOperands(block.terminal, function (place) {
            return handlePlace(place, blockId, inlinedJsxDeclarations);
          });
          if (block.terminal.kind === "scope") {
            var scope = block.terminal.scope;
            var _iterator216 = _createForOfIteratorHelper(scope.dependencies),
              _step216;
            try {
              for (_iterator216.s(); !(_step216 = _iterator216.n()).done; ) {
                var dep = _step216.value;
                dep.identifier = handleIdentifier(
                  dep.identifier,
                  inlinedJsxDeclarations
                );
              }
            } catch (err) {
              _iterator216.e(err);
            } finally {
              _iterator216.f();
            }
            for (
              var _i36 = 0, _arr2 = _toConsumableArray(scope.declarations);
              _i36 < _arr2.length;
              _i36++
            ) {
              var _arr2$_i = _slicedToArray(_arr2[_i36], 2),
                origId = _arr2$_i[0],
                decl = _arr2$_i[1];
              var newDecl = handleIdentifier(
                decl.identifier,
                inlinedJsxDeclarations
              );
              if (newDecl.id !== origId) {
                scope.declarations["delete"](origId);
                scope.declarations.set(decl.identifier.id, {
                  identifier: newDecl,
                  scope: decl.scope
                });
              }
            }
          }
        };
        for (_iterator214.s(); !(_step214 = _iterator214.n()).done; ) {
          _loop10();
        }
      } catch (err) {
        _iterator214.e(err);
      } finally {
        _iterator214.f();
      }
      reversePostorderBlocks(fn.body);
      markPredecessors(fn.body);
      markInstructionIds(fn.body);
      fixScopeAndIdentifierRanges(fn.body);
    }
    function createSymbolProperty(
      fn,
      instr,
      nextInstructions,
      propertyName,
      symbolName
    ) {
      var symbolPlace = createTemporaryPlace(fn.env, instr.value.loc);
      var symbolInstruction = {
        id: makeInstructionId(0),
        lvalue: Object.assign(Object.assign({}, symbolPlace), {
          effect: Effect.Mutate
        }),
        value: {
          kind: "LoadGlobal",
          binding: { kind: "Global", name: "Symbol" },
          loc: instr.value.loc
        },
        loc: instr.loc
      };
      nextInstructions.push(symbolInstruction);
      var symbolForPlace = createTemporaryPlace(fn.env, instr.value.loc);
      var symbolForInstruction = {
        id: makeInstructionId(0),
        lvalue: Object.assign(Object.assign({}, symbolForPlace), {
          effect: Effect.Read
        }),
        value: {
          kind: "PropertyLoad",
          object: Object.assign({}, symbolInstruction.lvalue),
          property: makePropertyLiteral("for"),
          loc: instr.value.loc
        },
        loc: instr.loc
      };
      nextInstructions.push(symbolForInstruction);
      var symbolValuePlace = createTemporaryPlace(fn.env, instr.value.loc);
      var symbolValueInstruction = {
        id: makeInstructionId(0),
        lvalue: Object.assign(Object.assign({}, symbolValuePlace), {
          effect: Effect.Mutate
        }),
        value: { kind: "Primitive", value: symbolName, loc: instr.value.loc },
        loc: instr.loc
      };
      nextInstructions.push(symbolValueInstruction);
      var $$typeofPlace = createTemporaryPlace(fn.env, instr.value.loc);
      var $$typeofInstruction = {
        id: makeInstructionId(0),
        lvalue: Object.assign(Object.assign({}, $$typeofPlace), {
          effect: Effect.Mutate
        }),
        value: {
          kind: "MethodCall",
          receiver: symbolInstruction.lvalue,
          property: symbolForInstruction.lvalue,
          args: [symbolValueInstruction.lvalue],
          loc: instr.value.loc
        },
        loc: instr.loc
      };
      var $$typeofProperty = {
        kind: "ObjectProperty",
        key: { name: propertyName, kind: "string" },
        type: "property",
        place: Object.assign(Object.assign({}, $$typeofPlace), {
          effect: Effect.Capture
        })
      };
      nextInstructions.push($$typeofInstruction);
      return $$typeofProperty;
    }
    function createTagProperty(fn, instr, nextInstructions, componentTag) {
      var tagProperty;
      switch (componentTag.kind) {
        case "BuiltinTag": {
          var tagPropertyPlace = createTemporaryPlace(fn.env, instr.value.loc);
          var tagInstruction = {
            id: makeInstructionId(0),
            lvalue: Object.assign(Object.assign({}, tagPropertyPlace), {
              effect: Effect.Mutate
            }),
            value: {
              kind: "Primitive",
              value: componentTag.name,
              loc: instr.value.loc
            },
            loc: instr.loc
          };
          tagProperty = {
            kind: "ObjectProperty",
            key: { name: "type", kind: "string" },
            type: "property",
            place: Object.assign(Object.assign({}, tagPropertyPlace), {
              effect: Effect.Capture
            })
          };
          nextInstructions.push(tagInstruction);
          break;
        }
        case "Identifier": {
          tagProperty = {
            kind: "ObjectProperty",
            key: { name: "type", kind: "string" },
            type: "property",
            place: Object.assign(Object.assign({}, componentTag), {
              effect: Effect.Capture
            })
          };
          break;
        }
      }
      return tagProperty;
    }
    function createPropsProperties(
      fn,
      instr,
      nextInstructions,
      propAttributes,
      children
    ) {
      var refProperty;
      var keyProperty;
      var props = [];
      var jsxAttributesWithoutKey = propAttributes.filter(function (p) {
        return p.kind === "JsxAttribute" && p.name !== "key";
      });
      var jsxSpreadAttributes = propAttributes.filter(function (p) {
        return p.kind === "JsxSpreadAttribute";
      });
      var spreadPropsOnly =
        jsxAttributesWithoutKey.length === 0 &&
        jsxSpreadAttributes.length === 1;
      propAttributes.forEach(function (prop) {
        switch (prop.kind) {
          case "JsxAttribute": {
            switch (prop.name) {
              case "key": {
                keyProperty = {
                  kind: "ObjectProperty",
                  key: { name: "key", kind: "string" },
                  type: "property",
                  place: Object.assign({}, prop.place)
                };
                break;
              }
              case "ref": {
                refProperty = {
                  kind: "ObjectProperty",
                  key: { name: "ref", kind: "string" },
                  type: "property",
                  place: Object.assign({}, prop.place)
                };
                var refPropProperty = {
                  kind: "ObjectProperty",
                  key: { name: "ref", kind: "string" },
                  type: "property",
                  place: Object.assign({}, prop.place)
                };
                props.push(refPropProperty);
                break;
              }
              default: {
                var attributeProperty = {
                  kind: "ObjectProperty",
                  key: { name: prop.name, kind: "string" },
                  type: "property",
                  place: Object.assign({}, prop.place)
                };
                props.push(attributeProperty);
              }
            }
            break;
          }
          case "JsxSpreadAttribute": {
            props.push({
              kind: "Spread",
              place: Object.assign({}, prop.argument)
            });
            break;
          }
        }
      });
      var propsPropertyPlace = createTemporaryPlace(fn.env, instr.value.loc);
      if (children) {
        var childrenPropProperty;
        if (children.length === 1) {
          childrenPropProperty = {
            kind: "ObjectProperty",
            key: { name: "children", kind: "string" },
            type: "property",
            place: Object.assign(Object.assign({}, children[0]), {
              effect: Effect.Capture
            })
          };
        } else {
          var childrenPropPropertyPlace = createTemporaryPlace(
            fn.env,
            instr.value.loc
          );
          var childrenPropInstruction = {
            id: makeInstructionId(0),
            lvalue: Object.assign(
              Object.assign({}, childrenPropPropertyPlace),
              { effect: Effect.Mutate }
            ),
            value: {
              kind: "ArrayExpression",
              elements: _toConsumableArray(children),
              loc: instr.value.loc
            },
            loc: instr.loc
          };
          nextInstructions.push(childrenPropInstruction);
          childrenPropProperty = {
            kind: "ObjectProperty",
            key: { name: "children", kind: "string" },
            type: "property",
            place: Object.assign(Object.assign({}, childrenPropPropertyPlace), {
              effect: Effect.Capture
            })
          };
        }
        props.push(childrenPropProperty);
      }
      if (refProperty == null) {
        var refPropertyPlace = createTemporaryPlace(fn.env, instr.value.loc);
        var refInstruction = {
          id: makeInstructionId(0),
          lvalue: Object.assign(Object.assign({}, refPropertyPlace), {
            effect: Effect.Mutate
          }),
          value: { kind: "Primitive", value: null, loc: instr.value.loc },
          loc: instr.loc
        };
        refProperty = {
          kind: "ObjectProperty",
          key: { name: "ref", kind: "string" },
          type: "property",
          place: Object.assign(Object.assign({}, refPropertyPlace), {
            effect: Effect.Capture
          })
        };
        nextInstructions.push(refInstruction);
      }
      if (keyProperty == null) {
        var keyPropertyPlace = createTemporaryPlace(fn.env, instr.value.loc);
        var keyInstruction = {
          id: makeInstructionId(0),
          lvalue: Object.assign(Object.assign({}, keyPropertyPlace), {
            effect: Effect.Mutate
          }),
          value: { kind: "Primitive", value: null, loc: instr.value.loc },
          loc: instr.loc
        };
        keyProperty = {
          kind: "ObjectProperty",
          key: { name: "key", kind: "string" },
          type: "property",
          place: Object.assign(Object.assign({}, keyPropertyPlace), {
            effect: Effect.Capture
          })
        };
        nextInstructions.push(keyInstruction);
      }
      var propsProperty;
      if (spreadPropsOnly) {
        var spreadProp = jsxSpreadAttributes[0];
        CompilerError.invariant(spreadProp.kind === "JsxSpreadAttribute", {
          reason: "Spread prop attribute must be of kind JSXSpreadAttribute",
          loc: instr.loc
        });
        propsProperty = {
          kind: "ObjectProperty",
          key: { name: "props", kind: "string" },
          type: "property",
          place: Object.assign(Object.assign({}, spreadProp.argument), {
            effect: Effect.Mutate
          })
        };
      } else {
        var propsInstruction = {
          id: makeInstructionId(0),
          lvalue: Object.assign(Object.assign({}, propsPropertyPlace), {
            effect: Effect.Mutate
          }),
          value: {
            kind: "ObjectExpression",
            properties: props,
            loc: instr.value.loc
          },
          loc: instr.loc
        };
        propsProperty = {
          kind: "ObjectProperty",
          key: { name: "props", kind: "string" },
          type: "property",
          place: Object.assign(Object.assign({}, propsPropertyPlace), {
            effect: Effect.Capture
          })
        };
        nextInstructions.push(propsInstruction);
      }
      return {
        refProperty: refProperty,
        keyProperty: keyProperty,
        propsProperty: propsProperty
      };
    }
    function handlePlace(place, blockId, inlinedJsxDeclarations) {
      var inlinedJsxDeclaration = inlinedJsxDeclarations.get(
        place.identifier.declarationId
      );
      if (
        inlinedJsxDeclaration == null ||
        inlinedJsxDeclaration.blockIdsToIgnore.has(blockId)
      ) {
        return place;
      }
      return Object.assign(Object.assign({}, place), {
        identifier: inlinedJsxDeclaration.identifier
      });
    }
    function handlelValue(lvalue, blockId, inlinedJsxDeclarations) {
      var inlinedJsxDeclaration = inlinedJsxDeclarations.get(
        lvalue.identifier.declarationId
      );
      if (
        inlinedJsxDeclaration == null ||
        inlinedJsxDeclaration.blockIdsToIgnore.has(blockId)
      ) {
        return lvalue;
      }
      return Object.assign(Object.assign({}, lvalue), {
        identifier: inlinedJsxDeclaration.identifier
      });
    }
    function handleIdentifier(identifier, inlinedJsxDeclarations) {
      var inlinedJsxDeclaration = inlinedJsxDeclarations.get(
        identifier.declarationId
      );
      return inlinedJsxDeclaration == null
        ? identifier
        : inlinedJsxDeclaration.identifier;
    }
    function findScopesToMerge(fn) {
      var objectMethodDecls = new Set();
      var mergeScopesBuilder = new DisjointSet();
      var _iterator217 = _createForOfIteratorHelper(fn.body.blocks),
        _step217;
      try {
        for (_iterator217.s(); !(_step217 = _iterator217.n()).done; ) {
          var _step217$value = _slicedToArray(_step217.value, 2),
            _ = _step217$value[0],
            block = _step217$value[1];
          var _iterator218 = _createForOfIteratorHelper(block.instructions),
            _step218;
          try {
            for (_iterator218.s(); !(_step218 = _iterator218.n()).done; ) {
              var _step218$value = _step218.value,
                lvalue = _step218$value.lvalue,
                value = _step218$value.value;
              if (value.kind === "ObjectMethod") {
                objectMethodDecls.add(lvalue.identifier);
              } else if (value.kind === "ObjectExpression") {
                var _iterator219 = _createForOfIteratorHelper(
                    eachInstructionValueOperand(value)
                  ),
                  _step219;
                try {
                  for (
                    _iterator219.s();
                    !(_step219 = _iterator219.n()).done;

                  ) {
                    var operand = _step219.value;
                    if (objectMethodDecls.has(operand.identifier)) {
                      var operandScope = operand.identifier.scope;
                      var lvalueScope = lvalue.identifier.scope;
                      CompilerError.invariant(
                        operandScope != null && lvalueScope != null,
                        {
                          reason:
                            "Internal error: Expected all ObjectExpressions and ObjectMethods to have non-null scope.",
                          suggestions: null,
                          loc: GeneratedSource
                        }
                      );
                      mergeScopesBuilder.union([operandScope, lvalueScope]);
                    }
                  }
                } catch (err) {
                  _iterator219.e(err);
                } finally {
                  _iterator219.f();
                }
              }
            }
          } catch (err) {
            _iterator218.e(err);
          } finally {
            _iterator218.f();
          }
        }
      } catch (err) {
        _iterator217.e(err);
      } finally {
        _iterator217.f();
      }
      return mergeScopesBuilder;
    }
    function alignObjectMethodScopes(fn) {
      var _iterator220 = _createForOfIteratorHelper(fn.body.blocks),
        _step220;
      try {
        for (_iterator220.s(); !(_step220 = _iterator220.n()).done; ) {
          var _step220$value = _slicedToArray(_step220.value, 2),
            _ = _step220$value[0],
            block = _step220$value[1];
          var _iterator223 = _createForOfIteratorHelper(block.instructions),
            _step223;
          try {
            for (_iterator223.s(); !(_step223 = _iterator223.n()).done; ) {
              var value = _step223.value.value;
              if (
                value.kind === "ObjectMethod" ||
                value.kind === "FunctionExpression"
              ) {
                alignObjectMethodScopes(value.loweredFunc.func);
              }
            }
          } catch (err) {
            _iterator223.e(err);
          } finally {
            _iterator223.f();
          }
        }
      } catch (err) {
        _iterator220.e(err);
      } finally {
        _iterator220.f();
      }
      var scopeGroupsMap = findScopesToMerge(fn).canonicalize();
      var _iterator221 = _createForOfIteratorHelper(scopeGroupsMap),
        _step221;
      try {
        for (_iterator221.s(); !(_step221 = _iterator221.n()).done; ) {
          var _step221$value = _slicedToArray(_step221.value, 2),
            scope = _step221$value[0],
            root = _step221$value[1];
          if (scope !== root) {
            root.range.start = makeInstructionId(
              Math.min(scope.range.start, root.range.start)
            );
            root.range.end = makeInstructionId(
              Math.max(scope.range.end, root.range.end)
            );
          }
        }
      } catch (err) {
        _iterator221.e(err);
      } finally {
        _iterator221.f();
      }
      var _iterator222 = _createForOfIteratorHelper(fn.body.blocks),
        _step222;
      try {
        for (_iterator222.s(); !(_step222 = _iterator222.n()).done; ) {
          var _step222$value = _slicedToArray(_step222.value, 2),
            _32 = _step222$value[0],
            _block10 = _step222$value[1];
          var _iterator224 = _createForOfIteratorHelper(_block10.instructions),
            _step224;
          try {
            for (_iterator224.s(); !(_step224 = _iterator224.n()).done; ) {
              var _identifier10 = _step224.value.lvalue.identifier;
              if (_identifier10.scope != null) {
                var _root2 = scopeGroupsMap.get(_identifier10.scope);
                if (_root2 != null) {
                  _identifier10.scope = _root2;
                }
              }
            }
          } catch (err) {
            _iterator224.e(err);
          } finally {
            _iterator224.f();
          }
        }
      } catch (err) {
        _iterator222.e(err);
      } finally {
        _iterator222.f();
      }
    }
    function visitReactiveFunction(fn, visitor, state) {
      visitor.visitBlock(fn.body, state);
    }
    var ReactiveFunctionVisitor = /*#__PURE__*/ (function () {
      function ReactiveFunctionVisitor() {
        _classCallCheck(this, ReactiveFunctionVisitor);
      }
      return _createClass(ReactiveFunctionVisitor, [
        { key: "visitID", value: function visitID(_id, _state) {} },
        { key: "visitParam", value: function visitParam(_place, _state) {} },
        {
          key: "visitLValue",
          value: function visitLValue(_id, _lvalue, _state) {}
        },
        {
          key: "visitPlace",
          value: function visitPlace(_id, _place, _state) {}
        },
        {
          key: "visitReactiveFunctionValue",
          value: function visitReactiveFunctionValue(
            _id,
            _dependencies,
            _fn,
            _state
          ) {}
        },
        {
          key: "visitValue",
          value: function visitValue(id, value, state) {
            this.traverseValue(id, value, state);
          }
        },
        {
          key: "traverseValue",
          value: function traverseValue(id, value, state) {
            switch (value.kind) {
              case "OptionalExpression": {
                this.visitValue(id, value.value, state);
                break;
              }
              case "LogicalExpression": {
                this.visitValue(id, value.left, state);
                this.visitValue(id, value.right, state);
                break;
              }
              case "ConditionalExpression": {
                this.visitValue(id, value.test, state);
                this.visitValue(id, value.consequent, state);
                this.visitValue(id, value.alternate, state);
                break;
              }
              case "SequenceExpression": {
                var _iterator225 = _createForOfIteratorHelper(
                    value.instructions
                  ),
                  _step225;
                try {
                  for (
                    _iterator225.s();
                    !(_step225 = _iterator225.n()).done;

                  ) {
                    var instr = _step225.value;
                    this.visitInstruction(instr, state);
                  }
                } catch (err) {
                  _iterator225.e(err);
                } finally {
                  _iterator225.f();
                }
                this.visitValue(value.id, value.value, state);
                break;
              }
              default: {
                var _iterator226 = _createForOfIteratorHelper(
                    eachInstructionValueOperand(value)
                  ),
                  _step226;
                try {
                  for (
                    _iterator226.s();
                    !(_step226 = _iterator226.n()).done;

                  ) {
                    var place = _step226.value;
                    this.visitPlace(id, place, state);
                  }
                } catch (err) {
                  _iterator226.e(err);
                } finally {
                  _iterator226.f();
                }
              }
            }
          }
        },
        {
          key: "visitInstruction",
          value: function visitInstruction(instruction, state) {
            this.traverseInstruction(instruction, state);
          }
        },
        {
          key: "traverseInstruction",
          value: function traverseInstruction(instruction, state) {
            this.visitID(instruction.id, state);
            var _iterator227 = _createForOfIteratorHelper(
                eachInstructionLValue(instruction)
              ),
              _step227;
            try {
              for (_iterator227.s(); !(_step227 = _iterator227.n()).done; ) {
                var operand = _step227.value;
                this.visitLValue(instruction.id, operand, state);
              }
            } catch (err) {
              _iterator227.e(err);
            } finally {
              _iterator227.f();
            }
            this.visitValue(instruction.id, instruction.value, state);
          }
        },
        {
          key: "visitTerminal",
          value: function visitTerminal(stmt, state) {
            this.traverseTerminal(stmt, state);
          }
        },
        {
          key: "traverseTerminal",
          value: function traverseTerminal(stmt, state) {
            var terminal = stmt.terminal;
            if (terminal.id !== null) {
              this.visitID(terminal.id, state);
            }
            switch (terminal.kind) {
              case "break":
              case "continue": {
                break;
              }
              case "return": {
                this.visitPlace(terminal.id, terminal.value, state);
                break;
              }
              case "throw": {
                this.visitPlace(terminal.id, terminal.value, state);
                break;
              }
              case "for": {
                this.visitValue(terminal.id, terminal.init, state);
                this.visitValue(terminal.id, terminal.test, state);
                this.visitBlock(terminal.loop, state);
                if (terminal.update !== null) {
                  this.visitValue(terminal.id, terminal.update, state);
                }
                break;
              }
              case "for-of": {
                this.visitValue(terminal.id, terminal.init, state);
                this.visitValue(terminal.id, terminal.test, state);
                this.visitBlock(terminal.loop, state);
                break;
              }
              case "for-in": {
                this.visitValue(terminal.id, terminal.init, state);
                this.visitBlock(terminal.loop, state);
                break;
              }
              case "do-while": {
                this.visitBlock(terminal.loop, state);
                this.visitValue(terminal.id, terminal.test, state);
                break;
              }
              case "while": {
                this.visitValue(terminal.id, terminal.test, state);
                this.visitBlock(terminal.loop, state);
                break;
              }
              case "if": {
                this.visitPlace(terminal.id, terminal.test, state);
                this.visitBlock(terminal.consequent, state);
                if (terminal.alternate !== null) {
                  this.visitBlock(terminal.alternate, state);
                }
                break;
              }
              case "switch": {
                this.visitPlace(terminal.id, terminal.test, state);
                var _iterator228 = _createForOfIteratorHelper(terminal.cases),
                  _step228;
                try {
                  for (
                    _iterator228.s();
                    !(_step228 = _iterator228.n()).done;

                  ) {
                    var case_ = _step228.value;
                    if (case_.test !== null) {
                      this.visitPlace(terminal.id, case_.test, state);
                    }
                    if (case_.block !== undefined) {
                      this.visitBlock(case_.block, state);
                    }
                  }
                } catch (err) {
                  _iterator228.e(err);
                } finally {
                  _iterator228.f();
                }
                break;
              }
              case "label": {
                this.visitBlock(terminal.block, state);
                break;
              }
              case "try": {
                this.visitBlock(terminal.block, state);
                this.visitBlock(terminal.handler, state);
                break;
              }
              default: {
                assertExhaustive$1(
                  terminal,
                  "Unexpected terminal kind `".concat(terminal.kind, "`")
                );
              }
            }
          }
        },
        {
          key: "visitScope",
          value: function visitScope(scope, state) {
            this.traverseScope(scope, state);
          }
        },
        {
          key: "traverseScope",
          value: function traverseScope(scope, state) {
            this.visitBlock(scope.instructions, state);
          }
        },
        {
          key: "visitPrunedScope",
          value: function visitPrunedScope(scopeBlock, state) {
            this.traversePrunedScope(scopeBlock, state);
          }
        },
        {
          key: "traversePrunedScope",
          value: function traversePrunedScope(scopeBlock, state) {
            this.visitBlock(scopeBlock.instructions, state);
          }
        },
        {
          key: "visitBlock",
          value: function visitBlock(block, state) {
            this.traverseBlock(block, state);
          }
        },
        {
          key: "traverseBlock",
          value: function traverseBlock(block, state) {
            var _iterator229 = _createForOfIteratorHelper(block),
              _step229;
            try {
              for (_iterator229.s(); !(_step229 = _iterator229.n()).done; ) {
                var instr = _step229.value;
                switch (instr.kind) {
                  case "instruction": {
                    this.visitInstruction(instr.instruction, state);
                    break;
                  }
                  case "scope": {
                    this.visitScope(instr, state);
                    break;
                  }
                  case "pruned-scope": {
                    this.visitPrunedScope(instr, state);
                    break;
                  }
                  case "terminal": {
                    this.visitTerminal(instr, state);
                    break;
                  }
                  default: {
                    assertExhaustive$1(
                      instr,
                      "Unexpected instruction kind `".concat(instr.kind, "`")
                    );
                  }
                }
              }
            } catch (err) {
              _iterator229.e(err);
            } finally {
              _iterator229.f();
            }
          }
        },
        {
          key: "visitHirFunction",
          value: function visitHirFunction(fn, state) {
            var _iterator230 = _createForOfIteratorHelper(fn.params),
              _step230;
            try {
              for (_iterator230.s(); !(_step230 = _iterator230.n()).done; ) {
                var param = _step230.value;
                var place = param.kind === "Identifier" ? param : param.place;
                this.visitParam(place, state);
              }
            } catch (err) {
              _iterator230.e(err);
            } finally {
              _iterator230.f();
            }
            var _iterator231 = _createForOfIteratorHelper(fn.body.blocks),
              _step231;
            try {
              for (_iterator231.s(); !(_step231 = _iterator231.n()).done; ) {
                var _step231$value = _slicedToArray(_step231.value, 2),
                  block = _step231$value[1];
                var _iterator232 = _createForOfIteratorHelper(
                    block.instructions
                  ),
                  _step232;
                try {
                  for (
                    _iterator232.s();
                    !(_step232 = _iterator232.n()).done;

                  ) {
                    var instr = _step232.value;
                    this.visitInstruction(instr, state);
                    if (
                      instr.value.kind === "FunctionExpression" ||
                      instr.value.kind === "ObjectMethod"
                    ) {
                      this.visitHirFunction(
                        instr.value.loweredFunc.func,
                        state
                      );
                    }
                  }
                } catch (err) {
                  _iterator232.e(err);
                } finally {
                  _iterator232.f();
                }
                var _iterator233 = _createForOfIteratorHelper(
                    eachTerminalOperand(block.terminal)
                  ),
                  _step233;
                try {
                  for (
                    _iterator233.s();
                    !(_step233 = _iterator233.n()).done;

                  ) {
                    var operand = _step233.value;
                    this.visitPlace(block.terminal.id, operand, state);
                  }
                } catch (err) {
                  _iterator233.e(err);
                } finally {
                  _iterator233.f();
                }
              }
            } catch (err) {
              _iterator231.e(err);
            } finally {
              _iterator231.f();
            }
          }
        }
      ]);
    })();
    var ReactiveFunctionTransform = /*#__PURE__*/ (function (
      _ReactiveFunctionVisi
    ) {
      function ReactiveFunctionTransform() {
        _classCallCheck(this, ReactiveFunctionTransform);
        return _callSuper(this, ReactiveFunctionTransform, arguments);
      }
      _inherits2(ReactiveFunctionTransform, _ReactiveFunctionVisi);
      return _createClass(ReactiveFunctionTransform, [
        {
          key: "traverseBlock",
          value: function traverseBlock(block, state) {
            var nextBlock = null;
            for (var i = 0; i < block.length; i++) {
              var instr = block[i];
              var transformed = void 0;
              switch (instr.kind) {
                case "instruction": {
                  transformed = this.transformInstruction(
                    instr.instruction,
                    state
                  );
                  break;
                }
                case "scope": {
                  transformed = this.transformScope(instr, state);
                  break;
                }
                case "pruned-scope": {
                  transformed = this.transformPrunedScope(instr, state);
                  break;
                }
                case "terminal": {
                  transformed = this.transformTerminal(instr, state);
                  break;
                }
                default: {
                  assertExhaustive$1(
                    instr,
                    "Unexpected instruction kind `".concat(instr.kind, "`")
                  );
                }
              }
              switch (transformed.kind) {
                case "keep": {
                  if (nextBlock !== null) {
                    nextBlock.push(instr);
                  }
                  break;
                }
                case "remove": {
                  if (nextBlock === null) {
                    nextBlock = block.slice(0, i);
                  }
                  break;
                }
                case "replace": {
                  nextBlock !== null && nextBlock !== void 0
                    ? nextBlock
                    : (nextBlock = block.slice(0, i));
                  nextBlock.push(transformed.value);
                  break;
                }
                case "replace-many": {
                  var _nextBlock;
                  nextBlock !== null && nextBlock !== void 0
                    ? nextBlock
                    : (nextBlock = block.slice(0, i));
                  (_nextBlock = nextBlock).push.apply(
                    _nextBlock,
                    _toConsumableArray(transformed.value)
                  );
                  break;
                }
              }
            }
            if (nextBlock !== null) {
              block.length = 0;
              block.push.apply(block, _toConsumableArray(nextBlock));
            }
          }
        },
        {
          key: "transformInstruction",
          value: function transformInstruction(instruction, state) {
            this.visitInstruction(instruction, state);
            return { kind: "keep" };
          }
        },
        {
          key: "transformTerminal",
          value: function transformTerminal(stmt, state) {
            this.visitTerminal(stmt, state);
            return { kind: "keep" };
          }
        },
        {
          key: "transformScope",
          value: function transformScope(scope, state) {
            this.visitScope(scope, state);
            return { kind: "keep" };
          }
        },
        {
          key: "transformPrunedScope",
          value: function transformPrunedScope(scope, state) {
            this.visitPrunedScope(scope, state);
            return { kind: "keep" };
          }
        },
        {
          key: "transformValue",
          value: function transformValue(id, value, state) {
            this.visitValue(id, value, state);
            return { kind: "keep" };
          }
        },
        {
          key: "transformReactiveFunctionValue",
          value: function transformReactiveFunctionValue(
            id,
            dependencies,
            fn,
            state
          ) {
            this.visitReactiveFunctionValue(id, dependencies, fn, state);
            return { kind: "keep" };
          }
        },
        {
          key: "traverseValue",
          value: function traverseValue(id, value, state) {
            switch (value.kind) {
              case "OptionalExpression": {
                var nextValue = this.transformValue(id, value.value, state);
                if (nextValue.kind === "replace") {
                  value.value = nextValue.value;
                }
                break;
              }
              case "LogicalExpression": {
                var left = this.transformValue(id, value.left, state);
                if (left.kind === "replace") {
                  value.left = left.value;
                }
                var right = this.transformValue(id, value.right, state);
                if (right.kind === "replace") {
                  value.right = right.value;
                }
                break;
              }
              case "ConditionalExpression": {
                var _test17 = this.transformValue(id, value.test, state);
                if (_test17.kind === "replace") {
                  value.test = _test17.value;
                }
                var consequent = this.transformValue(
                  id,
                  value.consequent,
                  state
                );
                if (consequent.kind === "replace") {
                  value.consequent = consequent.value;
                }
                var alternate = this.transformValue(id, value.alternate, state);
                if (alternate.kind === "replace") {
                  value.alternate = alternate.value;
                }
                break;
              }
              case "SequenceExpression": {
                var _iterator234 = _createForOfIteratorHelper(
                    value.instructions
                  ),
                  _step234;
                try {
                  for (
                    _iterator234.s();
                    !(_step234 = _iterator234.n()).done;

                  ) {
                    var instr = _step234.value;
                    this.visitInstruction(instr, state);
                  }
                } catch (err) {
                  _iterator234.e(err);
                } finally {
                  _iterator234.f();
                }
                var _nextValue2 = this.transformValue(
                  value.id,
                  value.value,
                  state
                );
                if (_nextValue2.kind === "replace") {
                  value.value = _nextValue2.value;
                }
                break;
              }
              default: {
                var _iterator235 = _createForOfIteratorHelper(
                    eachInstructionValueOperand(value)
                  ),
                  _step235;
                try {
                  for (
                    _iterator235.s();
                    !(_step235 = _iterator235.n()).done;

                  ) {
                    var place = _step235.value;
                    this.visitPlace(id, place, state);
                  }
                } catch (err) {
                  _iterator235.e(err);
                } finally {
                  _iterator235.f();
                }
              }
            }
          }
        },
        {
          key: "traverseInstruction",
          value: function traverseInstruction(instruction, state) {
            this.visitID(instruction.id, state);
            var _iterator236 = _createForOfIteratorHelper(
                eachInstructionLValue(instruction)
              ),
              _step236;
            try {
              for (_iterator236.s(); !(_step236 = _iterator236.n()).done; ) {
                var operand = _step236.value;
                this.visitLValue(instruction.id, operand, state);
              }
            } catch (err) {
              _iterator236.e(err);
            } finally {
              _iterator236.f();
            }
            var nextValue = this.transformValue(
              instruction.id,
              instruction.value,
              state
            );
            if (nextValue.kind === "replace") {
              instruction.value = nextValue.value;
            }
          }
        },
        {
          key: "traverseTerminal",
          value: function traverseTerminal(stmt, state) {
            var terminal = stmt.terminal;
            if (terminal.id !== null) {
              this.visitID(terminal.id, state);
            }
            switch (terminal.kind) {
              case "break":
              case "continue": {
                break;
              }
              case "return": {
                this.visitPlace(terminal.id, terminal.value, state);
                break;
              }
              case "throw": {
                this.visitPlace(terminal.id, terminal.value, state);
                break;
              }
              case "for": {
                var init = this.transformValue(
                  terminal.id,
                  terminal.init,
                  state
                );
                if (init.kind === "replace") {
                  terminal.init = init.value;
                }
                var _test18 = this.transformValue(
                  terminal.id,
                  terminal.test,
                  state
                );
                if (_test18.kind === "replace") {
                  terminal.test = _test18.value;
                }
                if (terminal.update !== null) {
                  var _update3 = this.transformValue(
                    terminal.id,
                    terminal.update,
                    state
                  );
                  if (_update3.kind === "replace") {
                    terminal.update = _update3.value;
                  }
                }
                this.visitBlock(terminal.loop, state);
                break;
              }
              case "for-of": {
                var _init3 = this.transformValue(
                  terminal.id,
                  terminal.init,
                  state
                );
                if (_init3.kind === "replace") {
                  terminal.init = _init3.value;
                }
                var _test19 = this.transformValue(
                  terminal.id,
                  terminal.test,
                  state
                );
                if (_test19.kind === "replace") {
                  terminal.test = _test19.value;
                }
                this.visitBlock(terminal.loop, state);
                break;
              }
              case "for-in": {
                var _init4 = this.transformValue(
                  terminal.id,
                  terminal.init,
                  state
                );
                if (_init4.kind === "replace") {
                  terminal.init = _init4.value;
                }
                this.visitBlock(terminal.loop, state);
                break;
              }
              case "do-while": {
                this.visitBlock(terminal.loop, state);
                var _test20 = this.transformValue(
                  terminal.id,
                  terminal.test,
                  state
                );
                if (_test20.kind === "replace") {
                  terminal.test = _test20.value;
                }
                break;
              }
              case "while": {
                var _test21 = this.transformValue(
                  terminal.id,
                  terminal.test,
                  state
                );
                if (_test21.kind === "replace") {
                  terminal.test = _test21.value;
                }
                this.visitBlock(terminal.loop, state);
                break;
              }
              case "if": {
                this.visitPlace(terminal.id, terminal.test, state);
                this.visitBlock(terminal.consequent, state);
                if (terminal.alternate !== null) {
                  this.visitBlock(terminal.alternate, state);
                }
                break;
              }
              case "switch": {
                this.visitPlace(terminal.id, terminal.test, state);
                var _iterator237 = _createForOfIteratorHelper(terminal.cases),
                  _step237;
                try {
                  for (
                    _iterator237.s();
                    !(_step237 = _iterator237.n()).done;

                  ) {
                    var case_ = _step237.value;
                    if (case_.test !== null) {
                      this.visitPlace(terminal.id, case_.test, state);
                    }
                    if (case_.block !== undefined) {
                      this.visitBlock(case_.block, state);
                    }
                  }
                } catch (err) {
                  _iterator237.e(err);
                } finally {
                  _iterator237.f();
                }
                break;
              }
              case "label": {
                this.visitBlock(terminal.block, state);
                break;
              }
              case "try": {
                this.visitBlock(terminal.block, state);
                if (terminal.handlerBinding !== null) {
                  this.visitPlace(terminal.id, terminal.handlerBinding, state);
                }
                this.visitBlock(terminal.handler, state);
                break;
              }
              default: {
                assertExhaustive$1(
                  terminal,
                  "Unexpected terminal kind `".concat(terminal.kind, "`")
                );
              }
            }
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    function eachReactiveValueOperand(instrValue) {
      var _iterator238, _step238, instr;
      return _regeneratorRuntime().wrap(
        function eachReactiveValueOperand$(_context9) {
          while (1)
            switch ((_context9.prev = _context9.next)) {
              case 0:
                _context9.t0 = instrValue.kind;
                _context9.next =
                  _context9.t0 === "OptionalExpression"
                    ? 3
                    : _context9.t0 === "LogicalExpression"
                      ? 5
                      : _context9.t0 === "SequenceExpression"
                        ? 8
                        : _context9.t0 === "ConditionalExpression"
                          ? 26
                          : 30;
                break;
              case 3:
                return _context9.delegateYield(
                  eachReactiveValueOperand(instrValue.value),
                  "t1",
                  4
                );
              case 4:
                return _context9.abrupt("break", 31);
              case 5:
                return _context9.delegateYield(
                  eachReactiveValueOperand(instrValue.left),
                  "t2",
                  6
                );
              case 6:
                return _context9.delegateYield(
                  eachReactiveValueOperand(instrValue.right),
                  "t3",
                  7
                );
              case 7:
                return _context9.abrupt("break", 31);
              case 8:
                _iterator238 = _createForOfIteratorHelper(
                  instrValue.instructions
                );
                _context9.prev = 9;
                _iterator238.s();
              case 11:
                if ((_step238 = _iterator238.n()).done) {
                  _context9.next = 16;
                  break;
                }
                instr = _step238.value;
                return _context9.delegateYield(
                  eachReactiveValueOperand(instr.value),
                  "t4",
                  14
                );
              case 14:
                _context9.next = 11;
                break;
              case 16:
                _context9.next = 21;
                break;
              case 18:
                _context9.prev = 18;
                _context9.t5 = _context9["catch"](9);
                _iterator238.e(_context9.t5);
              case 21:
                _context9.prev = 21;
                _iterator238.f();
                return _context9.finish(21);
              case 24:
                return _context9.delegateYield(
                  eachReactiveValueOperand(instrValue.value),
                  "t6",
                  25
                );
              case 25:
                return _context9.abrupt("break", 31);
              case 26:
                return _context9.delegateYield(
                  eachReactiveValueOperand(instrValue.test),
                  "t7",
                  27
                );
              case 27:
                return _context9.delegateYield(
                  eachReactiveValueOperand(instrValue.consequent),
                  "t8",
                  28
                );
              case 28:
                return _context9.delegateYield(
                  eachReactiveValueOperand(instrValue.alternate),
                  "t9",
                  29
                );
              case 29:
                return _context9.abrupt("break", 31);
              case 30:
                return _context9.delegateYield(
                  eachInstructionValueOperand(instrValue),
                  "t10",
                  31
                );
              case 31:
              case "end":
                return _context9.stop();
            }
        },
        _marked9,
        null,
        [[9, 18, 21, 24]]
      );
    }
    function assertScopeInstructionsWithinScopes(fn) {
      var existingScopes = new Set();
      visitReactiveFunction(fn, new FindAllScopesVisitor(), existingScopes);
      visitReactiveFunction(
        fn,
        new CheckInstructionsAgainstScopesVisitor(),
        existingScopes
      );
    }
    var FindAllScopesVisitor = /*#__PURE__*/ (function (
      _ReactiveFunctionVisi2
    ) {
      function FindAllScopesVisitor() {
        _classCallCheck(this, FindAllScopesVisitor);
        return _callSuper(this, FindAllScopesVisitor, arguments);
      }
      _inherits2(FindAllScopesVisitor, _ReactiveFunctionVisi2);
      return _createClass(FindAllScopesVisitor, [
        {
          key: "visitScope",
          value: function visitScope(block, state) {
            this.traverseScope(block, state);
            state.add(block.scope.id);
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    var CheckInstructionsAgainstScopesVisitor = /*#__PURE__*/ (function (
      _ReactiveFunctionVisi3
    ) {
      function CheckInstructionsAgainstScopesVisitor() {
        var _this8;
        _classCallCheck(this, CheckInstructionsAgainstScopesVisitor);
        _this8 = _callSuper(
          this,
          CheckInstructionsAgainstScopesVisitor,
          arguments
        );
        _this8.activeScopes = new Set();
        return _this8;
      }
      _inherits2(CheckInstructionsAgainstScopesVisitor, _ReactiveFunctionVisi3);
      return _createClass(CheckInstructionsAgainstScopesVisitor, [
        {
          key: "visitPlace",
          value: function visitPlace(id, place, state) {
            var scope = getPlaceScope(id, place);
            if (
              scope !== null &&
              state.has(scope.id) &&
              !this.activeScopes.has(scope.id)
            ) {
              CompilerError.invariant(false, {
                description: "Instruction ["
                  .concat(id, "] is part of scope @")
                  .concat(scope.id, ", but that scope has already completed."),
                loc: place.loc,
                reason:
                  "Encountered an instruction that should be part of a scope, but where that scope has already completed",
                suggestions: null
              });
            }
          }
        },
        {
          key: "visitScope",
          value: function visitScope(block, state) {
            this.activeScopes.add(block.scope.id);
            this.traverseScope(block, state);
            this.activeScopes["delete"](block.scope.id);
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    function assertWellFormedBreakTargets(fn) {
      visitReactiveFunction(fn, new Visitor$a(), new Set());
    }
    var Visitor$a = /*#__PURE__*/ (function (_ReactiveFunctionVisi4) {
      function Visitor() {
        _classCallCheck(this, Visitor);
        return _callSuper(this, Visitor, arguments);
      }
      _inherits2(Visitor, _ReactiveFunctionVisi4);
      return _createClass(Visitor, [
        {
          key: "visitTerminal",
          value: function visitTerminal(stmt, seenLabels) {
            if (stmt.label != null) {
              seenLabels.add(stmt.label.id);
            }
            var terminal = stmt.terminal;
            if (terminal.kind === "break" || terminal.kind === "continue") {
              CompilerError.invariant(seenLabels.has(terminal.target), {
                reason: "Unexpected break to invalid label",
                loc: stmt.terminal.loc
              });
            }
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    var _Context_nextScheduleId,
      _Context_scheduled,
      _Context_catchHandlers,
      _Context_controlFlowStack;
    function buildReactiveFunction(fn) {
      var cx = new Context$3(fn.body);
      var driver = new Driver(cx);
      var body = driver.traverseBlock(cx.block(fn.body.entry));
      return {
        loc: fn.loc,
        id: fn.id,
        params: fn.params,
        generator: fn.generator,
        async: fn.async,
        body: body,
        env: fn.env,
        directives: fn.directives
      };
    }
    var Driver = /*#__PURE__*/ (function () {
      function Driver(cx) {
        _classCallCheck(this, Driver);
        this.cx = cx;
      }
      return _createClass(Driver, [
        {
          key: "traverseBlock",
          value: function traverseBlock(block) {
            var blockValue = [];
            this.visitBlock(block, blockValue);
            return blockValue;
          }
        },
        {
          key: "visitBlock",
          value: function visitBlock(block, blockValue) {
            var _this9 = this;
            var _a;
            CompilerError.invariant(!this.cx.emitted.has(block.id), {
              reason: "Cannot emit the same block twice: bb".concat(block.id),
              description: null,
              loc: null,
              suggestions: null
            });
            this.cx.emitted.add(block.id);
            var _iterator239 = _createForOfIteratorHelper(block.instructions),
              _step239;
            try {
              for (_iterator239.s(); !(_step239 = _iterator239.n()).done; ) {
                var instruction = _step239.value;
                blockValue.push({
                  kind: "instruction",
                  instruction: instruction
                });
              }
            } catch (err) {
              _iterator239.e(err);
            } finally {
              _iterator239.f();
            }
            var terminal = block.terminal;
            var scheduleIds = [];
            switch (terminal.kind) {
              case "return": {
                blockValue.push({
                  kind: "terminal",
                  terminal: {
                    kind: "return",
                    loc: terminal.loc,
                    value: terminal.value,
                    id: terminal.id
                  },
                  label: null
                });
                break;
              }
              case "throw": {
                blockValue.push({
                  kind: "terminal",
                  terminal: {
                    kind: "throw",
                    loc: terminal.loc,
                    value: terminal.value,
                    id: terminal.id
                  },
                  label: null
                });
                break;
              }
              case "if": {
                var fallthroughId =
                  this.cx.reachable(terminal.fallthrough) &&
                  !this.cx.isScheduled(terminal.fallthrough)
                    ? terminal.fallthrough
                    : null;
                var alternateId =
                  terminal.alternate !== terminal.fallthrough
                    ? terminal.alternate
                    : null;
                if (fallthroughId !== null) {
                  var scheduleId = this.cx.schedule(fallthroughId, "if");
                  scheduleIds.push(scheduleId);
                }
                var consequent = null;
                if (this.cx.isScheduled(terminal.consequent)) {
                  CompilerError.invariant(false, {
                    reason:
                      "Unexpected 'if' where the consequent is already scheduled",
                    loc: terminal.loc
                  });
                } else {
                  consequent = this.traverseBlock(
                    this.cx.ir.blocks.get(terminal.consequent)
                  );
                }
                var alternate = null;
                if (alternateId !== null) {
                  if (this.cx.isScheduled(alternateId)) {
                    CompilerError.invariant(false, {
                      reason:
                        "Unexpected 'if' where the alternate is already scheduled",
                      loc: terminal.loc
                    });
                  } else {
                    alternate = this.traverseBlock(
                      this.cx.ir.blocks.get(alternateId)
                    );
                  }
                }
                this.cx.unscheduleAll(scheduleIds);
                blockValue.push({
                  kind: "terminal",
                  terminal: {
                    kind: "if",
                    loc: terminal.loc,
                    test: terminal.test,
                    consequent:
                      consequent !== null && consequent !== void 0
                        ? consequent
                        : this.emptyBlock(),
                    alternate: alternate,
                    id: terminal.id
                  },
                  label:
                    fallthroughId == null
                      ? null
                      : { id: fallthroughId, implicit: false }
                });
                if (fallthroughId !== null) {
                  this.visitBlock(
                    this.cx.ir.blocks.get(fallthroughId),
                    blockValue
                  );
                }
                break;
              }
              case "switch": {
                var _fallthroughId2 =
                  this.cx.reachable(terminal.fallthrough) &&
                  !this.cx.isScheduled(terminal.fallthrough)
                    ? terminal.fallthrough
                    : null;
                if (_fallthroughId2 !== null) {
                  var _scheduleId = this.cx.schedule(_fallthroughId2, "switch");
                  scheduleIds.push(_scheduleId);
                }
                var cases = [];
                _toConsumableArray(terminal.cases)
                  .reverse()
                  .forEach(function (case_, _index) {
                    var test = case_.test;
                    var consequent;
                    if (_this9.cx.isScheduled(case_.block)) {
                      CompilerError.invariant(
                        case_.block === terminal.fallthrough,
                        {
                          reason:
                            "Unexpected 'switch' where a case is already scheduled and block is not the fallthrough",
                          loc: terminal.loc
                        }
                      );
                      return;
                    } else {
                      consequent = _this9.traverseBlock(
                        _this9.cx.ir.blocks.get(case_.block)
                      );
                      var _scheduleId2 = _this9.cx.schedule(
                        case_.block,
                        "case"
                      );
                      scheduleIds.push(_scheduleId2);
                    }
                    cases.push({ test: test, block: consequent });
                  });
                cases.reverse();
                this.cx.unscheduleAll(scheduleIds);
                blockValue.push({
                  kind: "terminal",
                  terminal: {
                    kind: "switch",
                    loc: terminal.loc,
                    test: terminal.test,
                    cases: cases,
                    id: terminal.id
                  },
                  label:
                    _fallthroughId2 == null
                      ? null
                      : { id: _fallthroughId2, implicit: false }
                });
                if (_fallthroughId2 !== null) {
                  this.visitBlock(
                    this.cx.ir.blocks.get(_fallthroughId2),
                    blockValue
                  );
                }
                break;
              }
              case "do-while": {
                var _fallthroughId3 = !this.cx.isScheduled(terminal.fallthrough)
                  ? terminal.fallthrough
                  : null;
                var loopId =
                  !this.cx.isScheduled(terminal.loop) &&
                  terminal.loop !== terminal.fallthrough
                    ? terminal.loop
                    : null;
                var _scheduleId3 = this.cx.scheduleLoop(
                  terminal.fallthrough,
                  terminal.test,
                  terminal.loop
                );
                scheduleIds.push(_scheduleId3);
                var loopBody;
                if (loopId) {
                  loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
                } else {
                  CompilerError.invariant(false, {
                    reason:
                      "Unexpected 'do-while' where the loop is already scheduled",
                    loc: terminal.loc
                  });
                }
                var testValue = this.visitValueBlock(
                  terminal.test,
                  terminal.loc
                ).value;
                this.cx.unscheduleAll(scheduleIds);
                blockValue.push({
                  kind: "terminal",
                  terminal: {
                    kind: "do-while",
                    loc: terminal.loc,
                    test: testValue,
                    loop: loopBody,
                    id: terminal.id
                  },
                  label:
                    _fallthroughId3 == null
                      ? null
                      : { id: _fallthroughId3, implicit: false }
                });
                if (_fallthroughId3 !== null) {
                  this.visitBlock(
                    this.cx.ir.blocks.get(_fallthroughId3),
                    blockValue
                  );
                }
                break;
              }
              case "while": {
                var _fallthroughId4 =
                  this.cx.reachable(terminal.fallthrough) &&
                  !this.cx.isScheduled(terminal.fallthrough)
                    ? terminal.fallthrough
                    : null;
                var _loopId =
                  !this.cx.isScheduled(terminal.loop) &&
                  terminal.loop !== terminal.fallthrough
                    ? terminal.loop
                    : null;
                var _scheduleId4 = this.cx.scheduleLoop(
                  terminal.fallthrough,
                  terminal.test,
                  terminal.loop
                );
                scheduleIds.push(_scheduleId4);
                var _testValue = this.visitValueBlock(
                  terminal.test,
                  terminal.loc
                ).value;
                var _loopBody;
                if (_loopId) {
                  _loopBody = this.traverseBlock(
                    this.cx.ir.blocks.get(_loopId)
                  );
                } else {
                  CompilerError.invariant(false, {
                    reason:
                      "Unexpected 'while' where the loop is already scheduled",
                    loc: terminal.loc
                  });
                }
                this.cx.unscheduleAll(scheduleIds);
                blockValue.push({
                  kind: "terminal",
                  terminal: {
                    kind: "while",
                    loc: terminal.loc,
                    test: _testValue,
                    loop: _loopBody,
                    id: terminal.id
                  },
                  label:
                    _fallthroughId4 == null
                      ? null
                      : { id: _fallthroughId4, implicit: false }
                });
                if (_fallthroughId4 !== null) {
                  this.visitBlock(
                    this.cx.ir.blocks.get(_fallthroughId4),
                    blockValue
                  );
                }
                break;
              }
              case "for": {
                var _loopId2 =
                  !this.cx.isScheduled(terminal.loop) &&
                  terminal.loop !== terminal.fallthrough
                    ? terminal.loop
                    : null;
                var _fallthroughId5 = !this.cx.isScheduled(terminal.fallthrough)
                  ? terminal.fallthrough
                  : null;
                var _scheduleId5 = this.cx.scheduleLoop(
                  terminal.fallthrough,
                  (_a = terminal.update) !== null && _a !== void 0
                    ? _a
                    : terminal.test,
                  terminal.loop
                );
                scheduleIds.push(_scheduleId5);
                var init = this.visitValueBlock(terminal.init, terminal.loc);
                var initBlock = this.cx.ir.blocks.get(init.block);
                var initValue = init.value;
                if (initValue.kind === "SequenceExpression") {
                  var _last2 = initBlock.instructions.at(-1);
                  initValue.instructions.push(_last2);
                  initValue.value = {
                    kind: "Primitive",
                    value: undefined,
                    loc: terminal.loc
                  };
                } else {
                  initValue = {
                    kind: "SequenceExpression",
                    instructions: [initBlock.instructions.at(-1)],
                    id: terminal.id,
                    loc: terminal.loc,
                    value: {
                      kind: "Primitive",
                      value: undefined,
                      loc: terminal.loc
                    }
                  };
                }
                var _testValue2 = this.visitValueBlock(
                  terminal.test,
                  terminal.loc
                ).value;
                var updateValue =
                  terminal.update !== null
                    ? this.visitValueBlock(terminal.update, terminal.loc).value
                    : null;
                var _loopBody2;
                if (_loopId2) {
                  _loopBody2 = this.traverseBlock(
                    this.cx.ir.blocks.get(_loopId2)
                  );
                } else {
                  CompilerError.invariant(false, {
                    reason:
                      "Unexpected 'for' where the loop is already scheduled",
                    loc: terminal.loc
                  });
                }
                this.cx.unscheduleAll(scheduleIds);
                blockValue.push({
                  kind: "terminal",
                  terminal: {
                    kind: "for",
                    loc: terminal.loc,
                    init: initValue,
                    test: _testValue2,
                    update: updateValue,
                    loop: _loopBody2,
                    id: terminal.id
                  },
                  label:
                    _fallthroughId5 == null
                      ? null
                      : { id: _fallthroughId5, implicit: false }
                });
                if (_fallthroughId5 !== null) {
                  this.visitBlock(
                    this.cx.ir.blocks.get(_fallthroughId5),
                    blockValue
                  );
                }
                break;
              }
              case "for-of": {
                var _loopId3 =
                  !this.cx.isScheduled(terminal.loop) &&
                  terminal.loop !== terminal.fallthrough
                    ? terminal.loop
                    : null;
                var _fallthroughId6 = !this.cx.isScheduled(terminal.fallthrough)
                  ? terminal.fallthrough
                  : null;
                var _scheduleId6 = this.cx.scheduleLoop(
                  terminal.fallthrough,
                  terminal.init,
                  terminal.loop
                );
                scheduleIds.push(_scheduleId6);
                var _init5 = this.visitValueBlock(terminal.init, terminal.loc);
                var _initBlock3 = this.cx.ir.blocks.get(_init5.block);
                var _initValue = _init5.value;
                if (_initValue.kind === "SequenceExpression") {
                  var _last3 = _initBlock3.instructions.at(-1);
                  _initValue.instructions.push(_last3);
                  _initValue.value = {
                    kind: "Primitive",
                    value: undefined,
                    loc: terminal.loc
                  };
                } else {
                  _initValue = {
                    kind: "SequenceExpression",
                    instructions: [_initBlock3.instructions.at(-1)],
                    id: terminal.id,
                    loc: terminal.loc,
                    value: {
                      kind: "Primitive",
                      value: undefined,
                      loc: terminal.loc
                    }
                  };
                }
                var _test22 = this.visitValueBlock(terminal.test, terminal.loc);
                var testBlock = this.cx.ir.blocks.get(_test22.block);
                var _testValue3 = _test22.value;
                if (_testValue3.kind === "SequenceExpression") {
                  var _last4 = testBlock.instructions.at(-1);
                  _testValue3.instructions.push(_last4);
                  _testValue3.value = {
                    kind: "Primitive",
                    value: undefined,
                    loc: terminal.loc
                  };
                } else {
                  _testValue3 = {
                    kind: "SequenceExpression",
                    instructions: [testBlock.instructions.at(-1)],
                    id: terminal.id,
                    loc: terminal.loc,
                    value: {
                      kind: "Primitive",
                      value: undefined,
                      loc: terminal.loc
                    }
                  };
                }
                var _loopBody3;
                if (_loopId3) {
                  _loopBody3 = this.traverseBlock(
                    this.cx.ir.blocks.get(_loopId3)
                  );
                } else {
                  CompilerError.invariant(false, {
                    reason:
                      "Unexpected 'for-of' where the loop is already scheduled",
                    loc: terminal.loc
                  });
                }
                this.cx.unscheduleAll(scheduleIds);
                blockValue.push({
                  kind: "terminal",
                  terminal: {
                    kind: "for-of",
                    loc: terminal.loc,
                    init: _initValue,
                    test: _testValue3,
                    loop: _loopBody3,
                    id: terminal.id
                  },
                  label:
                    _fallthroughId6 == null
                      ? null
                      : { id: _fallthroughId6, implicit: false }
                });
                if (_fallthroughId6 !== null) {
                  this.visitBlock(
                    this.cx.ir.blocks.get(_fallthroughId6),
                    blockValue
                  );
                }
                break;
              }
              case "for-in": {
                var _loopId4 =
                  !this.cx.isScheduled(terminal.loop) &&
                  terminal.loop !== terminal.fallthrough
                    ? terminal.loop
                    : null;
                var _fallthroughId7 = !this.cx.isScheduled(terminal.fallthrough)
                  ? terminal.fallthrough
                  : null;
                var _scheduleId7 = this.cx.scheduleLoop(
                  terminal.fallthrough,
                  terminal.init,
                  terminal.loop
                );
                scheduleIds.push(_scheduleId7);
                var _init6 = this.visitValueBlock(terminal.init, terminal.loc);
                var _initBlock4 = this.cx.ir.blocks.get(_init6.block);
                var _initValue2 = _init6.value;
                if (_initValue2.kind === "SequenceExpression") {
                  var _last5 = _initBlock4.instructions.at(-1);
                  _initValue2.instructions.push(_last5);
                  _initValue2.value = {
                    kind: "Primitive",
                    value: undefined,
                    loc: terminal.loc
                  };
                } else {
                  _initValue2 = {
                    kind: "SequenceExpression",
                    instructions: [_initBlock4.instructions.at(-1)],
                    id: terminal.id,
                    loc: terminal.loc,
                    value: {
                      kind: "Primitive",
                      value: undefined,
                      loc: terminal.loc
                    }
                  };
                }
                var _loopBody4;
                if (_loopId4) {
                  _loopBody4 = this.traverseBlock(
                    this.cx.ir.blocks.get(_loopId4)
                  );
                } else {
                  CompilerError.invariant(false, {
                    reason:
                      "Unexpected 'for-in' where the loop is already scheduled",
                    loc: terminal.loc
                  });
                }
                this.cx.unscheduleAll(scheduleIds);
                blockValue.push({
                  kind: "terminal",
                  terminal: {
                    kind: "for-in",
                    loc: terminal.loc,
                    init: _initValue2,
                    loop: _loopBody4,
                    id: terminal.id
                  },
                  label:
                    _fallthroughId7 == null
                      ? null
                      : { id: _fallthroughId7, implicit: false }
                });
                if (_fallthroughId7 !== null) {
                  this.visitBlock(
                    this.cx.ir.blocks.get(_fallthroughId7),
                    blockValue
                  );
                }
                break;
              }
              case "branch": {
                var _consequent2 = null;
                if (this.cx.isScheduled(terminal.consequent)) {
                  var break_ = this.visitBreak(
                    terminal.consequent,
                    terminal.id,
                    terminal.loc
                  );
                  if (break_ !== null) {
                    _consequent2 = [break_];
                  }
                } else {
                  _consequent2 = this.traverseBlock(
                    this.cx.ir.blocks.get(terminal.consequent)
                  );
                }
                var _alternate2 = null;
                if (this.cx.isScheduled(terminal.alternate)) {
                  CompilerError.invariant(false, {
                    reason:
                      "Unexpected 'branch' where the alternate is already scheduled",
                    loc: terminal.loc
                  });
                } else {
                  _alternate2 = this.traverseBlock(
                    this.cx.ir.blocks.get(terminal.alternate)
                  );
                }
                blockValue.push({
                  kind: "terminal",
                  terminal: {
                    kind: "if",
                    loc: terminal.loc,
                    test: terminal.test,
                    consequent:
                      _consequent2 !== null && _consequent2 !== void 0
                        ? _consequent2
                        : this.emptyBlock(),
                    alternate: _alternate2,
                    id: terminal.id
                  },
                  label: null
                });
                break;
              }
              case "label": {
                var _fallthroughId8 =
                  this.cx.reachable(terminal.fallthrough) &&
                  !this.cx.isScheduled(terminal.fallthrough)
                    ? terminal.fallthrough
                    : null;
                if (_fallthroughId8 !== null) {
                  var _scheduleId8 = this.cx.schedule(_fallthroughId8, "if");
                  scheduleIds.push(_scheduleId8);
                }
                var _block11;
                if (this.cx.isScheduled(terminal.block)) {
                  CompilerError.invariant(false, {
                    reason:
                      "Unexpected 'label' where the block is already scheduled",
                    loc: terminal.loc
                  });
                } else {
                  _block11 = this.traverseBlock(
                    this.cx.ir.blocks.get(terminal.block)
                  );
                }
                this.cx.unscheduleAll(scheduleIds);
                blockValue.push({
                  kind: "terminal",
                  terminal: {
                    kind: "label",
                    loc: terminal.loc,
                    block: _block11,
                    id: terminal.id
                  },
                  label:
                    _fallthroughId8 == null
                      ? null
                      : { id: _fallthroughId8, implicit: false }
                });
                if (_fallthroughId8 !== null) {
                  this.visitBlock(
                    this.cx.ir.blocks.get(_fallthroughId8),
                    blockValue
                  );
                }
                break;
              }
              case "sequence":
              case "optional":
              case "ternary":
              case "logical": {
                var _fallthroughId9 =
                  terminal.fallthrough !== null &&
                  !this.cx.isScheduled(terminal.fallthrough)
                    ? terminal.fallthrough
                    : null;
                if (_fallthroughId9 !== null) {
                  var _scheduleId9 = this.cx.schedule(_fallthroughId9, "if");
                  scheduleIds.push(_scheduleId9);
                }
                var _this$visitValueBlock =
                    this.visitValueBlockTerminal(terminal),
                  place = _this$visitValueBlock.place,
                  value = _this$visitValueBlock.value;
                this.cx.unscheduleAll(scheduleIds);
                blockValue.push({
                  kind: "instruction",
                  instruction: {
                    id: terminal.id,
                    lvalue: place,
                    value: value,
                    loc: terminal.loc
                  }
                });
                if (_fallthroughId9 !== null) {
                  this.visitBlock(
                    this.cx.ir.blocks.get(_fallthroughId9),
                    blockValue
                  );
                }
                break;
              }
              case "goto": {
                switch (terminal.variant) {
                  case GotoVariant.Break: {
                    var _break_ = this.visitBreak(
                      terminal.block,
                      terminal.id,
                      terminal.loc
                    );
                    if (_break_ !== null) {
                      blockValue.push(_break_);
                    }
                    break;
                  }
                  case GotoVariant.Continue: {
                    var continue_ = this.visitContinue(
                      terminal.block,
                      terminal.id,
                      terminal.loc
                    );
                    if (continue_ !== null) {
                      blockValue.push(continue_);
                    }
                    break;
                  }
                  case GotoVariant.Try: {
                    break;
                  }
                  default: {
                    assertExhaustive$1(
                      terminal.variant,
                      "Unexpected goto variant `".concat(terminal.variant, "`")
                    );
                  }
                }
                break;
              }
              case "maybe-throw": {
                if (!this.cx.isScheduled(terminal.continuation)) {
                  this.visitBlock(
                    this.cx.ir.blocks.get(terminal.continuation),
                    blockValue
                  );
                }
                break;
              }
              case "try": {
                var _fallthroughId10 =
                  this.cx.reachable(terminal.fallthrough) &&
                  !this.cx.isScheduled(terminal.fallthrough)
                    ? terminal.fallthrough
                    : null;
                if (_fallthroughId10 !== null) {
                  var _scheduleId10 = this.cx.schedule(_fallthroughId10, "if");
                  scheduleIds.push(_scheduleId10);
                }
                this.cx.scheduleCatchHandler(terminal.handler);
                var _block12 = this.traverseBlock(
                  this.cx.ir.blocks.get(terminal.block)
                );
                var handler = this.traverseBlock(
                  this.cx.ir.blocks.get(terminal.handler)
                );
                this.cx.unscheduleAll(scheduleIds);
                blockValue.push({
                  kind: "terminal",
                  label:
                    _fallthroughId10 == null
                      ? null
                      : { id: _fallthroughId10, implicit: false },
                  terminal: {
                    kind: "try",
                    loc: terminal.loc,
                    block: _block12,
                    handlerBinding: terminal.handlerBinding,
                    handler: handler,
                    id: terminal.id
                  }
                });
                if (_fallthroughId10 !== null) {
                  this.visitBlock(
                    this.cx.ir.blocks.get(_fallthroughId10),
                    blockValue
                  );
                }
                break;
              }
              case "pruned-scope":
              case "scope": {
                var _fallthroughId11 = !this.cx.isScheduled(
                  terminal.fallthrough
                )
                  ? terminal.fallthrough
                  : null;
                if (_fallthroughId11 !== null) {
                  var _scheduleId11 = this.cx.schedule(_fallthroughId11, "if");
                  scheduleIds.push(_scheduleId11);
                  this.cx.scopeFallthroughs.add(_fallthroughId11);
                }
                var _block13;
                if (this.cx.isScheduled(terminal.block)) {
                  CompilerError.invariant(false, {
                    reason:
                      "Unexpected 'scope' where the block is already scheduled",
                    loc: terminal.loc
                  });
                } else {
                  _block13 = this.traverseBlock(
                    this.cx.ir.blocks.get(terminal.block)
                  );
                }
                this.cx.unscheduleAll(scheduleIds);
                blockValue.push({
                  kind: terminal.kind,
                  instructions: _block13,
                  scope: terminal.scope
                });
                if (_fallthroughId11 !== null) {
                  this.visitBlock(
                    this.cx.ir.blocks.get(_fallthroughId11),
                    blockValue
                  );
                }
                break;
              }
              case "unreachable": {
                break;
              }
              case "unsupported": {
                CompilerError.invariant(false, {
                  reason: "Unexpected unsupported terminal",
                  description: null,
                  loc: terminal.loc,
                  suggestions: null
                });
              }
              default: {
                assertExhaustive$1(terminal, "Unexpected terminal");
              }
            }
          }
        },
        {
          key: "visitValueBlock",
          value: function visitValueBlock(id, loc) {
            var defaultBlock = this.cx.ir.blocks.get(id);
            if (defaultBlock.terminal.kind === "branch") {
              var instructions = defaultBlock.instructions;
              if (instructions.length === 0) {
                return {
                  block: defaultBlock.id,
                  place: defaultBlock.terminal.test,
                  value: {
                    kind: "LoadLocal",
                    place: defaultBlock.terminal.test,
                    loc: defaultBlock.terminal.test.loc
                  },
                  id: defaultBlock.terminal.id
                };
              } else if (defaultBlock.instructions.length === 1) {
                var instr = defaultBlock.instructions[0];
                CompilerError.invariant(
                  instr.lvalue.identifier.id ===
                    defaultBlock.terminal.test.identifier.id,
                  {
                    reason:
                      "Expected branch block to end in an instruction that sets the test value",
                    description: null,
                    loc: instr.lvalue.loc,
                    suggestions: null
                  }
                );
                return {
                  block: defaultBlock.id,
                  place: instr.lvalue,
                  value: instr.value,
                  id: instr.id
                };
              } else {
                var _instr3 = defaultBlock.instructions.at(-1);
                var sequence = {
                  kind: "SequenceExpression",
                  instructions: defaultBlock.instructions.slice(0, -1),
                  id: _instr3.id,
                  value: _instr3.value,
                  loc: loc
                };
                return {
                  block: defaultBlock.id,
                  place: defaultBlock.terminal.test,
                  value: sequence,
                  id: defaultBlock.terminal.id
                };
              }
            } else if (defaultBlock.terminal.kind === "goto") {
              var _instructions = defaultBlock.instructions;
              if (_instructions.length === 0) {
                CompilerError.invariant(false, {
                  reason:
                    "Expected goto value block to have at least one instruction",
                  description: null,
                  loc: null,
                  suggestions: null
                });
              } else if (defaultBlock.instructions.length === 1) {
                var _instr4 = defaultBlock.instructions[0];
                var place = _instr4.lvalue;
                var value = _instr4.value;
                if (
                  value.kind === "StoreLocal" &&
                  value.lvalue.place.identifier.name === null
                ) {
                  place = value.lvalue.place;
                  value = {
                    kind: "LoadLocal",
                    place: value.value,
                    loc: value.value.loc
                  };
                }
                return {
                  block: defaultBlock.id,
                  place: place,
                  value: value,
                  id: _instr4.id
                };
              } else {
                var _instr5 = defaultBlock.instructions.at(-1);
                var _place22 = _instr5.lvalue;
                var _value18 = _instr5.value;
                if (
                  _value18.kind === "StoreLocal" &&
                  _value18.lvalue.place.identifier.name === null
                ) {
                  _place22 = _value18.lvalue.place;
                  _value18 = {
                    kind: "LoadLocal",
                    place: _value18.value,
                    loc: _value18.value.loc
                  };
                }
                var _sequence = {
                  kind: "SequenceExpression",
                  instructions: defaultBlock.instructions.slice(0, -1),
                  id: _instr5.id,
                  value: _value18,
                  loc: loc
                };
                return {
                  block: defaultBlock.id,
                  place: _place22,
                  value: _sequence,
                  id: _instr5.id
                };
              }
            } else {
              var init = this.visitValueBlockTerminal(defaultBlock.terminal);
              var _final = this.visitValueBlock(init.fallthrough, loc);
              var _sequence2 = {
                kind: "SequenceExpression",
                instructions: [].concat(
                  _toConsumableArray(defaultBlock.instructions),
                  [
                    {
                      id: init.id,
                      loc: loc,
                      lvalue: init.place,
                      value: init.value
                    }
                  ]
                ),
                id: _final.id,
                value: _final.value,
                loc: loc
              };
              return {
                block: init.fallthrough,
                value: _sequence2,
                place: _final.place,
                id: _final.id
              };
            }
          }
        },
        {
          key: "visitValueBlockTerminal",
          value: function visitValueBlockTerminal(terminal) {
            switch (terminal.kind) {
              case "sequence": {
                var block = this.visitValueBlock(terminal.block, terminal.loc);
                return {
                  value: block.value,
                  place: block.place,
                  fallthrough: terminal.fallthrough,
                  id: terminal.id
                };
              }
              case "optional": {
                var _test23 = this.visitValueBlock(terminal.test, terminal.loc);
                var testBlock = this.cx.ir.blocks.get(_test23.block);
                if (testBlock.terminal.kind !== "branch") {
                  CompilerError.throwTodo({
                    reason: "Unexpected terminal kind `".concat(
                      testBlock.terminal.kind,
                      "` for optional test block"
                    ),
                    description: null,
                    loc: testBlock.terminal.loc,
                    suggestions: null
                  });
                }
                var consequent = this.visitValueBlock(
                  testBlock.terminal.consequent,
                  terminal.loc
                );
                var call = {
                  kind: "SequenceExpression",
                  instructions: [
                    {
                      id: _test23.id,
                      loc: testBlock.terminal.loc,
                      lvalue: _test23.place,
                      value: _test23.value
                    }
                  ],
                  id: consequent.id,
                  value: consequent.value,
                  loc: terminal.loc
                };
                return {
                  place: Object.assign({}, consequent.place),
                  value: {
                    kind: "OptionalExpression",
                    optional: terminal.optional,
                    value: call,
                    id: terminal.id,
                    loc: terminal.loc
                  },
                  fallthrough: terminal.fallthrough,
                  id: terminal.id
                };
              }
              case "logical": {
                var _test24 = this.visitValueBlock(terminal.test, terminal.loc);
                var _testBlock3 = this.cx.ir.blocks.get(_test24.block);
                if (_testBlock3.terminal.kind !== "branch") {
                  CompilerError.throwTodo({
                    reason: "Unexpected terminal kind `".concat(
                      _testBlock3.terminal.kind,
                      "` for logical test block"
                    ),
                    description: null,
                    loc: _testBlock3.terminal.loc,
                    suggestions: null
                  });
                }
                var leftFinal = this.visitValueBlock(
                  _testBlock3.terminal.consequent,
                  terminal.loc
                );
                var left = {
                  kind: "SequenceExpression",
                  instructions: [
                    {
                      id: _test24.id,
                      loc: terminal.loc,
                      lvalue: _test24.place,
                      value: _test24.value
                    }
                  ],
                  id: leftFinal.id,
                  value: leftFinal.value,
                  loc: terminal.loc
                };
                var right = this.visitValueBlock(
                  _testBlock3.terminal.alternate,
                  terminal.loc
                );
                var value = {
                  kind: "LogicalExpression",
                  operator: terminal.operator,
                  left: left,
                  right: right.value,
                  loc: terminal.loc
                };
                return {
                  place: Object.assign({}, leftFinal.place),
                  value: value,
                  fallthrough: terminal.fallthrough,
                  id: terminal.id
                };
              }
              case "ternary": {
                var _test25 = this.visitValueBlock(terminal.test, terminal.loc);
                var _testBlock4 = this.cx.ir.blocks.get(_test25.block);
                if (_testBlock4.terminal.kind !== "branch") {
                  CompilerError.throwTodo({
                    reason: "Unexpected terminal kind `".concat(
                      _testBlock4.terminal.kind,
                      "` for ternary test block"
                    ),
                    description: null,
                    loc: _testBlock4.terminal.loc,
                    suggestions: null
                  });
                }
                var _consequent3 = this.visitValueBlock(
                  _testBlock4.terminal.consequent,
                  terminal.loc
                );
                var alternate = this.visitValueBlock(
                  _testBlock4.terminal.alternate,
                  terminal.loc
                );
                var _value19 = {
                  kind: "ConditionalExpression",
                  test: _test25.value,
                  consequent: _consequent3.value,
                  alternate: alternate.value,
                  loc: terminal.loc
                };
                return {
                  place: Object.assign({}, _consequent3.place),
                  value: _value19,
                  fallthrough: terminal.fallthrough,
                  id: terminal.id
                };
              }
              case "maybe-throw": {
                CompilerError.throwTodo({
                  reason:
                    "Support value blocks (conditional, logical, optional chaining, etc) within a try/catch statement",
                  description: null,
                  loc: terminal.loc,
                  suggestions: null
                });
              }
              case "label": {
                CompilerError.throwTodo({
                  reason:
                    "Support labeled statements combined with value blocks (conditional, logical, optional chaining, etc)",
                  description: null,
                  loc: terminal.loc,
                  suggestions: null
                });
              }
              default: {
                CompilerError.throwTodo({
                  reason: "Support `".concat(
                    terminal.kind,
                    "` as a value block terminal (conditional, logical, optional chaining, etc)"
                  ),
                  description: null,
                  loc: terminal.loc,
                  suggestions: null
                });
              }
            }
          }
        },
        {
          key: "emptyBlock",
          value: function emptyBlock() {
            return [];
          }
        },
        {
          key: "visitBreak",
          value: function visitBreak(block, id, loc) {
            var target = this.cx.getBreakTarget(block);
            if (target === null) {
              CompilerError.invariant(false, {
                reason: "Expected a break target",
                description: null,
                loc: null,
                suggestions: null
              });
            }
            if (this.cx.scopeFallthroughs.has(target.block)) {
              CompilerError.invariant(target.type === "implicit", {
                reason:
                  "Expected reactive scope to implicitly break to fallthrough",
                loc: loc
              });
              return null;
            }
            return {
              kind: "terminal",
              terminal: {
                kind: "break",
                loc: loc,
                target: target.block,
                id: id,
                targetKind: target.type
              },
              label: null
            };
          }
        },
        {
          key: "visitContinue",
          value: function visitContinue(block, id, loc) {
            var target = this.cx.getContinueTarget(block);
            CompilerError.invariant(target !== null, {
              reason: "Expected continue target to be scheduled for bb".concat(
                block
              ),
              description: null,
              loc: null,
              suggestions: null
            });
            return {
              kind: "terminal",
              terminal: {
                kind: "continue",
                loc: loc,
                target: target.block,
                id: id,
                targetKind: target.type
              },
              label: null
            };
          }
        }
      ]);
    })();
    var Context$3 = /*#__PURE__*/ (function () {
      function Context(ir) {
        _classCallCheck(this, Context);
        _Context_nextScheduleId.set(this, 0);
        this.emitted = new Set();
        this.scopeFallthroughs = new Set();
        _Context_scheduled.set(this, new Set());
        _Context_catchHandlers.set(this, new Set());
        _Context_controlFlowStack.set(this, []);
        this.ir = ir;
      }
      return _createClass(Context, [
        {
          key: "block",
          value: function block(id) {
            return this.ir.blocks.get(id);
          }
        },
        {
          key: "scheduleCatchHandler",
          value: function scheduleCatchHandler(block) {
            __classPrivateFieldGet(this, _Context_catchHandlers, "f").add(
              block
            );
          }
        },
        {
          key: "reachable",
          value: function reachable(id) {
            var block = this.ir.blocks.get(id);
            return block.terminal.kind !== "unreachable";
          }
        },
        {
          key: "schedule",
          value: function schedule(block, type) {
            var _a, _b;
            var id =
              (__classPrivateFieldSet(
                this,
                _Context_nextScheduleId,
                ((_b = __classPrivateFieldGet(
                  this,
                  _Context_nextScheduleId,
                  "f"
                )),
                (_a = _b++),
                _b),
                "f"
              ),
              _a);
            CompilerError.invariant(
              !__classPrivateFieldGet(this, _Context_scheduled, "f").has(block),
              {
                reason: "Break block is already scheduled: bb".concat(block),
                description: null,
                loc: null,
                suggestions: null
              }
            );
            __classPrivateFieldGet(this, _Context_scheduled, "f").add(block);
            __classPrivateFieldGet(this, _Context_controlFlowStack, "f").push({
              block: block,
              id: id,
              type: type
            });
            return id;
          }
        },
        {
          key: "scheduleLoop",
          value: function scheduleLoop(
            fallthroughBlock,
            continueBlock,
            loopBlock
          ) {
            var _a, _b;
            var id =
              (__classPrivateFieldSet(
                this,
                _Context_nextScheduleId,
                ((_b = __classPrivateFieldGet(
                  this,
                  _Context_nextScheduleId,
                  "f"
                )),
                (_a = _b++),
                _b),
                "f"
              ),
              _a);
            var ownsBlock = !__classPrivateFieldGet(
              this,
              _Context_scheduled,
              "f"
            ).has(fallthroughBlock);
            __classPrivateFieldGet(this, _Context_scheduled, "f").add(
              fallthroughBlock
            );
            CompilerError.invariant(
              !__classPrivateFieldGet(this, _Context_scheduled, "f").has(
                continueBlock
              ),
              {
                reason: "Continue block is already scheduled: bb".concat(
                  continueBlock
                ),
                description: null,
                loc: null,
                suggestions: null
              }
            );
            __classPrivateFieldGet(this, _Context_scheduled, "f").add(
              continueBlock
            );
            var ownsLoop = false;
            if (loopBlock !== null) {
              ownsLoop = !__classPrivateFieldGet(
                this,
                _Context_scheduled,
                "f"
              ).has(loopBlock);
              __classPrivateFieldGet(this, _Context_scheduled, "f").add(
                loopBlock
              );
            }
            __classPrivateFieldGet(this, _Context_controlFlowStack, "f").push({
              block: fallthroughBlock,
              ownsBlock: ownsBlock,
              id: id,
              type: "loop",
              continueBlock: continueBlock,
              loopBlock: loopBlock,
              ownsLoop: ownsLoop
            });
            return id;
          }
        },
        {
          key: "unschedule",
          value: function unschedule(scheduleId) {
            var last = __classPrivateFieldGet(
              this,
              _Context_controlFlowStack,
              "f"
            ).pop();
            CompilerError.invariant(
              last !== undefined && last.id === scheduleId,
              {
                reason: "Can only unschedule the last target",
                description: null,
                loc: null,
                suggestions: null
              }
            );
            if (last.type !== "loop" || last.ownsBlock !== null) {
              __classPrivateFieldGet(this, _Context_scheduled, "f")["delete"](
                last.block
              );
            }
            if (last.type === "loop") {
              __classPrivateFieldGet(this, _Context_scheduled, "f")["delete"](
                last.continueBlock
              );
              if (last.ownsLoop && last.loopBlock !== null) {
                __classPrivateFieldGet(this, _Context_scheduled, "f")["delete"](
                  last.loopBlock
                );
              }
            }
          }
        },
        {
          key: "unscheduleAll",
          value: function unscheduleAll(scheduleIds) {
            for (var i = scheduleIds.length - 1; i >= 0; i--) {
              this.unschedule(scheduleIds[i]);
            }
          }
        },
        {
          key: "isScheduled",
          value: function isScheduled(block) {
            return (
              __classPrivateFieldGet(this, _Context_scheduled, "f").has(
                block
              ) ||
              __classPrivateFieldGet(this, _Context_catchHandlers, "f").has(
                block
              )
            );
          }
        },
        {
          key: "getBreakTarget",
          value: function getBreakTarget(block) {
            var hasPrecedingLoop = false;
            for (
              var i =
                __classPrivateFieldGet(this, _Context_controlFlowStack, "f")
                  .length - 1;
              i >= 0;
              i--
            ) {
              var target = __classPrivateFieldGet(
                this,
                _Context_controlFlowStack,
                "f"
              )[i];
              if (target.block === block) {
                var type = void 0;
                if (target.type === "loop") {
                  type = hasPrecedingLoop ? "labeled" : "unlabeled";
                } else if (
                  i ===
                  __classPrivateFieldGet(this, _Context_controlFlowStack, "f")
                    .length -
                    1
                ) {
                  type = "implicit";
                } else {
                  type = "labeled";
                }
                return { block: target.block, type: type };
              }
              hasPrecedingLoop || (hasPrecedingLoop = target.type === "loop");
            }
            CompilerError.invariant(false, {
              reason: "Expected a break target",
              description: null,
              loc: null,
              suggestions: null
            });
          }
        },
        {
          key: "getContinueTarget",
          value: function getContinueTarget(block) {
            var hasPrecedingLoop = false;
            for (
              var i =
                __classPrivateFieldGet(this, _Context_controlFlowStack, "f")
                  .length - 1;
              i >= 0;
              i--
            ) {
              var target = __classPrivateFieldGet(
                this,
                _Context_controlFlowStack,
                "f"
              )[i];
              if (target.type == "loop" && target.continueBlock === block) {
                var type = void 0;
                if (hasPrecedingLoop) {
                  type = "labeled";
                } else if (
                  i ===
                  __classPrivateFieldGet(this, _Context_controlFlowStack, "f")
                    .length -
                    1
                ) {
                  type = "implicit";
                } else {
                  type = "unlabeled";
                }
                return { block: target.block, type: type };
              }
              hasPrecedingLoop || (hasPrecedingLoop = target.type === "loop");
            }
            return null;
          }
        },
        {
          key: "debugBreakTargets",
          value: function debugBreakTargets() {
            return __classPrivateFieldGet(
              this,
              _Context_controlFlowStack,
              "f"
            ).map(function (target) {
              return Object.assign({}, target);
            });
          }
        }
      ]);
    })();
    (_Context_nextScheduleId = new WeakMap()),
      (_Context_scheduled = new WeakMap()),
      (_Context_catchHandlers = new WeakMap()),
      (_Context_controlFlowStack = new WeakMap());
    var GuardKind;
    (function (GuardKind) {
      GuardKind[(GuardKind["PushHookGuard"] = 0)] = "PushHookGuard";
      GuardKind[(GuardKind["PopHookGuard"] = 1)] = "PopHookGuard";
      GuardKind[(GuardKind["AllowHook"] = 2)] = "AllowHook";
      GuardKind[(GuardKind["DisallowHook"] = 3)] = "DisallowHook";
    })(GuardKind || (GuardKind = {}));
    function memoizeFbtAndMacroOperandsInSameScope(fn) {
      var _a;
      var fbtMacroTags = new Set(
        [].concat(
          _toConsumableArray(
            Array.from(FBT_TAGS).map(function (tag) {
              return [tag, []];
            })
          ),
          _toConsumableArray(
            (_a = fn.env.config.customMacros) !== null && _a !== void 0
              ? _a
              : []
          )
        )
      );
      var fbtValues = new Set();
      var macroMethods = new Map();
      while (true) {
        var vsize = fbtValues.size;
        var msize = macroMethods.size;
        visit$1(fn, fbtMacroTags, fbtValues, macroMethods);
        if (vsize === fbtValues.size && msize === macroMethods.size) {
          break;
        }
      }
      return fbtValues;
    }
    var FBT_TAGS = new Set(["fbt", "fbt:param", "fbs", "fbs:param"]);
    var SINGLE_CHILD_FBT_TAGS = new Set(["fbt:param", "fbs:param"]);
    function visit$1(fn, fbtMacroTags, fbtValues, macroMethods) {
      var _iterator240 = _createForOfIteratorHelper(fn.body.blocks),
        _step240;
      try {
        for (_iterator240.s(); !(_step240 = _iterator240.n()).done; ) {
          var _step240$value = _slicedToArray(_step240.value, 2),
            block = _step240$value[1];
          var _iterator241 = _createForOfIteratorHelper(block.instructions),
            _step241;
          try {
            for (_iterator241.s(); !(_step241 = _iterator241.n()).done; ) {
              var instruction = _step241.value;
              var lvalue = instruction.lvalue,
                value = instruction.value;
              if (lvalue === null) {
                continue;
              }
              if (
                value.kind === "Primitive" &&
                typeof value.value === "string" &&
                matchesExactTag(value.value, fbtMacroTags)
              ) {
                fbtValues.add(lvalue.identifier.id);
              } else if (
                value.kind === "LoadGlobal" &&
                matchesExactTag(value.binding.name, fbtMacroTags)
              ) {
                fbtValues.add(lvalue.identifier.id);
              } else if (
                value.kind === "LoadGlobal" &&
                matchTagRoot(value.binding.name, fbtMacroTags) !== null
              ) {
                var _methods2 = matchTagRoot(value.binding.name, fbtMacroTags);
                macroMethods.set(lvalue.identifier.id, _methods2);
              } else if (
                value.kind === "PropertyLoad" &&
                macroMethods.has(value.object.identifier.id)
              ) {
                var _methods3 = macroMethods.get(value.object.identifier.id);
                var newMethods = [];
                var _iterator242 = _createForOfIteratorHelper(_methods3),
                  _step242;
                try {
                  for (
                    _iterator242.s();
                    !(_step242 = _iterator242.n()).done;

                  ) {
                    var method = _step242.value;
                    if (
                      method.length > 0 &&
                      (method[0].type === "wildcard" ||
                        (method[0].type === "name" &&
                          method[0].name === value.property))
                    ) {
                      if (method.length > 1) {
                        newMethods.push(method.slice(1));
                      } else {
                        fbtValues.add(lvalue.identifier.id);
                      }
                    }
                  }
                } catch (err) {
                  _iterator242.e(err);
                } finally {
                  _iterator242.f();
                }
                if (newMethods.length > 0) {
                  macroMethods.set(lvalue.identifier.id, newMethods);
                }
              } else if (isFbtCallExpression(fbtValues, value)) {
                var fbtScope = lvalue.identifier.scope;
                if (fbtScope === null) {
                  continue;
                }
                var _iterator243 = _createForOfIteratorHelper(
                    eachReactiveValueOperand(value)
                  ),
                  _step243;
                try {
                  for (
                    _iterator243.s();
                    !(_step243 = _iterator243.n()).done;

                  ) {
                    var operand = _step243.value;
                    operand.identifier.scope = fbtScope;
                    expandFbtScopeRange(
                      fbtScope.range,
                      operand.identifier.mutableRange
                    );
                    fbtValues.add(operand.identifier.id);
                  }
                } catch (err) {
                  _iterator243.e(err);
                } finally {
                  _iterator243.f();
                }
              } else if (
                isFbtJsxExpression(fbtMacroTags, fbtValues, value) ||
                isFbtJsxChild(fbtValues, lvalue, value)
              ) {
                var _fbtScope = lvalue.identifier.scope;
                if (_fbtScope === null) {
                  continue;
                }
                var _iterator244 = _createForOfIteratorHelper(
                    eachReactiveValueOperand(value)
                  ),
                  _step244;
                try {
                  for (
                    _iterator244.s();
                    !(_step244 = _iterator244.n()).done;

                  ) {
                    var _operand14 = _step244.value;
                    _operand14.identifier.scope = _fbtScope;
                    expandFbtScopeRange(
                      _fbtScope.range,
                      _operand14.identifier.mutableRange
                    );
                    fbtValues.add(_operand14.identifier.id);
                  }
                } catch (err) {
                  _iterator244.e(err);
                } finally {
                  _iterator244.f();
                }
              } else if (fbtValues.has(lvalue.identifier.id)) {
                var _fbtScope2 = lvalue.identifier.scope;
                if (_fbtScope2 === null) {
                  return;
                }
                var _iterator245 = _createForOfIteratorHelper(
                    eachReactiveValueOperand(value)
                  ),
                  _step245;
                try {
                  for (
                    _iterator245.s();
                    !(_step245 = _iterator245.n()).done;

                  ) {
                    var _operand15 = _step245.value;
                    if (
                      _operand15.identifier.name !== null &&
                      _operand15.identifier.name.kind === "named"
                    ) {
                      continue;
                    }
                    _operand15.identifier.scope = _fbtScope2;
                    expandFbtScopeRange(
                      _fbtScope2.range,
                      _operand15.identifier.mutableRange
                    );
                  }
                } catch (err) {
                  _iterator245.e(err);
                } finally {
                  _iterator245.f();
                }
              }
            }
          } catch (err) {
            _iterator241.e(err);
          } finally {
            _iterator241.f();
          }
        }
      } catch (err) {
        _iterator240.e(err);
      } finally {
        _iterator240.f();
      }
    }
    function matchesExactTag(s, tags) {
      return Array.from(tags).some(function (macro) {
        return typeof macro === "string"
          ? s === macro
          : macro[1].length === 0 && macro[0] === s;
      });
    }
    function matchTagRoot(s, tags) {
      var methods = [];
      var _iterator246 = _createForOfIteratorHelper(tags),
        _step246;
      try {
        for (_iterator246.s(); !(_step246 = _iterator246.n()).done; ) {
          var macro = _step246.value;
          if (typeof macro === "string") {
            continue;
          }
          var _macro = _slicedToArray(macro, 2),
            tag = _macro[0],
            rest = _macro[1];
          if (tag === s && rest.length > 0) {
            methods.push(rest);
          }
        }
      } catch (err) {
        _iterator246.e(err);
      } finally {
        _iterator246.f();
      }
      if (methods.length > 0) {
        return methods;
      } else {
        return null;
      }
    }
    function isFbtCallExpression(fbtValues, value) {
      return (
        (value.kind === "CallExpression" &&
          fbtValues.has(value.callee.identifier.id)) ||
        (value.kind === "MethodCall" &&
          fbtValues.has(value.property.identifier.id))
      );
    }
    function isFbtJsxExpression(fbtMacroTags, fbtValues, value) {
      return (
        value.kind === "JsxExpression" &&
        ((value.tag.kind === "Identifier" &&
          fbtValues.has(value.tag.identifier.id)) ||
          (value.tag.kind === "BuiltinTag" &&
            matchesExactTag(value.tag.name, fbtMacroTags)))
      );
    }
    function isFbtJsxChild(fbtValues, lvalue, value) {
      return (
        (value.kind === "JsxExpression" || value.kind === "JsxFragment") &&
        lvalue !== null &&
        fbtValues.has(lvalue.identifier.id)
      );
    }
    function expandFbtScopeRange(fbtRange, extendWith) {
      if (extendWith.start !== 0) {
        fbtRange.start = makeInstructionId(
          Math.min(fbtRange.start, extendWith.start)
        );
      }
    }
    var _Context_nextCacheIndex, _Context_declarations$1;
    var MEMO_CACHE_SENTINEL = "react.memo_cache_sentinel";
    var EARLY_RETURN_SENTINEL = "react.early_return_sentinel";
    function codegenFunction(fn, _ref32) {
      var uniqueIdentifiers = _ref32.uniqueIdentifiers,
        fbtOperands = _ref32.fbtOperands;
      var _a, _b, _c;
      var cx = new Context$2(
        fn.env,
        (_a = fn.id) !== null && _a !== void 0 ? _a : "[[ anonymous ]]",
        uniqueIdentifiers,
        fbtOperands,
        null
      );
      var fastRefreshState = null;
      if (
        fn.env.config.enableResetCacheOnSourceFileChanges &&
        fn.env.code !== null
      ) {
        var hash = crypto.createHmac("sha256", fn.env.code).digest("hex");
        fastRefreshState = { cacheIndex: cx.nextCacheIndex, hash: hash };
      }
      var compileResult = codegenReactiveFunction(cx, fn);
      if (compileResult.isErr()) {
        return compileResult;
      }
      var compiled = compileResult.unwrap();
      var hookGuard = fn.env.config.enableEmitHookGuards;
      if (hookGuard != null) {
        compiled.body = libExports.blockStatement([
          createHookGuard(
            hookGuard,
            compiled.body.body,
            GuardKind.PushHookGuard,
            GuardKind.PopHookGuard
          )
        ]);
      }
      var cacheCount = compiled.memoSlotsUsed;
      if (cacheCount !== 0) {
        var _compiled$body$body;
        var preface = [];
        preface.push(
          libExports.variableDeclaration("const", [
            libExports.variableDeclarator(
              libExports.identifier(cx.synthesizeName("$")),
              libExports.callExpression(
                libExports.identifier(fn.env.useMemoCacheIdentifier),
                [libExports.numericLiteral(cacheCount)]
              )
            )
          ])
        );
        if (fastRefreshState !== null) {
          var index = cx.synthesizeName("$i");
          preface.push(
            libExports.ifStatement(
              libExports.binaryExpression(
                "!==",
                libExports.memberExpression(
                  libExports.identifier(cx.synthesizeName("$")),
                  libExports.numericLiteral(fastRefreshState.cacheIndex),
                  true
                ),
                libExports.stringLiteral(fastRefreshState.hash)
              ),
              libExports.blockStatement([
                libExports.forStatement(
                  libExports.variableDeclaration("let", [
                    libExports.variableDeclarator(
                      libExports.identifier(index),
                      libExports.numericLiteral(0)
                    )
                  ]),
                  libExports.binaryExpression(
                    "<",
                    libExports.identifier(index),
                    libExports.numericLiteral(cacheCount)
                  ),
                  libExports.assignmentExpression(
                    "+=",
                    libExports.identifier(index),
                    libExports.numericLiteral(1)
                  ),
                  libExports.blockStatement([
                    libExports.expressionStatement(
                      libExports.assignmentExpression(
                        "=",
                        libExports.memberExpression(
                          libExports.identifier(cx.synthesizeName("$")),
                          libExports.identifier(index),
                          true
                        ),
                        libExports.callExpression(
                          libExports.memberExpression(
                            libExports.identifier("Symbol"),
                            libExports.identifier("for")
                          ),
                          [libExports.stringLiteral(MEMO_CACHE_SENTINEL)]
                        )
                      )
                    )
                  ])
                ),
                libExports.expressionStatement(
                  libExports.assignmentExpression(
                    "=",
                    libExports.memberExpression(
                      libExports.identifier(cx.synthesizeName("$")),
                      libExports.numericLiteral(fastRefreshState.cacheIndex),
                      true
                    ),
                    libExports.stringLiteral(fastRefreshState.hash)
                  )
                )
              ])
            )
          );
        }
        (_compiled$body$body = compiled.body.body).unshift.apply(
          _compiled$body$body,
          preface
        );
      }
      var emitInstrumentForget = fn.env.config.enableEmitInstrumentForget;
      if (emitInstrumentForget != null && fn.id != null) {
        var gating;
        if (
          emitInstrumentForget.gating != null &&
          emitInstrumentForget.globalGating != null
        ) {
          gating = libExports.logicalExpression(
            "&&",
            libExports.identifier(emitInstrumentForget.globalGating),
            libExports.identifier(
              emitInstrumentForget.gating.importSpecifierName
            )
          );
        } else if (emitInstrumentForget.gating != null) {
          gating = libExports.identifier(
            emitInstrumentForget.gating.importSpecifierName
          );
        } else {
          CompilerError.invariant(emitInstrumentForget.globalGating != null, {
            reason:
              "Bad config not caught! Expected at least one of gating or globalGating",
            loc: null,
            suggestions: null
          });
          gating = libExports.identifier(emitInstrumentForget.globalGating);
        }
        var _test26 = libExports.ifStatement(
          gating,
          libExports.expressionStatement(
            libExports.callExpression(
              libExports.identifier(
                emitInstrumentForget.fn.importSpecifierName
              ),
              [
                libExports.stringLiteral(fn.id),
                libExports.stringLiteral(
                  (_b = fn.env.filename) !== null && _b !== void 0 ? _b : ""
                )
              ]
            )
          )
        );
        compiled.body.body.unshift(_test26);
      }
      var outlined = [];
      var _iterator247 = _createForOfIteratorHelper(
          cx.env.getOutlinedFunctions()
        ),
        _step247;
      try {
        for (_iterator247.s(); !(_step247 = _iterator247.n()).done; ) {
          var _step247$value = _step247.value,
            outlinedFunction = _step247$value.fn,
            type = _step247$value.type;
          var reactiveFunction = buildReactiveFunction(outlinedFunction);
          pruneUnusedLabels(reactiveFunction);
          pruneUnusedLValues(reactiveFunction);
          pruneHoistedContexts(reactiveFunction);
          var identifiers = renameVariables(reactiveFunction);
          var codegen = codegenReactiveFunction(
            new Context$2(
              cx.env,
              (_c = reactiveFunction.id) !== null && _c !== void 0
                ? _c
                : "[[ anonymous ]]",
              identifiers,
              cx.fbtOperands
            ),
            reactiveFunction
          );
          if (codegen.isErr()) {
            return codegen;
          }
          outlined.push({ fn: codegen.unwrap(), type: type });
        }
      } catch (err) {
        _iterator247.e(err);
      } finally {
        _iterator247.f();
      }
      compiled.outlined = outlined;
      return compileResult;
    }
    function codegenReactiveFunction(cx, fn) {
      var _iterator248 = _createForOfIteratorHelper(fn.params),
        _step248;
      try {
        for (_iterator248.s(); !(_step248 = _iterator248.n()).done; ) {
          var param = _step248.value;
          if (param.kind === "Identifier") {
            cx.temp.set(param.identifier.declarationId, null);
          } else {
            cx.temp.set(param.place.identifier.declarationId, null);
          }
        }
      } catch (err) {
        _iterator248.e(err);
      } finally {
        _iterator248.f();
      }
      var params = fn.params.map(function (param) {
        return convertParameter(param);
      });
      var body = codegenBlock(cx, fn.body);
      body.directives = fn.directives.map(function (d) {
        return libExports.directive(libExports.directiveLiteral(d));
      });
      var statements = body.body;
      if (statements.length !== 0) {
        var _last6 = statements[statements.length - 1];
        if (_last6.type === "ReturnStatement" && _last6.argument == null) {
          statements.pop();
        }
      }
      if (cx.errors.hasErrors()) {
        return Err(cx.errors);
      }
      var countMemoBlockVisitor = new CountMemoBlockVisitor(fn.env);
      visitReactiveFunction(fn, countMemoBlockVisitor, undefined);
      return Ok({
        type: "CodegenFunction",
        loc: fn.loc,
        id: fn.id !== null ? libExports.identifier(fn.id) : null,
        params: params,
        body: body,
        generator: fn.generator,
        async: fn.async,
        memoSlotsUsed: cx.nextCacheIndex,
        memoBlocks: countMemoBlockVisitor.memoBlocks,
        memoValues: countMemoBlockVisitor.memoValues,
        prunedMemoBlocks: countMemoBlockVisitor.prunedMemoBlocks,
        prunedMemoValues: countMemoBlockVisitor.prunedMemoValues,
        outlined: [],
        hasLoweredContextAccess: fn.env.hasLoweredContextAccess,
        hasFireRewrite: fn.env.hasFireRewrite
      });
    }
    var CountMemoBlockVisitor = /*#__PURE__*/ (function (
      _ReactiveFunctionVisi5
    ) {
      function CountMemoBlockVisitor(env) {
        var _this10;
        _classCallCheck(this, CountMemoBlockVisitor);
        _this10 = _callSuper(this, CountMemoBlockVisitor);
        _this10.memoBlocks = 0;
        _this10.memoValues = 0;
        _this10.prunedMemoBlocks = 0;
        _this10.prunedMemoValues = 0;
        _this10.env = env;
        return _this10;
      }
      _inherits2(CountMemoBlockVisitor, _ReactiveFunctionVisi5);
      return _createClass(CountMemoBlockVisitor, [
        {
          key: "visitScope",
          value: function visitScope(scopeBlock, state) {
            this.memoBlocks += 1;
            this.memoValues += scopeBlock.scope.declarations.size;
            this.traverseScope(scopeBlock, state);
          }
        },
        {
          key: "visitPrunedScope",
          value: function visitPrunedScope(scopeBlock, state) {
            this.prunedMemoBlocks += 1;
            this.prunedMemoValues += scopeBlock.scope.declarations.size;
            this.traversePrunedScope(scopeBlock, state);
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    function convertParameter(param) {
      if (param.kind === "Identifier") {
        return convertIdentifier(param.identifier);
      } else {
        return libExports.restElement(
          convertIdentifier(param.place.identifier)
        );
      }
    }
    var Context$2 = /*#__PURE__*/ (function () {
      function Context(env, fnName, uniqueIdentifiers, fbtOperands) {
        var temporaries =
          arguments.length > 4 && arguments[4] !== undefined
            ? arguments[4]
            : null;
        _classCallCheck(this, Context);
        _Context_nextCacheIndex.set(this, 0);
        _Context_declarations$1.set(this, new Set());
        this.errors = new CompilerError();
        this.objectMethods = new Map();
        this.synthesizedNames = new Map();
        this.env = env;
        this.fnName = fnName;
        this.uniqueIdentifiers = uniqueIdentifiers;
        this.fbtOperands = fbtOperands;
        this.temp = temporaries !== null ? new Map(temporaries) : new Map();
      }
      return _createClass(Context, [
        {
          key: "nextCacheIndex",
          get: function get() {
            var _a, _b;
            return (
              __classPrivateFieldSet(
                this,
                _Context_nextCacheIndex,
                ((_b = __classPrivateFieldGet(
                  this,
                  _Context_nextCacheIndex,
                  "f"
                )),
                (_a = _b++),
                _b),
                "f"
              ),
              _a
            );
          }
        },
        {
          key: "declare",
          value: function declare(identifier) {
            __classPrivateFieldGet(this, _Context_declarations$1, "f").add(
              identifier.declarationId
            );
          }
        },
        {
          key: "hasDeclared",
          value: function hasDeclared(identifier) {
            return __classPrivateFieldGet(
              this,
              _Context_declarations$1,
              "f"
            ).has(identifier.declarationId);
          }
        },
        {
          key: "synthesizeName",
          value: function synthesizeName(name) {
            var previous = this.synthesizedNames.get(name);
            if (previous !== undefined) {
              return previous;
            }
            var validated = makeIdentifierName(name).value;
            var index = 0;
            while (this.uniqueIdentifiers.has(validated)) {
              validated = makeIdentifierName(
                "".concat(name).concat(index++)
              ).value;
            }
            this.uniqueIdentifiers.add(validated);
            this.synthesizedNames.set(name, validated);
            return validated;
          }
        }
      ]);
    })();
    (_Context_nextCacheIndex = new WeakMap()),
      (_Context_declarations$1 = new WeakMap());
    function codegenBlock(cx, block) {
      var temp = new Map(cx.temp);
      var result = codegenBlockNoReset(cx, block);
      var _iterator249 = _createForOfIteratorHelper(cx.temp),
        _step249;
      try {
        for (_iterator249.s(); !(_step249 = _iterator249.n()).done; ) {
          var _step249$value = _slicedToArray(_step249.value, 2),
            _key32 = _step249$value[0],
            value = _step249$value[1];
          if (!temp.has(_key32)) {
            continue;
          }
          CompilerError.invariant(temp.get(_key32) === value, {
            loc: null,
            reason: "Expected temporary value to be unchanged",
            description: null,
            suggestions: null
          });
        }
      } catch (err) {
        _iterator249.e(err);
      } finally {
        _iterator249.f();
      }
      cx.temp = temp;
      return result;
    }
    function codegenBlockNoReset(cx, block) {
      var statements = [];
      var _iterator250 = _createForOfIteratorHelper(block),
        _step250;
      try {
        for (_iterator250.s(); !(_step250 = _iterator250.n()).done; ) {
          var item = _step250.value;
          switch (item.kind) {
            case "instruction": {
              var statement = codegenInstructionNullable(cx, item.instruction);
              if (statement !== null) {
                statements.push(statement);
              }
              break;
            }
            case "pruned-scope": {
              var scopeBlock = codegenBlockNoReset(cx, item.instructions);
              statements.push.apply(
                statements,
                _toConsumableArray(scopeBlock.body)
              );
              break;
            }
            case "scope": {
              var temp = new Map(cx.temp);
              codegenReactiveScope(
                cx,
                statements,
                item.scope,
                item.instructions
              );
              cx.temp = temp;
              break;
            }
            case "terminal": {
              var _statement = codegenTerminal(cx, item.terminal);
              if (_statement === null) {
                break;
              }
              if (item.label !== null && !item.label.implicit) {
                var _block14 =
                  _statement.type === "BlockStatement" &&
                  _statement.body.length === 1
                    ? _statement.body[0]
                    : _statement;
                statements.push(
                  libExports.labeledStatement(
                    libExports.identifier(codegenLabel(item.label.id)),
                    _block14
                  )
                );
              } else if (_statement.type === "BlockStatement") {
                statements.push.apply(
                  statements,
                  _toConsumableArray(_statement.body)
                );
              } else {
                statements.push(_statement);
              }
              break;
            }
            default: {
              assertExhaustive$1(
                item,
                "Unexpected item kind `".concat(item.kind, "`")
              );
            }
          }
        }
      } catch (err) {
        _iterator250.e(err);
      } finally {
        _iterator250.f();
      }
      return libExports.blockStatement(statements);
    }
    function wrapCacheDep(cx, value) {
      if (cx.env.config.enableEmitFreeze != null) {
        return libExports.conditionalExpression(
          libExports.identifier("true"),
          libExports.callExpression(
            libExports.identifier(
              cx.env.config.enableEmitFreeze.importSpecifierName
            ),
            [value, libExports.stringLiteral(cx.fnName)]
          ),
          value
        );
      } else {
        return value;
      }
    }
    function codegenReactiveScope(cx, statements, scope, block) {
      var cacheStoreStatements = [];
      var cacheLoadStatements = [];
      var cacheLoads = [];
      var changeExpressions = [];
      var changeExpressionComments = [];
      var outputComments = [];
      var _iterator251 = _createForOfIteratorHelper(
          _toConsumableArray(scope.dependencies).sort(compareScopeDependency)
        ),
        _step251;
      try {
        for (_iterator251.s(); !(_step251 = _iterator251.n()).done; ) {
          var dep = _step251.value;
          var _index8 = cx.nextCacheIndex;
          changeExpressionComments.push(printDependencyComment(dep));
          var comparison = libExports.binaryExpression(
            "!==",
            libExports.memberExpression(
              libExports.identifier(cx.synthesizeName("$")),
              libExports.numericLiteral(_index8),
              true
            ),
            codegenDependency(cx, dep)
          );
          if (cx.env.config.enableChangeVariableCodegen) {
            var changeIdentifier = libExports.identifier(
              cx.synthesizeName("c_".concat(_index8))
            );
            statements.push(
              libExports.variableDeclaration("const", [
                libExports.variableDeclarator(changeIdentifier, comparison)
              ])
            );
            changeExpressions.push(changeIdentifier);
          } else {
            changeExpressions.push(comparison);
          }
          cacheStoreStatements.push(
            libExports.expressionStatement(
              libExports.assignmentExpression(
                "=",
                libExports.memberExpression(
                  libExports.identifier(cx.synthesizeName("$")),
                  libExports.numericLiteral(_index8),
                  true
                ),
                codegenDependency(cx, dep)
              )
            )
          );
        }
      } catch (err) {
        _iterator251.e(err);
      } finally {
        _iterator251.f();
      }
      var firstOutputIndex = null;
      var _iterator252 = _createForOfIteratorHelper(
          _toConsumableArray(scope.declarations).sort(
            function (_ref33, _ref34) {
              var _ref35 = _slicedToArray(_ref33, 2),
                a = _ref35[1];
              var _ref36 = _slicedToArray(_ref34, 2),
                b = _ref36[1];
              return compareScopeDeclaration(a, b);
            }
          )
        ),
        _step252;
      try {
        for (_iterator252.s(); !(_step252 = _iterator252.n()).done; ) {
          var _step252$value = _slicedToArray(_step252.value, 2),
            _identifier11 = _step252$value[1].identifier;
          var _index9 = cx.nextCacheIndex;
          if (firstOutputIndex === null) {
            firstOutputIndex = _index9;
          }
          CompilerError.invariant(_identifier11.name != null, {
            reason: "Expected scope declaration identifier to be named",
            description: "Declaration `"
              .concat(printIdentifier(_identifier11), "` is unnamed in scope @")
              .concat(scope.id),
            loc: null,
            suggestions: null
          });
          var _name6 = convertIdentifier(_identifier11);
          outputComments.push(_name6.name);
          if (!cx.hasDeclared(_identifier11)) {
            statements.push(
              libExports.variableDeclaration("let", [
                libExports.variableDeclarator(_name6)
              ])
            );
          }
          cacheLoads.push({
            name: _name6,
            index: _index9,
            value: wrapCacheDep(cx, _name6)
          });
          cx.declare(_identifier11);
        }
      } catch (err) {
        _iterator252.e(err);
      } finally {
        _iterator252.f();
      }
      var _iterator253 = _createForOfIteratorHelper(scope.reassignments),
        _step253;
      try {
        for (_iterator253.s(); !(_step253 = _iterator253.n()).done; ) {
          var reassignment = _step253.value;
          var _index10 = cx.nextCacheIndex;
          if (firstOutputIndex === null) {
            firstOutputIndex = _index10;
          }
          var _name7 = convertIdentifier(reassignment);
          outputComments.push(_name7.name);
          cacheLoads.push({
            name: _name7,
            index: _index10,
            value: wrapCacheDep(cx, _name7)
          });
        }
      } catch (err) {
        _iterator253.e(err);
      } finally {
        _iterator253.f();
      }
      var testCondition = changeExpressions.reduce(function (acc, ident) {
        if (acc == null) {
          return ident;
        }
        return libExports.logicalExpression("||", acc, ident);
      }, null);
      if (testCondition === null) {
        CompilerError.invariant(firstOutputIndex !== null, {
          reason: "Expected scope to have at least one declaration",
          description: "Scope '@".concat(scope.id, "' has no declarations"),
          loc: null,
          suggestions: null
        });
        testCondition = libExports.binaryExpression(
          "===",
          libExports.memberExpression(
            libExports.identifier(cx.synthesizeName("$")),
            libExports.numericLiteral(firstOutputIndex),
            true
          ),
          libExports.callExpression(
            libExports.memberExpression(
              libExports.identifier("Symbol"),
              libExports.identifier("for")
            ),
            [libExports.stringLiteral(MEMO_CACHE_SENTINEL)]
          )
        );
      }
      if (cx.env.config.disableMemoizationForDebugging) {
        CompilerError.invariant(
          cx.env.config.enableChangeDetectionForDebugging == null,
          {
            reason:
              "Expected to not have both change detection enabled and memoization disabled",
            description: "Incompatible config options",
            loc: null
          }
        );
        testCondition = libExports.logicalExpression(
          "||",
          testCondition,
          libExports.booleanLiteral(true)
        );
      }
      var computationBlock = codegenBlock(cx, block);
      var memoStatement;
      if (
        cx.env.config.enableChangeDetectionForDebugging != null &&
        changeExpressions.length > 0
      ) {
        var loc =
          _typeof(scope.loc) === "symbol"
            ? "unknown location"
            : "("
                .concat(scope.loc.start.line, ":")
                .concat(scope.loc.end.line, ")");
        var detectionFunction =
          cx.env.config.enableChangeDetectionForDebugging.importSpecifierName;
        var cacheLoadOldValueStatements = [];
        var changeDetectionStatements = [];
        var idempotenceDetectionStatements = [];
        var _iterator254 = _createForOfIteratorHelper(cacheLoads),
          _step254;
        try {
          for (_iterator254.s(); !(_step254 = _iterator254.n()).done; ) {
            var _step254$value = _step254.value,
              _name3 = _step254$value.name,
              index = _step254$value.index,
              value = _step254$value.value;
            var loadName = cx.synthesizeName("old$".concat(_name3.name));
            var slot = libExports.memberExpression(
              libExports.identifier(cx.synthesizeName("$")),
              libExports.numericLiteral(index),
              true
            );
            cacheStoreStatements.push(
              libExports.expressionStatement(
                libExports.assignmentExpression("=", slot, value)
              )
            );
            cacheLoadOldValueStatements.push(
              libExports.variableDeclaration("let", [
                libExports.variableDeclarator(
                  libExports.identifier(loadName),
                  slot
                )
              ])
            );
            changeDetectionStatements.push(
              libExports.expressionStatement(
                libExports.callExpression(
                  libExports.identifier(detectionFunction),
                  [
                    libExports.identifier(loadName),
                    libExports.cloneNode(_name3, true),
                    libExports.stringLiteral(_name3.name),
                    libExports.stringLiteral(cx.fnName),
                    libExports.stringLiteral("cached"),
                    libExports.stringLiteral(loc)
                  ]
                )
              )
            );
            idempotenceDetectionStatements.push(
              libExports.expressionStatement(
                libExports.callExpression(
                  libExports.identifier(detectionFunction),
                  [
                    libExports.cloneNode(slot, true),
                    libExports.cloneNode(_name3, true),
                    libExports.stringLiteral(_name3.name),
                    libExports.stringLiteral(cx.fnName),
                    libExports.stringLiteral("recomputed"),
                    libExports.stringLiteral(loc)
                  ]
                )
              )
            );
            idempotenceDetectionStatements.push(
              libExports.expressionStatement(
                libExports.assignmentExpression("=", _name3, slot)
              )
            );
          }
        } catch (err) {
          _iterator254.e(err);
        } finally {
          _iterator254.f();
        }
        var condition = cx.synthesizeName("condition");
        var recomputationBlock = libExports.cloneNode(computationBlock, true);
        memoStatement = libExports.blockStatement(
          [].concat(
            _toConsumableArray(computationBlock.body),
            [
              libExports.variableDeclaration("let", [
                libExports.variableDeclarator(
                  libExports.identifier(condition),
                  testCondition
                )
              ]),
              libExports.ifStatement(
                libExports.unaryExpression(
                  "!",
                  libExports.identifier(condition)
                ),
                libExports.blockStatement(
                  [].concat(
                    cacheLoadOldValueStatements,
                    changeDetectionStatements
                  )
                )
              )
            ],
            cacheStoreStatements,
            [
              libExports.ifStatement(
                libExports.identifier(condition),
                libExports.blockStatement(
                  [].concat(
                    _toConsumableArray(recomputationBlock.body),
                    idempotenceDetectionStatements
                  )
                )
              )
            ]
          )
        );
      } else {
        var _computationBlock$bod;
        var _iterator255 = _createForOfIteratorHelper(cacheLoads),
          _step255;
        try {
          for (_iterator255.s(); !(_step255 = _iterator255.n()).done; ) {
            var _step255$value = _step255.value,
              _name4 = _step255$value.name,
              _index7 = _step255$value.index,
              _value20 = _step255$value.value;
            cacheStoreStatements.push(
              libExports.expressionStatement(
                libExports.assignmentExpression(
                  "=",
                  libExports.memberExpression(
                    libExports.identifier(cx.synthesizeName("$")),
                    libExports.numericLiteral(_index7),
                    true
                  ),
                  _value20
                )
              )
            );
            cacheLoadStatements.push(
              libExports.expressionStatement(
                libExports.assignmentExpression(
                  "=",
                  _name4,
                  libExports.memberExpression(
                    libExports.identifier(cx.synthesizeName("$")),
                    libExports.numericLiteral(_index7),
                    true
                  )
                )
              )
            );
          }
        } catch (err) {
          _iterator255.e(err);
        } finally {
          _iterator255.f();
        }
        (_computationBlock$bod = computationBlock.body).push.apply(
          _computationBlock$bod,
          cacheStoreStatements
        );
        memoStatement = libExports.ifStatement(
          testCondition,
          computationBlock,
          libExports.blockStatement(cacheLoadStatements)
        );
      }
      if (cx.env.config.enableMemoizationComments) {
        if (changeExpressionComments.length) {
          libExports.addComment(
            memoStatement,
            "leading",
            " check if ".concat(
              printDelimitedCommentList(changeExpressionComments, "or"),
              " changed"
            ),
            true
          );
          libExports.addComment(
            memoStatement,
            "leading",
            ' "useMemo" for '.concat(
              printDelimitedCommentList(outputComments, "and"),
              ":"
            ),
            true
          );
        } else {
          libExports.addComment(
            memoStatement,
            "leading",
            " cache value with no dependencies",
            true
          );
          libExports.addComment(
            memoStatement,
            "leading",
            ' "useMemo" for '.concat(
              printDelimitedCommentList(outputComments, "and"),
              ":"
            ),
            true
          );
        }
        if (computationBlock.body.length > 0) {
          libExports.addComment(
            computationBlock.body[0],
            "leading",
            " Inputs changed, recompute",
            true
          );
        }
        if (cacheLoadStatements.length > 0) {
          libExports.addComment(
            cacheLoadStatements[0],
            "leading",
            " Inputs did not change, use cached value",
            true
          );
        }
      }
      statements.push(memoStatement);
      var earlyReturnValue = scope.earlyReturnValue;
      if (earlyReturnValue !== null) {
        CompilerError.invariant(
          earlyReturnValue.value.name !== null &&
            earlyReturnValue.value.name.kind === "named",
          {
            reason:
              "Expected early return value to be promoted to a named variable",
            loc: earlyReturnValue.loc,
            description: null,
            suggestions: null
          }
        );
        var _name5 = earlyReturnValue.value.name.value;
        statements.push(
          libExports.ifStatement(
            libExports.binaryExpression(
              "!==",
              libExports.identifier(_name5),
              libExports.callExpression(
                libExports.memberExpression(
                  libExports.identifier("Symbol"),
                  libExports.identifier("for")
                ),
                [libExports.stringLiteral(EARLY_RETURN_SENTINEL)]
              )
            ),
            libExports.blockStatement([
              libExports.returnStatement(libExports.identifier(_name5))
            ])
          )
        );
      }
    }
    function codegenTerminal(cx, terminal) {
      switch (terminal.kind) {
        case "break": {
          if (terminal.targetKind === "implicit") {
            return null;
          }
          return libExports.breakStatement(
            terminal.targetKind === "labeled"
              ? libExports.identifier(codegenLabel(terminal.target))
              : null
          );
        }
        case "continue": {
          if (terminal.targetKind === "implicit") {
            return null;
          }
          return libExports.continueStatement(
            terminal.targetKind === "labeled"
              ? libExports.identifier(codegenLabel(terminal.target))
              : null
          );
        }
        case "for": {
          return libExports.forStatement(
            codegenForInit(cx, terminal.init),
            codegenInstructionValueToExpression(cx, terminal.test),
            terminal.update !== null
              ? codegenInstructionValueToExpression(cx, terminal.update)
              : null,
            codegenBlock(cx, terminal.loop)
          );
        }
        case "for-in": {
          CompilerError.invariant(terminal.init.kind === "SequenceExpression", {
            reason: "Expected a sequence expression init for for..in",
            description: "Got `".concat(
              terminal.init.kind,
              "` expression instead"
            ),
            loc: terminal.init.loc,
            suggestions: null
          });
          if (terminal.init.instructions.length !== 2) {
            CompilerError.throwTodo({
              reason: "Support non-trivial for..in inits",
              description: null,
              loc: terminal.init.loc,
              suggestions: null
            });
          }
          var iterableCollection = terminal.init.instructions[0];
          var iterableItem = terminal.init.instructions[1];
          var lval;
          switch (iterableItem.value.kind) {
            case "StoreLocal": {
              lval = codegenLValue(cx, iterableItem.value.lvalue.place);
              break;
            }
            case "Destructure": {
              lval = codegenLValue(cx, iterableItem.value.lvalue.pattern);
              break;
            }
            default:
              CompilerError.invariant(false, {
                reason:
                  "Expected a StoreLocal or Destructure to be assigned to the collection",
                description: "Found ".concat(iterableItem.value.kind),
                loc: iterableItem.value.loc,
                suggestions: null
              });
          }
          var varDeclKind;
          switch (iterableItem.value.lvalue.kind) {
            case InstructionKind.Const:
              varDeclKind = "const";
              break;
            case InstructionKind.Let:
              varDeclKind = "let";
              break;
            case InstructionKind.Reassign:
              CompilerError.invariant(false, {
                reason:
                  "Destructure should never be Reassign as it would be an Object/ArrayPattern",
                description: null,
                loc: iterableItem.loc,
                suggestions: null
              });
            case InstructionKind.Catch:
            case InstructionKind.HoistedConst:
            case InstructionKind.HoistedLet:
            case InstructionKind.HoistedFunction:
            case InstructionKind.Function:
              CompilerError.invariant(false, {
                reason: "Unexpected ".concat(
                  iterableItem.value.lvalue.kind,
                  " variable in for..in collection"
                ),
                description: null,
                loc: iterableItem.loc,
                suggestions: null
              });
            default:
              assertExhaustive$1(
                iterableItem.value.lvalue.kind,
                "Unhandled lvalue kind: ".concat(iterableItem.value.lvalue.kind)
              );
          }
          return libExports.forInStatement(
            createVariableDeclaration(iterableItem.value.loc, varDeclKind, [
              libExports.variableDeclarator(lval, null)
            ]),
            codegenInstructionValueToExpression(cx, iterableCollection.value),
            codegenBlock(cx, terminal.loop)
          );
        }
        case "for-of": {
          CompilerError.invariant(
            terminal.init.kind === "SequenceExpression" &&
              terminal.init.instructions.length === 1 &&
              terminal.init.instructions[0].value.kind === "GetIterator",
            {
              reason:
                "Expected a single-expression sequence expression init for for..of",
              description: "Got `".concat(
                terminal.init.kind,
                "` expression instead"
              ),
              loc: terminal.init.loc,
              suggestions: null
            }
          );
          var _iterableCollection = terminal.init.instructions[0].value;
          CompilerError.invariant(terminal.test.kind === "SequenceExpression", {
            reason: "Expected a sequence expression test for for..of",
            description: "Got `".concat(
              terminal.init.kind,
              "` expression instead"
            ),
            loc: terminal.test.loc,
            suggestions: null
          });
          if (terminal.test.instructions.length !== 2) {
            CompilerError.throwTodo({
              reason: "Support non-trivial for..of inits",
              description: null,
              loc: terminal.init.loc,
              suggestions: null
            });
          }
          var _iterableItem = terminal.test.instructions[1];
          var _lval;
          switch (_iterableItem.value.kind) {
            case "StoreLocal": {
              _lval = codegenLValue(cx, _iterableItem.value.lvalue.place);
              break;
            }
            case "Destructure": {
              _lval = codegenLValue(cx, _iterableItem.value.lvalue.pattern);
              break;
            }
            default:
              CompilerError.invariant(false, {
                reason:
                  "Expected a StoreLocal or Destructure to be assigned to the collection",
                description: "Found ".concat(_iterableItem.value.kind),
                loc: _iterableItem.value.loc,
                suggestions: null
              });
          }
          var _varDeclKind;
          switch (_iterableItem.value.lvalue.kind) {
            case InstructionKind.Const:
              _varDeclKind = "const";
              break;
            case InstructionKind.Let:
              _varDeclKind = "let";
              break;
            case InstructionKind.Reassign:
            case InstructionKind.Catch:
            case InstructionKind.HoistedConst:
            case InstructionKind.HoistedLet:
            case InstructionKind.HoistedFunction:
            case InstructionKind.Function:
              CompilerError.invariant(false, {
                reason: "Unexpected ".concat(
                  _iterableItem.value.lvalue.kind,
                  " variable in for..of collection"
                ),
                description: null,
                loc: _iterableItem.loc,
                suggestions: null
              });
            default:
              assertExhaustive$1(
                _iterableItem.value.lvalue.kind,
                "Unhandled lvalue kind: ".concat(
                  _iterableItem.value.lvalue.kind
                )
              );
          }
          return libExports.forOfStatement(
            createVariableDeclaration(_iterableItem.value.loc, _varDeclKind, [
              libExports.variableDeclarator(_lval, null)
            ]),
            codegenInstructionValueToExpression(cx, _iterableCollection),
            codegenBlock(cx, terminal.loop)
          );
        }
        case "if": {
          var _test27 = codegenPlaceToExpression(cx, terminal.test);
          var consequent = codegenBlock(cx, terminal.consequent);
          var alternate = null;
          if (terminal.alternate !== null) {
            var block = codegenBlock(cx, terminal.alternate);
            if (block.body.length !== 0) {
              alternate = block;
            }
          }
          return libExports.ifStatement(_test27, consequent, alternate);
        }
        case "return": {
          var value = codegenPlaceToExpression(cx, terminal.value);
          if (value.type === "Identifier" && value.name === "undefined") {
            return libExports.returnStatement();
          }
          return libExports.returnStatement(value);
        }
        case "switch": {
          return libExports.switchStatement(
            codegenPlaceToExpression(cx, terminal.test),
            terminal.cases.map(function (case_) {
              var test =
                case_.test !== null
                  ? codegenPlaceToExpression(cx, case_.test)
                  : null;
              var block = codegenBlock(cx, case_.block);
              return libExports.switchCase(test, [block]);
            })
          );
        }
        case "throw": {
          return libExports.throwStatement(
            codegenPlaceToExpression(cx, terminal.value)
          );
        }
        case "do-while": {
          var _test28 = codegenInstructionValueToExpression(cx, terminal.test);
          return libExports.doWhileStatement(
            _test28,
            codegenBlock(cx, terminal.loop)
          );
        }
        case "while": {
          var _test29 = codegenInstructionValueToExpression(cx, terminal.test);
          return libExports.whileStatement(
            _test29,
            codegenBlock(cx, terminal.loop)
          );
        }
        case "label": {
          return codegenBlock(cx, terminal.block);
        }
        case "try": {
          var catchParam = null;
          if (terminal.handlerBinding !== null) {
            catchParam = convertIdentifier(terminal.handlerBinding.identifier);
            cx.temp.set(terminal.handlerBinding.identifier.declarationId, null);
          }
          return libExports.tryStatement(
            codegenBlock(cx, terminal.block),
            libExports.catchClause(
              catchParam,
              codegenBlock(cx, terminal.handler)
            )
          );
        }
        default: {
          assertExhaustive$1(
            terminal,
            "Unexpected terminal kind `".concat(terminal.kind, "`")
          );
        }
      }
    }
    function codegenInstructionNullable(cx, instr) {
      if (
        instr.value.kind === "StoreLocal" ||
        instr.value.kind === "StoreContext" ||
        instr.value.kind === "Destructure" ||
        instr.value.kind === "DeclareLocal" ||
        instr.value.kind === "DeclareContext"
      ) {
        var kind = instr.value.lvalue.kind;
        var lvalue;
        var value;
        if (instr.value.kind === "StoreLocal") {
          kind = cx.hasDeclared(instr.value.lvalue.place.identifier)
            ? InstructionKind.Reassign
            : kind;
          lvalue = instr.value.lvalue.place;
          value = codegenPlaceToExpression(cx, instr.value.value);
        } else if (instr.value.kind === "StoreContext") {
          lvalue = instr.value.lvalue.place;
          value = codegenPlaceToExpression(cx, instr.value.value);
        } else if (
          instr.value.kind === "DeclareLocal" ||
          instr.value.kind === "DeclareContext"
        ) {
          if (cx.hasDeclared(instr.value.lvalue.place.identifier)) {
            return null;
          }
          kind = instr.value.lvalue.kind;
          lvalue = instr.value.lvalue.place;
          value = null;
        } else {
          lvalue = instr.value.lvalue.pattern;
          var hasReassign = false;
          var hasDeclaration = false;
          var _iterator256 = _createForOfIteratorHelper(
              eachPatternOperand(lvalue)
            ),
            _step256;
          try {
            for (_iterator256.s(); !(_step256 = _iterator256.n()).done; ) {
              var place = _step256.value;
              if (
                kind !== InstructionKind.Reassign &&
                place.identifier.name === null
              ) {
                cx.temp.set(place.identifier.declarationId, null);
              }
              var isDeclared = cx.hasDeclared(place.identifier);
              hasReassign || (hasReassign = isDeclared);
              hasDeclaration || (hasDeclaration = !isDeclared);
            }
          } catch (err) {
            _iterator256.e(err);
          } finally {
            _iterator256.f();
          }
          if (hasReassign && hasDeclaration) {
            CompilerError.invariant(false, {
              reason:
                "Encountered a destructuring operation where some identifiers are already declared (reassignments) but others are not (declarations)",
              description: null,
              loc: instr.loc,
              suggestions: null
            });
          } else if (hasReassign) {
            kind = InstructionKind.Reassign;
          }
          value = codegenPlaceToExpression(cx, instr.value.value);
        }
        switch (kind) {
          case InstructionKind.Const: {
            CompilerError.invariant(instr.lvalue === null, {
              reason: "Const declaration cannot be referenced as an expression",
              description: null,
              loc: instr.value.loc,
              suggestions: null
            });
            return createVariableDeclaration(instr.loc, "const", [
              libExports.variableDeclarator(codegenLValue(cx, lvalue), value)
            ]);
          }
          case InstructionKind.Function: {
            CompilerError.invariant(instr.lvalue === null, {
              reason:
                "Function declaration cannot be referenced as an expression",
              description: null,
              loc: instr.value.loc,
              suggestions: null
            });
            var genLvalue = codegenLValue(cx, lvalue);
            CompilerError.invariant(genLvalue.type === "Identifier", {
              reason: "Expected an identifier as a function declaration lvalue",
              description: null,
              loc: instr.value.loc,
              suggestions: null
            });
            CompilerError.invariant(
              (value === null || value === void 0 ? void 0 : value.type) ===
                "FunctionExpression",
              {
                reason: "Expected a function as a function declaration value",
                description: null,
                loc: instr.value.loc,
                suggestions: null
              }
            );
            return createFunctionDeclaration(
              instr.loc,
              genLvalue,
              value.params,
              value.body,
              value.generator,
              value.async
            );
          }
          case InstructionKind.Let: {
            CompilerError.invariant(instr.lvalue === null, {
              reason: "Const declaration cannot be referenced as an expression",
              description: null,
              loc: instr.value.loc,
              suggestions: null
            });
            return createVariableDeclaration(instr.loc, "let", [
              libExports.variableDeclarator(codegenLValue(cx, lvalue), value)
            ]);
          }
          case InstructionKind.Reassign: {
            CompilerError.invariant(value !== null, {
              reason: "Expected a value for reassignment",
              description: null,
              loc: instr.value.loc,
              suggestions: null
            });
            var expr = libExports.assignmentExpression(
              "=",
              codegenLValue(cx, lvalue),
              value
            );
            if (instr.lvalue !== null) {
              if (instr.value.kind !== "StoreContext") {
                cx.temp.set(instr.lvalue.identifier.declarationId, expr);
                return null;
              } else {
                var statement = codegenInstruction(cx, instr, expr);
                if (statement.type === "EmptyStatement") {
                  return null;
                }
                return statement;
              }
            } else {
              return createExpressionStatement(instr.loc, expr);
            }
          }
          case InstructionKind.Catch: {
            return libExports.emptyStatement();
          }
          case InstructionKind.HoistedLet:
          case InstructionKind.HoistedConst:
          case InstructionKind.HoistedFunction: {
            CompilerError.invariant(false, {
              reason: "Expected ".concat(
                kind,
                " to have been pruned in PruneHoistedContexts"
              ),
              description: null,
              loc: instr.loc,
              suggestions: null
            });
          }
          default: {
            assertExhaustive$1(
              kind,
              "Unexpected instruction kind `".concat(kind, "`")
            );
          }
        }
      } else if (
        instr.value.kind === "StartMemoize" ||
        instr.value.kind === "FinishMemoize"
      ) {
        return null;
      } else if (instr.value.kind === "Debugger") {
        return libExports.debuggerStatement();
      } else if (instr.value.kind === "ObjectMethod") {
        CompilerError.invariant(instr.lvalue, {
          reason: "Expected object methods to have a temp lvalue",
          loc: null,
          suggestions: null
        });
        cx.objectMethods.set(instr.lvalue.identifier.id, instr.value);
        return null;
      } else {
        var _value21 = codegenInstructionValue(cx, instr.value);
        var _statement2 = codegenInstruction(cx, instr, _value21);
        if (_statement2.type === "EmptyStatement") {
          return null;
        }
        return _statement2;
      }
    }
    function codegenForInit(cx, init) {
      if (init.kind === "SequenceExpression") {
        var body = codegenBlock(
          cx,
          init.instructions.map(function (instruction) {
            return { kind: "instruction", instruction: instruction };
          })
        ).body;
        var declarators = [];
        var kind = "const";
        body.forEach(function (instr) {
          var _a;
          var top = undefined;
          if (
            instr.type === "ExpressionStatement" &&
            instr.expression.type === "AssignmentExpression" &&
            instr.expression.operator === "=" &&
            instr.expression.left.type === "Identifier" &&
            ((_a = top = declarators.at(-1)) === null || _a === void 0
              ? void 0
              : _a.id.type) === "Identifier" &&
            (top === null || top === void 0 ? void 0 : top.id.name) ===
              instr.expression.left.name &&
            (top === null || top === void 0 ? void 0 : top.init) == null
          ) {
            top.init = instr.expression.right;
          } else {
            CompilerError.invariant(
              instr.type === "VariableDeclaration" &&
                (instr.kind === "let" || instr.kind === "const"),
              {
                reason: "Expected a variable declaration",
                loc: init.loc,
                description: "Got ".concat(instr.type),
                suggestions: null
              }
            );
            if (instr.kind === "let") {
              kind = "let";
            }
            declarators.push.apply(
              declarators,
              _toConsumableArray(instr.declarations)
            );
          }
        });
        CompilerError.invariant(declarators.length > 0, {
          reason: "Expected a variable declaration",
          loc: init.loc,
          description: null,
          suggestions: null
        });
        return libExports.variableDeclaration(kind, declarators);
      } else {
        return codegenInstructionValueToExpression(cx, init);
      }
    }
    function printDependencyComment(dependency) {
      var identifier = convertIdentifier(dependency.identifier);
      var name = identifier.name;
      if (dependency.path !== null) {
        var _iterator257 = _createForOfIteratorHelper(dependency.path),
          _step257;
        try {
          for (_iterator257.s(); !(_step257 = _iterator257.n()).done; ) {
            var path = _step257.value;
            name += ".".concat(path.property);
          }
        } catch (err) {
          _iterator257.e(err);
        } finally {
          _iterator257.f();
        }
      }
      return name;
    }
    function printDelimitedCommentList(items, finalCompletion) {
      if (items.length === 2) {
        return items.join(" ".concat(finalCompletion, " "));
      } else if (items.length <= 1) {
        return items.join("");
      }
      var output = [];
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        if (i < items.length - 2) {
          output.push("".concat(item, ", "));
        } else if (i === items.length - 2) {
          output.push("".concat(item, ", ").concat(finalCompletion, " "));
        } else {
          output.push(item);
        }
      }
      return output.join("");
    }
    function codegenDependency(cx, dependency) {
      var object = convertIdentifier(dependency.identifier);
      if (dependency.path.length !== 0) {
        var hasOptional = dependency.path.some(function (path) {
          return path.optional;
        });
        var _iterator258 = _createForOfIteratorHelper(dependency.path),
          _step258;
        try {
          for (_iterator258.s(); !(_step258 = _iterator258.n()).done; ) {
            var path = _step258.value;
            var property =
              typeof path.property === "string"
                ? libExports.identifier(path.property)
                : libExports.numericLiteral(path.property);
            var isComputed = typeof path.property !== "string";
            if (hasOptional) {
              object = libExports.optionalMemberExpression(
                object,
                property,
                isComputed,
                path.optional
              );
            } else {
              object = libExports.memberExpression(
                object,
                property,
                isComputed
              );
            }
          }
        } catch (err) {
          _iterator258.e(err);
        } finally {
          _iterator258.f();
        }
      }
      return object;
    }
    function withLoc(fn) {
      return function (loc) {
        for (
          var _len7 = arguments.length,
            args = new Array(_len7 > 1 ? _len7 - 1 : 0),
            _key33 = 1;
          _key33 < _len7;
          _key33++
        ) {
          args[_key33 - 1] = arguments[_key33];
        }
        var node = fn.apply(void 0, args);
        if (loc != null && loc != GeneratedSource) {
          node.loc = loc;
        }
        return node;
      };
    }
    var createBinaryExpression = withLoc(libExports.binaryExpression);
    var createExpressionStatement = withLoc(libExports.expressionStatement);
    var createVariableDeclaration = withLoc(libExports.variableDeclaration);
    var createFunctionDeclaration = withLoc(libExports.functionDeclaration);
    var createTaggedTemplateExpression = withLoc(
      libExports.taggedTemplateExpression
    );
    var createLogicalExpression = withLoc(libExports.logicalExpression);
    var createSequenceExpression = withLoc(libExports.sequenceExpression);
    var createConditionalExpression = withLoc(libExports.conditionalExpression);
    var createTemplateLiteral = withLoc(libExports.templateLiteral);
    var createJsxNamespacedName = withLoc(libExports.jsxNamespacedName);
    var createJsxElement = withLoc(libExports.jsxElement);
    var createJsxAttribute = withLoc(libExports.jsxAttribute);
    var createJsxIdentifier = withLoc(libExports.jsxIdentifier);
    var createJsxExpressionContainer = withLoc(
      libExports.jsxExpressionContainer
    );
    var createJsxText = withLoc(libExports.jsxText);
    var createJsxClosingElement = withLoc(libExports.jsxClosingElement);
    var createJsxOpeningElement = withLoc(libExports.jsxOpeningElement);
    var createStringLiteral = withLoc(libExports.stringLiteral);
    function createHookGuard(guard, stmts, before, after) {
      function createHookGuardImpl(kind) {
        return libExports.expressionStatement(
          libExports.callExpression(
            libExports.identifier(guard.importSpecifierName),
            [libExports.numericLiteral(kind)]
          )
        );
      }
      return libExports.tryStatement(
        libExports.blockStatement(
          [createHookGuardImpl(before)].concat(_toConsumableArray(stmts))
        ),
        null,
        libExports.blockStatement([createHookGuardImpl(after)])
      );
    }
    function createCallExpression(config, callee, args, loc, isHook) {
      var callExpr = libExports.callExpression(callee, args);
      if (loc != null && loc != GeneratedSource) {
        callExpr.loc = loc;
      }
      var hookGuard = config.enableEmitHookGuards;
      if (hookGuard != null && isHook) {
        var iife = libExports.functionExpression(
          null,
          [],
          libExports.blockStatement([
            createHookGuard(
              hookGuard,
              [libExports.returnStatement(callExpr)],
              GuardKind.AllowHook,
              GuardKind.DisallowHook
            )
          ])
        );
        return libExports.callExpression(iife, []);
      } else {
        return callExpr;
      }
    }
    function codegenLabel(id) {
      return "bb".concat(id);
    }
    function codegenInstruction(cx, instr, value) {
      if (libExports.isStatement(value)) {
        return value;
      }
      if (instr.lvalue === null) {
        return libExports.expressionStatement(convertValueToExpression(value));
      }
      if (instr.lvalue.identifier.name === null) {
        cx.temp.set(instr.lvalue.identifier.declarationId, value);
        return libExports.emptyStatement();
      } else {
        var expressionValue = convertValueToExpression(value);
        if (cx.hasDeclared(instr.lvalue.identifier)) {
          return createExpressionStatement(
            instr.loc,
            libExports.assignmentExpression(
              "=",
              convertIdentifier(instr.lvalue.identifier),
              expressionValue
            )
          );
        } else {
          return createVariableDeclaration(instr.loc, "const", [
            libExports.variableDeclarator(
              convertIdentifier(instr.lvalue.identifier),
              expressionValue
            )
          ]);
        }
      }
    }
    function convertValueToExpression(value) {
      if (value.type === "JSXText") {
        return createStringLiteral(value.loc, value.value);
      }
      return value;
    }
    function codegenInstructionValueToExpression(cx, instrValue) {
      var value = codegenInstructionValue(cx, instrValue);
      return convertValueToExpression(value);
    }
    function codegenInstructionValue(cx, instrValue) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      var value;
      switch (instrValue.kind) {
        case "ArrayExpression": {
          var elements = instrValue.elements.map(function (element) {
            if (element.kind === "Identifier") {
              return codegenPlaceToExpression(cx, element);
            } else if (element.kind === "Spread") {
              return libExports.spreadElement(
                codegenPlaceToExpression(cx, element.place)
              );
            } else {
              return null;
            }
          });
          value = libExports.arrayExpression(elements);
          break;
        }
        case "BinaryExpression": {
          var left = codegenPlaceToExpression(cx, instrValue.left);
          var right = codegenPlaceToExpression(cx, instrValue.right);
          value = createBinaryExpression(
            instrValue.loc,
            instrValue.operator,
            left,
            right
          );
          break;
        }
        case "UnaryExpression": {
          value = libExports.unaryExpression(
            instrValue.operator,
            codegenPlaceToExpression(cx, instrValue.value)
          );
          break;
        }
        case "Primitive": {
          value = codegenValue(cx, instrValue.loc, instrValue.value);
          break;
        }
        case "CallExpression": {
          if (cx.env.config.enableForest) {
            var _callee3 = codegenPlaceToExpression(cx, instrValue.callee);
            var _args12 = instrValue.args.map(function (arg) {
              return codegenArgument(cx, arg);
            });
            value = libExports.callExpression(_callee3, _args12);
            if (instrValue.typeArguments != null) {
              value.typeArguments = libExports.typeParameterInstantiation(
                instrValue.typeArguments
              );
            }
            break;
          }
          var _isHook3 =
            getHookKind(cx.env, instrValue.callee.identifier) != null;
          var callee = codegenPlaceToExpression(cx, instrValue.callee);
          var args = instrValue.args.map(function (arg) {
            return codegenArgument(cx, arg);
          });
          value = createCallExpression(
            cx.env.config,
            callee,
            args,
            instrValue.loc,
            _isHook3
          );
          break;
        }
        case "OptionalExpression": {
          var optionalValue = codegenInstructionValueToExpression(
            cx,
            instrValue.value
          );
          switch (optionalValue.type) {
            case "OptionalCallExpression":
            case "CallExpression": {
              CompilerError.invariant(
                libExports.isExpression(optionalValue.callee),
                {
                  reason: "v8 intrinsics are validated during lowering",
                  description: null,
                  loc:
                    (_a = optionalValue.callee.loc) !== null && _a !== void 0
                      ? _a
                      : null,
                  suggestions: null
                }
              );
              value = libExports.optionalCallExpression(
                optionalValue.callee,
                optionalValue.arguments,
                instrValue.optional
              );
              break;
            }
            case "OptionalMemberExpression":
            case "MemberExpression": {
              var property = optionalValue.property;
              CompilerError.invariant(libExports.isExpression(property), {
                reason: "Private names are validated during lowering",
                description: null,
                loc: (_b = property.loc) !== null && _b !== void 0 ? _b : null,
                suggestions: null
              });
              value = libExports.optionalMemberExpression(
                optionalValue.object,
                property,
                optionalValue.computed,
                instrValue.optional
              );
              break;
            }
            default: {
              CompilerError.invariant(false, {
                reason:
                  "Expected an optional value to resolve to a call expression or member expression",
                description: "Got a `".concat(optionalValue.type, "`"),
                loc: instrValue.loc,
                suggestions: null
              });
            }
          }
          break;
        }
        case "MethodCall": {
          var _isHook4 =
            getHookKind(cx.env, instrValue.property.identifier) != null;
          var memberExpr = codegenPlaceToExpression(cx, instrValue.property);
          CompilerError.invariant(
            libExports.isMemberExpression(memberExpr) ||
              libExports.isOptionalMemberExpression(memberExpr),
            {
              reason:
                "[Codegen] Internal error: MethodCall::property must be an unpromoted + unmemoized MemberExpression. " +
                "Got a `".concat(memberExpr.type, "`"),
              description: null,
              loc: (_c = memberExpr.loc) !== null && _c !== void 0 ? _c : null,
              suggestions: null
            }
          );
          CompilerError.invariant(
            libExports.isNodesEquivalent(
              memberExpr.object,
              codegenPlaceToExpression(cx, instrValue.receiver)
            ),
            {
              reason:
                "[Codegen] Internal error: Forget should always generate MethodCall::property " +
                "as a MemberExpression of MethodCall::receiver",
              description: null,
              loc: (_d = memberExpr.loc) !== null && _d !== void 0 ? _d : null,
              suggestions: null
            }
          );
          var _args13 = instrValue.args.map(function (arg) {
            return codegenArgument(cx, arg);
          });
          value = createCallExpression(
            cx.env.config,
            memberExpr,
            _args13,
            instrValue.loc,
            _isHook4
          );
          break;
        }
        case "NewExpression": {
          var _callee4 = codegenPlaceToExpression(cx, instrValue.callee);
          var _args14 = instrValue.args.map(function (arg) {
            return codegenArgument(cx, arg);
          });
          value = libExports.newExpression(_callee4, _args14);
          break;
        }
        case "ObjectExpression": {
          var properties = [];
          var _iterator259 = _createForOfIteratorHelper(instrValue.properties),
            _step259;
          try {
            for (_iterator259.s(); !(_step259 = _iterator259.n()).done; ) {
              var _property9 = _step259.value;
              if (_property9.kind === "ObjectProperty") {
                var _key34 = codegenObjectPropertyKey(cx, _property9.key);
                switch (_property9.type) {
                  case "property": {
                    var _value22 = codegenPlaceToExpression(
                      cx,
                      _property9.place
                    );
                    properties.push(
                      libExports.objectProperty(
                        _key34,
                        _value22,
                        _property9.key.kind === "computed",
                        _key34.type === "Identifier" &&
                          _value22.type === "Identifier" &&
                          _value22.name === _key34.name
                      )
                    );
                    break;
                  }
                  case "method": {
                    var method = cx.objectMethods.get(
                      _property9.place.identifier.id
                    );
                    CompilerError.invariant(method, {
                      reason: "Expected ObjectMethod instruction",
                      loc: null,
                      suggestions: null
                    });
                    var loweredFunc = method.loweredFunc;
                    var reactiveFunction = buildReactiveFunction(
                      loweredFunc.func
                    );
                    pruneUnusedLabels(reactiveFunction);
                    pruneUnusedLValues(reactiveFunction);
                    var fn = codegenReactiveFunction(
                      new Context$2(
                        cx.env,
                        (_e = reactiveFunction.id) !== null && _e !== void 0
                          ? _e
                          : "[[ anonymous ]]",
                        cx.uniqueIdentifiers,
                        cx.fbtOperands,
                        cx.temp
                      ),
                      reactiveFunction
                    ).unwrap();
                    var babelNode = libExports.objectMethod(
                      "method",
                      _key34,
                      fn.params,
                      fn.body,
                      false
                    );
                    babelNode.async = fn.async;
                    babelNode.generator = fn.generator;
                    properties.push(babelNode);
                    break;
                  }
                  default:
                    assertExhaustive$1(
                      _property9.type,
                      "Unexpected property type: ".concat(_property9.type)
                    );
                }
              } else {
                properties.push(
                  libExports.spreadElement(
                    codegenPlaceToExpression(cx, _property9.place)
                  )
                );
              }
            }
          } catch (err) {
            _iterator259.e(err);
          } finally {
            _iterator259.f();
          }
          value = libExports.objectExpression(properties);
          break;
        }
        case "JSXText": {
          value = createJsxText(instrValue.loc, instrValue.value);
          break;
        }
        case "JsxExpression": {
          var attributes = [];
          var _iterator260 = _createForOfIteratorHelper(instrValue.props),
            _step260;
          try {
            for (_iterator260.s(); !(_step260 = _iterator260.n()).done; ) {
              var attribute = _step260.value;
              attributes.push(codegenJsxAttribute(cx, attribute));
            }
          } catch (err) {
            _iterator260.e(err);
          } finally {
            _iterator260.f();
          }
          var tagValue =
            instrValue.tag.kind === "Identifier"
              ? codegenPlaceToExpression(cx, instrValue.tag)
              : libExports.stringLiteral(instrValue.tag.name);
          var tag;
          if (tagValue.type === "Identifier") {
            tag = createJsxIdentifier(instrValue.tag.loc, tagValue.name);
          } else if (tagValue.type === "MemberExpression") {
            tag = convertMemberExpressionToJsx(tagValue);
          } else {
            CompilerError.invariant(tagValue.type === "StringLiteral", {
              reason:
                "Expected JSX tag to be an identifier or string, got `".concat(
                  tagValue.type,
                  "`"
                ),
              description: null,
              loc: (_f = tagValue.loc) !== null && _f !== void 0 ? _f : null,
              suggestions: null
            });
            if (tagValue.value.indexOf(":") >= 0) {
              var _tagValue$value$split = tagValue.value.split(":", 2),
                _tagValue$value$split2 = _slicedToArray(
                  _tagValue$value$split,
                  2
                ),
                namespace = _tagValue$value$split2[0],
                _name8 = _tagValue$value$split2[1];
              tag = createJsxNamespacedName(
                instrValue.tag.loc,
                createJsxIdentifier(instrValue.tag.loc, namespace),
                createJsxIdentifier(instrValue.tag.loc, _name8)
              );
            } else {
              tag = createJsxIdentifier(instrValue.loc, tagValue.value);
            }
          }
          var children;
          if (
            tagValue.type === "StringLiteral" &&
            SINGLE_CHILD_FBT_TAGS.has(tagValue.value)
          ) {
            CompilerError.invariant(instrValue.children != null, {
              loc: instrValue.loc,
              reason: "Expected fbt element to have children",
              suggestions: null,
              description: null
            });
            children = instrValue.children.map(function (child) {
              return codegenJsxFbtChildElement(cx, child);
            });
          } else {
            children =
              instrValue.children !== null
                ? instrValue.children.map(function (child) {
                    return codegenJsxElement(cx, child);
                  })
                : [];
          }
          value = createJsxElement(
            instrValue.loc,
            createJsxOpeningElement(
              instrValue.openingLoc,
              tag,
              attributes,
              instrValue.children === null
            ),
            instrValue.children !== null
              ? createJsxClosingElement(instrValue.closingLoc, tag)
              : null,
            children,
            instrValue.children === null
          );
          break;
        }
        case "JsxFragment": {
          value = libExports.jsxFragment(
            libExports.jsxOpeningFragment(),
            libExports.jsxClosingFragment(),
            instrValue.children.map(function (child) {
              return codegenJsxElement(cx, child);
            })
          );
          break;
        }
        case "UnsupportedNode": {
          var _node10 = instrValue.node;
          if (!libExports.isExpression(_node10)) {
            return _node10;
          }
          value = _node10;
          break;
        }
        case "PropertyStore":
        case "PropertyLoad":
        case "PropertyDelete": {
          var _memberExpr;
          if (typeof instrValue.property === "string") {
            _memberExpr = libExports.memberExpression(
              codegenPlaceToExpression(cx, instrValue.object),
              libExports.identifier(instrValue.property)
            );
          } else {
            _memberExpr = libExports.memberExpression(
              codegenPlaceToExpression(cx, instrValue.object),
              libExports.numericLiteral(instrValue.property),
              true
            );
          }
          if (instrValue.kind === "PropertyStore") {
            value = libExports.assignmentExpression(
              "=",
              _memberExpr,
              codegenPlaceToExpression(cx, instrValue.value)
            );
          } else if (instrValue.kind === "PropertyLoad") {
            value = _memberExpr;
          } else {
            value = libExports.unaryExpression("delete", _memberExpr);
          }
          break;
        }
        case "ComputedStore": {
          value = libExports.assignmentExpression(
            "=",
            libExports.memberExpression(
              codegenPlaceToExpression(cx, instrValue.object),
              codegenPlaceToExpression(cx, instrValue.property),
              true
            ),
            codegenPlaceToExpression(cx, instrValue.value)
          );
          break;
        }
        case "ComputedLoad": {
          var object = codegenPlaceToExpression(cx, instrValue.object);
          var _property10 = codegenPlaceToExpression(cx, instrValue.property);
          value = libExports.memberExpression(object, _property10, true);
          break;
        }
        case "ComputedDelete": {
          value = libExports.unaryExpression(
            "delete",
            libExports.memberExpression(
              codegenPlaceToExpression(cx, instrValue.object),
              codegenPlaceToExpression(cx, instrValue.property),
              true
            )
          );
          break;
        }
        case "LoadLocal":
        case "LoadContext": {
          value = codegenPlaceToExpression(cx, instrValue.place);
          break;
        }
        case "FunctionExpression": {
          var _loweredFunc = instrValue.loweredFunc.func;
          var _reactiveFunction = buildReactiveFunction(_loweredFunc);
          pruneUnusedLabels(_reactiveFunction);
          pruneUnusedLValues(_reactiveFunction);
          pruneHoistedContexts(_reactiveFunction);
          var _fn2 = codegenReactiveFunction(
            new Context$2(
              cx.env,
              (_g = _reactiveFunction.id) !== null && _g !== void 0
                ? _g
                : "[[ anonymous ]]",
              cx.uniqueIdentifiers,
              cx.fbtOperands,
              cx.temp
            ),
            _reactiveFunction
          ).unwrap();
          if (instrValue.type === "ArrowFunctionExpression") {
            var body = _fn2.body;
            if (body.body.length === 1 && _loweredFunc.directives.length == 0) {
              var stmt = body.body[0];
              if (stmt.type === "ReturnStatement" && stmt.argument != null) {
                body = stmt.argument;
              }
            }
            value = libExports.arrowFunctionExpression(
              _fn2.params,
              body,
              _fn2.async
            );
          } else {
            value = libExports.functionExpression(
              (_h = _fn2.id) !== null && _h !== void 0
                ? _h
                : instrValue.name != null
                  ? libExports.identifier(instrValue.name)
                  : null,
              _fn2.params,
              _fn2.body,
              _fn2.generator,
              _fn2.async
            );
          }
          break;
        }
        case "TaggedTemplateExpression": {
          value = createTaggedTemplateExpression(
            instrValue.loc,
            codegenPlaceToExpression(cx, instrValue.tag),
            libExports.templateLiteral(
              [libExports.templateElement(instrValue.value)],
              []
            )
          );
          break;
        }
        case "TypeCastExpression": {
          if (libExports.isTSType(instrValue.typeAnnotation)) {
            value = libExports.tsAsExpression(
              codegenPlaceToExpression(cx, instrValue.value),
              instrValue.typeAnnotation
            );
          } else {
            value = libExports.typeCastExpression(
              codegenPlaceToExpression(cx, instrValue.value),
              libExports.typeAnnotation(instrValue.typeAnnotation)
            );
          }
          break;
        }
        case "LogicalExpression": {
          value = createLogicalExpression(
            instrValue.loc,
            instrValue.operator,
            codegenInstructionValueToExpression(cx, instrValue.left),
            codegenInstructionValueToExpression(cx, instrValue.right)
          );
          break;
        }
        case "ConditionalExpression": {
          value = createConditionalExpression(
            instrValue.loc,
            codegenInstructionValueToExpression(cx, instrValue.test),
            codegenInstructionValueToExpression(cx, instrValue.consequent),
            codegenInstructionValueToExpression(cx, instrValue.alternate)
          );
          break;
        }
        case "SequenceExpression": {
          var _body = codegenBlockNoReset(
            cx,
            instrValue.instructions.map(function (instruction) {
              return { kind: "instruction", instruction: instruction };
            })
          ).body;
          var _expressions2 = _body.map(function (stmt) {
            var _a, _b;
            if (stmt.type === "ExpressionStatement") {
              return stmt.expression;
            } else {
              if (libExports.isVariableDeclaration(stmt)) {
                var declarator = stmt.declarations[0];
                cx.errors.push({
                  reason:
                    "(CodegenReactiveFunction::codegenInstructionValue) Cannot declare variables in a value block, tried to declare '".concat(
                      declarator.id.name,
                      "'"
                    ),
                  severity: ErrorSeverity.Todo,
                  loc:
                    (_a = declarator.loc) !== null && _a !== void 0 ? _a : null,
                  suggestions: null
                });
                return libExports.stringLiteral(
                  "TODO handle ".concat(declarator.id)
                );
              } else {
                cx.errors.push({
                  reason:
                    "(CodegenReactiveFunction::codegenInstructionValue) Handle conversion of ".concat(
                      stmt.type,
                      " to expression"
                    ),
                  severity: ErrorSeverity.Todo,
                  loc: (_b = stmt.loc) !== null && _b !== void 0 ? _b : null,
                  suggestions: null
                });
                return libExports.stringLiteral(
                  "TODO handle ".concat(stmt.type)
                );
              }
            }
          });
          if (_expressions2.length === 0) {
            value = codegenInstructionValueToExpression(cx, instrValue.value);
          } else {
            value = createSequenceExpression(
              instrValue.loc,
              [].concat(_toConsumableArray(_expressions2), [
                codegenInstructionValueToExpression(cx, instrValue.value)
              ])
            );
          }
          break;
        }
        case "TemplateLiteral": {
          value = createTemplateLiteral(
            instrValue.loc,
            instrValue.quasis.map(function (q) {
              return libExports.templateElement(q);
            }),
            instrValue.subexprs.map(function (p) {
              return codegenPlaceToExpression(cx, p);
            })
          );
          break;
        }
        case "LoadGlobal": {
          value = libExports.identifier(instrValue.binding.name);
          break;
        }
        case "RegExpLiteral": {
          value = libExports.regExpLiteral(
            instrValue.pattern,
            instrValue.flags
          );
          break;
        }
        case "MetaProperty": {
          value = libExports.metaProperty(
            libExports.identifier(instrValue.meta),
            libExports.identifier(instrValue.property)
          );
          break;
        }
        case "Await": {
          value = libExports.awaitExpression(
            codegenPlaceToExpression(cx, instrValue.value)
          );
          break;
        }
        case "GetIterator": {
          value = codegenPlaceToExpression(cx, instrValue.collection);
          break;
        }
        case "IteratorNext": {
          value = codegenPlaceToExpression(cx, instrValue.iterator);
          break;
        }
        case "NextPropertyOf": {
          value = codegenPlaceToExpression(cx, instrValue.value);
          break;
        }
        case "PostfixUpdate": {
          value = libExports.updateExpression(
            instrValue.operation,
            codegenPlaceToExpression(cx, instrValue.lvalue),
            false
          );
          break;
        }
        case "PrefixUpdate": {
          value = libExports.updateExpression(
            instrValue.operation,
            codegenPlaceToExpression(cx, instrValue.lvalue),
            true
          );
          break;
        }
        case "StoreLocal": {
          CompilerError.invariant(
            instrValue.lvalue.kind === InstructionKind.Reassign,
            {
              reason: "Unexpected StoreLocal in codegenInstructionValue",
              description: null,
              loc: instrValue.loc,
              suggestions: null
            }
          );
          value = libExports.assignmentExpression(
            "=",
            codegenLValue(cx, instrValue.lvalue.place),
            codegenPlaceToExpression(cx, instrValue.value)
          );
          break;
        }
        case "StoreGlobal": {
          value = libExports.assignmentExpression(
            "=",
            libExports.identifier(instrValue.name),
            codegenPlaceToExpression(cx, instrValue.value)
          );
          break;
        }
        case "StartMemoize":
        case "FinishMemoize":
        case "Debugger":
        case "DeclareLocal":
        case "DeclareContext":
        case "Destructure":
        case "ObjectMethod":
        case "StoreContext": {
          CompilerError.invariant(false, {
            reason: "Unexpected ".concat(
              instrValue.kind,
              " in codegenInstructionValue"
            ),
            description: null,
            loc: instrValue.loc,
            suggestions: null
          });
        }
        default: {
          assertExhaustive$1(
            instrValue,
            "Unexpected instruction value kind `".concat(instrValue.kind, "`")
          );
        }
      }
      return value;
    }
    var STRING_REQUIRES_EXPR_CONTAINER_PATTERN = /[\0-\x1F\x7F-\uFFFF]|"|\\/;
    function codegenJsxAttribute(cx, attribute) {
      switch (attribute.kind) {
        case "JsxAttribute": {
          var propName;
          if (attribute.name.indexOf(":") === -1) {
            propName = createJsxIdentifier(attribute.place.loc, attribute.name);
          } else {
            var _attribute$name$split = attribute.name.split(":", 2),
              _attribute$name$split2 = _slicedToArray(_attribute$name$split, 2),
              namespace = _attribute$name$split2[0],
              _name9 = _attribute$name$split2[1];
            propName = createJsxNamespacedName(
              attribute.place.loc,
              createJsxIdentifier(attribute.place.loc, namespace),
              createJsxIdentifier(attribute.place.loc, _name9)
            );
          }
          var innerValue = codegenPlaceToExpression(cx, attribute.place);
          var value;
          switch (innerValue.type) {
            case "StringLiteral": {
              value = innerValue;
              if (
                STRING_REQUIRES_EXPR_CONTAINER_PATTERN.test(value.value) &&
                !cx.fbtOperands.has(attribute.place.identifier.id)
              ) {
                value = createJsxExpressionContainer(value.loc, value);
              }
              break;
            }
            default: {
              value = createJsxExpressionContainer(
                attribute.place.loc,
                innerValue
              );
              break;
            }
          }
          return createJsxAttribute(attribute.place.loc, propName, value);
        }
        case "JsxSpreadAttribute": {
          return libExports.jsxSpreadAttribute(
            codegenPlaceToExpression(cx, attribute.argument)
          );
        }
        default: {
          assertExhaustive$1(
            attribute,
            "Unexpected attribute kind `".concat(attribute.kind, "`")
          );
        }
      }
    }
    var JSX_TEXT_CHILD_REQUIRES_EXPR_CONTAINER_PATTERN = /[<>&{}]/;
    function codegenJsxElement(cx, place) {
      var value = codegenPlace(cx, place);
      switch (value.type) {
        case "JSXText": {
          if (
            JSX_TEXT_CHILD_REQUIRES_EXPR_CONTAINER_PATTERN.test(value.value)
          ) {
            return createJsxExpressionContainer(
              place.loc,
              createStringLiteral(place.loc, value.value)
            );
          }
          return createJsxText(place.loc, value.value);
        }
        case "JSXElement":
        case "JSXFragment": {
          return value;
        }
        default: {
          return createJsxExpressionContainer(place.loc, value);
        }
      }
    }
    function codegenJsxFbtChildElement(cx, place) {
      var value = codegenPlace(cx, place);
      switch (value.type) {
        case "JSXText":
        case "JSXElement": {
          return value;
        }
        default: {
          return createJsxExpressionContainer(place.loc, value);
        }
      }
    }
    function convertMemberExpressionToJsx(expr) {
      var _a, _b;
      CompilerError.invariant(expr.property.type === "Identifier", {
        reason: "Expected JSX member expression property to be a string",
        description: null,
        loc: (_a = expr.loc) !== null && _a !== void 0 ? _a : null,
        suggestions: null
      });
      var property = libExports.jsxIdentifier(expr.property.name);
      if (expr.object.type === "Identifier") {
        return libExports.jsxMemberExpression(
          libExports.jsxIdentifier(expr.object.name),
          property
        );
      } else {
        CompilerError.invariant(expr.object.type === "MemberExpression", {
          reason:
            "Expected JSX member expression to be an identifier or nested member expression",
          description: null,
          loc: (_b = expr.object.loc) !== null && _b !== void 0 ? _b : null,
          suggestions: null
        });
        var object = convertMemberExpressionToJsx(expr.object);
        return libExports.jsxMemberExpression(object, property);
      }
    }
    function codegenObjectPropertyKey(cx, key) {
      switch (key.kind) {
        case "string": {
          return libExports.stringLiteral(key.name);
        }
        case "identifier": {
          return libExports.identifier(key.name);
        }
        case "computed": {
          var expr = codegenPlace(cx, key.name);
          CompilerError.invariant(libExports.isExpression(expr), {
            reason: "Expected object property key to be an expression",
            description: null,
            loc: key.name.loc,
            suggestions: null
          });
          return expr;
        }
      }
    }
    function codegenArrayPattern(cx, pattern) {
      var hasHoles = !pattern.items.every(function (e) {
        return e.kind !== "Hole";
      });
      if (hasHoles) {
        var result = libExports.arrayPattern([]);
        var _iterator261 = _createForOfIteratorHelper(pattern.items),
          _step261;
        try {
          for (_iterator261.s(); !(_step261 = _iterator261.n()).done; ) {
            var item = _step261.value;
            if (item.kind === "Hole") {
              result.elements.push(null);
            } else {
              result.elements.push(codegenLValue(cx, item));
            }
          }
        } catch (err) {
          _iterator261.e(err);
        } finally {
          _iterator261.f();
        }
        return result;
      } else {
        return libExports.arrayPattern(
          pattern.items.map(function (item) {
            if (item.kind === "Hole") {
              return null;
            }
            return codegenLValue(cx, item);
          })
        );
      }
    }
    function codegenLValue(cx, pattern) {
      switch (pattern.kind) {
        case "ArrayPattern": {
          return codegenArrayPattern(cx, pattern);
        }
        case "ObjectPattern": {
          return libExports.objectPattern(
            pattern.properties.map(function (property) {
              if (property.kind === "ObjectProperty") {
                var _key35 = codegenObjectPropertyKey(cx, property.key);
                var value = codegenLValue(cx, property.place);
                return libExports.objectProperty(
                  _key35,
                  value,
                  property.key.kind === "computed",
                  _key35.type === "Identifier" &&
                    value.type === "Identifier" &&
                    value.name === _key35.name
                );
              } else {
                return libExports.restElement(
                  codegenLValue(cx, property.place)
                );
              }
            })
          );
        }
        case "Spread": {
          return libExports.restElement(codegenLValue(cx, pattern.place));
        }
        case "Identifier": {
          return convertIdentifier(pattern.identifier);
        }
        default: {
          assertExhaustive$1(
            pattern,
            "Unexpected pattern kind `".concat(pattern.kind, "`")
          );
        }
      }
    }
    function codegenValue(cx, loc, value) {
      if (typeof value === "number") {
        return libExports.numericLiteral(value);
      } else if (typeof value === "boolean") {
        return libExports.booleanLiteral(value);
      } else if (typeof value === "string") {
        return createStringLiteral(loc, value);
      } else if (value === null) {
        return libExports.nullLiteral();
      } else if (value === undefined) {
        return libExports.identifier("undefined");
      } else {
        assertExhaustive$1(value, "Unexpected primitive value kind");
      }
    }
    function codegenArgument(cx, arg) {
      if (arg.kind === "Identifier") {
        return codegenPlaceToExpression(cx, arg);
      } else {
        return libExports.spreadElement(
          codegenPlaceToExpression(cx, arg.place)
        );
      }
    }
    function codegenPlaceToExpression(cx, place) {
      var value = codegenPlace(cx, place);
      return convertValueToExpression(value);
    }
    function codegenPlace(cx, place) {
      var tmp = cx.temp.get(place.identifier.declarationId);
      if (tmp != null) {
        return tmp;
      }
      CompilerError.invariant(
        place.identifier.name !== null || tmp !== undefined,
        {
          reason: "[Codegen] No value found for temporary",
          description: "Value for '".concat(
            printPlace(place),
            "' was not set in the codegen context"
          ),
          loc: place.loc,
          suggestions: null
        }
      );
      var identifier = convertIdentifier(place.identifier);
      identifier.loc = place.loc;
      return identifier;
    }
    function convertIdentifier(identifier) {
      CompilerError.invariant(
        identifier.name !== null && identifier.name.kind === "named",
        {
          reason:
            "Expected temporaries to be promoted to named identifiers in an earlier pass",
          loc: GeneratedSource,
          description: "identifier ".concat(identifier.id, " is unnamed"),
          suggestions: null
        }
      );
      return libExports.identifier(identifier.name.value);
    }
    function compareScopeDependency(a, b) {
      var _a, _b;
      CompilerError.invariant(
        ((_a = a.identifier.name) === null || _a === void 0
          ? void 0
          : _a.kind) === "named" &&
          ((_b = b.identifier.name) === null || _b === void 0
            ? void 0
            : _b.kind) === "named",
        {
          reason: "[Codegen] Expected named identifier for dependency",
          loc: a.identifier.loc
        }
      );
      var aName = [a.identifier.name.value]
        .concat(
          _toConsumableArray(
            a.path.map(function (entry) {
              return ""
                .concat(entry.optional ? "?" : "")
                .concat(entry.property);
            })
          )
        )
        .join(".");
      var bName = [b.identifier.name.value]
        .concat(
          _toConsumableArray(
            b.path.map(function (entry) {
              return ""
                .concat(entry.optional ? "?" : "")
                .concat(entry.property);
            })
          )
        )
        .join(".");
      if (aName < bName) return -1;
      else if (aName > bName) return 1;
      else return 0;
    }
    function compareScopeDeclaration(a, b) {
      var _a, _b;
      CompilerError.invariant(
        ((_a = a.identifier.name) === null || _a === void 0
          ? void 0
          : _a.kind) === "named" &&
          ((_b = b.identifier.name) === null || _b === void 0
            ? void 0
            : _b.kind) === "named",
        {
          reason: "[Codegen] Expected named identifier for declaration",
          loc: a.identifier.loc
        }
      );
      var aName = a.identifier.name.value;
      var bName = b.identifier.name.value;
      if (aName < bName) return -1;
      else if (aName > bName) return 1;
      else return 0;
    }
    function extractScopeDeclarationsFromDestructuring(fn) {
      var state = new State$1(fn.env);
      visitReactiveFunction(fn, new Visitor$9(), state);
    }
    var State$1 = /*#__PURE__*/ _createClass(function State(env) {
      _classCallCheck(this, State);
      this.declared = new Set();
      this.env = env;
    });
    var Visitor$9 = /*#__PURE__*/ (function (_ReactiveFunctionTran) {
      function Visitor() {
        _classCallCheck(this, Visitor);
        return _callSuper(this, Visitor, arguments);
      }
      _inherits2(Visitor, _ReactiveFunctionTran);
      return _createClass(Visitor, [
        {
          key: "visitScope",
          value: function visitScope(scope, state) {
            var _iterator262 = _createForOfIteratorHelper(
                scope.scope.declarations
              ),
              _step262;
            try {
              for (_iterator262.s(); !(_step262 = _iterator262.n()).done; ) {
                var _step262$value = _slicedToArray(_step262.value, 2),
                  declaration = _step262$value[1];
                state.declared.add(declaration.identifier.declarationId);
              }
            } catch (err) {
              _iterator262.e(err);
            } finally {
              _iterator262.f();
            }
            this.traverseScope(scope, state);
          }
        },
        {
          key: "transformInstruction",
          value: function transformInstruction(instruction, state) {
            this.visitInstruction(instruction, state);
            if (instruction.value.kind === "Destructure") {
              var transformed = transformDestructuring(
                state,
                instruction,
                instruction.value
              );
              if (transformed) {
                return {
                  kind: "replace-many",
                  value: transformed.map(function (instruction) {
                    return { kind: "instruction", instruction: instruction };
                  })
                };
              }
            }
            return { kind: "keep" };
          }
        }
      ]);
    })(ReactiveFunctionTransform);
    function transformDestructuring(state, instr, destructure) {
      var reassigned = new Set();
      var hasDeclaration = false;
      var _iterator263 = _createForOfIteratorHelper(
          eachPatternOperand(destructure.lvalue.pattern)
        ),
        _step263;
      try {
        for (_iterator263.s(); !(_step263 = _iterator263.n()).done; ) {
          var place = _step263.value;
          var isDeclared = state.declared.has(place.identifier.declarationId);
          if (isDeclared) {
            reassigned.add(place.identifier.id);
          }
          hasDeclaration || (hasDeclaration = !isDeclared);
        }
      } catch (err) {
        _iterator263.e(err);
      } finally {
        _iterator263.f();
      }
      if (reassigned.size === 0 || !hasDeclaration) {
        return null;
      }
      var instructions = [];
      var renamed = new Map();
      mapPatternOperands(destructure.lvalue.pattern, function (place) {
        if (!reassigned.has(place.identifier.id)) {
          return place;
        }
        var temporary = clonePlaceToTemporary(state.env, place);
        promoteTemporary(temporary.identifier);
        renamed.set(place, temporary);
        return temporary;
      });
      instructions.push(instr);
      var _iterator264 = _createForOfIteratorHelper(renamed),
        _step264;
      try {
        for (_iterator264.s(); !(_step264 = _iterator264.n()).done; ) {
          var _step264$value = _slicedToArray(_step264.value, 2),
            original = _step264$value[0],
            temporary = _step264$value[1];
          instructions.push({
            id: instr.id,
            lvalue: null,
            value: {
              kind: "StoreLocal",
              lvalue: { kind: InstructionKind.Reassign, place: original },
              value: temporary,
              type: null,
              loc: destructure.loc
            },
            loc: instr.loc
          });
        }
      } catch (err) {
        _iterator264.e(err);
      } finally {
        _iterator264.f();
      }
      return instructions;
    }
    function mergeReactiveScopesThatInvalidateTogether(fn) {
      var lastUsageVisitor = new FindLastUsageVisitor();
      visitReactiveFunction(fn, lastUsageVisitor, undefined);
      visitReactiveFunction(
        fn,
        new Transform$4(lastUsageVisitor.lastUsage),
        null
      );
    }
    function log(msg) {}
    var FindLastUsageVisitor = /*#__PURE__*/ (function (
      _ReactiveFunctionVisi6
    ) {
      function FindLastUsageVisitor() {
        var _this11;
        _classCallCheck(this, FindLastUsageVisitor);
        _this11 = _callSuper(this, FindLastUsageVisitor, arguments);
        _this11.lastUsage = new Map();
        return _this11;
      }
      _inherits2(FindLastUsageVisitor, _ReactiveFunctionVisi6);
      return _createClass(FindLastUsageVisitor, [
        {
          key: "visitPlace",
          value: function visitPlace(id, place, _state) {
            var previousUsage = this.lastUsage.get(
              place.identifier.declarationId
            );
            var lastUsage =
              previousUsage !== undefined
                ? makeInstructionId(Math.max(previousUsage, id))
                : id;
            this.lastUsage.set(place.identifier.declarationId, lastUsage);
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    var Transform$4 = /*#__PURE__*/ (function (_ReactiveFunctionTran2) {
      function Transform(lastUsage) {
        var _this12;
        _classCallCheck(this, Transform);
        _this12 = _callSuper(this, Transform);
        _this12.lastUsage = lastUsage;
        return _this12;
      }
      _inherits2(Transform, _ReactiveFunctionTran2);
      return _createClass(Transform, [
        {
          key: "transformScope",
          value: function transformScope(scopeBlock, state) {
            this.visitScope(scopeBlock, scopeBlock.scope.dependencies);
            if (
              state !== null &&
              areEqualDependencies(state, scopeBlock.scope.dependencies)
            ) {
              return { kind: "replace-many", value: scopeBlock.instructions };
            } else {
              return { kind: "keep" };
            }
          }
        },
        {
          key: "visitBlock",
          value: function visitBlock(block, state) {
            this.traverseBlock(block, state);
            var current = null;
            var merged = [];
            function reset() {
              CompilerError.invariant(current !== null, {
                loc: null,
                reason:
                  "MergeConsecutiveScopes: expected current scope to be non-null if reset()",
                suggestions: null,
                description: null
              });
              if (current.to > current.from + 1) {
                merged.push(current);
              }
              current = null;
            }
            for (var i = 0; i < block.length; i++) {
              var instr = block[i];
              switch (instr.kind) {
                case "terminal": {
                  if (current !== null) {
                    reset();
                  }
                  break;
                }
                case "pruned-scope": {
                  if (current !== null) {
                    reset();
                  }
                  break;
                }
                case "instruction": {
                  switch (instr.instruction.value.kind) {
                    case "BinaryExpression":
                    case "ComputedLoad":
                    case "JSXText":
                    case "LoadGlobal":
                    case "LoadLocal":
                    case "Primitive":
                    case "PropertyLoad":
                    case "TemplateLiteral":
                    case "UnaryExpression": {
                      if (
                        current !== null &&
                        instr.instruction.lvalue !== null
                      ) {
                        current.lvalues.add(
                          instr.instruction.lvalue.identifier.declarationId
                        );
                      }
                      break;
                    }
                    case "StoreLocal": {
                      if (current !== null) {
                        if (
                          instr.instruction.value.lvalue.kind ===
                          InstructionKind.Const
                        ) {
                          var _iterator265 = _createForOfIteratorHelper(
                              eachInstructionLValue(instr.instruction)
                            ),
                            _step265;
                          try {
                            for (
                              _iterator265.s();
                              !(_step265 = _iterator265.n()).done;

                            ) {
                              var lvalue = _step265.value;
                              current.lvalues.add(
                                lvalue.identifier.declarationId
                              );
                            }
                          } catch (err) {
                            _iterator265.e(err);
                          } finally {
                            _iterator265.f();
                          }
                        } else {
                          reset();
                        }
                      }
                      break;
                    }
                    default: {
                      if (current !== null) {
                        reset();
                      }
                    }
                  }
                  break;
                }
                case "scope": {
                  if (
                    current !== null &&
                    canMergeScopes(current.block, instr) &&
                    areLValuesLastUsedByScope(
                      instr.scope,
                      current.lvalues,
                      this.lastUsage
                    )
                  ) {
                    current.block.scope.range.end = makeInstructionId(
                      Math.max(
                        current.block.scope.range.end,
                        instr.scope.range.end
                      )
                    );
                    var _iterator266 = _createForOfIteratorHelper(
                        instr.scope.declarations
                      ),
                      _step266;
                    try {
                      for (
                        _iterator266.s();
                        !(_step266 = _iterator266.n()).done;

                      ) {
                        var _step266$value = _slicedToArray(_step266.value, 2),
                          _key36 = _step266$value[0],
                          value = _step266$value[1];
                        current.block.scope.declarations.set(_key36, value);
                      }
                    } catch (err) {
                      _iterator266.e(err);
                    } finally {
                      _iterator266.f();
                    }
                    updateScopeDeclarations(
                      current.block.scope,
                      this.lastUsage
                    );
                    current.to = i + 1;
                    current.lvalues.clear();
                    if (!scopeIsEligibleForMerging(instr)) {
                      reset();
                    }
                  } else {
                    if (current !== null) {
                      reset();
                    }
                    if (scopeIsEligibleForMerging(instr)) {
                      current = {
                        block: instr,
                        from: i,
                        to: i + 1,
                        lvalues: new Set()
                      };
                    }
                  }
                  break;
                }
                default: {
                  assertExhaustive$1(
                    instr,
                    "Unexpected instruction kind `".concat(instr.kind, "`")
                  );
                }
              }
            }
            if (current !== null) {
              reset();
            }
            if (merged.length) {
              var _iterator267 = _createForOfIteratorHelper(merged),
                _step267;
              try {
                for (_iterator267.s(); !(_step267 = _iterator267.n()).done; ) {
                  var entry = _step267.value;
                  log(
                    printReactiveScopeSummary(entry.block.scope) +
                      " from=".concat(entry.from, " to=").concat(entry.to)
                  );
                }
              } catch (err) {
                _iterator267.e(err);
              } finally {
                _iterator267.f();
              }
            }
            if (merged.length === 0) {
              return;
            }
            var nextInstructions = [];
            var index = 0;
            for (
              var _i37 = 0, _merged2 = merged;
              _i37 < _merged2.length;
              _i37++
            ) {
              var _entry = _merged2[_i37];
              if (index < _entry.from) {
                nextInstructions.push.apply(
                  nextInstructions,
                  _toConsumableArray(block.slice(index, _entry.from))
                );
                index = _entry.from;
              }
              var mergedScope = block[_entry.from];
              CompilerError.invariant(mergedScope.kind === "scope", {
                loc: null,
                reason:
                  "MergeConsecutiveScopes: Expected scope starting index to be a scope",
                description: null,
                suggestions: null
              });
              nextInstructions.push(mergedScope);
              index++;
              while (index < _entry.to) {
                var _instr6 = block[index++];
                if (_instr6.kind === "scope") {
                  var _mergedScope$instruct;
                  (_mergedScope$instruct = mergedScope.instructions).push.apply(
                    _mergedScope$instruct,
                    _toConsumableArray(_instr6.instructions)
                  );
                  mergedScope.scope.merged.add(_instr6.scope.id);
                } else {
                  mergedScope.instructions.push(_instr6);
                }
              }
            }
            while (index < block.length) {
              nextInstructions.push(block[index++]);
            }
            block.length = 0;
            block.push.apply(block, nextInstructions);
          }
        }
      ]);
    })(ReactiveFunctionTransform);
    function updateScopeDeclarations(scope, lastUsage) {
      var _iterator268 = _createForOfIteratorHelper(scope.declarations),
        _step268;
      try {
        for (_iterator268.s(); !(_step268 = _iterator268.n()).done; ) {
          var _step268$value = _slicedToArray(_step268.value, 2),
            id = _step268$value[0],
            decl = _step268$value[1];
          var lastUsedAt = lastUsage.get(decl.identifier.declarationId);
          if (lastUsedAt < scope.range.end) {
            scope.declarations["delete"](id);
          }
        }
      } catch (err) {
        _iterator268.e(err);
      } finally {
        _iterator268.f();
      }
    }
    function areLValuesLastUsedByScope(scope, lvalues, lastUsage) {
      var _iterator269 = _createForOfIteratorHelper(lvalues),
        _step269;
      try {
        for (_iterator269.s(); !(_step269 = _iterator269.n()).done; ) {
          var lvalue = _step269.value;
          var lastUsedAt = lastUsage.get(lvalue);
          if (lastUsedAt >= scope.range.end) {
            return false;
          }
        }
      } catch (err) {
        _iterator269.e(err);
      } finally {
        _iterator269.f();
      }
      return true;
    }
    function canMergeScopes(current, next) {
      if (
        current.scope.reassignments.size !== 0 ||
        next.scope.reassignments.size !== 0
      ) {
        return false;
      }
      if (
        areEqualDependencies(
          current.scope.dependencies,
          next.scope.dependencies
        )
      ) {
        return true;
      }
      if (
        areEqualDependencies(
          new Set(
            _toConsumableArray(current.scope.declarations.values()).map(
              function (declaration) {
                return { identifier: declaration.identifier, path: [] };
              }
            )
          ),
          next.scope.dependencies
        ) ||
        (next.scope.dependencies.size !== 0 &&
          _toConsumableArray(next.scope.dependencies).every(function (dep) {
            return (
              isAlwaysInvalidatingType(dep.identifier.type) &&
              Iterable_some(
                current.scope.declarations.values(),
                function (decl) {
                  return (
                    decl.identifier.declarationId ===
                    dep.identifier.declarationId
                  );
                }
              )
            );
          }))
      ) {
        return true;
      }
      log("  ".concat(printReactiveScopeSummary(current.scope)));
      log("  ".concat(printReactiveScopeSummary(next.scope)));
      return false;
    }
    function isAlwaysInvalidatingType(type) {
      switch (type.kind) {
        case "Object": {
          switch (type.shapeId) {
            case BuiltInArrayId:
            case BuiltInObjectId:
            case BuiltInFunctionId:
            case BuiltInJsxId: {
              return true;
            }
          }
          break;
        }
        case "Function": {
          return true;
        }
      }
      return false;
    }
    function areEqualDependencies(a, b) {
      if (a.size !== b.size) {
        return false;
      }
      var _iterator270 = _createForOfIteratorHelper(a),
        _step270;
      try {
        for (_iterator270.s(); !(_step270 = _iterator270.n()).done; ) {
          var aValue = _step270.value;
          var found = false;
          var _iterator271 = _createForOfIteratorHelper(b),
            _step271;
          try {
            for (_iterator271.s(); !(_step271 = _iterator271.n()).done; ) {
              var bValue = _step271.value;
              if (
                aValue.identifier.declarationId ===
                  bValue.identifier.declarationId &&
                areEqualPaths(aValue.path, bValue.path)
              ) {
                found = true;
                break;
              }
            }
          } catch (err) {
            _iterator271.e(err);
          } finally {
            _iterator271.f();
          }
          if (!found) {
            return false;
          }
        }
      } catch (err) {
        _iterator270.e(err);
      } finally {
        _iterator270.f();
      }
      return true;
    }
    function scopeIsEligibleForMerging(scopeBlock) {
      if (scopeBlock.scope.dependencies.size === 0) {
        return true;
      }
      return _toConsumableArray(scopeBlock.scope.declarations).some(
        function (_ref37) {
          var _ref38 = _slicedToArray(_ref37, 2),
            decl = _ref38[1];
          return isAlwaysInvalidatingType(decl.identifier.type);
        }
      );
    }
    var _PromoteInterposedTemporaries_promotable,
      _PromoteInterposedTemporaries_consts,
      _PromoteInterposedTemporaries_globals;
    var PromoteTemporaries = /*#__PURE__*/ (function (_ReactiveFunctionVisi7) {
      function PromoteTemporaries() {
        _classCallCheck(this, PromoteTemporaries);
        return _callSuper(this, PromoteTemporaries, arguments);
      }
      _inherits2(PromoteTemporaries, _ReactiveFunctionVisi7);
      return _createClass(PromoteTemporaries, [
        {
          key: "visitScope",
          value: function visitScope(scopeBlock, state) {
            var _iterator272 = _createForOfIteratorHelper(
                scopeBlock.scope.dependencies
              ),
              _step272;
            try {
              for (_iterator272.s(); !(_step272 = _iterator272.n()).done; ) {
                var dep = _step272.value;
                var _identifier12 = dep.identifier;
                if (_identifier12.name == null) {
                  promoteIdentifier(_identifier12, state);
                }
              }
            } catch (err) {
              _iterator272.e(err);
            } finally {
              _iterator272.f();
            }
            var _iterator273 = _createForOfIteratorHelper(
                scopeBlock.scope.declarations
              ),
              _step273;
            try {
              for (_iterator273.s(); !(_step273 = _iterator273.n()).done; ) {
                var _step273$value = _slicedToArray(_step273.value, 2),
                  declaration = _step273$value[1];
                if (declaration.identifier.name == null) {
                  promoteIdentifier(declaration.identifier, state);
                }
              }
            } catch (err) {
              _iterator273.e(err);
            } finally {
              _iterator273.f();
            }
            this.traverseScope(scopeBlock, state);
          }
        },
        {
          key: "visitPrunedScope",
          value: function visitPrunedScope(scopeBlock, state) {
            var _a;
            var _iterator274 = _createForOfIteratorHelper(
                scopeBlock.scope.declarations
              ),
              _step274;
            try {
              for (_iterator274.s(); !(_step274 = _iterator274.n()).done; ) {
                var _step274$value = _slicedToArray(_step274.value, 2),
                  declaration = _step274$value[1];
                if (
                  declaration.identifier.name == null &&
                  ((_a = state.pruned.get(
                    declaration.identifier.declarationId
                  )) === null || _a === void 0
                    ? void 0
                    : _a.usedOutsideScope) === true
                ) {
                  promoteIdentifier(declaration.identifier, state);
                }
              }
            } catch (err) {
              _iterator274.e(err);
            } finally {
              _iterator274.f();
            }
            this.traversePrunedScope(scopeBlock, state);
          }
        },
        {
          key: "visitParam",
          value: function visitParam(place, state) {
            if (place.identifier.name === null) {
              promoteIdentifier(place.identifier, state);
            }
          }
        },
        {
          key: "visitValue",
          value: function visitValue(id, value, state) {
            this.traverseValue(id, value, state);
            if (
              value.kind === "FunctionExpression" ||
              value.kind === "ObjectMethod"
            ) {
              this.visitHirFunction(value.loweredFunc.func, state);
            }
          }
        },
        {
          key: "visitReactiveFunctionValue",
          value: function visitReactiveFunctionValue(
            _id,
            _dependencies,
            fn,
            state
          ) {
            var _iterator275 = _createForOfIteratorHelper(fn.params),
              _step275;
            try {
              for (_iterator275.s(); !(_step275 = _iterator275.n()).done; ) {
                var operand = _step275.value;
                var place =
                  operand.kind === "Identifier" ? operand : operand.place;
                if (place.identifier.name === null) {
                  promoteIdentifier(place.identifier, state);
                }
              }
            } catch (err) {
              _iterator275.e(err);
            } finally {
              _iterator275.f();
            }
            visitReactiveFunction(fn, this, state);
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    var PromoteAllInstancedOfPromotedTemporaries = /*#__PURE__*/ (function (
      _ReactiveFunctionVisi8
    ) {
      function PromoteAllInstancedOfPromotedTemporaries() {
        _classCallCheck(this, PromoteAllInstancedOfPromotedTemporaries);
        return _callSuper(
          this,
          PromoteAllInstancedOfPromotedTemporaries,
          arguments
        );
      }
      _inherits2(
        PromoteAllInstancedOfPromotedTemporaries,
        _ReactiveFunctionVisi8
      );
      return _createClass(PromoteAllInstancedOfPromotedTemporaries, [
        {
          key: "visitPlace",
          value: function visitPlace(_id, place, state) {
            if (
              place.identifier.name === null &&
              state.promoted.has(place.identifier.declarationId)
            ) {
              promoteIdentifier(place.identifier, state);
            }
          }
        },
        {
          key: "visitLValue",
          value: function visitLValue(_id, _lvalue, _state) {
            this.visitPlace(_id, _lvalue, _state);
          }
        },
        {
          key: "traverseScopeIdentifiers",
          value: function traverseScopeIdentifiers(scope, state) {
            var _iterator276 = _createForOfIteratorHelper(scope.declarations),
              _step276;
            try {
              for (_iterator276.s(); !(_step276 = _iterator276.n()).done; ) {
                var _step276$value = _slicedToArray(_step276.value, 2),
                  decl = _step276$value[1];
                if (
                  decl.identifier.name === null &&
                  state.promoted.has(decl.identifier.declarationId)
                ) {
                  promoteIdentifier(decl.identifier, state);
                }
              }
            } catch (err) {
              _iterator276.e(err);
            } finally {
              _iterator276.f();
            }
            var _iterator277 = _createForOfIteratorHelper(scope.dependencies),
              _step277;
            try {
              for (_iterator277.s(); !(_step277 = _iterator277.n()).done; ) {
                var dep = _step277.value;
                if (
                  dep.identifier.name === null &&
                  state.promoted.has(dep.identifier.declarationId)
                ) {
                  promoteIdentifier(dep.identifier, state);
                }
              }
            } catch (err) {
              _iterator277.e(err);
            } finally {
              _iterator277.f();
            }
            var _iterator278 = _createForOfIteratorHelper(scope.reassignments),
              _step278;
            try {
              for (_iterator278.s(); !(_step278 = _iterator278.n()).done; ) {
                var reassignment = _step278.value;
                if (
                  reassignment.name === null &&
                  state.promoted.has(reassignment.declarationId)
                ) {
                  promoteIdentifier(reassignment, state);
                }
              }
            } catch (err) {
              _iterator278.e(err);
            } finally {
              _iterator278.f();
            }
          }
        },
        {
          key: "visitScope",
          value: function visitScope(scope, state) {
            this.traverseScope(scope, state);
            this.traverseScopeIdentifiers(scope.scope, state);
          }
        },
        {
          key: "visitPrunedScope",
          value: function visitPrunedScope(scopeBlock, state) {
            this.traversePrunedScope(scopeBlock, state);
            this.traverseScopeIdentifiers(scopeBlock.scope, state);
          }
        },
        {
          key: "visitReactiveFunctionValue",
          value: function visitReactiveFunctionValue(
            _id,
            _dependencies,
            fn,
            state
          ) {
            visitReactiveFunction(fn, this, state);
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    var CollectPromotableTemporaries = /*#__PURE__*/ (function (
      _ReactiveFunctionVisi9
    ) {
      function CollectPromotableTemporaries() {
        var _this13;
        _classCallCheck(this, CollectPromotableTemporaries);
        _this13 = _callSuper(this, CollectPromotableTemporaries, arguments);
        _this13.activeScopes = [];
        return _this13;
      }
      _inherits2(CollectPromotableTemporaries, _ReactiveFunctionVisi9);
      return _createClass(CollectPromotableTemporaries, [
        {
          key: "visitPlace",
          value: function visitPlace(_id, place, state) {
            if (
              this.activeScopes.length !== 0 &&
              state.pruned.has(place.identifier.declarationId)
            ) {
              var prunedPlace = state.pruned.get(
                place.identifier.declarationId
              );
              if (
                prunedPlace.activeScopes.indexOf(this.activeScopes.at(-1)) ===
                -1
              ) {
                prunedPlace.usedOutsideScope = true;
              }
            }
          }
        },
        {
          key: "visitValue",
          value: function visitValue(id, value, state) {
            this.traverseValue(id, value, state);
            if (
              value.kind === "JsxExpression" &&
              value.tag.kind === "Identifier"
            ) {
              state.tags.add(value.tag.identifier.declarationId);
            }
          }
        },
        {
          key: "visitPrunedScope",
          value: function visitPrunedScope(scopeBlock, state) {
            var _iterator279 = _createForOfIteratorHelper(
                scopeBlock.scope.declarations
              ),
              _step279;
            try {
              for (_iterator279.s(); !(_step279 = _iterator279.n()).done; ) {
                var _step279$value = _slicedToArray(_step279.value, 2),
                  _id = _step279$value[0],
                  decl = _step279$value[1];
                state.pruned.set(decl.identifier.declarationId, {
                  activeScopes: _toConsumableArray(this.activeScopes),
                  usedOutsideScope: false
                });
              }
            } catch (err) {
              _iterator279.e(err);
            } finally {
              _iterator279.f();
            }
            this.visitBlock(scopeBlock.instructions, state);
          }
        },
        {
          key: "visitScope",
          value: function visitScope(scopeBlock, state) {
            this.activeScopes.push(scopeBlock.scope.id);
            this.traverseScope(scopeBlock, state);
            this.activeScopes.pop();
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    var PromoteInterposedTemporaries = /*#__PURE__*/ (function (
      _ReactiveFunctionVisi10
    ) {
      function PromoteInterposedTemporaries(promotable, params) {
        var _this14;
        _classCallCheck(this, PromoteInterposedTemporaries);
        _this14 = _callSuper(this, PromoteInterposedTemporaries);
        _PromoteInterposedTemporaries_promotable.set(_this14, void 0);
        _PromoteInterposedTemporaries_consts.set(_this14, new Set());
        _PromoteInterposedTemporaries_globals.set(_this14, new Set());
        params.forEach(function (param) {
          switch (param.kind) {
            case "Identifier":
              __classPrivateFieldGet(
                _this14,
                _PromoteInterposedTemporaries_consts,
                "f"
              ).add(param.identifier.id);
              break;
            case "Spread":
              __classPrivateFieldGet(
                _this14,
                _PromoteInterposedTemporaries_consts,
                "f"
              ).add(param.place.identifier.id);
              break;
          }
        });
        __classPrivateFieldSet(
          _this14,
          _PromoteInterposedTemporaries_promotable,
          promotable,
          "f"
        );
        return _this14;
      }
      _inherits2(PromoteInterposedTemporaries, _ReactiveFunctionVisi10);
      return _createClass(PromoteInterposedTemporaries, [
        {
          key: "visitPlace",
          value: function visitPlace(_id, place, state) {
            var promo = state.get(place.identifier.id);
            if (promo) {
              var _promo = _slicedToArray(promo, 2),
                _identifier13 = _promo[0],
                needsPromotion = _promo[1];
              if (
                needsPromotion &&
                _identifier13.name === null &&
                !__classPrivateFieldGet(
                  this,
                  _PromoteInterposedTemporaries_consts,
                  "f"
                ).has(_identifier13.id)
              ) {
                promoteIdentifier(
                  _identifier13,
                  __classPrivateFieldGet(
                    this,
                    _PromoteInterposedTemporaries_promotable,
                    "f"
                  )
                );
              }
            }
          }
        },
        {
          key: "visitInstruction",
          value: function visitInstruction(instruction, state) {
            var _this15 = this;
            var _iterator280 = _createForOfIteratorHelper(
                eachInstructionValueLValue(instruction.value)
              ),
              _step280;
            try {
              for (_iterator280.s(); !(_step280 = _iterator280.n()).done; ) {
                var lval = _step280.value;
                CompilerError.invariant(lval.identifier.name != null, {
                  reason:
                    "PromoteInterposedTemporaries: Assignment targets not expected to be temporaries",
                  loc: instruction.loc
                });
              }
            } catch (err) {
              _iterator280.e(err);
            } finally {
              _iterator280.f();
            }
            switch (instruction.value.kind) {
              case "CallExpression":
              case "MethodCall":
              case "Await":
              case "PropertyStore":
              case "PropertyDelete":
              case "ComputedStore":
              case "ComputedDelete":
              case "PostfixUpdate":
              case "PrefixUpdate":
              case "StoreLocal":
              case "StoreContext":
              case "StoreGlobal":
              case "Destructure": {
                var constStore = false;
                if (
                  (instruction.value.kind === "StoreContext" ||
                    instruction.value.kind === "StoreLocal") &&
                  (instruction.value.lvalue.kind === "Const" ||
                    instruction.value.lvalue.kind === "HoistedConst")
                ) {
                  __classPrivateFieldGet(
                    this,
                    _PromoteInterposedTemporaries_consts,
                    "f"
                  ).add(instruction.value.lvalue.place.identifier.id);
                  constStore = true;
                }
                if (
                  instruction.value.kind === "Destructure" &&
                  (instruction.value.lvalue.kind === "Const" ||
                    instruction.value.lvalue.kind === "HoistedConst")
                ) {
                  _toConsumableArray(
                    eachPatternOperand(instruction.value.lvalue.pattern)
                  ).forEach(function (ident) {
                    return __classPrivateFieldGet(
                      _this15,
                      _PromoteInterposedTemporaries_consts,
                      "f"
                    ).add(ident.identifier.id);
                  });
                  constStore = true;
                }
                if (instruction.value.kind === "MethodCall") {
                  __classPrivateFieldGet(
                    this,
                    _PromoteInterposedTemporaries_consts,
                    "f"
                  ).add(instruction.value.property.identifier.id);
                }
                _get(
                  _getPrototypeOf(PromoteInterposedTemporaries.prototype),
                  "visitInstruction",
                  this
                ).call(this, instruction, state);
                if (
                  !constStore &&
                  (instruction.lvalue == null ||
                    instruction.lvalue.identifier.name != null)
                ) {
                  var _iterator281 = _createForOfIteratorHelper(
                      state.entries()
                    ),
                    _step281;
                  try {
                    for (
                      _iterator281.s();
                      !(_step281 = _iterator281.n()).done;

                    ) {
                      var _step281$value = _slicedToArray(_step281.value, 2),
                        _key37 = _step281$value[0],
                        _step281$value$ = _slicedToArray(_step281$value[1], 2),
                        ident = _step281$value$[0],
                        _ = _step281$value$[1];
                      state.set(_key37, [ident, true]);
                    }
                  } catch (err) {
                    _iterator281.e(err);
                  } finally {
                    _iterator281.f();
                  }
                }
                if (
                  instruction.lvalue &&
                  instruction.lvalue.identifier.name === null
                ) {
                  state.set(instruction.lvalue.identifier.id, [
                    instruction.lvalue.identifier,
                    false
                  ]);
                }
                break;
              }
              case "DeclareContext":
              case "DeclareLocal": {
                if (
                  instruction.value.lvalue.kind === "Const" ||
                  instruction.value.lvalue.kind === "HoistedConst"
                ) {
                  __classPrivateFieldGet(
                    this,
                    _PromoteInterposedTemporaries_consts,
                    "f"
                  ).add(instruction.value.lvalue.place.identifier.id);
                }
                _get(
                  _getPrototypeOf(PromoteInterposedTemporaries.prototype),
                  "visitInstruction",
                  this
                ).call(this, instruction, state);
                break;
              }
              case "LoadContext":
              case "LoadLocal": {
                if (
                  instruction.lvalue &&
                  instruction.lvalue.identifier.name === null
                ) {
                  if (
                    __classPrivateFieldGet(
                      this,
                      _PromoteInterposedTemporaries_consts,
                      "f"
                    ).has(instruction.value.place.identifier.id)
                  ) {
                    __classPrivateFieldGet(
                      this,
                      _PromoteInterposedTemporaries_consts,
                      "f"
                    ).add(instruction.lvalue.identifier.id);
                  }
                  state.set(instruction.lvalue.identifier.id, [
                    instruction.lvalue.identifier,
                    false
                  ]);
                }
                _get(
                  _getPrototypeOf(PromoteInterposedTemporaries.prototype),
                  "visitInstruction",
                  this
                ).call(this, instruction, state);
                break;
              }
              case "PropertyLoad":
              case "ComputedLoad": {
                if (instruction.lvalue) {
                  if (
                    __classPrivateFieldGet(
                      this,
                      _PromoteInterposedTemporaries_globals,
                      "f"
                    ).has(instruction.value.object.identifier.id)
                  ) {
                    __classPrivateFieldGet(
                      this,
                      _PromoteInterposedTemporaries_globals,
                      "f"
                    ).add(instruction.lvalue.identifier.id);
                    __classPrivateFieldGet(
                      this,
                      _PromoteInterposedTemporaries_consts,
                      "f"
                    ).add(instruction.lvalue.identifier.id);
                  }
                  if (instruction.lvalue.identifier.name === null) {
                    state.set(instruction.lvalue.identifier.id, [
                      instruction.lvalue.identifier,
                      false
                    ]);
                  }
                }
                _get(
                  _getPrototypeOf(PromoteInterposedTemporaries.prototype),
                  "visitInstruction",
                  this
                ).call(this, instruction, state);
                break;
              }
              case "LoadGlobal": {
                instruction.lvalue &&
                  __classPrivateFieldGet(
                    this,
                    _PromoteInterposedTemporaries_globals,
                    "f"
                  ).add(instruction.lvalue.identifier.id);
                _get(
                  _getPrototypeOf(PromoteInterposedTemporaries.prototype),
                  "visitInstruction",
                  this
                ).call(this, instruction, state);
                break;
              }
              default: {
                _get(
                  _getPrototypeOf(PromoteInterposedTemporaries.prototype),
                  "visitInstruction",
                  this
                ).call(this, instruction, state);
              }
            }
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    (_PromoteInterposedTemporaries_promotable = new WeakMap()),
      (_PromoteInterposedTemporaries_consts = new WeakMap()),
      (_PromoteInterposedTemporaries_globals = new WeakMap());
    function promoteUsedTemporaries(fn) {
      var state = { tags: new Set(), promoted: new Set(), pruned: new Map() };
      visitReactiveFunction(fn, new CollectPromotableTemporaries(), state);
      var _iterator282 = _createForOfIteratorHelper(fn.params),
        _step282;
      try {
        for (_iterator282.s(); !(_step282 = _iterator282.n()).done; ) {
          var operand = _step282.value;
          var place = operand.kind === "Identifier" ? operand : operand.place;
          if (place.identifier.name === null) {
            promoteIdentifier(place.identifier, state);
          }
        }
      } catch (err) {
        _iterator282.e(err);
      } finally {
        _iterator282.f();
      }
      visitReactiveFunction(fn, new PromoteTemporaries(), state);
      visitReactiveFunction(
        fn,
        new PromoteInterposedTemporaries(state, fn.params),
        new Map()
      );
      visitReactiveFunction(
        fn,
        new PromoteAllInstancedOfPromotedTemporaries(),
        state
      );
    }
    function promoteIdentifier(identifier, state) {
      CompilerError.invariant(identifier.name === null, {
        reason:
          "promoteTemporary: Expected to be called only for temporary variables",
        description: null,
        loc: GeneratedSource,
        suggestions: null
      });
      if (state.tags.has(identifier.declarationId)) {
        promoteTemporaryJsxTag(identifier);
      } else {
        promoteTemporary(identifier);
      }
      state.promoted.add(identifier.declarationId);
    }
    function propagateEarlyReturns(fn) {
      visitReactiveFunction(fn, new Transform$3(fn.env), {
        withinReactiveScope: false,
        earlyReturnValue: null
      });
    }
    var Transform$3 = /*#__PURE__*/ (function (_ReactiveFunctionTran3) {
      function Transform(env) {
        var _this16;
        _classCallCheck(this, Transform);
        _this16 = _callSuper(this, Transform);
        _this16.env = env;
        return _this16;
      }
      _inherits2(Transform, _ReactiveFunctionTran3);
      return _createClass(Transform, [
        {
          key: "visitScope",
          value: function visitScope(scopeBlock, parentState) {
            if (scopeBlock.scope.earlyReturnValue !== null) {
              return;
            }
            var innerState = {
              withinReactiveScope: true,
              earlyReturnValue: parentState.earlyReturnValue
            };
            this.traverseScope(scopeBlock, innerState);
            var earlyReturnValue = innerState.earlyReturnValue;
            if (earlyReturnValue !== null) {
              if (!parentState.withinReactiveScope) {
                scopeBlock.scope.earlyReturnValue = earlyReturnValue;
                scopeBlock.scope.declarations.set(earlyReturnValue.value.id, {
                  identifier: earlyReturnValue.value,
                  scope: scopeBlock.scope
                });
                var instructions = scopeBlock.instructions;
                var loc = earlyReturnValue.loc;
                var sentinelTemp = createTemporaryPlace(this.env, loc);
                var symbolTemp = createTemporaryPlace(this.env, loc);
                var forTemp = createTemporaryPlace(this.env, loc);
                var argTemp = createTemporaryPlace(this.env, loc);
                scopeBlock.instructions = [
                  {
                    kind: "instruction",
                    instruction: {
                      id: makeInstructionId(0),
                      loc: loc,
                      lvalue: Object.assign({}, symbolTemp),
                      value: {
                        kind: "LoadGlobal",
                        binding: { kind: "Global", name: "Symbol" },
                        loc: loc
                      }
                    }
                  },
                  {
                    kind: "instruction",
                    instruction: {
                      id: makeInstructionId(0),
                      loc: loc,
                      lvalue: Object.assign({}, forTemp),
                      value: {
                        kind: "PropertyLoad",
                        object: Object.assign({}, symbolTemp),
                        property: makePropertyLiteral("for"),
                        loc: loc
                      }
                    }
                  },
                  {
                    kind: "instruction",
                    instruction: {
                      id: makeInstructionId(0),
                      loc: loc,
                      lvalue: Object.assign({}, argTemp),
                      value: {
                        kind: "Primitive",
                        value: EARLY_RETURN_SENTINEL,
                        loc: loc
                      }
                    }
                  },
                  {
                    kind: "instruction",
                    instruction: {
                      id: makeInstructionId(0),
                      loc: loc,
                      lvalue: Object.assign({}, sentinelTemp),
                      value: {
                        kind: "MethodCall",
                        receiver: symbolTemp,
                        property: forTemp,
                        args: [argTemp],
                        loc: loc
                      }
                    }
                  },
                  {
                    kind: "instruction",
                    instruction: {
                      id: makeInstructionId(0),
                      loc: loc,
                      lvalue: null,
                      value: {
                        kind: "StoreLocal",
                        loc: loc,
                        type: null,
                        lvalue: {
                          kind: InstructionKind.Let,
                          place: {
                            kind: "Identifier",
                            effect: Effect.ConditionallyMutate,
                            loc: loc,
                            reactive: true,
                            identifier: earlyReturnValue.value
                          }
                        },
                        value: Object.assign({}, sentinelTemp)
                      }
                    }
                  },
                  {
                    kind: "terminal",
                    label: { id: earlyReturnValue.label, implicit: false },
                    terminal: {
                      kind: "label",
                      id: makeInstructionId(0),
                      loc: GeneratedSource,
                      block: instructions
                    }
                  }
                ];
              } else {
                parentState.earlyReturnValue = earlyReturnValue;
              }
            }
          }
        },
        {
          key: "transformTerminal",
          value: function transformTerminal(stmt, state) {
            if (state.withinReactiveScope && stmt.terminal.kind === "return") {
              var loc = stmt.terminal.value.loc;
              var earlyReturnValue;
              if (state.earlyReturnValue !== null) {
                earlyReturnValue = state.earlyReturnValue;
              } else {
                var _identifier14 = createTemporaryPlace(
                  this.env,
                  loc
                ).identifier;
                promoteTemporary(_identifier14);
                earlyReturnValue = {
                  label: this.env.nextBlockId,
                  loc: loc,
                  value: _identifier14
                };
              }
              state.earlyReturnValue = earlyReturnValue;
              return {
                kind: "replace-many",
                value: [
                  {
                    kind: "instruction",
                    instruction: {
                      id: makeInstructionId(0),
                      loc: loc,
                      lvalue: null,
                      value: {
                        kind: "StoreLocal",
                        loc: loc,
                        type: null,
                        lvalue: {
                          kind: InstructionKind.Reassign,
                          place: {
                            kind: "Identifier",
                            identifier: earlyReturnValue.value,
                            effect: Effect.Capture,
                            loc: loc,
                            reactive: true
                          }
                        },
                        value: stmt.terminal.value
                      }
                    }
                  },
                  {
                    kind: "terminal",
                    label: null,
                    terminal: {
                      kind: "break",
                      id: makeInstructionId(0),
                      loc: loc,
                      targetKind: "labeled",
                      target: earlyReturnValue.label
                    }
                  }
                ]
              };
            }
            this.traverseTerminal(stmt, state);
            return { kind: "keep" };
          }
        }
      ]);
    })(ReactiveFunctionTransform);
    function pruneHoistedContexts(fn) {
      var hoistedIdentifiers = new Map();
      visitReactiveFunction(fn, new Visitor$8(), hoistedIdentifiers);
    }
    var Visitor$8 = /*#__PURE__*/ (function (_ReactiveFunctionTran4) {
      function Visitor() {
        _classCallCheck(this, Visitor);
        return _callSuper(this, Visitor, arguments);
      }
      _inherits2(Visitor, _ReactiveFunctionTran4);
      return _createClass(Visitor, [
        {
          key: "transformInstruction",
          value: function transformInstruction(instruction, state) {
            this.visitInstruction(instruction, state);
            if (
              instruction.value.kind === "DeclareContext" &&
              instruction.value.lvalue.kind === "HoistedConst"
            ) {
              state.set(
                instruction.value.lvalue.place.identifier.declarationId,
                InstructionKind.Const
              );
              return { kind: "remove" };
            }
            if (
              instruction.value.kind === "DeclareContext" &&
              instruction.value.lvalue.kind === "HoistedLet"
            ) {
              state.set(
                instruction.value.lvalue.place.identifier.declarationId,
                InstructionKind.Let
              );
              return { kind: "remove" };
            }
            if (
              instruction.value.kind === "DeclareContext" &&
              instruction.value.lvalue.kind === "HoistedFunction"
            ) {
              state.set(
                instruction.value.lvalue.place.identifier.declarationId,
                InstructionKind.Function
              );
              return { kind: "remove" };
            }
            if (
              instruction.value.kind === "StoreContext" &&
              state.has(instruction.value.lvalue.place.identifier.declarationId)
            ) {
              var kind = state.get(
                instruction.value.lvalue.place.identifier.declarationId
              );
              return {
                kind: "replace",
                value: {
                  kind: "instruction",
                  instruction: Object.assign(Object.assign({}, instruction), {
                    value: Object.assign(Object.assign({}, instruction.value), {
                      lvalue: Object.assign(
                        Object.assign({}, instruction.value.lvalue),
                        { kind: kind }
                      ),
                      type: null,
                      kind: "StoreLocal"
                    })
                  })
                }
              };
            }
            return { kind: "keep" };
          }
        }
      ]);
    })(ReactiveFunctionTransform);
    function inferOperandEffect(state, place) {
      var value = state.kind(place);
      CompilerError.invariant(value != null, {
        reason: "Expected operand to have a kind",
        loc: null
      });
      switch (place.effect) {
        case Effect.Store:
        case Effect.Mutate: {
          if (isRefOrRefValue(place.identifier)) {
            break;
          } else if (value.kind === ValueKind.Context) {
            CompilerError.invariant(value.context.size > 0, {
              reason:
                "[InferFunctionEffects] Expected Context-kind value's capture list to be non-empty.",
              loc: place.loc
            });
            return {
              kind: "ContextMutation",
              loc: place.loc,
              effect: place.effect,
              places: value.context
            };
          } else if (
            value.kind !== ValueKind.Mutable &&
            value.kind !== ValueKind.Primitive
          ) {
            var reason = getWriteErrorReason(value);
            return {
              kind:
                value.reason.size === 1 && value.reason.has(ValueReason.Global)
                  ? "GlobalMutation"
                  : "ReactMutation",
              error: {
                reason: reason,
                description:
                  place.identifier.name !== null &&
                  place.identifier.name.kind === "named"
                    ? "Found mutation of `".concat(
                        place.identifier.name.value,
                        "`"
                      )
                    : null,
                loc: place.loc,
                suggestions: null,
                severity: ErrorSeverity.InvalidReact
              }
            };
          }
          break;
        }
      }
      return null;
    }
    function inheritFunctionEffects(state, place) {
      var effects = inferFunctionInstrEffects(state, place);
      return effects
        .flatMap(function (effect) {
          if (
            effect.kind === "GlobalMutation" ||
            effect.kind === "ReactMutation"
          ) {
            return [effect];
          } else {
            var _effects = [];
            CompilerError.invariant(effect.kind === "ContextMutation", {
              reason: "Expected ContextMutation",
              loc: null
            });
            var _iterator283 = _createForOfIteratorHelper(effect.places),
              _step283;
            try {
              for (_iterator283.s(); !(_step283 = _iterator283.n()).done; ) {
                var _place23 = _step283.value;
                if (state.isDefined(_place23)) {
                  var replayedEffect = inferOperandEffect(
                    state,
                    Object.assign(Object.assign({}, _place23), {
                      loc: effect.loc,
                      effect: effect.effect
                    })
                  );
                  if (replayedEffect != null) {
                    if (replayedEffect.kind === "ContextMutation") {
                      _effects.push(effect);
                    } else {
                      _effects.push(replayedEffect);
                    }
                  }
                }
              }
            } catch (err) {
              _iterator283.e(err);
            } finally {
              _iterator283.f();
            }
            return _effects;
          }
        })
        .filter(function (effect) {
          return effect != null;
        });
    }
    function inferFunctionInstrEffects(state, place) {
      var effects = [];
      var instrs = state.values(place);
      CompilerError.invariant(instrs != null, {
        reason: "Expected operand to have instructions",
        loc: null
      });
      var _iterator284 = _createForOfIteratorHelper(instrs),
        _step284;
      try {
        for (_iterator284.s(); !(_step284 = _iterator284.n()).done; ) {
          var instr = _step284.value;
          if (
            (instr.kind === "FunctionExpression" ||
              instr.kind === "ObjectMethod") &&
            instr.loweredFunc.func.effects != null
          ) {
            effects.push.apply(
              effects,
              _toConsumableArray(instr.loweredFunc.func.effects)
            );
          }
        }
      } catch (err) {
        _iterator284.e(err);
      } finally {
        _iterator284.f();
      }
      return effects;
    }
    function operandEffects(state, place, filterRenderSafe) {
      var functionEffects = [];
      var effect = inferOperandEffect(state, place);
      effect && functionEffects.push(effect);
      functionEffects.push.apply(
        functionEffects,
        _toConsumableArray(inheritFunctionEffects(state, place))
      );
      if (filterRenderSafe) {
        return functionEffects.filter(function (effect) {
          return !isEffectSafeOutsideRender(effect);
        });
      } else {
        return functionEffects;
      }
    }
    function inferInstructionFunctionEffects(env, state, instr) {
      var _a, _b;
      var _c;
      var functionEffects = [];
      switch (instr.value.kind) {
        case "JsxExpression": {
          if (instr.value.tag.kind === "Identifier") {
            functionEffects.push.apply(
              functionEffects,
              _toConsumableArray(operandEffects(state, instr.value.tag, false))
            );
          }
          (_a = instr.value.children) === null || _a === void 0
            ? void 0
            : _a.forEach(function (child) {
                return functionEffects.push.apply(
                  functionEffects,
                  _toConsumableArray(operandEffects(state, child, false))
                );
              });
          var _iterator285 = _createForOfIteratorHelper(instr.value.props),
            _step285;
          try {
            for (_iterator285.s(); !(_step285 = _iterator285.n()).done; ) {
              var attr = _step285.value;
              if (attr.kind === "JsxSpreadAttribute") {
                functionEffects.push.apply(
                  functionEffects,
                  _toConsumableArray(
                    operandEffects(state, attr.argument, false)
                  )
                );
              } else {
                functionEffects.push.apply(
                  functionEffects,
                  _toConsumableArray(operandEffects(state, attr.place, true))
                );
              }
            }
          } catch (err) {
            _iterator285.e(err);
          } finally {
            _iterator285.f();
          }
          break;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          var _iterator286 = _createForOfIteratorHelper(
              eachInstructionOperand(instr)
            ),
            _step286;
          try {
            for (_iterator286.s(); !(_step286 = _iterator286.n()).done; ) {
              var _instr$value$loweredF;
              var operand = _step286.value;
              (_b = (_c = instr.value.loweredFunc.func).effects) !== null &&
              _b !== void 0
                ? _b
                : (_c.effects = []);
              (_instr$value$loweredF =
                instr.value.loweredFunc.func.effects).push.apply(
                _instr$value$loweredF,
                _toConsumableArray(inferFunctionInstrEffects(state, operand))
              );
            }
          } catch (err) {
            _iterator286.e(err);
          } finally {
            _iterator286.f();
          }
          break;
        }
        case "MethodCall":
        case "CallExpression": {
          var callee;
          if (instr.value.kind === "MethodCall") {
            callee = instr.value.property;
            functionEffects.push.apply(
              functionEffects,
              _toConsumableArray(
                operandEffects(state, instr.value.receiver, false)
              )
            );
          } else {
            callee = instr.value.callee;
          }
          functionEffects.push.apply(
            functionEffects,
            _toConsumableArray(operandEffects(state, callee, false))
          );
          var _isHook5 = getHookKind(env, callee.identifier) != null;
          var _iterator287 = _createForOfIteratorHelper(instr.value.args),
            _step287;
          try {
            for (_iterator287.s(); !(_step287 = _iterator287.n()).done; ) {
              var arg = _step287.value;
              var place = arg.kind === "Identifier" ? arg : arg.place;
              functionEffects.push.apply(
                functionEffects,
                _toConsumableArray(operandEffects(state, place, _isHook5))
              );
            }
          } catch (err) {
            _iterator287.e(err);
          } finally {
            _iterator287.f();
          }
          break;
        }
        case "StartMemoize":
        case "FinishMemoize":
        case "LoadLocal":
        case "StoreLocal": {
          break;
        }
        case "StoreGlobal": {
          functionEffects.push({
            kind: "GlobalMutation",
            error: {
              reason:
                "Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render)",
              loc: instr.loc,
              suggestions: null,
              severity: ErrorSeverity.InvalidReact
            }
          });
          break;
        }
        default: {
          var _iterator288 = _createForOfIteratorHelper(
              eachInstructionOperand(instr)
            ),
            _step288;
          try {
            for (_iterator288.s(); !(_step288 = _iterator288.n()).done; ) {
              var _operand16 = _step288.value;
              functionEffects.push.apply(
                functionEffects,
                _toConsumableArray(operandEffects(state, _operand16, false))
              );
            }
          } catch (err) {
            _iterator288.e(err);
          } finally {
            _iterator288.f();
          }
        }
      }
      return functionEffects;
    }
    function inferTerminalFunctionEffects(state, block) {
      var functionEffects = [];
      var _iterator289 = _createForOfIteratorHelper(
          eachTerminalOperand(block.terminal)
        ),
        _step289;
      try {
        for (_iterator289.s(); !(_step289 = _iterator289.n()).done; ) {
          var operand = _step289.value;
          functionEffects.push.apply(
            functionEffects,
            _toConsumableArray(operandEffects(state, operand, true))
          );
        }
      } catch (err) {
        _iterator289.e(err);
      } finally {
        _iterator289.f();
      }
      return functionEffects;
    }
    function transformFunctionEffectErrors(functionEffects) {
      return functionEffects.map(function (eff) {
        switch (eff.kind) {
          case "ReactMutation":
          case "GlobalMutation": {
            return eff.error;
          }
          case "ContextMutation": {
            return {
              severity: ErrorSeverity.Invariant,
              reason:
                "Unexpected ContextMutation in top-level function effects",
              loc: eff.loc
            };
          }
          default:
            assertExhaustive$1(
              eff,
              "Unexpected function effect kind `".concat(eff.kind, "`")
            );
        }
      });
    }
    function isEffectSafeOutsideRender(effect) {
      return effect.kind === "GlobalMutation";
    }
    function getWriteErrorReason(abstractValue) {
      if (abstractValue.reason.has(ValueReason.Global)) {
        return "Writing to a variable defined outside a component or hook is not allowed. Consider using an effect";
      } else if (abstractValue.reason.has(ValueReason.JsxCaptured)) {
        return "Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX";
      } else if (abstractValue.reason.has(ValueReason.Context)) {
        return "Mutating a value returned from 'useContext()', which should not be mutated";
      } else if (abstractValue.reason.has(ValueReason.KnownReturnSignature)) {
        return "Mutating a value returned from a function whose return value should not be mutated";
      } else if (
        abstractValue.reason.has(ValueReason.ReactiveFunctionArgument)
      ) {
        return "Mutating component props or hook arguments is not allowed. Consider using a local variable instead";
      } else if (abstractValue.reason.has(ValueReason.State)) {
        return "Mutating a value returned from 'useState()', which should not be mutated. Use the setter function to update instead";
      } else if (abstractValue.reason.has(ValueReason.ReducerState)) {
        return "Mutating a value returned from 'useReducer()', which should not be mutated. Use the dispatch function to update instead";
      } else {
        return "This mutates a variable that React considers immutable";
      }
    }
    var _InferenceState_env, _InferenceState_values, _InferenceState_variables;
    var UndefinedValue = {
      kind: "Primitive",
      loc: GeneratedSource,
      value: undefined
    };
    function inferReferenceEffects(fn) {
      var options =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : { isFunctionExpression: false };
      var _a;
      var initialState = InferenceState.empty(fn.env);
      var value = { kind: "Primitive", loc: fn.loc, value: undefined };
      initialState.initialize(value, {
        kind: ValueKind.Frozen,
        reason: new Set([ValueReason.Other]),
        context: new Set()
      });
      var _iterator290 = _createForOfIteratorHelper(fn.context),
        _step290;
      try {
        for (_iterator290.s(); !(_step290 = _iterator290.n()).done; ) {
          var _ref39 = _step290.value;
          var _value24 = {
            kind: "ObjectExpression",
            properties: [],
            loc: _ref39.loc
          };
          initialState.initialize(_value24, {
            kind: ValueKind.Context,
            reason: new Set([ValueReason.Other]),
            context: new Set([_ref39])
          });
          initialState.define(_ref39, _value24);
        }
      } catch (err) {
        _iterator290.e(err);
      } finally {
        _iterator290.f();
      }
      var paramKind = options.isFunctionExpression
        ? {
            kind: ValueKind.Mutable,
            reason: new Set([ValueReason.Other]),
            context: new Set()
          }
        : {
            kind: ValueKind.Frozen,
            reason: new Set([ValueReason.ReactiveFunctionArgument]),
            context: new Set()
          };
      if (fn.fnType === "Component") {
        CompilerError.invariant(fn.params.length <= 2, {
          reason:
            "Expected React component to have not more than two parameters: one for props and for ref",
          description: null,
          loc: fn.loc,
          suggestions: null
        });
        var _fn$params = _slicedToArray(fn.params, 2),
          props = _fn$params[0],
          ref = _fn$params[1];
        var _value23;
        var place;
        if (props) {
          inferParam(props, initialState, paramKind);
        }
        if (ref) {
          if (ref.kind === "Identifier") {
            place = ref;
            _value23 = {
              kind: "ObjectExpression",
              properties: [],
              loc: ref.loc
            };
          } else {
            place = ref.place;
            _value23 = {
              kind: "ObjectExpression",
              properties: [],
              loc: ref.place.loc
            };
          }
          initialState.initialize(_value23, {
            kind: ValueKind.Mutable,
            reason: new Set([ValueReason.Other]),
            context: new Set()
          });
          initialState.define(place, _value23);
        }
      } else {
        var _iterator291 = _createForOfIteratorHelper(fn.params),
          _step291;
        try {
          for (_iterator291.s(); !(_step291 = _iterator291.n()).done; ) {
            var param = _step291.value;
            inferParam(param, initialState, paramKind);
          }
        } catch (err) {
          _iterator291.e(err);
        } finally {
          _iterator291.f();
        }
      }
      var statesByBlock = new Map();
      var queuedStates = new Map();
      function queue(blockId, state) {
        var _a;
        var queuedState = queuedStates.get(blockId);
        if (queuedState != null) {
          state =
            (_a = queuedState.merge(state)) !== null && _a !== void 0
              ? _a
              : queuedState;
          queuedStates.set(blockId, state);
        } else {
          var prevState = statesByBlock.get(blockId);
          var nextState = prevState != null ? prevState.merge(state) : state;
          if (nextState != null) {
            queuedStates.set(blockId, nextState);
          }
        }
      }
      queue(fn.body.entry, initialState);
      var functionEffects =
        (_a = fn.effects) !== null && _a !== void 0 ? _a : [];
      while (queuedStates.size !== 0) {
        var _iterator292 = _createForOfIteratorHelper(fn.body.blocks),
          _step292;
        try {
          for (_iterator292.s(); !(_step292 = _iterator292.n()).done; ) {
            var _step292$value = _slicedToArray(_step292.value, 2),
              blockId = _step292$value[0],
              block = _step292$value[1];
            var incomingState = queuedStates.get(blockId);
            queuedStates["delete"](blockId);
            if (incomingState == null) {
              continue;
            }
            statesByBlock.set(blockId, incomingState);
            var state = incomingState.clone();
            inferBlock(fn.env, state, block, functionEffects);
            var _iterator293 = _createForOfIteratorHelper(
                eachTerminalSuccessor(block.terminal)
              ),
              _step293;
            try {
              for (_iterator293.s(); !(_step293 = _iterator293.n()).done; ) {
                var nextBlockId = _step293.value;
                queue(nextBlockId, state);
              }
            } catch (err) {
              _iterator293.e(err);
            } finally {
              _iterator293.f();
            }
          }
        } catch (err) {
          _iterator292.e(err);
        } finally {
          _iterator292.f();
        }
      }
      if (options.isFunctionExpression) {
        fn.effects = functionEffects;
        return [];
      } else {
        return transformFunctionEffectErrors(functionEffects);
      }
    }
    var InferenceState = /*#__PURE__*/ (function () {
      function InferenceState(env, values, variables) {
        _classCallCheck(this, InferenceState);
        _InferenceState_env.set(this, void 0);
        _InferenceState_values.set(this, void 0);
        _InferenceState_variables.set(this, void 0);
        __classPrivateFieldSet(this, _InferenceState_env, env, "f");
        __classPrivateFieldSet(this, _InferenceState_values, values, "f");
        __classPrivateFieldSet(this, _InferenceState_variables, variables, "f");
      }
      return _createClass(
        InferenceState,
        [
          {
            key: "initialize",
            value: function initialize(value, kind) {
              CompilerError.invariant(value.kind !== "LoadLocal", {
                reason:
                  "Expected all top-level identifiers to be defined as variables, not values",
                description: null,
                loc: value.loc,
                suggestions: null
              });
              __classPrivateFieldGet(this, _InferenceState_values, "f").set(
                value,
                kind
              );
            }
          },
          {
            key: "values",
            value: function values(place) {
              var values = __classPrivateFieldGet(
                this,
                _InferenceState_variables,
                "f"
              ).get(place.identifier.id);
              CompilerError.invariant(values != null, {
                reason: "[hoisting] Expected value kind to be initialized",
                description: "".concat(printPlace(place)),
                loc: place.loc,
                suggestions: null
              });
              return Array.from(values);
            }
          },
          {
            key: "kind",
            value: function kind(place) {
              var values = __classPrivateFieldGet(
                this,
                _InferenceState_variables,
                "f"
              ).get(place.identifier.id);
              CompilerError.invariant(values != null, {
                reason: "[hoisting] Expected value kind to be initialized",
                description: "".concat(printPlace(place)),
                loc: place.loc,
                suggestions: null
              });
              var mergedKind = null;
              var _iterator294 = _createForOfIteratorHelper(values),
                _step294;
              try {
                for (_iterator294.s(); !(_step294 = _iterator294.n()).done; ) {
                  var value = _step294.value;
                  var _kind = __classPrivateFieldGet(
                    this,
                    _InferenceState_values,
                    "f"
                  ).get(value);
                  mergedKind =
                    mergedKind !== null
                      ? mergeAbstractValues(mergedKind, _kind)
                      : _kind;
                }
              } catch (err) {
                _iterator294.e(err);
              } finally {
                _iterator294.f();
              }
              CompilerError.invariant(mergedKind !== null, {
                reason:
                  "InferReferenceEffects::kind: Expected at least one value",
                description: "No value found at `".concat(
                  printPlace(place),
                  "`"
                ),
                loc: place.loc,
                suggestions: null
              });
              return mergedKind;
            }
          },
          {
            key: "alias",
            value: function alias(place, value) {
              var values = __classPrivateFieldGet(
                this,
                _InferenceState_variables,
                "f"
              ).get(value.identifier.id);
              CompilerError.invariant(values != null, {
                reason:
                  "[hoisting] Expected value for identifier to be initialized",
                description: "".concat(printIdentifier(value.identifier)),
                loc: value.loc,
                suggestions: null
              });
              __classPrivateFieldGet(this, _InferenceState_variables, "f").set(
                place.identifier.id,
                new Set(values)
              );
            }
          },
          {
            key: "define",
            value: function define(place, value) {
              CompilerError.invariant(
                __classPrivateFieldGet(this, _InferenceState_values, "f").has(
                  value
                ),
                {
                  reason: "Expected value to be initialized at '".concat(
                    printSourceLocation(value.loc),
                    "'"
                  ),
                  description: null,
                  loc: value.loc,
                  suggestions: null
                }
              );
              __classPrivateFieldGet(this, _InferenceState_variables, "f").set(
                place.identifier.id,
                new Set([value])
              );
            }
          },
          {
            key: "isDefined",
            value: function isDefined(place) {
              return __classPrivateFieldGet(
                this,
                _InferenceState_variables,
                "f"
              ).has(place.identifier.id);
            }
          },
          {
            key: "referenceAndRecordEffects",
            value: function referenceAndRecordEffects(
              freezeActions,
              place,
              effectKind,
              reason
            ) {
              var values = __classPrivateFieldGet(
                this,
                _InferenceState_variables,
                "f"
              ).get(place.identifier.id);
              if (values === undefined) {
                CompilerError.invariant(effectKind !== Effect.Store, {
                  reason:
                    "[InferReferenceEffects] Unhandled store reference effect",
                  description: null,
                  loc: place.loc,
                  suggestions: null
                });
                place.effect =
                  effectKind === Effect.ConditionallyMutate
                    ? Effect.ConditionallyMutate
                    : Effect.Read;
                return;
              }
              var action = this.reference(place, effectKind, reason);
              action && freezeActions.push(action);
            }
          },
          {
            key: "freezeValues",
            value: function freezeValues(values, reason) {
              var _iterator295 = _createForOfIteratorHelper(values),
                _step295;
              try {
                for (_iterator295.s(); !(_step295 = _iterator295.n()).done; ) {
                  var value = _step295.value;
                  if (value.kind === "DeclareContext") {
                    continue;
                  }
                  __classPrivateFieldGet(this, _InferenceState_values, "f").set(
                    value,
                    {
                      kind: ValueKind.Frozen,
                      reason: reason,
                      context: new Set()
                    }
                  );
                  if (
                    value.kind === "FunctionExpression" &&
                    (__classPrivateFieldGet(this, _InferenceState_env, "f")
                      .config.enablePreserveExistingMemoizationGuarantees ||
                      __classPrivateFieldGet(this, _InferenceState_env, "f")
                        .config.enableTransitivelyFreezeFunctionExpressions)
                  ) {
                    var _iterator296 = _createForOfIteratorHelper(
                        value.loweredFunc.func.context
                      ),
                      _step296;
                    try {
                      for (
                        _iterator296.s();
                        !(_step296 = _iterator296.n()).done;

                      ) {
                        var operand = _step296.value;
                        var operandValues = __classPrivateFieldGet(
                          this,
                          _InferenceState_variables,
                          "f"
                        ).get(operand.identifier.id);
                        if (operandValues !== undefined) {
                          this.freezeValues(operandValues, reason);
                        }
                      }
                    } catch (err) {
                      _iterator296.e(err);
                    } finally {
                      _iterator296.f();
                    }
                  }
                }
              } catch (err) {
                _iterator295.e(err);
              } finally {
                _iterator295.f();
              }
            }
          },
          {
            key: "reference",
            value: function reference(place, effectKind, reason) {
              var values = __classPrivateFieldGet(
                this,
                _InferenceState_variables,
                "f"
              ).get(place.identifier.id);
              CompilerError.invariant(values !== undefined, {
                reason:
                  "[InferReferenceEffects] Expected value to be initialized",
                description: null,
                loc: place.loc,
                suggestions: null
              });
              var valueKind = this.kind(place);
              var effect = null;
              var freeze = null;
              switch (effectKind) {
                case Effect.Freeze: {
                  if (
                    valueKind.kind === ValueKind.Mutable ||
                    valueKind.kind === ValueKind.Context ||
                    valueKind.kind === ValueKind.MaybeFrozen
                  ) {
                    var reasonSet = new Set([reason]);
                    effect = Effect.Freeze;
                    valueKind = {
                      kind: ValueKind.Frozen,
                      reason: reasonSet,
                      context: new Set()
                    };
                    freeze = { values: values, reason: reasonSet };
                  } else {
                    effect = Effect.Read;
                  }
                  break;
                }
                case Effect.ConditionallyMutate: {
                  if (
                    valueKind.kind === ValueKind.Mutable ||
                    valueKind.kind === ValueKind.Context
                  ) {
                    effect = Effect.ConditionallyMutate;
                  } else {
                    effect = Effect.Read;
                  }
                  break;
                }
                case Effect.Mutate: {
                  effect = Effect.Mutate;
                  break;
                }
                case Effect.Store: {
                  effect = isObjectType(place.identifier)
                    ? Effect.Store
                    : Effect.Mutate;
                  break;
                }
                case Effect.Capture: {
                  if (
                    valueKind.kind === ValueKind.Primitive ||
                    valueKind.kind === ValueKind.Global ||
                    valueKind.kind === ValueKind.Frozen ||
                    valueKind.kind === ValueKind.MaybeFrozen
                  ) {
                    effect = Effect.Read;
                  } else {
                    effect = Effect.Capture;
                  }
                  break;
                }
                case Effect.Read: {
                  effect = Effect.Read;
                  break;
                }
                case Effect.Unknown: {
                  CompilerError.invariant(false, {
                    reason:
                      "Unexpected unknown effect, expected to infer a precise effect kind",
                    description: null,
                    loc: place.loc,
                    suggestions: null
                  });
                }
                default: {
                  assertExhaustive$1(
                    effectKind,
                    "Unexpected reference kind `".concat(effectKind, "`")
                  );
                }
              }
              CompilerError.invariant(effect !== null, {
                reason: "Expected effect to be set",
                description: null,
                loc: place.loc,
                suggestions: null
              });
              place.effect = effect;
              return freeze;
            }
          },
          {
            key: "merge",
            value: function merge(other) {
              var nextValues = null;
              var nextVariables = null;
              var _iterator297 = _createForOfIteratorHelper(
                  __classPrivateFieldGet(this, _InferenceState_values, "f")
                ),
                _step297;
              try {
                for (_iterator297.s(); !(_step297 = _iterator297.n()).done; ) {
                  var _step297$value = _slicedToArray(_step297.value, 2),
                    id = _step297$value[0],
                    thisValue = _step297$value[1];
                  var otherValue = __classPrivateFieldGet(
                    other,
                    _InferenceState_values,
                    "f"
                  ).get(id);
                  if (otherValue !== undefined) {
                    var mergedValue = mergeAbstractValues(
                      thisValue,
                      otherValue
                    );
                    if (mergedValue !== thisValue) {
                      nextValues =
                        nextValues !== null && nextValues !== void 0
                          ? nextValues
                          : new Map(
                              __classPrivateFieldGet(
                                this,
                                _InferenceState_values,
                                "f"
                              )
                            );
                      nextValues.set(id, mergedValue);
                    }
                  }
                }
              } catch (err) {
                _iterator297.e(err);
              } finally {
                _iterator297.f();
              }
              var _iterator298 = _createForOfIteratorHelper(
                  __classPrivateFieldGet(other, _InferenceState_values, "f")
                ),
                _step298;
              try {
                for (_iterator298.s(); !(_step298 = _iterator298.n()).done; ) {
                  var _step298$value = _slicedToArray(_step298.value, 2),
                    _id7 = _step298$value[0],
                    _otherValue = _step298$value[1];
                  if (
                    __classPrivateFieldGet(
                      this,
                      _InferenceState_values,
                      "f"
                    ).has(_id7)
                  ) {
                    continue;
                  }
                  nextValues =
                    nextValues !== null && nextValues !== void 0
                      ? nextValues
                      : new Map(
                          __classPrivateFieldGet(
                            this,
                            _InferenceState_values,
                            "f"
                          )
                        );
                  nextValues.set(_id7, _otherValue);
                }
              } catch (err) {
                _iterator298.e(err);
              } finally {
                _iterator298.f();
              }
              var _iterator299 = _createForOfIteratorHelper(
                  __classPrivateFieldGet(this, _InferenceState_variables, "f")
                ),
                _step299;
              try {
                for (_iterator299.s(); !(_step299 = _iterator299.n()).done; ) {
                  var _step299$value = _slicedToArray(_step299.value, 2),
                    _id8 = _step299$value[0],
                    thisValues = _step299$value[1];
                  var otherValues = __classPrivateFieldGet(
                    other,
                    _InferenceState_variables,
                    "f"
                  ).get(_id8);
                  if (otherValues !== undefined) {
                    var mergedValues = null;
                    var _iterator301 = _createForOfIteratorHelper(otherValues),
                      _step301;
                    try {
                      for (
                        _iterator301.s();
                        !(_step301 = _iterator301.n()).done;

                      ) {
                        var _otherValue2 = _step301.value;
                        if (!thisValues.has(_otherValue2)) {
                          mergedValues =
                            mergedValues !== null && mergedValues !== void 0
                              ? mergedValues
                              : new Set(thisValues);
                          mergedValues.add(_otherValue2);
                        }
                      }
                    } catch (err) {
                      _iterator301.e(err);
                    } finally {
                      _iterator301.f();
                    }
                    if (mergedValues !== null) {
                      nextVariables =
                        nextVariables !== null && nextVariables !== void 0
                          ? nextVariables
                          : new Map(
                              __classPrivateFieldGet(
                                this,
                                _InferenceState_variables,
                                "f"
                              )
                            );
                      nextVariables.set(_id8, mergedValues);
                    }
                  }
                }
              } catch (err) {
                _iterator299.e(err);
              } finally {
                _iterator299.f();
              }
              var _iterator300 = _createForOfIteratorHelper(
                  __classPrivateFieldGet(other, _InferenceState_variables, "f")
                ),
                _step300;
              try {
                for (_iterator300.s(); !(_step300 = _iterator300.n()).done; ) {
                  var _step300$value = _slicedToArray(_step300.value, 2),
                    _id9 = _step300$value[0],
                    _otherValues = _step300$value[1];
                  if (
                    __classPrivateFieldGet(
                      this,
                      _InferenceState_variables,
                      "f"
                    ).has(_id9)
                  ) {
                    continue;
                  }
                  nextVariables =
                    nextVariables !== null && nextVariables !== void 0
                      ? nextVariables
                      : new Map(
                          __classPrivateFieldGet(
                            this,
                            _InferenceState_variables,
                            "f"
                          )
                        );
                  nextVariables.set(_id9, new Set(_otherValues));
                }
              } catch (err) {
                _iterator300.e(err);
              } finally {
                _iterator300.f();
              }
              if (nextVariables === null && nextValues === null) {
                return null;
              } else {
                return new InferenceState(
                  __classPrivateFieldGet(this, _InferenceState_env, "f"),
                  nextValues !== null && nextValues !== void 0
                    ? nextValues
                    : new Map(
                        __classPrivateFieldGet(
                          this,
                          _InferenceState_values,
                          "f"
                        )
                      ),
                  nextVariables !== null && nextVariables !== void 0
                    ? nextVariables
                    : new Map(
                        __classPrivateFieldGet(
                          this,
                          _InferenceState_variables,
                          "f"
                        )
                      )
                );
              }
            }
          },
          {
            key: "clone",
            value: function clone() {
              return new InferenceState(
                __classPrivateFieldGet(this, _InferenceState_env, "f"),
                new Map(
                  __classPrivateFieldGet(this, _InferenceState_values, "f")
                ),
                new Map(
                  __classPrivateFieldGet(this, _InferenceState_variables, "f")
                )
              );
            }
          },
          {
            key: "debug",
            value: function debug() {
              var result = { values: {}, variables: {} };
              var objects = new Map();
              function identify(value) {
                var id = objects.get(value);
                if (id == null) {
                  id = objects.size;
                  objects.set(value, id);
                }
                return id;
              }
              var _iterator302 = _createForOfIteratorHelper(
                  __classPrivateFieldGet(this, _InferenceState_values, "f")
                ),
                _step302;
              try {
                for (_iterator302.s(); !(_step302 = _iterator302.n()).done; ) {
                  var _step302$value = _slicedToArray(_step302.value, 2),
                    value = _step302$value[0],
                    kind = _step302$value[1];
                  var id = identify(value);
                  result.values[id] = {
                    kind: kind,
                    value: printMixedHIR(value)
                  };
                }
              } catch (err) {
                _iterator302.e(err);
              } finally {
                _iterator302.f();
              }
              var _iterator303 = _createForOfIteratorHelper(
                  __classPrivateFieldGet(this, _InferenceState_variables, "f")
                ),
                _step303;
              try {
                for (_iterator303.s(); !(_step303 = _iterator303.n()).done; ) {
                  var _step303$value = _slicedToArray(_step303.value, 2),
                    variable = _step303$value[0],
                    values = _step303$value[1];
                  result.variables["$".concat(variable)] =
                    _toConsumableArray(values).map(identify);
                }
              } catch (err) {
                _iterator303.e(err);
              } finally {
                _iterator303.f();
              }
              return result;
            }
          },
          {
            key: "inferPhi",
            value: function inferPhi(phi) {
              var values = new Set();
              var _iterator304 = _createForOfIteratorHelper(phi.operands),
                _step304;
              try {
                for (_iterator304.s(); !(_step304 = _iterator304.n()).done; ) {
                  var _step304$value = _slicedToArray(_step304.value, 2),
                    _ = _step304$value[0],
                    operand = _step304$value[1];
                  var operandValues = __classPrivateFieldGet(
                    this,
                    _InferenceState_variables,
                    "f"
                  ).get(operand.identifier.id);
                  if (operandValues === undefined) continue;
                  var _iterator305 = _createForOfIteratorHelper(operandValues),
                    _step305;
                  try {
                    for (
                      _iterator305.s();
                      !(_step305 = _iterator305.n()).done;

                    ) {
                      var v = _step305.value;
                      values.add(v);
                    }
                  } catch (err) {
                    _iterator305.e(err);
                  } finally {
                    _iterator305.f();
                  }
                }
              } catch (err) {
                _iterator304.e(err);
              } finally {
                _iterator304.f();
              }
              if (values.size > 0) {
                __classPrivateFieldGet(
                  this,
                  _InferenceState_variables,
                  "f"
                ).set(phi.place.identifier.id, values);
              }
            }
          }
        ],
        [
          {
            key: "empty",
            value: function empty(env) {
              return new InferenceState(env, new Map(), new Map());
            }
          }
        ]
      );
    })();
    (_InferenceState_env = new WeakMap()),
      (_InferenceState_values = new WeakMap()),
      (_InferenceState_variables = new WeakMap());
    function inferParam(param, initialState, paramKind) {
      var value;
      var place;
      if (param.kind === "Identifier") {
        place = param;
        value = { kind: "Primitive", loc: param.loc, value: undefined };
      } else {
        place = param.place;
        value = { kind: "Primitive", loc: param.place.loc, value: undefined };
      }
      initialState.initialize(value, paramKind);
      initialState.define(place, value);
    }
    function mergeValues(a, b) {
      if (a === b) {
        return a;
      } else if (a === ValueKind.MaybeFrozen || b === ValueKind.MaybeFrozen) {
        return ValueKind.MaybeFrozen;
      } else if (a === ValueKind.Mutable || b === ValueKind.Mutable) {
        if (a === ValueKind.Frozen || b === ValueKind.Frozen) {
          return ValueKind.MaybeFrozen;
        } else if (a === ValueKind.Context || b === ValueKind.Context) {
          return ValueKind.Context;
        } else {
          return ValueKind.Mutable;
        }
      } else if (a === ValueKind.Context || b === ValueKind.Context) {
        if (a === ValueKind.Frozen || b === ValueKind.Frozen) {
          return ValueKind.MaybeFrozen;
        } else {
          return ValueKind.Context;
        }
      } else if (a === ValueKind.Frozen || b === ValueKind.Frozen) {
        return ValueKind.Frozen;
      } else if (a === ValueKind.Global || b === ValueKind.Global) {
        return ValueKind.Global;
      } else {
        CompilerError.invariant(
          a === ValueKind.Primitive && b == ValueKind.Primitive,
          {
            reason: "Unexpected value kind in mergeValues()",
            description: "Found kinds ".concat(a, " and ").concat(b),
            loc: GeneratedSource
          }
        );
        return ValueKind.Primitive;
      }
    }
    function isSuperset(a, b) {
      var _iterator306 = _createForOfIteratorHelper(b),
        _step306;
      try {
        for (_iterator306.s(); !(_step306 = _iterator306.n()).done; ) {
          var v = _step306.value;
          if (!a.has(v)) {
            return false;
          }
        }
      } catch (err) {
        _iterator306.e(err);
      } finally {
        _iterator306.f();
      }
      return true;
    }
    function mergeAbstractValues(a, b) {
      var kind = mergeValues(a.kind, b.kind);
      if (
        kind === a.kind &&
        kind === b.kind &&
        isSuperset(a.reason, b.reason) &&
        isSuperset(a.context, b.context)
      ) {
        return a;
      }
      var reason = new Set(a.reason);
      var _iterator307 = _createForOfIteratorHelper(b.reason),
        _step307;
      try {
        for (_iterator307.s(); !(_step307 = _iterator307.n()).done; ) {
          var r = _step307.value;
          reason.add(r);
        }
      } catch (err) {
        _iterator307.e(err);
      } finally {
        _iterator307.f();
      }
      var context = new Set(a.context);
      var _iterator308 = _createForOfIteratorHelper(b.context),
        _step308;
      try {
        for (_iterator308.s(); !(_step308 = _iterator308.n()).done; ) {
          var c = _step308.value;
          context.add(c);
        }
      } catch (err) {
        _iterator308.e(err);
      } finally {
        _iterator308.f();
      }
      return { kind: kind, reason: reason, context: context };
    }
    function inferBlock(env, state, block, functionEffects) {
      var _a, _b, _c, _d, _e;
      var _iterator309 = _createForOfIteratorHelper(block.phis),
        _step309;
      try {
        for (_iterator309.s(); !(_step309 = _iterator309.n()).done; ) {
          var phi = _step309.value;
          state.inferPhi(phi);
        }
      } catch (err) {
        _iterator309.e(err);
      } finally {
        _iterator309.f();
      }
      var _iterator310 = _createForOfIteratorHelper(block.instructions),
        _step310;
      try {
        for (_iterator310.s(); !(_step310 = _iterator310.n()).done; ) {
          var instr = _step310.value;
          var instrValue = instr.value;
          var defaultLvalueEffect = Effect.ConditionallyMutate;
          var continuation = void 0;
          var freezeActions = [];
          switch (instrValue.kind) {
            case "BinaryExpression": {
              continuation = {
                kind: "initialize",
                valueKind: {
                  kind: ValueKind.Primitive,
                  reason: new Set([ValueReason.Other]),
                  context: new Set()
                },
                effect: { kind: Effect.Read, reason: ValueReason.Other }
              };
              break;
            }
            case "ArrayExpression": {
              var contextRefOperands = getContextRefOperand(state, instrValue);
              var valueKind =
                contextRefOperands.length > 0
                  ? {
                      kind: ValueKind.Context,
                      reason: new Set([ValueReason.Other]),
                      context: new Set(contextRefOperands)
                    }
                  : {
                      kind: ValueKind.Mutable,
                      reason: new Set([ValueReason.Other]),
                      context: new Set()
                    };
              var _iterator312 = _createForOfIteratorHelper(
                  instrValue.elements
                ),
                _step312;
              try {
                for (_iterator312.s(); !(_step312 = _iterator312.n()).done; ) {
                  var element = _step312.value;
                  if (element.kind === "Spread") {
                    state.referenceAndRecordEffects(
                      freezeActions,
                      element.place,
                      isArrayType(element.place.identifier)
                        ? Effect.Capture
                        : Effect.ConditionallyMutate,
                      ValueReason.Other
                    );
                  } else if (element.kind === "Identifier") {
                    state.referenceAndRecordEffects(
                      freezeActions,
                      element,
                      Effect.Capture,
                      ValueReason.Other
                    );
                  } else;
                }
              } catch (err) {
                _iterator312.e(err);
              } finally {
                _iterator312.f();
              }
              state.initialize(instrValue, valueKind);
              state.define(instr.lvalue, instrValue);
              instr.lvalue.effect = Effect.Store;
              continuation = { kind: "funeffects" };
              break;
            }
            case "NewExpression": {
              var _valueKind = {
                kind: ValueKind.Mutable,
                reason: new Set([ValueReason.Other]),
                context: new Set()
              };
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.callee,
                Effect.Read,
                ValueReason.Other
              );
              var _iterator313 = _createForOfIteratorHelper(
                  eachCallArgument(instrValue.args)
                ),
                _step313;
              try {
                for (_iterator313.s(); !(_step313 = _iterator313.n()).done; ) {
                  var operand = _step313.value;
                  state.referenceAndRecordEffects(
                    freezeActions,
                    operand,
                    Effect.ConditionallyMutate,
                    ValueReason.Other
                  );
                }
              } catch (err) {
                _iterator313.e(err);
              } finally {
                _iterator313.f();
              }
              state.initialize(instrValue, _valueKind);
              state.define(instr.lvalue, instrValue);
              instr.lvalue.effect = Effect.ConditionallyMutate;
              continuation = { kind: "funeffects" };
              break;
            }
            case "ObjectExpression": {
              var _contextRefOperands = getContextRefOperand(state, instrValue);
              var _valueKind2 =
                _contextRefOperands.length > 0
                  ? {
                      kind: ValueKind.Context,
                      reason: new Set([ValueReason.Other]),
                      context: new Set(_contextRefOperands)
                    }
                  : {
                      kind: ValueKind.Mutable,
                      reason: new Set([ValueReason.Other]),
                      context: new Set()
                    };
              var _iterator314 = _createForOfIteratorHelper(
                  instrValue.properties
                ),
                _step314;
              try {
                for (_iterator314.s(); !(_step314 = _iterator314.n()).done; ) {
                  var property = _step314.value;
                  switch (property.kind) {
                    case "ObjectProperty": {
                      if (property.key.kind === "computed") {
                        state.referenceAndRecordEffects(
                          freezeActions,
                          property.key.name,
                          Effect.Freeze,
                          ValueReason.Other
                        );
                      }
                      state.referenceAndRecordEffects(
                        freezeActions,
                        property.place,
                        Effect.Capture,
                        ValueReason.Other
                      );
                      break;
                    }
                    case "Spread": {
                      state.referenceAndRecordEffects(
                        freezeActions,
                        property.place,
                        Effect.Capture,
                        ValueReason.Other
                      );
                      break;
                    }
                    default: {
                      assertExhaustive$1(
                        property,
                        "Unexpected property kind `".concat(property.kind, "`")
                      );
                    }
                  }
                }
              } catch (err) {
                _iterator314.e(err);
              } finally {
                _iterator314.f();
              }
              state.initialize(instrValue, _valueKind2);
              state.define(instr.lvalue, instrValue);
              instr.lvalue.effect = Effect.Store;
              continuation = { kind: "funeffects" };
              break;
            }
            case "UnaryExpression": {
              continuation = {
                kind: "initialize",
                valueKind: {
                  kind: ValueKind.Primitive,
                  reason: new Set([ValueReason.Other]),
                  context: new Set()
                },
                effect: { kind: Effect.Read, reason: ValueReason.Other }
              };
              break;
            }
            case "UnsupportedNode": {
              continuation = {
                kind: "initialize",
                valueKind: {
                  kind: ValueKind.Mutable,
                  reason: new Set([ValueReason.Other]),
                  context: new Set()
                },
                effect: null
              };
              break;
            }
            case "JsxExpression": {
              if (instrValue.tag.kind === "Identifier") {
                state.referenceAndRecordEffects(
                  freezeActions,
                  instrValue.tag,
                  Effect.Freeze,
                  ValueReason.JsxCaptured
                );
              }
              if (instrValue.children !== null) {
                var _iterator315 = _createForOfIteratorHelper(
                    instrValue.children
                  ),
                  _step315;
                try {
                  for (
                    _iterator315.s();
                    !(_step315 = _iterator315.n()).done;

                  ) {
                    var child = _step315.value;
                    state.referenceAndRecordEffects(
                      freezeActions,
                      child,
                      Effect.Freeze,
                      ValueReason.JsxCaptured
                    );
                  }
                } catch (err) {
                  _iterator315.e(err);
                } finally {
                  _iterator315.f();
                }
              }
              var _iterator316 = _createForOfIteratorHelper(instrValue.props),
                _step316;
              try {
                for (_iterator316.s(); !(_step316 = _iterator316.n()).done; ) {
                  var attr = _step316.value;
                  if (attr.kind === "JsxSpreadAttribute") {
                    state.referenceAndRecordEffects(
                      freezeActions,
                      attr.argument,
                      Effect.Freeze,
                      ValueReason.JsxCaptured
                    );
                  } else {
                    state.referenceAndRecordEffects(
                      freezeActions,
                      attr.place,
                      Effect.Freeze,
                      ValueReason.JsxCaptured
                    );
                  }
                }
              } catch (err) {
                _iterator316.e(err);
              } finally {
                _iterator316.f();
              }
              state.initialize(instrValue, {
                kind: ValueKind.Frozen,
                reason: new Set([ValueReason.Other]),
                context: new Set()
              });
              state.define(instr.lvalue, instrValue);
              instr.lvalue.effect = Effect.ConditionallyMutate;
              continuation = { kind: "funeffects" };
              break;
            }
            case "JsxFragment": {
              continuation = {
                kind: "initialize",
                valueKind: {
                  kind: ValueKind.Frozen,
                  reason: new Set([ValueReason.Other]),
                  context: new Set()
                },
                effect: { kind: Effect.Freeze, reason: ValueReason.Other }
              };
              break;
            }
            case "TemplateLiteral": {
              continuation = {
                kind: "initialize",
                valueKind: {
                  kind: ValueKind.Primitive,
                  reason: new Set([ValueReason.Other]),
                  context: new Set()
                },
                effect: { kind: Effect.Read, reason: ValueReason.Other }
              };
              break;
            }
            case "RegExpLiteral": {
              continuation = {
                kind: "initialize",
                valueKind: {
                  kind: ValueKind.Mutable,
                  reason: new Set([ValueReason.Other]),
                  context: new Set()
                },
                effect: {
                  kind: Effect.ConditionallyMutate,
                  reason: ValueReason.Other
                }
              };
              break;
            }
            case "MetaProperty": {
              if (
                instrValue.meta !== "import" ||
                instrValue.property !== "meta"
              ) {
                continuation = { kind: "funeffects" };
                break;
              }
              continuation = {
                kind: "initialize",
                valueKind: {
                  kind: ValueKind.Global,
                  reason: new Set([ValueReason.Global]),
                  context: new Set()
                },
                effect: null
              };
              break;
            }
            case "LoadGlobal":
              continuation = {
                kind: "initialize",
                valueKind: {
                  kind: ValueKind.Global,
                  reason: new Set([ValueReason.Global]),
                  context: new Set()
                },
                effect: null
              };
              break;
            case "Debugger":
            case "JSXText":
            case "Primitive": {
              continuation = {
                kind: "initialize",
                valueKind: {
                  kind: ValueKind.Primitive,
                  reason: new Set([ValueReason.Other]),
                  context: new Set()
                },
                effect: null
              };
              break;
            }
            case "ObjectMethod":
            case "FunctionExpression": {
              var hasMutableOperand = false;
              var _iterator317 = _createForOfIteratorHelper(
                  eachInstructionOperand(instr)
                ),
                _step317;
              try {
                for (_iterator317.s(); !(_step317 = _iterator317.n()).done; ) {
                  var _operand17 = _step317.value;
                  CompilerError.invariant(
                    _operand17.effect !== Effect.Unknown,
                    {
                      reason: "Expected fn effects to be populated",
                      loc: _operand17.loc
                    }
                  );
                  state.referenceAndRecordEffects(
                    freezeActions,
                    _operand17,
                    _operand17.effect,
                    ValueReason.Other
                  );
                  hasMutableOperand ||
                    (hasMutableOperand = isMutableEffect(
                      _operand17.effect,
                      _operand17.loc
                    ));
                }
              } catch (err) {
                _iterator317.e(err);
              } finally {
                _iterator317.f();
              }
              state.initialize(instrValue, {
                kind: hasMutableOperand ? ValueKind.Mutable : ValueKind.Frozen,
                reason: new Set([ValueReason.Other]),
                context: new Set()
              });
              state.define(instr.lvalue, instrValue);
              instr.lvalue.effect = Effect.Store;
              continuation = { kind: "funeffects" };
              break;
            }
            case "TaggedTemplateExpression": {
              var operands = _toConsumableArray(
                eachInstructionValueOperand(instrValue)
              );
              if (operands.length !== 1) {
                CompilerError.throwTodo({
                  reason:
                    "Support tagged template expressions with interpolations",
                  loc: instrValue.loc
                });
              }
              var signature = getFunctionCallSignature(
                env,
                instrValue.tag.identifier.type
              );
              var calleeEffect =
                (_a =
                  signature === null || signature === void 0
                    ? void 0
                    : signature.calleeEffect) !== null && _a !== void 0
                  ? _a
                  : Effect.ConditionallyMutate;
              var returnValueKind =
                signature !== null
                  ? {
                      kind: signature.returnValueKind,
                      reason: new Set([
                        (_b = signature.returnValueReason) !== null &&
                        _b !== void 0
                          ? _b
                          : ValueReason.KnownReturnSignature
                      ]),
                      context: new Set()
                    }
                  : {
                      kind: ValueKind.Mutable,
                      reason: new Set([ValueReason.Other]),
                      context: new Set()
                    };
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.tag,
                calleeEffect,
                ValueReason.Other
              );
              state.initialize(instrValue, returnValueKind);
              state.define(instr.lvalue, instrValue);
              instr.lvalue.effect = Effect.ConditionallyMutate;
              continuation = { kind: "funeffects" };
              break;
            }
            case "CallExpression": {
              var _signature = getFunctionCallSignature(
                env,
                instrValue.callee.identifier.type
              );
              var effects =
                _signature !== null
                  ? getFunctionEffects(instrValue, _signature)
                  : null;
              var _returnValueKind =
                _signature !== null
                  ? {
                      kind: _signature.returnValueKind,
                      reason: new Set([
                        (_c = _signature.returnValueReason) !== null &&
                        _c !== void 0
                          ? _c
                          : ValueReason.KnownReturnSignature
                      ]),
                      context: new Set()
                    }
                  : {
                      kind: ValueKind.Mutable,
                      reason: new Set([ValueReason.Other]),
                      context: new Set()
                    };
              var hasCaptureArgument = false;
              for (var i = 0; i < instrValue.args.length; i++) {
                var arg = instrValue.args[i];
                var place = arg.kind === "Identifier" ? arg : arg.place;
                state.referenceAndRecordEffects(
                  freezeActions,
                  place,
                  getArgumentEffect(effects != null ? effects[i] : null, arg),
                  ValueReason.Other
                );
                hasCaptureArgument ||
                  (hasCaptureArgument = place.effect === Effect.Capture);
              }
              if (_signature !== null) {
                state.referenceAndRecordEffects(
                  freezeActions,
                  instrValue.callee,
                  _signature.calleeEffect,
                  ValueReason.Other
                );
              } else {
                state.referenceAndRecordEffects(
                  freezeActions,
                  instrValue.callee,
                  Effect.ConditionallyMutate,
                  ValueReason.Other
                );
              }
              hasCaptureArgument ||
                (hasCaptureArgument =
                  instrValue.callee.effect === Effect.Capture);
              state.initialize(instrValue, _returnValueKind);
              state.define(instr.lvalue, instrValue);
              instr.lvalue.effect = hasCaptureArgument
                ? Effect.Store
                : Effect.ConditionallyMutate;
              continuation = { kind: "funeffects" };
              break;
            }
            case "MethodCall": {
              CompilerError.invariant(state.isDefined(instrValue.receiver), {
                reason:
                  "[InferReferenceEffects] Internal error: receiver of PropertyCall should have been defined by corresponding PropertyLoad",
                description: null,
                loc: instrValue.loc,
                suggestions: null
              });
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.property,
                Effect.Read,
                ValueReason.Other
              );
              var _signature2 = getFunctionCallSignature(
                env,
                instrValue.property.identifier.type
              );
              var _returnValueKind2 =
                _signature2 !== null
                  ? {
                      kind: _signature2.returnValueKind,
                      reason: new Set([
                        (_d = _signature2.returnValueReason) !== null &&
                        _d !== void 0
                          ? _d
                          : ValueReason.KnownReturnSignature
                      ]),
                      context: new Set()
                    }
                  : {
                      kind: ValueKind.Mutable,
                      reason: new Set([ValueReason.Other]),
                      context: new Set()
                    };
              if (
                _signature2 !== null &&
                _signature2.mutableOnlyIfOperandsAreMutable &&
                areArgumentsImmutableAndNonMutating(state, instrValue.args)
              ) {
                var _iterator318 = _createForOfIteratorHelper(instrValue.args),
                  _step318;
                try {
                  for (
                    _iterator318.s();
                    !(_step318 = _iterator318.n()).done;

                  ) {
                    var _arg = _step318.value;
                    var _place24 =
                      _arg.kind === "Identifier" ? _arg : _arg.place;
                    state.referenceAndRecordEffects(
                      freezeActions,
                      _place24,
                      Effect.Read,
                      ValueReason.Other
                    );
                  }
                } catch (err) {
                  _iterator318.e(err);
                } finally {
                  _iterator318.f();
                }
                state.referenceAndRecordEffects(
                  freezeActions,
                  instrValue.receiver,
                  Effect.Capture,
                  ValueReason.Other
                );
                state.initialize(instrValue, _returnValueKind2);
                state.define(instr.lvalue, instrValue);
                instr.lvalue.effect =
                  instrValue.receiver.effect === Effect.Capture
                    ? Effect.Store
                    : Effect.ConditionallyMutate;
                continuation = { kind: "funeffects" };
                break;
              }
              var _effects2 =
                _signature2 !== null
                  ? getFunctionEffects(instrValue, _signature2)
                  : null;
              var _hasCaptureArgument = false;
              for (var _i38 = 0; _i38 < instrValue.args.length; _i38++) {
                var _arg2 = instrValue.args[_i38];
                var _place25 =
                  _arg2.kind === "Identifier" ? _arg2 : _arg2.place;
                state.referenceAndRecordEffects(
                  freezeActions,
                  _place25,
                  getArgumentEffect(
                    _effects2 != null ? _effects2[_i38] : null,
                    _arg2
                  ),
                  ValueReason.Other
                );
                _hasCaptureArgument ||
                  (_hasCaptureArgument = _place25.effect === Effect.Capture);
              }
              if (_signature2 !== null) {
                state.referenceAndRecordEffects(
                  freezeActions,
                  instrValue.receiver,
                  _signature2.calleeEffect,
                  ValueReason.Other
                );
              } else {
                state.referenceAndRecordEffects(
                  freezeActions,
                  instrValue.receiver,
                  Effect.ConditionallyMutate,
                  ValueReason.Other
                );
              }
              _hasCaptureArgument ||
                (_hasCaptureArgument =
                  instrValue.receiver.effect === Effect.Capture);
              state.initialize(instrValue, _returnValueKind2);
              state.define(instr.lvalue, instrValue);
              instr.lvalue.effect = _hasCaptureArgument
                ? Effect.Store
                : Effect.ConditionallyMutate;
              continuation = { kind: "funeffects" };
              break;
            }
            case "PropertyStore": {
              var effect =
                state.kind(instrValue.object).kind === ValueKind.Context
                  ? Effect.ConditionallyMutate
                  : Effect.Capture;
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.value,
                effect,
                ValueReason.Other
              );
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.object,
                Effect.Store,
                ValueReason.Other
              );
              var lvalue = instr.lvalue;
              state.alias(lvalue, instrValue.value);
              lvalue.effect = Effect.Store;
              continuation = { kind: "funeffects" };
              break;
            }
            case "PropertyDelete": {
              continuation = {
                kind: "initialize",
                valueKind: {
                  kind: ValueKind.Primitive,
                  reason: new Set([ValueReason.Other]),
                  context: new Set()
                },
                effect: { kind: Effect.Mutate, reason: ValueReason.Other }
              };
              break;
            }
            case "PropertyLoad": {
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.object,
                Effect.Read,
                ValueReason.Other
              );
              var _lvalue9 = instr.lvalue;
              _lvalue9.effect = Effect.ConditionallyMutate;
              state.initialize(instrValue, state.kind(instrValue.object));
              state.define(_lvalue9, instrValue);
              continuation = { kind: "funeffects" };
              break;
            }
            case "ComputedStore": {
              var _effect =
                state.kind(instrValue.object).kind === ValueKind.Context
                  ? Effect.ConditionallyMutate
                  : Effect.Capture;
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.value,
                _effect,
                ValueReason.Other
              );
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.property,
                Effect.Capture,
                ValueReason.Other
              );
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.object,
                Effect.Store,
                ValueReason.Other
              );
              var _lvalue10 = instr.lvalue;
              state.alias(_lvalue10, instrValue.value);
              _lvalue10.effect = Effect.Store;
              continuation = { kind: "funeffects" };
              break;
            }
            case "ComputedDelete": {
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.object,
                Effect.Mutate,
                ValueReason.Other
              );
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.property,
                Effect.Read,
                ValueReason.Other
              );
              state.initialize(instrValue, {
                kind: ValueKind.Primitive,
                reason: new Set([ValueReason.Other]),
                context: new Set()
              });
              state.define(instr.lvalue, instrValue);
              instr.lvalue.effect = Effect.Mutate;
              continuation = { kind: "funeffects" };
              break;
            }
            case "ComputedLoad": {
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.object,
                Effect.Read,
                ValueReason.Other
              );
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.property,
                Effect.Read,
                ValueReason.Other
              );
              var _lvalue11 = instr.lvalue;
              _lvalue11.effect = Effect.ConditionallyMutate;
              state.initialize(instrValue, state.kind(instrValue.object));
              state.define(_lvalue11, instrValue);
              continuation = { kind: "funeffects" };
              break;
            }
            case "Await": {
              state.initialize(instrValue, state.kind(instrValue.value));
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.value,
                Effect.ConditionallyMutate,
                ValueReason.Other
              );
              var _lvalue12 = instr.lvalue;
              _lvalue12.effect = Effect.ConditionallyMutate;
              state.alias(_lvalue12, instrValue.value);
              continuation = { kind: "funeffects" };
              break;
            }
            case "TypeCastExpression": {
              state.initialize(instrValue, state.kind(instrValue.value));
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.value,
                Effect.Read,
                ValueReason.Other
              );
              var _lvalue13 = instr.lvalue;
              _lvalue13.effect = Effect.ConditionallyMutate;
              state.alias(_lvalue13, instrValue.value);
              continuation = { kind: "funeffects" };
              break;
            }
            case "StartMemoize":
            case "FinishMemoize": {
              var _iterator319 = _createForOfIteratorHelper(
                  eachInstructionValueOperand(instrValue)
                ),
                _step319;
              try {
                for (_iterator319.s(); !(_step319 = _iterator319.n()).done; ) {
                  var val = _step319.value;
                  if (env.config.enablePreserveExistingMemoizationGuarantees) {
                    state.referenceAndRecordEffects(
                      freezeActions,
                      val,
                      Effect.Freeze,
                      ValueReason.Other
                    );
                  } else {
                    state.referenceAndRecordEffects(
                      freezeActions,
                      val,
                      Effect.Read,
                      ValueReason.Other
                    );
                  }
                }
              } catch (err) {
                _iterator319.e(err);
              } finally {
                _iterator319.f();
              }
              var _lvalue14 = instr.lvalue;
              _lvalue14.effect = Effect.ConditionallyMutate;
              state.initialize(instrValue, {
                kind: ValueKind.Frozen,
                reason: new Set([ValueReason.Other]),
                context: new Set()
              });
              state.define(_lvalue14, instrValue);
              continuation = { kind: "funeffects" };
              break;
            }
            case "LoadLocal": {
              var _lvalue15 = instr.lvalue;
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.place,
                Effect.Capture,
                ValueReason.Other
              );
              _lvalue15.effect = Effect.ConditionallyMutate;
              state.alias(_lvalue15, instrValue.place);
              continuation = { kind: "funeffects" };
              break;
            }
            case "LoadContext": {
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.place,
                Effect.Capture,
                ValueReason.Other
              );
              var _lvalue16 = instr.lvalue;
              _lvalue16.effect = Effect.ConditionallyMutate;
              var _valueKind3 = state.kind(instrValue.place);
              state.initialize(instrValue, _valueKind3);
              state.define(_lvalue16, instrValue);
              continuation = { kind: "funeffects" };
              break;
            }
            case "DeclareLocal": {
              var value = UndefinedValue;
              state.initialize(
                value,
                instrValue.lvalue.kind === InstructionKind.Catch
                  ? {
                      kind: ValueKind.Mutable,
                      reason: new Set([ValueReason.Other]),
                      context: new Set()
                    }
                  : {
                      kind: ValueKind.Primitive,
                      reason: new Set([ValueReason.Other]),
                      context: new Set()
                    }
              );
              state.define(instrValue.lvalue.place, value);
              continuation = { kind: "funeffects" };
              break;
            }
            case "DeclareContext": {
              state.initialize(instrValue, {
                kind: ValueKind.Mutable,
                reason: new Set([ValueReason.Other]),
                context: new Set()
              });
              state.define(instrValue.lvalue.place, instrValue);
              continuation = { kind: "funeffects" };
              break;
            }
            case "PostfixUpdate":
            case "PrefixUpdate": {
              var _effect2 =
                state.isDefined(instrValue.lvalue) &&
                state.kind(instrValue.lvalue).kind === ValueKind.Context
                  ? Effect.ConditionallyMutate
                  : Effect.Capture;
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.value,
                _effect2,
                ValueReason.Other
              );
              var _lvalue17 = instr.lvalue;
              state.alias(_lvalue17, instrValue.value);
              _lvalue17.effect = Effect.Store;
              state.alias(instrValue.lvalue, instrValue.value);
              instrValue.lvalue.effect = Effect.Store;
              continuation = { kind: "funeffects" };
              break;
            }
            case "StoreLocal": {
              var _effect3 =
                state.isDefined(instrValue.lvalue.place) &&
                state.kind(instrValue.lvalue.place).kind === ValueKind.Context
                  ? Effect.ConditionallyMutate
                  : Effect.Capture;
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.value,
                _effect3,
                ValueReason.Other
              );
              var _lvalue18 = instr.lvalue;
              state.alias(_lvalue18, instrValue.value);
              _lvalue18.effect = Effect.Store;
              state.alias(instrValue.lvalue.place, instrValue.value);
              instrValue.lvalue.place.effect = Effect.Store;
              continuation = { kind: "funeffects" };
              break;
            }
            case "StoreContext": {
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.value,
                Effect.ConditionallyMutate,
                ValueReason.Other
              );
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.lvalue.place,
                Effect.Mutate,
                ValueReason.Other
              );
              var _lvalue19 = instr.lvalue;
              state.alias(_lvalue19, instrValue.value);
              _lvalue19.effect = Effect.Store;
              continuation = { kind: "funeffects" };
              break;
            }
            case "StoreGlobal": {
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.value,
                Effect.Capture,
                ValueReason.Other
              );
              var _lvalue20 = instr.lvalue;
              _lvalue20.effect = Effect.Store;
              continuation = { kind: "funeffects" };
              break;
            }
            case "Destructure": {
              var _effect4 = Effect.Capture;
              var _iterator320 = _createForOfIteratorHelper(
                  eachPatternOperand(instrValue.lvalue.pattern)
                ),
                _step320;
              try {
                for (_iterator320.s(); !(_step320 = _iterator320.n()).done; ) {
                  var _place26 = _step320.value;
                  if (
                    state.isDefined(_place26) &&
                    state.kind(_place26).kind === ValueKind.Context
                  ) {
                    _effect4 = Effect.ConditionallyMutate;
                    break;
                  }
                }
              } catch (err) {
                _iterator320.e(err);
              } finally {
                _iterator320.f();
              }
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.value,
                _effect4,
                ValueReason.Other
              );
              var _lvalue21 = instr.lvalue;
              state.alias(_lvalue21, instrValue.value);
              _lvalue21.effect = Effect.Store;
              var _iterator321 = _createForOfIteratorHelper(
                  eachPatternOperand(instrValue.lvalue.pattern)
                ),
                _step321;
              try {
                for (_iterator321.s(); !(_step321 = _iterator321.n()).done; ) {
                  var _place27 = _step321.value;
                  state.alias(_place27, instrValue.value);
                  _place27.effect = Effect.Store;
                }
              } catch (err) {
                _iterator321.e(err);
              } finally {
                _iterator321.f();
              }
              continuation = { kind: "funeffects" };
              break;
            }
            case "GetIterator": {
              var kind = state.kind(instrValue.collection).kind;
              var _isMutable =
                kind === ValueKind.Mutable || kind === ValueKind.Context;
              var _effect5 = void 0;
              var _valueKind4 = void 0;
              if (
                !_isMutable ||
                isArrayType(instrValue.collection.identifier)
              ) {
                _effect5 = { kind: Effect.Read, reason: ValueReason.Other };
                _valueKind4 = {
                  kind: ValueKind.Mutable,
                  reason: new Set([ValueReason.Other]),
                  context: new Set()
                };
              } else {
                _effect5 = { kind: Effect.Capture, reason: ValueReason.Other };
                _valueKind4 = state.kind(instrValue.collection);
              }
              continuation = {
                kind: "initialize",
                effect: _effect5,
                valueKind: _valueKind4,
                lvalueEffect: Effect.Store
              };
              break;
            }
            case "IteratorNext": {
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.iterator,
                Effect.ConditionallyMutate,
                ValueReason.Other
              );
              state.referenceAndRecordEffects(
                freezeActions,
                instrValue.collection,
                Effect.Capture,
                ValueReason.Other
              );
              state.initialize(instrValue, state.kind(instrValue.collection));
              state.define(instr.lvalue, instrValue);
              instr.lvalue.effect = Effect.Store;
              continuation = { kind: "funeffects" };
              break;
            }
            case "NextPropertyOf": {
              continuation = {
                kind: "initialize",
                effect: { kind: Effect.Read, reason: ValueReason.Other },
                lvalueEffect: Effect.Store,
                valueKind: {
                  kind: ValueKind.Primitive,
                  reason: new Set([ValueReason.Other]),
                  context: new Set()
                }
              };
              break;
            }
            default: {
              assertExhaustive$1(instrValue, "Unexpected instruction kind");
            }
          }
          if (continuation.kind === "initialize") {
            var _iterator322 = _createForOfIteratorHelper(
                eachInstructionOperand(instr)
              ),
              _step322;
            try {
              for (_iterator322.s(); !(_step322 = _iterator322.n()).done; ) {
                var _operand18 = _step322.value;
                CompilerError.invariant(continuation.effect != null, {
                  reason:
                    "effectKind must be set for instruction value `".concat(
                      instrValue.kind,
                      "`"
                    ),
                  description: null,
                  loc: instrValue.loc,
                  suggestions: null
                });
                state.referenceAndRecordEffects(
                  freezeActions,
                  _operand18,
                  continuation.effect.kind,
                  continuation.effect.reason
                );
              }
            } catch (err) {
              _iterator322.e(err);
            } finally {
              _iterator322.f();
            }
            state.initialize(instrValue, continuation.valueKind);
            state.define(instr.lvalue, instrValue);
            instr.lvalue.effect =
              (_e = continuation.lvalueEffect) !== null && _e !== void 0
                ? _e
                : defaultLvalueEffect;
          }
          functionEffects.push.apply(
            functionEffects,
            _toConsumableArray(
              inferInstructionFunctionEffects(env, state, instr)
            )
          );
          freezeActions.forEach(function (_ref41) {
            var values = _ref41.values,
              reason = _ref41.reason;
            return state.freezeValues(values, reason);
          });
        }
      } catch (err) {
        _iterator310.e(err);
      } finally {
        _iterator310.f();
      }
      var terminalFreezeActions = [];
      var _iterator311 = _createForOfIteratorHelper(
          eachTerminalOperand(block.terminal)
        ),
        _step311;
      try {
        for (_iterator311.s(); !(_step311 = _iterator311.n()).done; ) {
          var _operand19 = _step311.value;
          var _effect6 = void 0;
          if (
            block.terminal.kind === "return" ||
            block.terminal.kind === "throw"
          ) {
            if (
              state.isDefined(_operand19) &&
              state.kind(_operand19).kind === ValueKind.Context
            ) {
              _effect6 = Effect.ConditionallyMutate;
            } else {
              _effect6 = Effect.Freeze;
            }
          } else {
            _effect6 = Effect.Read;
          }
          state.referenceAndRecordEffects(
            terminalFreezeActions,
            _operand19,
            _effect6,
            ValueReason.Other
          );
        }
      } catch (err) {
        _iterator311.e(err);
      } finally {
        _iterator311.f();
      }
      functionEffects.push.apply(
        functionEffects,
        _toConsumableArray(inferTerminalFunctionEffects(state, block))
      );
      terminalFreezeActions.forEach(function (_ref40) {
        var values = _ref40.values,
          reason = _ref40.reason;
        return state.freezeValues(values, reason);
      });
    }
    function getContextRefOperand(state, instrValue) {
      var result = [];
      var _iterator323 = _createForOfIteratorHelper(
          eachInstructionValueOperand(instrValue)
        ),
        _step323;
      try {
        for (_iterator323.s(); !(_step323 = _iterator323.n()).done; ) {
          var place = _step323.value;
          if (
            state.isDefined(place) &&
            state.kind(place).kind === ValueKind.Context
          ) {
            result.push(place);
          }
        }
      } catch (err) {
        _iterator323.e(err);
      } finally {
        _iterator323.f();
      }
      return result;
    }
    function getFunctionCallSignature(env, type) {
      if (type.kind !== "Function") {
        return null;
      }
      return env.getFunctionSignature(type);
    }
    function getFunctionEffects(fn, sig) {
      var results = [];
      for (var i = 0; i < fn.args.length; i++) {
        var arg = fn.args[i];
        if (i < sig.positionalParams.length) {
          if (arg.kind === "Identifier") {
            results.push(sig.positionalParams[i]);
          } else {
            return null;
          }
        } else if (sig.restParam !== null) {
          results.push(sig.restParam);
        } else {
          return null;
        }
      }
      return results;
    }
    function areArgumentsImmutableAndNonMutating(state, args) {
      var _iterator324 = _createForOfIteratorHelper(args),
        _step324;
      try {
        for (_iterator324.s(); !(_step324 = _iterator324.n()).done; ) {
          var arg = _step324.value;
          var place = arg.kind === "Identifier" ? arg : arg.place;
          var kind = state.kind(place).kind;
          switch (kind) {
            case ValueKind.Global:
            case ValueKind.Primitive:
            case ValueKind.Frozen: {
              break;
            }
            default: {
              return false;
            }
          }
          var values = state.values(place);
          var _iterator325 = _createForOfIteratorHelper(values),
            _step325;
          try {
            for (_iterator325.s(); !(_step325 = _iterator325.n()).done; ) {
              var value = _step325.value;
              if (
                value.kind === "FunctionExpression" &&
                value.loweredFunc.func.params.some(function (param) {
                  var place = param.kind === "Identifier" ? param : param.place;
                  var range = place.identifier.mutableRange;
                  return range.end > range.start + 1;
                })
              ) {
                return false;
              }
            }
          } catch (err) {
            _iterator325.e(err);
          } finally {
            _iterator325.f();
          }
        }
      } catch (err) {
        _iterator324.e(err);
      } finally {
        _iterator324.f();
      }
      return true;
    }
    function getArgumentEffect(signatureEffect, arg) {
      if (signatureEffect != null) {
        if (arg.kind === "Identifier") {
          return signatureEffect;
        } else if (
          signatureEffect === Effect.Mutate ||
          signatureEffect === Effect.ConditionallyMutate
        ) {
          return signatureEffect;
        } else {
          if (signatureEffect === Effect.Freeze) {
            CompilerError.throwTodo({
              reason: "Support spread syntax for hook arguments",
              loc: arg.place.loc
            });
          }
          return Effect.ConditionallyMutate;
        }
      } else {
        return Effect.ConditionallyMutate;
      }
    }
    function pruneNonEscapingScopes(fn) {
      var state = new State(fn.env);
      var _iterator326 = _createForOfIteratorHelper(fn.params),
        _step326;
      try {
        for (_iterator326.s(); !(_step326 = _iterator326.n()).done; ) {
          var param = _step326.value;
          if (param.kind === "Identifier") {
            state.declare(param.identifier.declarationId);
          } else {
            state.declare(param.place.identifier.declarationId);
          }
        }
      } catch (err) {
        _iterator326.e(err);
      } finally {
        _iterator326.f();
      }
      visitReactiveFunction(fn, new CollectDependenciesVisitor(fn.env), state);
      var memoized = computeMemoizedIdentifiers(state);
      visitReactiveFunction(fn, new PruneScopesTransform(), memoized);
    }
    var MemoizationLevel;
    (function (MemoizationLevel) {
      MemoizationLevel["Memoized"] = "Memoized";
      MemoizationLevel["Conditional"] = "Conditional";
      MemoizationLevel["Unmemoized"] = "Unmemoized";
      MemoizationLevel["Never"] = "Never";
    })(MemoizationLevel || (MemoizationLevel = {}));
    function joinAliases(kind1, kind2) {
      if (
        kind1 === MemoizationLevel.Memoized ||
        kind2 === MemoizationLevel.Memoized
      ) {
        return MemoizationLevel.Memoized;
      } else if (
        kind1 === MemoizationLevel.Conditional ||
        kind2 === MemoizationLevel.Conditional
      ) {
        return MemoizationLevel.Conditional;
      } else if (
        kind1 === MemoizationLevel.Unmemoized ||
        kind2 === MemoizationLevel.Unmemoized
      ) {
        return MemoizationLevel.Unmemoized;
      } else {
        return MemoizationLevel.Never;
      }
    }
    var State = /*#__PURE__*/ (function () {
      function State(env) {
        _classCallCheck(this, State);
        this.definitions = new Map();
        this.identifiers = new Map();
        this.scopes = new Map();
        this.escapingValues = new Set();
        this.env = env;
      }
      return _createClass(State, [
        {
          key: "declare",
          value: function declare(id) {
            this.identifiers.set(id, {
              level: MemoizationLevel.Never,
              memoized: false,
              dependencies: new Set(),
              scopes: new Set(),
              seen: false
            });
          }
        },
        {
          key: "visitOperand",
          value: function visitOperand(id, place, identifier) {
            var scope = getPlaceScope(id, place);
            if (scope !== null) {
              var _node11 = this.scopes.get(scope.id);
              if (_node11 === undefined) {
                _node11 = {
                  dependencies: _toConsumableArray(scope.dependencies).map(
                    function (dep) {
                      return dep.identifier.declarationId;
                    }
                  ),
                  seen: false
                };
                this.scopes.set(scope.id, _node11);
              }
              var identifierNode = this.identifiers.get(identifier);
              CompilerError.invariant(identifierNode !== undefined, {
                reason: "Expected identifier to be initialized",
                description: null,
                loc: place.loc,
                suggestions: null
              });
              identifierNode.scopes.add(scope.id);
            }
          }
        }
      ]);
    })();
    function computeMemoizedIdentifiers(state) {
      var memoized = new Set();
      function visit(id) {
        var forceMemoize =
          arguments.length > 1 && arguments[1] !== undefined
            ? arguments[1]
            : false;
        var node = state.identifiers.get(id);
        CompilerError.invariant(node !== undefined, {
          reason:
            "Expected a node for all identifiers, none found for `".concat(
              id,
              "`"
            ),
          description: null,
          loc: null,
          suggestions: null
        });
        if (node.seen) {
          return node.memoized;
        }
        node.seen = true;
        node.memoized = false;
        var hasMemoizedDependency = false;
        var _iterator327 = _createForOfIteratorHelper(node.dependencies),
          _step327;
        try {
          for (_iterator327.s(); !(_step327 = _iterator327.n()).done; ) {
            var dep = _step327.value;
            var isDepMemoized = visit(dep);
            hasMemoizedDependency || (hasMemoizedDependency = isDepMemoized);
          }
        } catch (err) {
          _iterator327.e(err);
        } finally {
          _iterator327.f();
        }
        if (
          node.level === MemoizationLevel.Memoized ||
          (node.level === MemoizationLevel.Conditional &&
            (hasMemoizedDependency || forceMemoize)) ||
          (node.level === MemoizationLevel.Unmemoized && forceMemoize)
        ) {
          node.memoized = true;
          memoized.add(id);
          var _iterator328 = _createForOfIteratorHelper(node.scopes),
            _step328;
          try {
            for (_iterator328.s(); !(_step328 = _iterator328.n()).done; ) {
              var scope = _step328.value;
              forceMemoizeScopeDependencies(scope);
            }
          } catch (err) {
            _iterator328.e(err);
          } finally {
            _iterator328.f();
          }
        }
        return node.memoized;
      }
      function forceMemoizeScopeDependencies(id) {
        var node = state.scopes.get(id);
        CompilerError.invariant(node !== undefined, {
          reason: "Expected a node for all scopes",
          description: null,
          loc: null,
          suggestions: null
        });
        if (node.seen) {
          return;
        }
        node.seen = true;
        var _iterator329 = _createForOfIteratorHelper(node.dependencies),
          _step329;
        try {
          for (_iterator329.s(); !(_step329 = _iterator329.n()).done; ) {
            var dep = _step329.value;
            visit(dep, true);
          }
        } catch (err) {
          _iterator329.e(err);
        } finally {
          _iterator329.f();
        }
        return;
      }
      var _iterator330 = _createForOfIteratorHelper(state.escapingValues),
        _step330;
      try {
        for (_iterator330.s(); !(_step330 = _iterator330.n()).done; ) {
          var value = _step330.value;
          visit(value);
        }
      } catch (err) {
        _iterator330.e(err);
      } finally {
        _iterator330.f();
      }
      return memoized;
    }
    function computeMemoizationInputs(env, value, lvalue, options) {
      switch (value.kind) {
        case "ConditionalExpression": {
          return {
            lvalues:
              lvalue !== null
                ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
                : [],
            rvalues: [].concat(
              _toConsumableArray(
                computeMemoizationInputs(env, value.consequent, null, options)
                  .rvalues
              ),
              _toConsumableArray(
                computeMemoizationInputs(env, value.alternate, null, options)
                  .rvalues
              )
            )
          };
        }
        case "LogicalExpression": {
          return {
            lvalues:
              lvalue !== null
                ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
                : [],
            rvalues: [].concat(
              _toConsumableArray(
                computeMemoizationInputs(env, value.left, null, options).rvalues
              ),
              _toConsumableArray(
                computeMemoizationInputs(env, value.right, null, options)
                  .rvalues
              )
            )
          };
        }
        case "SequenceExpression": {
          return {
            lvalues:
              lvalue !== null
                ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
                : [],
            rvalues: computeMemoizationInputs(env, value.value, null, options)
              .rvalues
          };
        }
        case "JsxExpression": {
          var operands = [];
          if (value.tag.kind === "Identifier") {
            operands.push(value.tag);
          }
          var _iterator331 = _createForOfIteratorHelper(value.props),
            _step331;
          try {
            for (_iterator331.s(); !(_step331 = _iterator331.n()).done; ) {
              var prop = _step331.value;
              if (prop.kind === "JsxAttribute") {
                operands.push(prop.place);
              } else {
                operands.push(prop.argument);
              }
            }
          } catch (err) {
            _iterator331.e(err);
          } finally {
            _iterator331.f();
          }
          if (value.children !== null) {
            var _iterator332 = _createForOfIteratorHelper(value.children),
              _step332;
            try {
              for (_iterator332.s(); !(_step332 = _iterator332.n()).done; ) {
                var child = _step332.value;
                operands.push(child);
              }
            } catch (err) {
              _iterator332.e(err);
            } finally {
              _iterator332.f();
            }
          }
          var level = options.memoizeJsxElements
            ? MemoizationLevel.Memoized
            : MemoizationLevel.Unmemoized;
          return {
            lvalues: lvalue !== null ? [{ place: lvalue, level: level }] : [],
            rvalues: operands
          };
        }
        case "JsxFragment": {
          var _level = options.memoizeJsxElements
            ? MemoizationLevel.Memoized
            : MemoizationLevel.Unmemoized;
          return {
            lvalues: lvalue !== null ? [{ place: lvalue, level: _level }] : [],
            rvalues: value.children
          };
        }
        case "NextPropertyOf":
        case "StartMemoize":
        case "FinishMemoize":
        case "Debugger":
        case "ComputedDelete":
        case "PropertyDelete":
        case "LoadGlobal":
        case "MetaProperty":
        case "TemplateLiteral":
        case "Primitive":
        case "JSXText":
        case "BinaryExpression":
        case "UnaryExpression": {
          var _level2 = options.forceMemoizePrimitives
            ? MemoizationLevel.Memoized
            : MemoizationLevel.Never;
          return {
            lvalues: lvalue !== null ? [{ place: lvalue, level: _level2 }] : [],
            rvalues: []
          };
        }
        case "Await":
        case "TypeCastExpression": {
          return {
            lvalues:
              lvalue !== null
                ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
                : [],
            rvalues: [value.value]
          };
        }
        case "IteratorNext": {
          return {
            lvalues:
              lvalue !== null
                ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
                : [],
            rvalues: [value.iterator, value.collection]
          };
        }
        case "GetIterator": {
          return {
            lvalues:
              lvalue !== null
                ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
                : [],
            rvalues: [value.collection]
          };
        }
        case "LoadLocal": {
          return {
            lvalues:
              lvalue !== null
                ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
                : [],
            rvalues: [value.place]
          };
        }
        case "LoadContext": {
          return {
            lvalues:
              lvalue !== null
                ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
                : [],
            rvalues: [value.place]
          };
        }
        case "DeclareContext": {
          var lvalues = [
            { place: value.lvalue.place, level: MemoizationLevel.Memoized }
          ];
          if (lvalue !== null) {
            lvalues.push({ place: lvalue, level: MemoizationLevel.Unmemoized });
          }
          return { lvalues: lvalues, rvalues: [] };
        }
        case "DeclareLocal": {
          var _lvalues = [
            { place: value.lvalue.place, level: MemoizationLevel.Unmemoized }
          ];
          if (lvalue !== null) {
            _lvalues.push({
              place: lvalue,
              level: MemoizationLevel.Unmemoized
            });
          }
          return { lvalues: _lvalues, rvalues: [] };
        }
        case "PrefixUpdate":
        case "PostfixUpdate": {
          var _lvalues2 = [
            { place: value.lvalue, level: MemoizationLevel.Conditional }
          ];
          if (lvalue !== null) {
            _lvalues2.push({
              place: lvalue,
              level: MemoizationLevel.Conditional
            });
          }
          return { lvalues: _lvalues2, rvalues: [value.value] };
        }
        case "StoreLocal": {
          var _lvalues3 = [
            { place: value.lvalue.place, level: MemoizationLevel.Conditional }
          ];
          if (lvalue !== null) {
            _lvalues3.push({
              place: lvalue,
              level: MemoizationLevel.Conditional
            });
          }
          return { lvalues: _lvalues3, rvalues: [value.value] };
        }
        case "StoreContext": {
          var _lvalues4 = [
            { place: value.lvalue.place, level: MemoizationLevel.Memoized }
          ];
          if (lvalue !== null) {
            _lvalues4.push({
              place: lvalue,
              level: MemoizationLevel.Conditional
            });
          }
          return { lvalues: _lvalues4, rvalues: [value.value] };
        }
        case "StoreGlobal": {
          var _lvalues5 = [];
          if (lvalue !== null) {
            _lvalues5.push({
              place: lvalue,
              level: MemoizationLevel.Unmemoized
            });
          }
          return { lvalues: _lvalues5, rvalues: [value.value] };
        }
        case "Destructure": {
          var _lvalues6 = [];
          if (lvalue !== null) {
            _lvalues6.push({
              place: lvalue,
              level: MemoizationLevel.Conditional
            });
          }
          _lvalues6.push.apply(
            _lvalues6,
            _toConsumableArray(computePatternLValues(value.lvalue.pattern))
          );
          return { lvalues: _lvalues6, rvalues: [value.value] };
        }
        case "ComputedLoad":
        case "PropertyLoad": {
          var _level3 = options.forceMemoizePrimitives
            ? MemoizationLevel.Memoized
            : MemoizationLevel.Conditional;
          return {
            lvalues: lvalue !== null ? [{ place: lvalue, level: _level3 }] : [],
            rvalues: [value.object]
          };
        }
        case "ComputedStore": {
          var _lvalues7 = [
            { place: value.object, level: MemoizationLevel.Conditional }
          ];
          if (lvalue !== null) {
            _lvalues7.push({
              place: lvalue,
              level: MemoizationLevel.Conditional
            });
          }
          return { lvalues: _lvalues7, rvalues: [value.value] };
        }
        case "OptionalExpression": {
          var _lvalues8 = [];
          if (lvalue !== null) {
            _lvalues8.push({
              place: lvalue,
              level: MemoizationLevel.Conditional
            });
          }
          return {
            lvalues: _lvalues8,
            rvalues: _toConsumableArray(
              computeMemoizationInputs(env, value.value, null, options).rvalues
            )
          };
        }
        case "TaggedTemplateExpression": {
          var signature = getFunctionCallSignature(
            env,
            value.tag.identifier.type
          );
          var _lvalues9 = [];
          if (lvalue !== null) {
            _lvalues9.push({ place: lvalue, level: MemoizationLevel.Memoized });
          }
          if (
            (signature === null || signature === void 0
              ? void 0
              : signature.noAlias) === true
          ) {
            return { lvalues: _lvalues9, rvalues: [] };
          }
          var _operands2 = _toConsumableArray(eachReactiveValueOperand(value));
          _lvalues9.push.apply(
            _lvalues9,
            _toConsumableArray(
              _operands2
                .filter(function (operand) {
                  return isMutableEffect(operand.effect, operand.loc);
                })
                .map(function (place) {
                  return { place: place, level: MemoizationLevel.Memoized };
                })
            )
          );
          return { lvalues: _lvalues9, rvalues: _operands2 };
        }
        case "CallExpression": {
          var _signature3 = getFunctionCallSignature(
            env,
            value.callee.identifier.type
          );
          var _lvalues10 = [];
          if (lvalue !== null) {
            _lvalues10.push({
              place: lvalue,
              level: MemoizationLevel.Memoized
            });
          }
          if (
            (_signature3 === null || _signature3 === void 0
              ? void 0
              : _signature3.noAlias) === true
          ) {
            return { lvalues: _lvalues10, rvalues: [] };
          }
          var _operands3 = _toConsumableArray(eachReactiveValueOperand(value));
          _lvalues10.push.apply(
            _lvalues10,
            _toConsumableArray(
              _operands3
                .filter(function (operand) {
                  return isMutableEffect(operand.effect, operand.loc);
                })
                .map(function (place) {
                  return { place: place, level: MemoizationLevel.Memoized };
                })
            )
          );
          return { lvalues: _lvalues10, rvalues: _operands3 };
        }
        case "MethodCall": {
          var _signature4 = getFunctionCallSignature(
            env,
            value.property.identifier.type
          );
          var _lvalues11 = [];
          if (lvalue !== null) {
            _lvalues11.push({
              place: lvalue,
              level: MemoizationLevel.Memoized
            });
          }
          if (
            (_signature4 === null || _signature4 === void 0
              ? void 0
              : _signature4.noAlias) === true
          ) {
            return { lvalues: _lvalues11, rvalues: [] };
          }
          var _operands4 = _toConsumableArray(eachReactiveValueOperand(value));
          _lvalues11.push.apply(
            _lvalues11,
            _toConsumableArray(
              _operands4
                .filter(function (operand) {
                  return isMutableEffect(operand.effect, operand.loc);
                })
                .map(function (place) {
                  return { place: place, level: MemoizationLevel.Memoized };
                })
            )
          );
          return { lvalues: _lvalues11, rvalues: _operands4 };
        }
        case "RegExpLiteral":
        case "ObjectMethod":
        case "FunctionExpression":
        case "ArrayExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "PropertyStore": {
          var _operands5 = _toConsumableArray(eachReactiveValueOperand(value));
          var _lvalues12 = _operands5
            .filter(function (operand) {
              return isMutableEffect(operand.effect, operand.loc);
            })
            .map(function (place) {
              return { place: place, level: MemoizationLevel.Memoized };
            });
          if (lvalue !== null) {
            _lvalues12.push({
              place: lvalue,
              level: MemoizationLevel.Memoized
            });
          }
          return { lvalues: _lvalues12, rvalues: _operands5 };
        }
        case "UnsupportedNode": {
          CompilerError.invariant(false, {
            reason: "Unexpected unsupported node",
            description: null,
            loc: value.loc,
            suggestions: null
          });
        }
        default: {
          assertExhaustive$1(
            value,
            "Unexpected value kind `".concat(value.kind, "`")
          );
        }
      }
    }
    function computePatternLValues(pattern) {
      var lvalues = [];
      switch (pattern.kind) {
        case "ArrayPattern": {
          var _iterator333 = _createForOfIteratorHelper(pattern.items),
            _step333;
          try {
            for (_iterator333.s(); !(_step333 = _iterator333.n()).done; ) {
              var item = _step333.value;
              if (item.kind === "Identifier") {
                lvalues.push({
                  place: item,
                  level: MemoizationLevel.Conditional
                });
              } else if (item.kind === "Spread") {
                lvalues.push({
                  place: item.place,
                  level: MemoizationLevel.Memoized
                });
              }
            }
          } catch (err) {
            _iterator333.e(err);
          } finally {
            _iterator333.f();
          }
          break;
        }
        case "ObjectPattern": {
          var _iterator334 = _createForOfIteratorHelper(pattern.properties),
            _step334;
          try {
            for (_iterator334.s(); !(_step334 = _iterator334.n()).done; ) {
              var property = _step334.value;
              if (property.kind === "ObjectProperty") {
                lvalues.push({
                  place: property.place,
                  level: MemoizationLevel.Conditional
                });
              } else {
                lvalues.push({
                  place: property.place,
                  level: MemoizationLevel.Memoized
                });
              }
            }
          } catch (err) {
            _iterator334.e(err);
          } finally {
            _iterator334.f();
          }
          break;
        }
        default: {
          assertExhaustive$1(
            pattern,
            "Unexpected pattern kind `".concat(pattern.kind, "`")
          );
        }
      }
      return lvalues;
    }
    var CollectDependenciesVisitor = /*#__PURE__*/ (function (
      _ReactiveFunctionVisi11
    ) {
      function CollectDependenciesVisitor(env) {
        var _this17;
        _classCallCheck(this, CollectDependenciesVisitor);
        _this17 = _callSuper(this, CollectDependenciesVisitor);
        _this17.env = env;
        _this17.options = {
          memoizeJsxElements: !_this17.env.config.enableForest,
          forceMemoizePrimitives: _this17.env.config.enableForest
        };
        return _this17;
      }
      _inherits2(CollectDependenciesVisitor, _ReactiveFunctionVisi11);
      return _createClass(CollectDependenciesVisitor, [
        {
          key: "visitInstruction",
          value: function visitInstruction(instruction, state) {
            var _a, _b, _c;
            this.traverseInstruction(instruction, state);
            var aliasing = computeMemoizationInputs(
              this.env,
              instruction.value,
              instruction.lvalue,
              this.options
            );
            var _iterator335 = _createForOfIteratorHelper(aliasing.rvalues),
              _step335;
            try {
              for (_iterator335.s(); !(_step335 = _iterator335.n()).done; ) {
                var _operand20 = _step335.value;
                var operandId =
                  (_a = state.definitions.get(
                    _operand20.identifier.declarationId
                  )) !== null && _a !== void 0
                    ? _a
                    : _operand20.identifier.declarationId;
                state.visitOperand(instruction.id, _operand20, operandId);
              }
            } catch (err) {
              _iterator335.e(err);
            } finally {
              _iterator335.f();
            }
            var _iterator336 = _createForOfIteratorHelper(aliasing.lvalues),
              _step336;
            try {
              for (_iterator336.s(); !(_step336 = _iterator336.n()).done; ) {
                var _step336$value = _step336.value,
                  lvalue = _step336$value.place,
                  level = _step336$value.level;
                var lvalueId =
                  (_b = state.definitions.get(
                    lvalue.identifier.declarationId
                  )) !== null && _b !== void 0
                    ? _b
                    : lvalue.identifier.declarationId;
                var _node12 = state.identifiers.get(lvalueId);
                if (_node12 === undefined) {
                  _node12 = {
                    level: MemoizationLevel.Never,
                    memoized: false,
                    dependencies: new Set(),
                    scopes: new Set(),
                    seen: false
                  };
                  state.identifiers.set(lvalueId, _node12);
                }
                _node12.level = joinAliases(_node12.level, level);
                var _iterator338 = _createForOfIteratorHelper(aliasing.rvalues),
                  _step338;
                try {
                  for (
                    _iterator338.s();
                    !(_step338 = _iterator338.n()).done;

                  ) {
                    var _operand21 = _step338.value;
                    var _operandId =
                      (_c = state.definitions.get(
                        _operand21.identifier.declarationId
                      )) !== null && _c !== void 0
                        ? _c
                        : _operand21.identifier.declarationId;
                    if (_operandId === lvalueId) {
                      continue;
                    }
                    _node12.dependencies.add(_operandId);
                  }
                } catch (err) {
                  _iterator338.e(err);
                } finally {
                  _iterator338.f();
                }
                state.visitOperand(instruction.id, lvalue, lvalueId);
              }
            } catch (err) {
              _iterator336.e(err);
            } finally {
              _iterator336.f();
            }
            if (
              instruction.value.kind === "LoadLocal" &&
              instruction.lvalue !== null
            ) {
              state.definitions.set(
                instruction.lvalue.identifier.declarationId,
                instruction.value.place.identifier.declarationId
              );
            } else if (
              instruction.value.kind === "CallExpression" ||
              instruction.value.kind === "MethodCall"
            ) {
              var callee =
                instruction.value.kind === "CallExpression"
                  ? instruction.value.callee
                  : instruction.value.property;
              if (getHookKind(state.env, callee.identifier) != null) {
                var signature = getFunctionCallSignature(
                  this.env,
                  callee.identifier.type
                );
                if (signature && signature.noAlias === true) {
                  return;
                }
                var _iterator337 = _createForOfIteratorHelper(
                    instruction.value.args
                  ),
                  _step337;
                try {
                  for (
                    _iterator337.s();
                    !(_step337 = _iterator337.n()).done;

                  ) {
                    var operand = _step337.value;
                    var place =
                      operand.kind === "Spread" ? operand.place : operand;
                    state.escapingValues.add(place.identifier.declarationId);
                  }
                } catch (err) {
                  _iterator337.e(err);
                } finally {
                  _iterator337.f();
                }
              }
            }
          }
        },
        {
          key: "visitTerminal",
          value: function visitTerminal(stmt, state) {
            this.traverseTerminal(stmt, state);
            if (stmt.terminal.kind === "return") {
              state.escapingValues.add(
                stmt.terminal.value.identifier.declarationId
              );
            }
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    var PruneScopesTransform = /*#__PURE__*/ (function (
      _ReactiveFunctionTran5
    ) {
      function PruneScopesTransform() {
        var _this18;
        _classCallCheck(this, PruneScopesTransform);
        _this18 = _callSuper(this, PruneScopesTransform, arguments);
        _this18.prunedScopes = new Set();
        _this18.reassignments = new Map();
        return _this18;
      }
      _inherits2(PruneScopesTransform, _ReactiveFunctionTran5);
      return _createClass(PruneScopesTransform, [
        {
          key: "transformScope",
          value: function transformScope(scopeBlock, state) {
            this.visitScope(scopeBlock, state);
            if (
              (scopeBlock.scope.declarations.size === 0 &&
                scopeBlock.scope.reassignments.size === 0) ||
              scopeBlock.scope.earlyReturnValue !== null
            ) {
              return { kind: "keep" };
            }
            var hasMemoizedOutput =
              Array.from(scopeBlock.scope.declarations.values()).some(
                function (decl) {
                  return state.has(decl.identifier.declarationId);
                }
              ) ||
              Array.from(scopeBlock.scope.reassignments).some(
                function (identifier) {
                  return state.has(identifier.declarationId);
                }
              );
            if (hasMemoizedOutput) {
              return { kind: "keep" };
            } else {
              this.prunedScopes.add(scopeBlock.scope.id);
              return { kind: "replace-many", value: scopeBlock.instructions };
            }
          }
        },
        {
          key: "transformInstruction",
          value: function transformInstruction(instruction, state) {
            var _this19 = this;
            var _a;
            this.traverseInstruction(instruction, state);
            var value = instruction.value;
            if (
              value.kind === "StoreLocal" &&
              value.lvalue.kind === "Reassign"
            ) {
              var ids = getOrInsertDefault(
                this.reassignments,
                value.lvalue.place.identifier.declarationId,
                new Set()
              );
              ids.add(value.value.identifier);
            } else if (value.kind === "FinishMemoize") {
              var decls;
              if (value.decl.identifier.scope == null) {
                decls =
                  (_a = this.reassignments.get(
                    value.decl.identifier.declarationId
                  )) !== null && _a !== void 0
                    ? _a
                    : [value.decl.identifier];
              } else {
                decls = [value.decl.identifier];
              }
              if (
                _toConsumableArray(decls).every(function (decl) {
                  return (
                    decl.scope == null ||
                    _this19.prunedScopes.has(decl.scope.id)
                  );
                })
              ) {
                value.pruned = true;
              }
            }
            return { kind: "keep" };
          }
        }
      ]);
    })(ReactiveFunctionTransform);
    var Visitor$7 = /*#__PURE__*/ (function (_ReactiveFunctionVisi12) {
      function Visitor() {
        _classCallCheck(this, Visitor);
        return _callSuper(this, Visitor, arguments);
      }
      _inherits2(Visitor, _ReactiveFunctionVisi12);
      return _createClass(Visitor, [
        {
          key: "visitLValue",
          value: function visitLValue(id, lvalue, state) {
            this.visitPlace(id, lvalue, state);
          }
        },
        {
          key: "visitPlace",
          value: function visitPlace(_id, place, state) {
            if (place.reactive) {
              state.add(place.identifier.id);
            }
          }
        },
        {
          key: "visitPrunedScope",
          value: function visitPrunedScope(scopeBlock, state) {
            this.traversePrunedScope(scopeBlock, state);
            var _iterator339 = _createForOfIteratorHelper(
                scopeBlock.scope.declarations
              ),
              _step339;
            try {
              for (_iterator339.s(); !(_step339 = _iterator339.n()).done; ) {
                var _step339$value = _slicedToArray(_step339.value, 2),
                  id = _step339$value[0],
                  decl = _step339$value[1];
                if (
                  !isPrimitiveType(decl.identifier) &&
                  !isStableRefType(decl.identifier, state)
                ) {
                  state.add(id);
                }
              }
            } catch (err) {
              _iterator339.e(err);
            } finally {
              _iterator339.f();
            }
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    function isStableRefType(identifier, reactiveIdentifiers) {
      return (
        isUseRefType(identifier) && !reactiveIdentifiers.has(identifier.id)
      );
    }
    function collectReactiveIdentifiers(fn) {
      var visitor = new Visitor$7();
      var state = new Set();
      visitReactiveFunction(fn, visitor, state);
      return state;
    }
    function pruneNonReactiveDependencies(fn) {
      var reactiveIdentifiers = collectReactiveIdentifiers(fn);
      visitReactiveFunction(fn, new Visitor$6(), reactiveIdentifiers);
    }
    var Visitor$6 = /*#__PURE__*/ (function (_ReactiveFunctionVisi13) {
      function Visitor() {
        _classCallCheck(this, Visitor);
        return _callSuper(this, Visitor, arguments);
      }
      _inherits2(Visitor, _ReactiveFunctionVisi13);
      return _createClass(Visitor, [
        {
          key: "visitInstruction",
          value: function visitInstruction(instruction, state) {
            this.traverseInstruction(instruction, state);
            var lvalue = instruction.lvalue,
              value = instruction.value;
            switch (value.kind) {
              case "LoadLocal": {
                if (lvalue !== null && state.has(value.place.identifier.id)) {
                  state.add(lvalue.identifier.id);
                }
                break;
              }
              case "StoreLocal": {
                if (state.has(value.value.identifier.id)) {
                  state.add(value.lvalue.place.identifier.id);
                  if (lvalue !== null) {
                    state.add(lvalue.identifier.id);
                  }
                }
                break;
              }
              case "Destructure": {
                if (state.has(value.value.identifier.id)) {
                  var _iterator340 = _createForOfIteratorHelper(
                      eachPatternOperand(value.lvalue.pattern)
                    ),
                    _step340;
                  try {
                    for (
                      _iterator340.s();
                      !(_step340 = _iterator340.n()).done;

                    ) {
                      var _lvalue22 = _step340.value;
                      if (isStableType(_lvalue22.identifier)) {
                        continue;
                      }
                      state.add(_lvalue22.identifier.id);
                    }
                  } catch (err) {
                    _iterator340.e(err);
                  } finally {
                    _iterator340.f();
                  }
                  if (lvalue !== null) {
                    state.add(lvalue.identifier.id);
                  }
                }
                break;
              }
              case "PropertyLoad": {
                if (
                  lvalue !== null &&
                  state.has(value.object.identifier.id) &&
                  !isStableType(lvalue.identifier)
                ) {
                  state.add(lvalue.identifier.id);
                }
                break;
              }
              case "ComputedLoad": {
                if (
                  lvalue !== null &&
                  (state.has(value.object.identifier.id) ||
                    state.has(value.property.identifier.id))
                ) {
                  state.add(lvalue.identifier.id);
                }
                break;
              }
            }
          }
        },
        {
          key: "visitScope",
          value: function visitScope(scopeBlock, state) {
            this.traverseScope(scopeBlock, state);
            var _iterator341 = _createForOfIteratorHelper(
                scopeBlock.scope.dependencies
              ),
              _step341;
            try {
              for (_iterator341.s(); !(_step341 = _iterator341.n()).done; ) {
                var dep = _step341.value;
                var isReactive = state.has(dep.identifier.id);
                if (!isReactive) {
                  scopeBlock.scope.dependencies["delete"](dep);
                }
              }
            } catch (err) {
              _iterator341.e(err);
            } finally {
              _iterator341.f();
            }
            if (scopeBlock.scope.dependencies.size !== 0) {
              var _iterator342 = _createForOfIteratorHelper(
                  scopeBlock.scope.declarations
                ),
                _step342;
              try {
                for (_iterator342.s(); !(_step342 = _iterator342.n()).done; ) {
                  var _step342$value = _slicedToArray(_step342.value, 2),
                    declaration = _step342$value[1];
                  state.add(declaration.identifier.id);
                }
              } catch (err) {
                _iterator342.e(err);
              } finally {
                _iterator342.f();
              }
              var _iterator343 = _createForOfIteratorHelper(
                  scopeBlock.scope.reassignments
                ),
                _step343;
              try {
                for (_iterator343.s(); !(_step343 = _iterator343.n()).done; ) {
                  var reassignment = _step343.value;
                  state.add(reassignment.id);
                }
              } catch (err) {
                _iterator343.e(err);
              } finally {
                _iterator343.f();
              }
            }
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    function pruneUnusedLValues(fn) {
      var lvalues = new Map();
      visitReactiveFunction(fn, new Visitor$5(), lvalues);
      var _iterator344 = _createForOfIteratorHelper(lvalues),
        _step344;
      try {
        for (_iterator344.s(); !(_step344 = _iterator344.n()).done; ) {
          var _step344$value = _slicedToArray(_step344.value, 2),
            instr = _step344$value[1];
          instr.lvalue = null;
        }
      } catch (err) {
        _iterator344.e(err);
      } finally {
        _iterator344.f();
      }
    }
    var Visitor$5 = /*#__PURE__*/ (function (_ReactiveFunctionVisi14) {
      function Visitor() {
        _classCallCheck(this, Visitor);
        return _callSuper(this, Visitor, arguments);
      }
      _inherits2(Visitor, _ReactiveFunctionVisi14);
      return _createClass(Visitor, [
        {
          key: "visitPlace",
          value: function visitPlace(id, place, state) {
            state["delete"](place.identifier.declarationId);
          }
        },
        {
          key: "visitInstruction",
          value: function visitInstruction(instruction, state) {
            this.traverseInstruction(instruction, state);
            if (
              instruction.lvalue !== null &&
              instruction.lvalue.identifier.name === null
            ) {
              state.set(
                instruction.lvalue.identifier.declarationId,
                instruction
              );
            }
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    function pruneUnusedLabels(fn) {
      var labels = new Set();
      visitReactiveFunction(fn, new Transform$2(), labels);
    }
    var Transform$2 = /*#__PURE__*/ (function (_ReactiveFunctionTran6) {
      function Transform() {
        _classCallCheck(this, Transform);
        return _callSuper(this, Transform, arguments);
      }
      _inherits2(Transform, _ReactiveFunctionTran6);
      return _createClass(Transform, [
        {
          key: "transformTerminal",
          value: function transformTerminal(stmt, state) {
            this.traverseTerminal(stmt, state);
            var terminal = stmt.terminal;
            if (
              (terminal.kind === "break" || terminal.kind === "continue") &&
              terminal.targetKind === "labeled"
            ) {
              state.add(terminal.target);
            }
            var isReachableLabel =
              stmt.label !== null && state.has(stmt.label.id);
            if (stmt.terminal.kind === "label" && !isReachableLabel) {
              var block = _toConsumableArray(stmt.terminal.block);
              var _last7 = block.at(-1);
              if (
                _last7 !== undefined &&
                _last7.kind === "terminal" &&
                _last7.terminal.kind === "break" &&
                _last7.terminal.target === null
              ) {
                block.pop();
              }
              return { kind: "replace-many", value: block };
            } else {
              if (!isReachableLabel && stmt.label != null) {
                stmt.label.implicit = true;
              }
              return { kind: "keep" };
            }
          }
        }
      ]);
    })(ReactiveFunctionTransform);
    function pruneUnusedScopes(fn) {
      visitReactiveFunction(fn, new Transform$1(), {
        hasReturnStatement: false
      });
    }
    var Transform$1 = /*#__PURE__*/ (function (_ReactiveFunctionTran7) {
      function Transform() {
        _classCallCheck(this, Transform);
        return _callSuper(this, Transform, arguments);
      }
      _inherits2(Transform, _ReactiveFunctionTran7);
      return _createClass(Transform, [
        {
          key: "visitTerminal",
          value: function visitTerminal(stmt, state) {
            this.traverseTerminal(stmt, state);
            if (stmt.terminal.kind === "return") {
              state.hasReturnStatement = true;
            }
          }
        },
        {
          key: "transformScope",
          value: function transformScope(scopeBlock, _state) {
            var scopeState = { hasReturnStatement: false };
            this.visitScope(scopeBlock, scopeState);
            if (
              !scopeState.hasReturnStatement &&
              scopeBlock.scope.reassignments.size === 0 &&
              (scopeBlock.scope.declarations.size === 0 ||
                !hasOwnDeclaration(scopeBlock))
            ) {
              return {
                kind: "replace",
                value: {
                  kind: "pruned-scope",
                  scope: scopeBlock.scope,
                  instructions: scopeBlock.instructions
                }
              };
            } else {
              return { kind: "keep" };
            }
          }
        }
      ]);
    })(ReactiveFunctionTransform);
    function hasOwnDeclaration(block) {
      var _iterator345 = _createForOfIteratorHelper(
          block.scope.declarations.values()
        ),
        _step345;
      try {
        for (_iterator345.s(); !(_step345 = _iterator345.n()).done; ) {
          var declaration = _step345.value;
          if (declaration.scope.id === block.scope.id) {
            return true;
          }
        }
      } catch (err) {
        _iterator345.e(err);
      } finally {
        _iterator345.f();
      }
      return false;
    }
    function collectReferencedGlobals(fn) {
      var identifiers = new Set();
      visitReactiveFunction(fn, new Visitor$4(), identifiers);
      return identifiers;
    }
    var Visitor$4 = /*#__PURE__*/ (function (_ReactiveFunctionVisi15) {
      function Visitor() {
        _classCallCheck(this, Visitor);
        return _callSuper(this, Visitor, arguments);
      }
      _inherits2(Visitor, _ReactiveFunctionVisi15);
      return _createClass(Visitor, [
        {
          key: "visitValue",
          value: function visitValue(id, value, state) {
            this.traverseValue(id, value, state);
            if (
              value.kind === "FunctionExpression" ||
              value.kind === "ObjectMethod"
            ) {
              this.visitHirFunction(value.loweredFunc.func, state);
            } else if (value.kind === "LoadGlobal") {
              state.add(value.binding.name);
            }
          }
        },
        {
          key: "visitReactiveFunctionValue",
          value: function visitReactiveFunctionValue(
            _id,
            _dependencies,
            fn,
            state
          ) {
            visitReactiveFunction(fn, this, state);
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    var _Scopes_instances,
      _Scopes_seen,
      _Scopes_stack,
      _Scopes_globals,
      _Scopes_lookup;
    function renameVariables(fn) {
      var globals = collectReferencedGlobals(fn);
      var scopes = new Scopes(globals);
      renameVariablesImpl(fn, new Visitor$3(), scopes);
      return new Set(
        [].concat(_toConsumableArray(scopes.names), _toConsumableArray(globals))
      );
    }
    function renameVariablesImpl(fn, visitor, scopes) {
      scopes.enter(function () {
        var _iterator346 = _createForOfIteratorHelper(fn.params),
          _step346;
        try {
          for (_iterator346.s(); !(_step346 = _iterator346.n()).done; ) {
            var param = _step346.value;
            if (param.kind === "Identifier") {
              scopes.visit(param.identifier);
            } else {
              scopes.visit(param.place.identifier);
            }
          }
        } catch (err) {
          _iterator346.e(err);
        } finally {
          _iterator346.f();
        }
        visitReactiveFunction(fn, visitor, scopes);
      });
    }
    var Visitor$3 = /*#__PURE__*/ (function (_ReactiveFunctionVisi16) {
      function Visitor() {
        _classCallCheck(this, Visitor);
        return _callSuper(this, Visitor, arguments);
      }
      _inherits2(Visitor, _ReactiveFunctionVisi16);
      return _createClass(Visitor, [
        {
          key: "visitParam",
          value: function visitParam(place, state) {
            state.visit(place.identifier);
          }
        },
        {
          key: "visitLValue",
          value: function visitLValue(_id, lvalue, state) {
            state.visit(lvalue.identifier);
          }
        },
        {
          key: "visitPlace",
          value: function visitPlace(id, place, state) {
            state.visit(place.identifier);
          }
        },
        {
          key: "visitBlock",
          value: function visitBlock(block, state) {
            var _this20 = this;
            state.enter(function () {
              _this20.traverseBlock(block, state);
            });
          }
        },
        {
          key: "visitPrunedScope",
          value: function visitPrunedScope(scopeBlock, state) {
            this.traverseBlock(scopeBlock.instructions, state);
          }
        },
        {
          key: "visitScope",
          value: function visitScope(scope, state) {
            var _iterator347 = _createForOfIteratorHelper(
                scope.scope.declarations
              ),
              _step347;
            try {
              for (_iterator347.s(); !(_step347 = _iterator347.n()).done; ) {
                var _step347$value = _slicedToArray(_step347.value, 2),
                  _ = _step347$value[0],
                  declaration = _step347$value[1];
                state.visit(declaration.identifier);
              }
            } catch (err) {
              _iterator347.e(err);
            } finally {
              _iterator347.f();
            }
            this.traverseScope(scope, state);
          }
        },
        {
          key: "visitValue",
          value: function visitValue(id, value, state) {
            this.traverseValue(id, value, state);
            if (
              value.kind === "FunctionExpression" ||
              value.kind === "ObjectMethod"
            ) {
              this.visitHirFunction(value.loweredFunc.func, state);
            }
          }
        },
        {
          key: "visitReactiveFunctionValue",
          value: function visitReactiveFunctionValue(
            _id,
            _dependencies,
            _fn,
            _state
          ) {
            renameVariablesImpl(_fn, this, _state);
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    var Scopes = /*#__PURE__*/ (function () {
      function Scopes(globals) {
        _classCallCheck(this, Scopes);
        _Scopes_instances.add(this);
        _Scopes_seen.set(this, new Map());
        _Scopes_stack.set(this, [new Map()]);
        _Scopes_globals.set(this, void 0);
        this.names = new Set();
        __classPrivateFieldSet(this, _Scopes_globals, globals, "f");
      }
      return _createClass(Scopes, [
        {
          key: "visit",
          value: function visit(identifier) {
            var originalName = identifier.name;
            if (originalName === null) {
              return;
            }
            var mappedName = __classPrivateFieldGet(
              this,
              _Scopes_seen,
              "f"
            ).get(identifier.declarationId);
            if (mappedName !== undefined) {
              identifier.name = mappedName;
              return;
            }
            var name = originalName.value;
            var id = 0;
            if (isPromotedTemporary(originalName.value)) {
              name = "t".concat(id++);
            } else if (isPromotedJsxTemporary(originalName.value)) {
              name = "T".concat(id++);
            }
            while (
              __classPrivateFieldGet(
                this,
                _Scopes_instances,
                "m",
                _Scopes_lookup
              ).call(this, name) !== null ||
              __classPrivateFieldGet(this, _Scopes_globals, "f").has(name)
            ) {
              if (isPromotedTemporary(originalName.value)) {
                name = "t".concat(id++);
              } else if (isPromotedJsxTemporary(originalName.value)) {
                name = "T".concat(id++);
              } else {
                name = "".concat(originalName.value, "$").concat(id++);
              }
            }
            var identifierName = makeIdentifierName(name);
            identifier.name = identifierName;
            __classPrivateFieldGet(this, _Scopes_seen, "f").set(
              identifier.declarationId,
              identifierName
            );
            __classPrivateFieldGet(this, _Scopes_stack, "f")
              .at(-1)
              .set(identifierName.value, identifier.declarationId);
            this.names.add(identifierName.value);
          }
        },
        {
          key: "enter",
          value: function enter(fn) {
            var next = new Map();
            __classPrivateFieldGet(this, _Scopes_stack, "f").push(next);
            fn();
            var last = __classPrivateFieldGet(this, _Scopes_stack, "f").pop();
            CompilerError.invariant(last === next, {
              reason: "Mismatch push/pop calls",
              description: null,
              loc: null,
              suggestions: null
            });
          }
        }
      ]);
    })();
    (_Scopes_seen = new WeakMap()),
      (_Scopes_stack = new WeakMap()),
      (_Scopes_globals = new WeakMap()),
      (_Scopes_instances = new WeakSet()),
      (_Scopes_lookup = function _Scopes_lookup(name) {
        for (
          var i = __classPrivateFieldGet(this, _Scopes_stack, "f").length - 1;
          i >= 0;
          i--
        ) {
          var scope = __classPrivateFieldGet(this, _Scopes_stack, "f")[i];
          var entry = scope.get(name);
          if (entry !== undefined) {
            return entry;
          }
        }
        return null;
      });
    function stabilizeBlockIds(fn) {
      var referenced = new Set();
      visitReactiveFunction(fn, new CollectReferencedLabels(), referenced);
      var mappings = new Map();
      var _iterator348 = _createForOfIteratorHelper(referenced),
        _step348;
      try {
        for (_iterator348.s(); !(_step348 = _iterator348.n()).done; ) {
          var blockId = _step348.value;
          mappings.set(blockId, makeBlockId(mappings.size));
        }
      } catch (err) {
        _iterator348.e(err);
      } finally {
        _iterator348.f();
      }
      visitReactiveFunction(fn, new RewriteBlockIds(), mappings);
    }
    var CollectReferencedLabels = /*#__PURE__*/ (function (
      _ReactiveFunctionVisi17
    ) {
      function CollectReferencedLabels() {
        _classCallCheck(this, CollectReferencedLabels);
        return _callSuper(this, CollectReferencedLabels, arguments);
      }
      _inherits2(CollectReferencedLabels, _ReactiveFunctionVisi17);
      return _createClass(CollectReferencedLabels, [
        {
          key: "visitScope",
          value: function visitScope(scope, state) {
            var earlyReturnValue = scope.scope.earlyReturnValue;
            if (earlyReturnValue != null) {
              state.add(earlyReturnValue.label);
            }
            this.traverseScope(scope, state);
          }
        },
        {
          key: "visitTerminal",
          value: function visitTerminal(stmt, state) {
            if (stmt.label != null) {
              if (!stmt.label.implicit) {
                state.add(stmt.label.id);
              }
            }
            this.traverseTerminal(stmt, state);
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    var RewriteBlockIds = /*#__PURE__*/ (function (_ReactiveFunctionVisi18) {
      function RewriteBlockIds() {
        _classCallCheck(this, RewriteBlockIds);
        return _callSuper(this, RewriteBlockIds, arguments);
      }
      _inherits2(RewriteBlockIds, _ReactiveFunctionVisi18);
      return _createClass(RewriteBlockIds, [
        {
          key: "visitScope",
          value: function visitScope(scope, state) {
            var earlyReturnValue = scope.scope.earlyReturnValue;
            if (earlyReturnValue != null) {
              var rewrittenId = getOrInsertDefault(
                state,
                earlyReturnValue.label,
                state.size
              );
              earlyReturnValue.label = makeBlockId(rewrittenId);
            }
            this.traverseScope(scope, state);
          }
        },
        {
          key: "visitTerminal",
          value: function visitTerminal(stmt, state) {
            if (stmt.label != null) {
              var rewrittenId = getOrInsertDefault(
                state,
                stmt.label.id,
                state.size
              );
              stmt.label.id = makeBlockId(rewrittenId);
            }
            var terminal = stmt.terminal;
            if (terminal.kind === "break" || terminal.kind === "continue") {
              var _rewrittenId = getOrInsertDefault(
                state,
                terminal.target,
                state.size
              );
              terminal.target = makeBlockId(_rewrittenId);
            }
            this.traverseTerminal(stmt, state);
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    function inferAliases(func) {
      var aliases = new DisjointSet();
      var _iterator349 = _createForOfIteratorHelper(func.body.blocks),
        _step349;
      try {
        for (_iterator349.s(); !(_step349 = _iterator349.n()).done; ) {
          var _step349$value = _slicedToArray(_step349.value, 2),
            _ = _step349$value[0],
            block = _step349$value[1];
          var _iterator350 = _createForOfIteratorHelper(block.instructions),
            _step350;
          try {
            for (_iterator350.s(); !(_step350 = _iterator350.n()).done; ) {
              var instr = _step350.value;
              inferInstr(instr, aliases);
            }
          } catch (err) {
            _iterator350.e(err);
          } finally {
            _iterator350.f();
          }
        }
      } catch (err) {
        _iterator349.e(err);
      } finally {
        _iterator349.f();
      }
      return aliases;
    }
    function inferInstr(instr, aliases) {
      var lvalue = instr.lvalue,
        instrValue = instr.value;
      var alias = null;
      switch (instrValue.kind) {
        case "LoadLocal":
        case "LoadContext": {
          if (isPrimitiveType(instrValue.place.identifier)) {
            return;
          }
          alias = instrValue.place;
          break;
        }
        case "StoreLocal":
        case "StoreContext": {
          alias = instrValue.value;
          break;
        }
        case "Destructure": {
          alias = instrValue.value;
          break;
        }
        case "ComputedLoad":
        case "PropertyLoad": {
          alias = instrValue.object;
          break;
        }
        case "TypeCastExpression": {
          alias = instrValue.value;
          break;
        }
        default:
          return;
      }
      aliases.union([lvalue.identifier, alias.identifier]);
    }
    function inferAliasForPhis(func, aliases) {
      var _a, _b;
      var _iterator351 = _createForOfIteratorHelper(func.body.blocks),
        _step351;
      try {
        for (_iterator351.s(); !(_step351 = _iterator351.n()).done; ) {
          var _step351$value = _slicedToArray(_step351.value, 2),
            _ = _step351$value[0],
            block = _step351$value[1];
          var _iterator352 = _createForOfIteratorHelper(block.phis),
            _step352;
          try {
            for (_iterator352.s(); !(_step352 = _iterator352.n()).done; ) {
              var phi = _step352.value;
              var isPhiMutatedAfterCreation =
                phi.place.identifier.mutableRange.end >
                ((_b =
                  (_a = block.instructions.at(0)) === null || _a === void 0
                    ? void 0
                    : _a.id) !== null && _b !== void 0
                  ? _b
                  : block.terminal.id);
              if (isPhiMutatedAfterCreation) {
                var _iterator353 = _createForOfIteratorHelper(phi.operands),
                  _step353;
                try {
                  for (
                    _iterator353.s();
                    !(_step353 = _iterator353.n()).done;

                  ) {
                    var _step353$value = _slicedToArray(_step353.value, 2),
                      operand = _step353$value[1];
                    aliases.union([phi.place.identifier, operand.identifier]);
                  }
                } catch (err) {
                  _iterator353.e(err);
                } finally {
                  _iterator353.f();
                }
              }
            }
          } catch (err) {
            _iterator352.e(err);
          } finally {
            _iterator352.f();
          }
        }
      } catch (err) {
        _iterator351.e(err);
      } finally {
        _iterator351.f();
      }
    }
    function inferAliasForStores(func, aliases) {
      var _iterator354 = _createForOfIteratorHelper(func.body.blocks),
        _step354;
      try {
        for (_iterator354.s(); !(_step354 = _iterator354.n()).done; ) {
          var _step354$value = _slicedToArray(_step354.value, 2),
            _ = _step354$value[0],
            block = _step354$value[1];
          var _iterator355 = _createForOfIteratorHelper(block.instructions),
            _step355;
          try {
            for (_iterator355.s(); !(_step355 = _iterator355.n()).done; ) {
              var instr = _step355.value;
              var value = instr.value,
                lvalue = instr.lvalue;
              var isStore =
                lvalue.effect === Effect.Store ||
                !_toConsumableArray(eachInstructionValueOperand(value)).every(
                  function (operand) {
                    return operand.effect !== Effect.Store;
                  }
                );
              if (!isStore) {
                continue;
              }
              var _iterator356 = _createForOfIteratorHelper(
                  eachInstructionLValue(instr)
                ),
                _step356;
              try {
                for (_iterator356.s(); !(_step356 = _iterator356.n()).done; ) {
                  var operand = _step356.value;
                  maybeAlias(aliases, lvalue, operand, instr.id);
                }
              } catch (err) {
                _iterator356.e(err);
              } finally {
                _iterator356.f();
              }
              var _iterator357 = _createForOfIteratorHelper(
                  eachInstructionValueOperand(value)
                ),
                _step357;
              try {
                for (_iterator357.s(); !(_step357 = _iterator357.n()).done; ) {
                  var _operand22 = _step357.value;
                  if (
                    _operand22.effect === Effect.Capture ||
                    _operand22.effect === Effect.Store
                  ) {
                    maybeAlias(aliases, lvalue, _operand22, instr.id);
                  }
                }
              } catch (err) {
                _iterator357.e(err);
              } finally {
                _iterator357.f();
              }
            }
          } catch (err) {
            _iterator355.e(err);
          } finally {
            _iterator355.f();
          }
        }
      } catch (err) {
        _iterator354.e(err);
      } finally {
        _iterator354.f();
      }
    }
    function maybeAlias(aliases, lvalue, rvalue, id) {
      if (
        lvalue.identifier.mutableRange.end > id + 1 ||
        rvalue.identifier.mutableRange.end > id
      ) {
        aliases.union([lvalue.identifier, rvalue.identifier]);
      }
    }
    function infer$1(place, instrId) {
      if (!isRefOrRefValue(place.identifier)) {
        place.identifier.mutableRange.end = makeInstructionId(instrId + 1);
      }
    }
    function inferPlace(place, instrId, inferMutableRangeForStores) {
      switch (place.effect) {
        case Effect.Unknown: {
          throw new Error(
            "Found an unknown place ".concat(printPlace(place), "}!")
          );
        }
        case Effect.Capture:
        case Effect.Read:
        case Effect.Freeze:
          return;
        case Effect.Store:
          if (inferMutableRangeForStores) {
            infer$1(place, instrId);
          }
          return;
        case Effect.ConditionallyMutate:
        case Effect.Mutate: {
          infer$1(place, instrId);
          return;
        }
        default:
          assertExhaustive$1(
            place.effect,
            "Unexpected ".concat(printPlace(place), " effect")
          );
      }
    }
    function inferMutableLifetimes(func, inferMutableRangeForStores) {
      var _a, _b;
      var contextVariableDeclarationInstructions = new Map();
      var _iterator358 = _createForOfIteratorHelper(func.body.blocks),
        _step358;
      try {
        for (_iterator358.s(); !(_step358 = _iterator358.n()).done; ) {
          var _step358$value = _slicedToArray(_step358.value, 2),
            _ = _step358$value[0],
            block = _step358$value[1];
          var _iterator359 = _createForOfIteratorHelper(block.phis),
            _step359;
          try {
            for (_iterator359.s(); !(_step359 = _iterator359.n()).done; ) {
              var phi = _step359.value;
              var isPhiMutatedAfterCreation =
                phi.place.identifier.mutableRange.end >
                ((_b =
                  (_a = block.instructions.at(0)) === null || _a === void 0
                    ? void 0
                    : _a.id) !== null && _b !== void 0
                  ? _b
                  : block.terminal.id);
              if (
                inferMutableRangeForStores &&
                isPhiMutatedAfterCreation &&
                phi.place.identifier.mutableRange.start === 0
              ) {
                var _iterator362 = _createForOfIteratorHelper(phi.operands),
                  _step362;
                try {
                  for (
                    _iterator362.s();
                    !(_step362 = _iterator362.n()).done;

                  ) {
                    var _step362$value = _slicedToArray(_step362.value, 2),
                      operand = _step362$value[1];
                    if (phi.place.identifier.mutableRange.start === 0) {
                      phi.place.identifier.mutableRange.start =
                        operand.identifier.mutableRange.start;
                    } else {
                      phi.place.identifier.mutableRange.start =
                        makeInstructionId(
                          Math.min(
                            phi.place.identifier.mutableRange.start,
                            operand.identifier.mutableRange.start
                          )
                        );
                    }
                  }
                } catch (err) {
                  _iterator362.e(err);
                } finally {
                  _iterator362.f();
                }
              }
            }
          } catch (err) {
            _iterator359.e(err);
          } finally {
            _iterator359.f();
          }
          var _iterator360 = _createForOfIteratorHelper(block.instructions),
            _step360;
          try {
            for (_iterator360.s(); !(_step360 = _iterator360.n()).done; ) {
              var instr = _step360.value;
              var _iterator363 = _createForOfIteratorHelper(
                  eachInstructionLValue(instr)
                ),
                _step363;
              try {
                for (_iterator363.s(); !(_step363 = _iterator363.n()).done; ) {
                  var _operand23 = _step363.value;
                  var lvalueId = _operand23.identifier;
                  lvalueId.mutableRange.start = instr.id;
                  lvalueId.mutableRange.end = makeInstructionId(instr.id + 1);
                }
              } catch (err) {
                _iterator363.e(err);
              } finally {
                _iterator363.f();
              }
              var _iterator364 = _createForOfIteratorHelper(
                  eachInstructionOperand(instr)
                ),
                _step364;
              try {
                for (_iterator364.s(); !(_step364 = _iterator364.n()).done; ) {
                  var _operand24 = _step364.value;
                  inferPlace(_operand24, instr.id, inferMutableRangeForStores);
                }
              } catch (err) {
                _iterator364.e(err);
              } finally {
                _iterator364.f();
              }
              if (
                instr.value.kind === "DeclareContext" ||
                (instr.value.kind === "StoreContext" &&
                  instr.value.lvalue.kind !== InstructionKind.Reassign)
              ) {
                contextVariableDeclarationInstructions.set(
                  instr.value.lvalue.place.identifier,
                  instr.id
                );
              } else if (instr.value.kind === "StoreContext") {
                var declaration = contextVariableDeclarationInstructions.get(
                  instr.value.lvalue.place.identifier
                );
                if (
                  declaration != null &&
                  !isRefOrRefValue(instr.value.lvalue.place.identifier)
                ) {
                  var range = instr.value.lvalue.place.identifier.mutableRange;
                  if (range.start === 0) {
                    range.start = declaration;
                  } else {
                    range.start = makeInstructionId(
                      Math.min(range.start, declaration)
                    );
                  }
                }
              }
            }
          } catch (err) {
            _iterator360.e(err);
          } finally {
            _iterator360.f();
          }
          var _iterator361 = _createForOfIteratorHelper(
              eachTerminalOperand(block.terminal)
            ),
            _step361;
          try {
            for (_iterator361.s(); !(_step361 = _iterator361.n()).done; ) {
              var _operand25 = _step361.value;
              inferPlace(
                _operand25,
                block.terminal.id,
                inferMutableRangeForStores
              );
            }
          } catch (err) {
            _iterator361.e(err);
          } finally {
            _iterator361.f();
          }
        }
      } catch (err) {
        _iterator358.e(err);
      } finally {
        _iterator358.f();
      }
    }
    function inferMutableRangesForAlias(_fn, aliases) {
      var aliasSets = aliases.buildSets();
      var _iterator365 = _createForOfIteratorHelper(aliasSets),
        _step365;
      try {
        for (_iterator365.s(); !(_step365 = _iterator365.n()).done; ) {
          var aliasSet = _step365.value;
          var mutatingIdentifiers = _toConsumableArray(aliasSet).filter(
            function (id) {
              return (
                id.mutableRange.end - id.mutableRange.start > 1 &&
                !isRefOrRefValue(id)
              );
            }
          );
          if (mutatingIdentifiers.length > 0) {
            var lastMutatingInstructionId = 0;
            var _iterator366 = _createForOfIteratorHelper(mutatingIdentifiers),
              _step366;
            try {
              for (_iterator366.s(); !(_step366 = _iterator366.n()).done; ) {
                var id = _step366.value;
                if (id.mutableRange.end > lastMutatingInstructionId) {
                  lastMutatingInstructionId = id.mutableRange.end;
                }
              }
            } catch (err) {
              _iterator366.e(err);
            } finally {
              _iterator366.f();
            }
            var _iterator367 = _createForOfIteratorHelper(aliasSet),
              _step367;
            try {
              for (_iterator367.s(); !(_step367 = _iterator367.n()).done; ) {
                var alias = _step367.value;
                if (
                  alias.mutableRange.end < lastMutatingInstructionId &&
                  !isRefOrRefValue(alias)
                ) {
                  alias.mutableRange.end = lastMutatingInstructionId;
                }
              }
            } catch (err) {
              _iterator367.e(err);
            } finally {
              _iterator367.f();
            }
          }
        }
      } catch (err) {
        _iterator365.e(err);
      } finally {
        _iterator365.f();
      }
    }
    function inferTryCatchAliases(fn, aliases) {
      var handlerParams = new Map();
      var _iterator368 = _createForOfIteratorHelper(fn.body.blocks),
        _step368;
      try {
        for (_iterator368.s(); !(_step368 = _iterator368.n()).done; ) {
          var _step368$value = _slicedToArray(_step368.value, 2),
            _ = _step368$value[0],
            block = _step368$value[1];
          if (
            block.terminal.kind === "try" &&
            block.terminal.handlerBinding !== null
          ) {
            handlerParams.set(
              block.terminal.handler,
              block.terminal.handlerBinding.identifier
            );
          } else if (block.terminal.kind === "maybe-throw") {
            var handlerParam = handlerParams.get(block.terminal.handler);
            if (handlerParam === undefined) {
              continue;
            }
            var _iterator369 = _createForOfIteratorHelper(block.instructions),
              _step369;
            try {
              for (_iterator369.s(); !(_step369 = _iterator369.n()).done; ) {
                var instr = _step369.value;
                aliases.union([handlerParam, instr.lvalue.identifier]);
              }
            } catch (err) {
              _iterator369.e(err);
            } finally {
              _iterator369.f();
            }
          }
        }
      } catch (err) {
        _iterator368.e(err);
      } finally {
        _iterator368.f();
      }
    }
    function inferMutableRanges(ir) {
      inferMutableLifetimes(ir, false);
      var aliases = inferAliases(ir);
      inferTryCatchAliases(ir, aliases);
      var prevAliases = aliases.canonicalize();
      while (true) {
        inferMutableRangesForAlias(ir, aliases);
        inferAliasForStores(ir, aliases);
        inferAliasForPhis(ir, aliases);
        var nextAliases = aliases.canonicalize();
        if (areEqualMaps(prevAliases, nextAliases)) {
          break;
        }
        prevAliases = nextAliases;
      }
      inferMutableLifetimes(ir, true);
      prevAliases = aliases.canonicalize();
      while (true) {
        inferMutableRangesForAlias(ir, aliases);
        inferAliasForPhis(ir, aliases);
        var _nextAliases = aliases.canonicalize();
        if (areEqualMaps(prevAliases, _nextAliases)) {
          break;
        }
        prevAliases = _nextAliases;
      }
    }
    function areEqualMaps(a, b) {
      if (a.size !== b.size) {
        return false;
      }
      var _iterator370 = _createForOfIteratorHelper(a),
        _step370;
      try {
        for (_iterator370.s(); !(_step370 = _iterator370.n()).done; ) {
          var _step370$value = _slicedToArray(_step370.value, 2),
            _key38 = _step370$value[0],
            value = _step370$value[1];
          if (!b.has(_key38)) {
            return false;
          }
          if (b.get(_key38) !== value) {
            return false;
          }
        }
      } catch (err) {
        _iterator370.e(err);
      } finally {
        _iterator370.f();
      }
      return true;
    }
    function analyseFunctions(func) {
      var _iterator371 = _createForOfIteratorHelper(func.body.blocks),
        _step371;
      try {
        for (_iterator371.s(); !(_step371 = _iterator371.n()).done; ) {
          var _step371$value = _slicedToArray(_step371.value, 2),
            _ = _step371$value[0],
            block = _step371$value[1];
          var _iterator372 = _createForOfIteratorHelper(block.instructions),
            _step372;
          try {
            for (_iterator372.s(); !(_step372 = _iterator372.n()).done; ) {
              var instr = _step372.value;
              switch (instr.value.kind) {
                case "ObjectMethod":
                case "FunctionExpression": {
                  lower(instr.value.loweredFunc.func);
                  infer(instr.value.loweredFunc);
                  var _iterator373 = _createForOfIteratorHelper(
                      instr.value.loweredFunc.func.context
                    ),
                    _step373;
                  try {
                    for (
                      _iterator373.s();
                      !(_step373 = _iterator373.n()).done;

                    ) {
                      var operand = _step373.value;
                      operand.identifier.mutableRange.start =
                        makeInstructionId(0);
                      operand.identifier.mutableRange.end =
                        makeInstructionId(0);
                      operand.identifier.scope = null;
                    }
                  } catch (err) {
                    _iterator373.e(err);
                  } finally {
                    _iterator373.f();
                  }
                  break;
                }
              }
            }
          } catch (err) {
            _iterator372.e(err);
          } finally {
            _iterator372.f();
          }
        }
      } catch (err) {
        _iterator371.e(err);
      } finally {
        _iterator371.f();
      }
    }
    function lower(func) {
      var _a, _b;
      analyseFunctions(func);
      inferReferenceEffects(func, { isFunctionExpression: true });
      deadCodeElimination(func);
      inferMutableRanges(func);
      rewriteInstructionKindsBasedOnReassignment(func);
      inferReactiveScopeVariables(func);
      (_b =
        (_a = func.env.logger) === null || _a === void 0
          ? void 0
          : _a.debugLogIRs) === null || _b === void 0
        ? void 0
        : _b.call(_a, {
            kind: "hir",
            name: "AnalyseFunction (inner)",
            value: func
          });
    }
    function infer(loweredFunc) {
      var _iterator374 = _createForOfIteratorHelper(loweredFunc.func.context),
        _step374;
      try {
        for (_iterator374.s(); !(_step374 = _iterator374.n()).done; ) {
          var operand = _step374.value;
          var _identifier15 = operand.identifier;
          CompilerError.invariant(operand.effect === Effect.Unknown, {
            reason:
              "[AnalyseFunctions] Expected Function context effects to not have been set",
            loc: operand.loc
          });
          if (isRefOrRefValue(_identifier15)) {
            operand.effect = Effect.Capture;
          } else if (isMutatedOrReassigned(_identifier15)) {
            operand.effect = Effect.Capture;
          } else {
            operand.effect = Effect.Read;
          }
        }
      } catch (err) {
        _iterator374.e(err);
      } finally {
        _iterator374.f();
      }
    }
    function isMutatedOrReassigned(id) {
      return id.mutableRange.end > id.mutableRange.start;
    }
    function collectMaybeMemoDependencies(value, maybeDeps, optional) {
      var _a;
      switch (value.kind) {
        case "LoadGlobal": {
          return {
            root: { kind: "Global", identifierName: value.binding.name },
            path: []
          };
        }
        case "PropertyLoad": {
          var object = maybeDeps.get(value.object.identifier.id);
          if (object != null) {
            return {
              root: object.root,
              path: [].concat(_toConsumableArray(object.path), [
                { property: value.property, optional: optional }
              ])
            };
          }
          break;
        }
        case "LoadLocal":
        case "LoadContext": {
          var source = maybeDeps.get(value.place.identifier.id);
          if (source != null) {
            return source;
          } else if (
            value.place.identifier.name != null &&
            value.place.identifier.name.kind === "named"
          ) {
            return {
              root: {
                kind: "NamedLocal",
                value: Object.assign({}, value.place)
              },
              path: []
            };
          }
          break;
        }
        case "StoreLocal": {
          var lvalue = value.lvalue.place.identifier;
          var rvalue = value.value.identifier.id;
          var aliased = maybeDeps.get(rvalue);
          if (
            aliased != null &&
            ((_a = lvalue.name) === null || _a === void 0
              ? void 0
              : _a.kind) !== "named"
          ) {
            maybeDeps.set(lvalue.id, aliased);
            return aliased;
          }
          break;
        }
      }
      return null;
    }
    function collectTemporaries(instr, env, sidemap) {
      var value = instr.value,
        lvalue = instr.lvalue;
      switch (value.kind) {
        case "FunctionExpression": {
          sidemap.functions.set(instr.lvalue.identifier.id, instr);
          break;
        }
        case "LoadGlobal": {
          var _global = env.getGlobalDeclaration(value.binding, value.loc);
          var hookKind =
            _global !== null ? getHookKindForType(env, _global) : null;
          var lvalId = instr.lvalue.identifier.id;
          if (hookKind === "useMemo" || hookKind === "useCallback") {
            sidemap.manualMemos.set(lvalId, {
              kind: hookKind,
              loadInstr: instr
            });
          } else if (value.binding.name === "React") {
            sidemap.react.add(lvalId);
          }
          break;
        }
        case "PropertyLoad": {
          if (sidemap.react.has(value.object.identifier.id)) {
            var property = value.property;
            if (property === "useMemo" || property === "useCallback") {
              sidemap.manualMemos.set(instr.lvalue.identifier.id, {
                kind: property,
                loadInstr: instr
              });
            }
          }
          break;
        }
        case "ArrayExpression": {
          if (
            value.elements.every(function (e) {
              return e.kind === "Identifier";
            })
          ) {
            sidemap.maybeDepsLists.set(
              instr.lvalue.identifier.id,
              value.elements
            );
          }
          break;
        }
      }
      var maybeDep = collectMaybeMemoDependencies(
        value,
        sidemap.maybeDeps,
        sidemap.optionals.has(lvalue.identifier.id)
      );
      if (maybeDep != null) {
        sidemap.maybeDeps.set(lvalue.identifier.id, maybeDep);
      }
    }
    function makeManualMemoizationMarkers(
      fnExpr,
      env,
      depsList,
      memoDecl,
      manualMemoId
    ) {
      return [
        {
          id: makeInstructionId(0),
          lvalue: createTemporaryPlace(env, fnExpr.loc),
          value: {
            kind: "StartMemoize",
            manualMemoId: manualMemoId,
            deps: depsList,
            loc: fnExpr.loc
          },
          loc: fnExpr.loc
        },
        {
          id: makeInstructionId(0),
          lvalue: createTemporaryPlace(env, fnExpr.loc),
          value: {
            kind: "FinishMemoize",
            manualMemoId: manualMemoId,
            decl: Object.assign({}, memoDecl),
            loc: fnExpr.loc
          },
          loc: fnExpr.loc
        }
      ];
    }
    function getManualMemoizationReplacement(fn, loc, kind) {
      if (kind === "useMemo") {
        return { kind: "CallExpression", callee: fn, args: [], loc: loc };
      } else {
        return {
          kind: "LoadLocal",
          place: {
            kind: "Identifier",
            identifier: fn.identifier,
            effect: Effect.Unknown,
            reactive: false,
            loc: loc
          },
          loc: loc
        };
      }
    }
    function extractManualMemoizationArgs(instr, kind, sidemap) {
      var _instr$value$args = _slicedToArray(instr.value.args, 2),
        fnPlace = _instr$value$args[0],
        depsListPlace = _instr$value$args[1];
      if (fnPlace == null) {
        CompilerError.throwInvalidReact({
          reason: "Expected a callback function to be passed to ".concat(kind),
          loc: instr.value.loc,
          suggestions: null
        });
      }
      if (
        fnPlace.kind === "Spread" ||
        (depsListPlace === null || depsListPlace === void 0
          ? void 0
          : depsListPlace.kind) === "Spread"
      ) {
        CompilerError.throwInvalidReact({
          reason: "Unexpected spread argument to ".concat(kind),
          loc: instr.value.loc,
          suggestions: null
        });
      }
      var depsList = null;
      if (depsListPlace != null) {
        var maybeDepsList = sidemap.maybeDepsLists.get(
          depsListPlace.identifier.id
        );
        if (maybeDepsList == null) {
          CompilerError.throwInvalidReact({
            reason: "Expected the dependency list for ".concat(
              kind,
              " to be an array literal"
            ),
            suggestions: null,
            loc: depsListPlace.loc
          });
        }
        depsList = maybeDepsList.map(function (dep) {
          var maybeDep = sidemap.maybeDeps.get(dep.identifier.id);
          if (maybeDep == null) {
            CompilerError.throwInvalidReact({
              reason:
                "Expected the dependency list to be an array of simple expressions (e.g. `x`, `x.y.z`, `x?.y?.z`)",
              suggestions: null,
              loc: dep.loc
            });
          }
          return maybeDep;
        });
      }
      return { fnPlace: fnPlace, depsList: depsList };
    }
    function dropManualMemoization(func) {
      var isValidationEnabled =
        func.env.config.validatePreserveExistingMemoizationGuarantees ||
        func.env.config.validateNoSetStateInRender ||
        func.env.config.enablePreserveExistingMemoizationGuarantees;
      var optionals = findOptionalPlaces(func);
      var sidemap = {
        functions: new Map(),
        manualMemos: new Map(),
        react: new Set(),
        maybeDeps: new Map(),
        maybeDepsLists: new Map(),
        optionals: optionals
      };
      var nextManualMemoId = 0;
      var queuedInserts = new Map();
      var _iterator375 = _createForOfIteratorHelper(func.body.blocks),
        _step375;
      try {
        for (_iterator375.s(); !(_step375 = _iterator375.n()).done; ) {
          var _step375$value = _slicedToArray(_step375.value, 2),
            _33 = _step375$value[0],
            _block15 = _step375$value[1];
          for (var _i39 = 0; _i39 < _block15.instructions.length; _i39++) {
            var _instr7 = _block15.instructions[_i39];
            if (
              _instr7.value.kind === "CallExpression" ||
              _instr7.value.kind === "MethodCall"
            ) {
              var id =
                _instr7.value.kind === "CallExpression"
                  ? _instr7.value.callee.identifier.id
                  : _instr7.value.property.identifier.id;
              var manualMemo = sidemap.manualMemos.get(id);
              if (manualMemo != null) {
                var _extractManualMemoiza = extractManualMemoizationArgs(
                    _instr7,
                    manualMemo.kind,
                    sidemap
                  ),
                  fnPlace = _extractManualMemoiza.fnPlace,
                  depsList = _extractManualMemoiza.depsList;
                _instr7.value = getManualMemoizationReplacement(
                  fnPlace,
                  _instr7.value.loc,
                  manualMemo.kind
                );
                if (isValidationEnabled) {
                  if (!sidemap.functions.has(fnPlace.identifier.id)) {
                    CompilerError.throwInvalidReact({
                      reason:
                        "Expected the first argument to be an inline function expression",
                      suggestions: [],
                      loc: fnPlace.loc
                    });
                  }
                  var memoDecl =
                    manualMemo.kind === "useMemo"
                      ? _instr7.lvalue
                      : {
                          kind: "Identifier",
                          identifier: fnPlace.identifier,
                          effect: Effect.Unknown,
                          reactive: false,
                          loc: fnPlace.loc
                        };
                  var _makeManualMemoizatio = makeManualMemoizationMarkers(
                      fnPlace,
                      func.env,
                      depsList,
                      memoDecl,
                      nextManualMemoId++
                    ),
                    _makeManualMemoizatio2 = _slicedToArray(
                      _makeManualMemoizatio,
                      2
                    ),
                    startMarker = _makeManualMemoizatio2[0],
                    finishMarker = _makeManualMemoizatio2[1];
                  queuedInserts.set(manualMemo.loadInstr.id, startMarker);
                  queuedInserts.set(_instr7.id, finishMarker);
                }
              }
            } else {
              collectTemporaries(_instr7, func.env, sidemap);
            }
          }
        }
      } catch (err) {
        _iterator375.e(err);
      } finally {
        _iterator375.f();
      }
      if (queuedInserts.size > 0) {
        var hasChanges = false;
        var _iterator376 = _createForOfIteratorHelper(func.body.blocks),
          _step376;
        try {
          for (_iterator376.s(); !(_step376 = _iterator376.n()).done; ) {
            var _step376$value = _slicedToArray(_step376.value, 2),
              _ = _step376$value[0],
              block = _step376$value[1];
            var nextInstructions = null;
            for (var i = 0; i < block.instructions.length; i++) {
              var instr = block.instructions[i];
              var insertInstr = queuedInserts.get(instr.id);
              if (insertInstr != null) {
                nextInstructions =
                  nextInstructions !== null && nextInstructions !== void 0
                    ? nextInstructions
                    : block.instructions.slice(0, i);
                nextInstructions.push(instr);
                nextInstructions.push(insertInstr);
              } else if (nextInstructions != null) {
                nextInstructions.push(instr);
              }
            }
            if (nextInstructions !== null) {
              block.instructions = nextInstructions;
              hasChanges = true;
            }
          }
        } catch (err) {
          _iterator376.e(err);
        } finally {
          _iterator376.f();
        }
        if (hasChanges) {
          markInstructionIds(func.body);
        }
      }
    }
    function findOptionalPlaces(fn) {
      var optionals = new Set();
      var _iterator377 = _createForOfIteratorHelper(fn.body.blocks),
        _step377;
      try {
        for (_iterator377.s(); !(_step377 = _iterator377.n()).done; ) {
          var _step377$value = _slicedToArray(_step377.value, 2),
            block = _step377$value[1];
          if (block.terminal.kind === "optional" && block.terminal.optional) {
            var optionalTerminal = block.terminal;
            var testBlock = fn.body.blocks.get(block.terminal.test);
            loop: while (true) {
              var terminal = testBlock.terminal;
              switch (terminal.kind) {
                case "branch": {
                  if (terminal.fallthrough === optionalTerminal.fallthrough) {
                    var consequent = fn.body.blocks.get(terminal.consequent);
                    var _last8 = consequent.instructions.at(-1);
                    if (
                      _last8 !== undefined &&
                      _last8.value.kind === "StoreLocal"
                    ) {
                      optionals.add(_last8.value.value.identifier.id);
                    }
                    break loop;
                  } else {
                    testBlock = fn.body.blocks.get(terminal.fallthrough);
                  }
                  break;
                }
                case "optional":
                case "logical":
                case "sequence":
                case "ternary": {
                  testBlock = fn.body.blocks.get(terminal.fallthrough);
                  break;
                }
                default: {
                  CompilerError.invariant(false, {
                    reason: "Unexpected terminal in optional",
                    loc: terminal.loc
                  });
                }
              }
            }
          }
        }
      } catch (err) {
        _iterator377.e(err);
      } finally {
        _iterator377.f();
      }
      return optionals;
    }
    function inferReactivePlaces(fn) {
      var reactiveIdentifiers = new ReactivityMap(
        findDisjointMutableValues(fn)
      );
      var _iterator378 = _createForOfIteratorHelper(fn.params),
        _step378;
      try {
        for (_iterator378.s(); !(_step378 = _iterator378.n()).done; ) {
          var param = _step378.value;
          var place = param.kind === "Identifier" ? param : param.place;
          reactiveIdentifiers.markReactive(place);
        }
      } catch (err) {
        _iterator378.e(err);
      } finally {
        _iterator378.f();
      }
      var postDominators = computePostDominatorTree(fn, {
        includeThrowsAsExitNode: false
      });
      var postDominatorFrontierCache = new Map();
      function isReactiveControlledBlock(id) {
        var controlBlocks = postDominatorFrontierCache.get(id);
        if (controlBlocks === undefined) {
          controlBlocks = postDominatorFrontier(fn, postDominators, id);
          postDominatorFrontierCache.set(id, controlBlocks);
        }
        var _iterator379 = _createForOfIteratorHelper(controlBlocks),
          _step379;
        try {
          for (_iterator379.s(); !(_step379 = _iterator379.n()).done; ) {
            var blockId = _step379.value;
            var controlBlock = fn.body.blocks.get(blockId);
            switch (controlBlock.terminal.kind) {
              case "if":
              case "branch": {
                if (
                  reactiveIdentifiers.isReactive(controlBlock.terminal.test)
                ) {
                  return true;
                }
                break;
              }
              case "switch": {
                if (
                  reactiveIdentifiers.isReactive(controlBlock.terminal.test)
                ) {
                  return true;
                }
                var _iterator380 = _createForOfIteratorHelper(
                    controlBlock.terminal.cases
                  ),
                  _step380;
                try {
                  for (
                    _iterator380.s();
                    !(_step380 = _iterator380.n()).done;

                  ) {
                    var case_ = _step380.value;
                    if (
                      case_.test !== null &&
                      reactiveIdentifiers.isReactive(case_.test)
                    ) {
                      return true;
                    }
                  }
                } catch (err) {
                  _iterator380.e(err);
                } finally {
                  _iterator380.f();
                }
                break;
              }
            }
          }
        } catch (err) {
          _iterator379.e(err);
        } finally {
          _iterator379.f();
        }
        return false;
      }
      do {
        var _iterator381 = _createForOfIteratorHelper(fn.body.blocks),
          _step381;
        try {
          for (_iterator381.s(); !(_step381 = _iterator381.n()).done; ) {
            var _step381$value = _slicedToArray(_step381.value, 2),
              block = _step381$value[1];
            var hasReactiveControl = isReactiveControlledBlock(block.id);
            var _iterator382 = _createForOfIteratorHelper(block.phis),
              _step382;
            try {
              for (_iterator382.s(); !(_step382 = _iterator382.n()).done; ) {
                var phi = _step382.value;
                if (reactiveIdentifiers.isReactive(phi.place)) {
                  continue;
                }
                var isPhiReactive = false;
                var _iterator385 = _createForOfIteratorHelper(phi.operands),
                  _step385;
                try {
                  for (
                    _iterator385.s();
                    !(_step385 = _iterator385.n()).done;

                  ) {
                    var _step385$value = _slicedToArray(_step385.value, 2),
                      operand = _step385$value[1];
                    if (reactiveIdentifiers.isReactive(operand)) {
                      isPhiReactive = true;
                      break;
                    }
                  }
                } catch (err) {
                  _iterator385.e(err);
                } finally {
                  _iterator385.f();
                }
                if (isPhiReactive) {
                  reactiveIdentifiers.markReactive(phi.place);
                } else {
                  var _iterator386 = _createForOfIteratorHelper(phi.operands),
                    _step386;
                  try {
                    for (
                      _iterator386.s();
                      !(_step386 = _iterator386.n()).done;

                    ) {
                      var _step386$value = _slicedToArray(_step386.value, 1),
                        pred = _step386$value[0];
                      if (isReactiveControlledBlock(pred)) {
                        reactiveIdentifiers.markReactive(phi.place);
                        break;
                      }
                    }
                  } catch (err) {
                    _iterator386.e(err);
                  } finally {
                    _iterator386.f();
                  }
                }
              }
            } catch (err) {
              _iterator382.e(err);
            } finally {
              _iterator382.f();
            }
            var _iterator383 = _createForOfIteratorHelper(block.instructions),
              _step383;
            try {
              for (_iterator383.s(); !(_step383 = _iterator383.n()).done; ) {
                var instruction = _step383.value;
                var value = instruction.value;
                var hasReactiveInput = false;
                var _iterator387 = _createForOfIteratorHelper(
                    eachInstructionValueOperand(value)
                  ),
                  _step387;
                try {
                  for (
                    _iterator387.s();
                    !(_step387 = _iterator387.n()).done;

                  ) {
                    var _operand27 = _step387.value;
                    var reactive = reactiveIdentifiers.isReactive(_operand27);
                    hasReactiveInput || (hasReactiveInput = reactive);
                  }
                } catch (err) {
                  _iterator387.e(err);
                } finally {
                  _iterator387.f();
                }
                if (
                  value.kind === "CallExpression" &&
                  (getHookKind(fn.env, value.callee.identifier) != null ||
                    isUseOperator(value.callee.identifier))
                ) {
                  hasReactiveInput = true;
                } else if (
                  value.kind === "MethodCall" &&
                  (getHookKind(fn.env, value.property.identifier) != null ||
                    isUseOperator(value.property.identifier))
                ) {
                  hasReactiveInput = true;
                }
                if (hasReactiveInput) {
                  var _iterator388 = _createForOfIteratorHelper(
                      eachInstructionLValue(instruction)
                    ),
                    _step388;
                  try {
                    for (
                      _iterator388.s();
                      !(_step388 = _iterator388.n()).done;

                    ) {
                      var lvalue = _step388.value;
                      if (isStableType(lvalue.identifier)) {
                        continue;
                      }
                      reactiveIdentifiers.markReactive(lvalue);
                    }
                  } catch (err) {
                    _iterator388.e(err);
                  } finally {
                    _iterator388.f();
                  }
                }
                if (hasReactiveInput || hasReactiveControl) {
                  var _iterator389 = _createForOfIteratorHelper(
                      eachInstructionValueOperand(value)
                    ),
                    _step389;
                  try {
                    for (
                      _iterator389.s();
                      !(_step389 = _iterator389.n()).done;

                    ) {
                      var _operand26 = _step389.value;
                      switch (_operand26.effect) {
                        case Effect.Capture:
                        case Effect.Store:
                        case Effect.ConditionallyMutate:
                        case Effect.Mutate: {
                          if (isMutable(instruction, _operand26)) {
                            reactiveIdentifiers.markReactive(_operand26);
                          }
                          break;
                        }
                        case Effect.Freeze:
                        case Effect.Read: {
                          break;
                        }
                        case Effect.Unknown: {
                          CompilerError.invariant(false, {
                            reason: "Unexpected unknown effect",
                            description: null,
                            loc: _operand26.loc,
                            suggestions: null
                          });
                        }
                        default: {
                          assertExhaustive$1(
                            _operand26.effect,
                            "Unexpected effect kind `".concat(
                              _operand26.effect,
                              "`"
                            )
                          );
                        }
                      }
                    }
                  } catch (err) {
                    _iterator389.e(err);
                  } finally {
                    _iterator389.f();
                  }
                }
              }
            } catch (err) {
              _iterator383.e(err);
            } finally {
              _iterator383.f();
            }
            var _iterator384 = _createForOfIteratorHelper(
                eachTerminalOperand(block.terminal)
              ),
              _step384;
            try {
              for (_iterator384.s(); !(_step384 = _iterator384.n()).done; ) {
                var _operand28 = _step384.value;
                reactiveIdentifiers.isReactive(_operand28);
              }
            } catch (err) {
              _iterator384.e(err);
            } finally {
              _iterator384.f();
            }
          }
        } catch (err) {
          _iterator381.e(err);
        } finally {
          _iterator381.f();
        }
      } while (reactiveIdentifiers.snapshot());
    }
    function postDominatorFrontier(fn, postDominators, targetId) {
      var visited = new Set();
      var frontier = new Set();
      var targetPostDominators = postDominatorsOf(fn, postDominators, targetId);
      for (
        var _i40 = 0,
          _arr3 = [].concat(_toConsumableArray(targetPostDominators), [
            targetId
          ]);
        _i40 < _arr3.length;
        _i40++
      ) {
        var blockId = _arr3[_i40];
        if (visited.has(blockId)) {
          continue;
        }
        visited.add(blockId);
        var block = fn.body.blocks.get(blockId);
        var _iterator390 = _createForOfIteratorHelper(block.preds),
          _step390;
        try {
          for (_iterator390.s(); !(_step390 = _iterator390.n()).done; ) {
            var pred = _step390.value;
            if (!targetPostDominators.has(pred)) {
              frontier.add(pred);
            }
          }
        } catch (err) {
          _iterator390.e(err);
        } finally {
          _iterator390.f();
        }
      }
      return frontier;
    }
    function postDominatorsOf(fn, postDominators, targetId) {
      var _a;
      var result = new Set();
      var visited = new Set();
      var queue = [targetId];
      while (queue.length) {
        var currentId = queue.shift();
        if (visited.has(currentId)) {
          continue;
        }
        visited.add(currentId);
        var current = fn.body.blocks.get(currentId);
        var _iterator391 = _createForOfIteratorHelper(current.preds),
          _step391;
        try {
          for (_iterator391.s(); !(_step391 = _iterator391.n()).done; ) {
            var pred = _step391.value;
            var predPostDominator =
              (_a = postDominators.get(pred)) !== null && _a !== void 0
                ? _a
                : pred;
            if (
              predPostDominator === targetId ||
              result.has(predPostDominator)
            ) {
              result.add(pred);
            }
            queue.push(pred);
          }
        } catch (err) {
          _iterator391.e(err);
        } finally {
          _iterator391.f();
        }
      }
      return result;
    }
    var ReactivityMap = /*#__PURE__*/ (function () {
      function ReactivityMap(aliasedIdentifiers) {
        _classCallCheck(this, ReactivityMap);
        this.hasChanges = false;
        this.reactive = new Set();
        this.aliasedIdentifiers = aliasedIdentifiers;
      }
      return _createClass(ReactivityMap, [
        {
          key: "isReactive",
          value: function isReactive(place) {
            var _a;
            var identifier =
              (_a = this.aliasedIdentifiers.find(place.identifier)) !== null &&
              _a !== void 0
                ? _a
                : place.identifier;
            var reactive = this.reactive.has(identifier.id);
            if (reactive) {
              place.reactive = true;
            }
            return reactive;
          }
        },
        {
          key: "markReactive",
          value: function markReactive(place) {
            var _a;
            place.reactive = true;
            var identifier =
              (_a = this.aliasedIdentifiers.find(place.identifier)) !== null &&
              _a !== void 0
                ? _a
                : place.identifier;
            if (!this.reactive.has(identifier.id)) {
              this.hasChanges = true;
              this.reactive.add(identifier.id);
            }
          }
        },
        {
          key: "snapshot",
          value: function snapshot() {
            var hasChanges = this.hasChanges;
            this.hasChanges = false;
            return hasChanges;
          }
        }
      ]);
    })();
    function inlineImmediatelyInvokedFunctionExpressions(fn) {
      var functions = new Map();
      var inlinedFunctions = new Set();
      var queue = Array.from(fn.body.blocks.values());
      queue: for (var _i41 = 0, _queue = queue; _i41 < _queue.length; _i41++) {
        var block = _queue[_i41];
        for (var ii = 0; ii < block.instructions.length; ii++) {
          var instr = block.instructions[ii];
          switch (instr.value.kind) {
            case "FunctionExpression": {
              if (instr.lvalue.identifier.name === null) {
                functions.set(instr.lvalue.identifier.id, instr.value);
              }
              break;
            }
            case "CallExpression": {
              if (instr.value.args.length !== 0) {
                continue;
              }
              var body = functions.get(instr.value.callee.identifier.id);
              if (body === undefined) {
                continue;
              }
              if (
                body.loweredFunc.func.params.length > 0 ||
                body.loweredFunc.func.async ||
                body.loweredFunc.func.generator
              ) {
                continue;
              }
              inlinedFunctions.add(instr.value.callee.identifier.id);
              var continuationBlockId = fn.env.nextBlockId;
              var continuationBlock = {
                id: continuationBlockId,
                instructions: block.instructions.slice(ii + 1),
                kind: block.kind,
                phis: new Set(),
                preds: new Set(),
                terminal: block.terminal
              };
              fn.body.blocks.set(continuationBlockId, continuationBlock);
              block.instructions.length = ii;
              var newTerminal = {
                block: body.loweredFunc.func.body.entry,
                id: makeInstructionId(0),
                kind: "label",
                fallthrough: continuationBlockId,
                loc: block.terminal.loc
              };
              block.terminal = newTerminal;
              var result = instr.lvalue;
              declareTemporary(fn.env, block, result);
              promoteTemporary(result.identifier);
              var _iterator392 = _createForOfIteratorHelper(
                  body.loweredFunc.func.body.blocks
                ),
                _step392;
              try {
                for (_iterator392.s(); !(_step392 = _iterator392.n()).done; ) {
                  var _step392$value = _slicedToArray(_step392.value, 2),
                    id = _step392$value[0],
                    _block16 = _step392$value[1];
                  _block16.preds.clear();
                  rewriteBlock(fn.env, _block16, continuationBlockId, result);
                  fn.body.blocks.set(id, _block16);
                }
              } catch (err) {
                _iterator392.e(err);
              } finally {
                _iterator392.f();
              }
              queue.push(continuationBlock);
              continue queue;
            }
            default: {
              var _iterator393 = _createForOfIteratorHelper(
                  eachInstructionValueOperand(instr.value)
                ),
                _step393;
              try {
                for (_iterator393.s(); !(_step393 = _iterator393.n()).done; ) {
                  var place = _step393.value;
                  functions["delete"](place.identifier.id);
                }
              } catch (err) {
                _iterator393.e(err);
              } finally {
                _iterator393.f();
              }
            }
          }
        }
      }
      if (inlinedFunctions.size !== 0) {
        var _iterator394 = _createForOfIteratorHelper(fn.body.blocks),
          _step394;
        try {
          for (_iterator394.s(); !(_step394 = _iterator394.n()).done; ) {
            var _step394$value = _slicedToArray(_step394.value, 2),
              _block17 = _step394$value[1];
            retainWhere(_block17.instructions, function (instr) {
              return !inlinedFunctions.has(instr.lvalue.identifier.id);
            });
          }
        } catch (err) {
          _iterator394.e(err);
        } finally {
          _iterator394.f();
        }
        reversePostorderBlocks(fn.body);
        markInstructionIds(fn.body);
        markPredecessors(fn.body);
      }
    }
    function rewriteBlock(env, block, returnTarget, returnValue) {
      var terminal = block.terminal;
      if (terminal.kind !== "return") {
        return;
      }
      block.instructions.push({
        id: makeInstructionId(0),
        loc: terminal.loc,
        lvalue: createTemporaryPlace(env, terminal.loc),
        value: {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Reassign,
            place: Object.assign({}, returnValue)
          },
          value: terminal.value,
          type: null,
          loc: terminal.loc
        }
      });
      block.terminal = {
        kind: "goto",
        block: returnTarget,
        id: makeInstructionId(0),
        variant: GotoVariant.Break,
        loc: block.terminal.loc
      };
    }
    function declareTemporary(env, block, result) {
      block.instructions.push({
        id: makeInstructionId(0),
        loc: GeneratedSource,
        lvalue: createTemporaryPlace(env, result.loc),
        value: {
          kind: "DeclareLocal",
          lvalue: { place: result, kind: InstructionKind.Let },
          type: null,
          loc: result.loc
        }
      });
    }
    function inferEffectDependencies(fn) {
      var hasRewrite = false;
      var fnExpressions = new Map();
      var autodepFnConfigs = new Map();
      var _iterator395 = _createForOfIteratorHelper(
          fn.env.config.inferEffectDependencies
        ),
        _step395;
      try {
        for (_iterator395.s(); !(_step395 = _iterator395.n()).done; ) {
          var effectTarget = _step395.value;
          var moduleTargets = getOrInsertWith(
            autodepFnConfigs,
            effectTarget["function"].source,
            function () {
              return new Map();
            }
          );
          moduleTargets.set(
            effectTarget["function"].importSpecifierName,
            effectTarget.numRequiredArgs
          );
        }
      } catch (err) {
        _iterator395.e(err);
      } finally {
        _iterator395.f();
      }
      var autodepFnLoads = new Map();
      var autodepModuleLoads = new Map();
      var scopeInfos = new Map();
      var loadGlobals = new Set();
      var reactiveIds = inferReactiveIdentifiers(fn);
      var _iterator396 = _createForOfIteratorHelper(fn.body.blocks),
        _step396;
      try {
        for (_iterator396.s(); !(_step396 = _iterator396.n()).done; ) {
          var _step396$value = _slicedToArray(_step396.value, 2),
            block = _step396$value[1];
          if (
            block.terminal.kind === "scope" ||
            block.terminal.kind === "pruned-scope"
          ) {
            var scopeBlock = fn.body.blocks.get(block.terminal.block);
            scopeInfos.set(block.terminal.scope.id, {
              pruned: block.terminal.kind === "pruned-scope",
              deps: block.terminal.scope.dependencies,
              hasSingleInstr:
                scopeBlock.instructions.length === 1 &&
                scopeBlock.terminal.kind === "goto" &&
                scopeBlock.terminal.block === block.terminal.fallthrough
            });
          }
          var rewriteInstrs = new Map();
          var _iterator397 = _createForOfIteratorHelper(block.instructions),
            _step397;
          try {
            for (_iterator397.s(); !(_step397 = _iterator397.n()).done; ) {
              var _instr8 = _step397.value;
              var value = _instr8.value,
                lvalue = _instr8.lvalue;
              if (value.kind === "FunctionExpression") {
                fnExpressions.set(lvalue.identifier.id, _instr8);
              } else if (value.kind === "PropertyLoad") {
                if (
                  typeof value.property === "string" &&
                  autodepModuleLoads.has(value.object.identifier.id)
                ) {
                  var _moduleTargets = autodepModuleLoads.get(
                    value.object.identifier.id
                  );
                  var propertyName = value.property;
                  var numRequiredArgs = _moduleTargets.get(propertyName);
                  if (numRequiredArgs != null) {
                    autodepFnLoads.set(lvalue.identifier.id, numRequiredArgs);
                  }
                }
              } else if (value.kind === "LoadGlobal") {
                loadGlobals.add(lvalue.identifier.id);
                if (value.binding.kind === "ImportNamespace") {
                  var _moduleTargets2 = autodepFnConfigs.get(
                    value.binding.module
                  );
                  if (_moduleTargets2 != null) {
                    autodepModuleLoads.set(
                      lvalue.identifier.id,
                      _moduleTargets2
                    );
                  }
                }
                if (
                  value.binding.kind === "ImportSpecifier" ||
                  value.binding.kind === "ImportDefault"
                ) {
                  var _moduleTargets3 = autodepFnConfigs.get(
                    value.binding.module
                  );
                  if (_moduleTargets3 != null) {
                    var importSpecifierName =
                      value.binding.kind === "ImportSpecifier"
                        ? value.binding.imported
                        : DEFAULT_EXPORT;
                    var _numRequiredArgs =
                      _moduleTargets3.get(importSpecifierName);
                    if (_numRequiredArgs != null) {
                      autodepFnLoads.set(
                        lvalue.identifier.id,
                        _numRequiredArgs
                      );
                    }
                  }
                }
              } else if (
                value.kind === "CallExpression" ||
                value.kind === "MethodCall"
              ) {
                var callee =
                  value.kind === "CallExpression"
                    ? value.callee
                    : value.property;
                if (
                  value.args.length ===
                    autodepFnLoads.get(callee.identifier.id) &&
                  value.args[0].kind === "Identifier"
                ) {
                  var effectDeps = [];
                  var newInstructions = [];
                  var deps = {
                    kind: "ArrayExpression",
                    elements: effectDeps,
                    loc: GeneratedSource
                  };
                  var depsPlace = createTemporaryPlace(fn.env, GeneratedSource);
                  depsPlace.effect = Effect.Read;
                  var fnExpr = fnExpressions.get(value.args[0].identifier.id);
                  if (fnExpr != null) {
                    var scopeInfo =
                      fnExpr.lvalue.identifier.scope != null
                        ? scopeInfos.get(fnExpr.lvalue.identifier.scope.id)
                        : null;
                    CompilerError.invariant(scopeInfo != null, {
                      reason: "Expected function expression scope to exist",
                      loc: value.loc
                    });
                    if (scopeInfo.pruned || !scopeInfo.hasSingleInstr) {
                      CompilerError.throwTodo({
                        reason:
                          "[InferEffectDependencies] Expected effect function to have non-pruned scope and its scope to have exactly one instruction",
                        loc: fnExpr.loc
                      });
                    }
                    var _iterator399 = _createForOfIteratorHelper(
                        scopeInfo.deps
                      ),
                      _step399;
                    try {
                      for (
                        _iterator399.s();
                        !(_step399 = _iterator399.n()).done;

                      ) {
                        var dep = _step399.value;
                        if (
                          (isUseRefType(dep.identifier) ||
                            isSetStateType(dep.identifier)) &&
                          !reactiveIds.has(dep.identifier.id)
                        ) {
                          continue;
                        }
                        var _writeDependencyToIns =
                            writeDependencyToInstructions(
                              dep,
                              reactiveIds.has(dep.identifier.id),
                              fn.env,
                              fnExpr.loc
                            ),
                          place = _writeDependencyToIns.place,
                          instructions = _writeDependencyToIns.instructions;
                        newInstructions.push.apply(
                          newInstructions,
                          _toConsumableArray(instructions)
                        );
                        effectDeps.push(place);
                      }
                    } catch (err) {
                      _iterator399.e(err);
                    } finally {
                      _iterator399.f();
                    }
                    newInstructions.push({
                      id: makeInstructionId(0),
                      loc: GeneratedSource,
                      lvalue: Object.assign(Object.assign({}, depsPlace), {
                        effect: Effect.Mutate
                      }),
                      value: deps
                    });
                    value.args.push(
                      Object.assign(Object.assign({}, depsPlace), {
                        effect: Effect.Freeze
                      })
                    );
                    rewriteInstrs.set(_instr8.id, newInstructions);
                  } else if (loadGlobals.has(value.args[0].identifier.id)) {
                    newInstructions.push({
                      id: makeInstructionId(0),
                      loc: GeneratedSource,
                      lvalue: Object.assign(Object.assign({}, depsPlace), {
                        effect: Effect.Mutate
                      }),
                      value: deps
                    });
                    value.args.push(
                      Object.assign(Object.assign({}, depsPlace), {
                        effect: Effect.Freeze
                      })
                    );
                    rewriteInstrs.set(_instr8.id, newInstructions);
                  }
                }
              }
            }
          } catch (err) {
            _iterator397.e(err);
          } finally {
            _iterator397.f();
          }
          if (rewriteInstrs.size > 0) {
            hasRewrite = true;
            var newInstrs = [];
            var _iterator398 = _createForOfIteratorHelper(block.instructions),
              _step398;
            try {
              for (_iterator398.s(); !(_step398 = _iterator398.n()).done; ) {
                var instr = _step398.value;
                var newInstr = rewriteInstrs.get(instr.id);
                if (newInstr != null) {
                  newInstrs.push.apply(
                    newInstrs,
                    _toConsumableArray(newInstr).concat([instr])
                  );
                } else {
                  newInstrs.push(instr);
                }
              }
            } catch (err) {
              _iterator398.e(err);
            } finally {
              _iterator398.f();
            }
            block.instructions = newInstrs;
          }
        }
      } catch (err) {
        _iterator396.e(err);
      } finally {
        _iterator396.f();
      }
      if (hasRewrite) {
        markInstructionIds(fn.body);
        fixScopeAndIdentifierRanges(fn.body);
      }
    }
    function writeDependencyToInstructions(dep, reactive, env, loc) {
      var instructions = [];
      var currValue = createTemporaryPlace(env, GeneratedSource);
      currValue.reactive = reactive;
      instructions.push({
        id: makeInstructionId(0),
        loc: GeneratedSource,
        lvalue: Object.assign(Object.assign({}, currValue), {
          effect: Effect.Mutate
        }),
        value: {
          kind: "LoadLocal",
          place: {
            kind: "Identifier",
            identifier: dep.identifier,
            effect: Effect.Capture,
            reactive: reactive,
            loc: loc
          },
          loc: loc
        }
      });
      var _iterator400 = _createForOfIteratorHelper(dep.path),
        _step400;
      try {
        for (_iterator400.s(); !(_step400 = _iterator400.n()).done; ) {
          var path = _step400.value;
          if (path.optional) {
            break;
          }
          if (path.property === "current") {
            break;
          }
          var nextValue = createTemporaryPlace(env, GeneratedSource);
          nextValue.reactive = reactive;
          instructions.push({
            id: makeInstructionId(0),
            loc: GeneratedSource,
            lvalue: Object.assign(Object.assign({}, nextValue), {
              effect: Effect.Mutate
            }),
            value: {
              kind: "PropertyLoad",
              object: Object.assign(Object.assign({}, currValue), {
                effect: Effect.Capture
              }),
              property: path.property,
              loc: loc
            }
          });
          currValue = nextValue;
        }
      } catch (err) {
        _iterator400.e(err);
      } finally {
        _iterator400.f();
      }
      currValue.effect = Effect.Freeze;
      return { place: currValue, instructions: instructions };
    }
    function inferReactiveIdentifiers(fn) {
      var reactiveIds = new Set();
      var _iterator401 = _createForOfIteratorHelper(fn.body.blocks),
        _step401;
      try {
        for (_iterator401.s(); !(_step401 = _iterator401.n()).done; ) {
          var _step401$value = _slicedToArray(_step401.value, 2),
            block = _step401$value[1];
          var _iterator402 = _createForOfIteratorHelper(block.instructions),
            _step402;
          try {
            for (_iterator402.s(); !(_step402 = _iterator402.n()).done; ) {
              var instr = _step402.value;
              var _iterator404 = _createForOfIteratorHelper(
                  eachInstructionOperand(instr)
                ),
                _step404;
              try {
                for (_iterator404.s(); !(_step404 = _iterator404.n()).done; ) {
                  var place = _step404.value;
                  if (place.reactive) {
                    reactiveIds.add(place.identifier.id);
                  }
                }
              } catch (err) {
                _iterator404.e(err);
              } finally {
                _iterator404.f();
              }
            }
          } catch (err) {
            _iterator402.e(err);
          } finally {
            _iterator402.f();
          }
          var _iterator403 = _createForOfIteratorHelper(
              eachTerminalOperand(block.terminal)
            ),
            _step403;
          try {
            for (_iterator403.s(); !(_step403 = _iterator403.n()).done; ) {
              var _place28 = _step403.value;
              if (_place28.reactive) {
                reactiveIds.add(_place28.identifier.id);
              }
            }
          } catch (err) {
            _iterator403.e(err);
          } finally {
            _iterator403.f();
          }
        }
      } catch (err) {
        _iterator401.e(err);
      } finally {
        _iterator401.f();
      }
      return reactiveIds;
    }
    function instructionReordering(fn) {
      var _a;
      var shared = new Map();
      var references = findReferencedRangeOfTemporaries(fn);
      var _iterator405 = _createForOfIteratorHelper(fn.body.blocks),
        _step405;
      try {
        for (_iterator405.s(); !(_step405 = _iterator405.n()).done; ) {
          var _step405$value = _slicedToArray(_step405.value, 2),
            block = _step405$value[1];
          reorderBlock(fn.env, block, shared, references);
        }
      } catch (err) {
        _iterator405.e(err);
      } finally {
        _iterator405.f();
      }
      CompilerError.invariant(shared.size === 0, {
        reason:
          "InstructionReordering: expected all reorderable nodes to have been emitted",
        loc:
          (_a = _toConsumableArray(shared.values())
            .map(function (node) {
              var _a;
              return (_a = node.instruction) === null || _a === void 0
                ? void 0
                : _a.loc;
            })
            .filter(function (loc) {
              return loc != null;
            })[0]) !== null && _a !== void 0
            ? _a
            : GeneratedSource
      });
      markInstructionIds(fn.body);
    }
    var ReferenceKind;
    (function (ReferenceKind) {
      ReferenceKind[(ReferenceKind["Read"] = 0)] = "Read";
      ReferenceKind[(ReferenceKind["Write"] = 1)] = "Write";
    })(ReferenceKind || (ReferenceKind = {}));
    function findReferencedRangeOfTemporaries(fn) {
      var singleUseIdentifiers = new Map();
      var lastAssignments = new Map();
      function reference(instr, place, kind) {
        var _a;
        if (
          place.identifier.name !== null &&
          place.identifier.name.kind === "named"
        ) {
          if (kind === ReferenceKind.Write) {
            var _name10 = place.identifier.name.value;
            var previous = lastAssignments.get(_name10);
            if (previous === undefined) {
              lastAssignments.set(_name10, instr);
            } else {
              lastAssignments.set(
                _name10,
                makeInstructionId(Math.max(previous, instr))
              );
            }
          }
          return;
        } else if (kind === ReferenceKind.Read) {
          var previousCount =
            (_a = singleUseIdentifiers.get(place.identifier.id)) !== null &&
            _a !== void 0
              ? _a
              : 0;
          singleUseIdentifiers.set(place.identifier.id, previousCount + 1);
        }
      }
      var _iterator406 = _createForOfIteratorHelper(fn.body.blocks),
        _step406;
      try {
        for (_iterator406.s(); !(_step406 = _iterator406.n()).done; ) {
          var _step406$value = _slicedToArray(_step406.value, 2),
            block = _step406$value[1];
          var _iterator407 = _createForOfIteratorHelper(block.instructions),
            _step407;
          try {
            for (_iterator407.s(); !(_step407 = _iterator407.n()).done; ) {
              var instr = _step407.value;
              var _iterator409 = _createForOfIteratorHelper(
                  eachInstructionValueLValue(instr.value)
                ),
                _step409;
              try {
                for (_iterator409.s(); !(_step409 = _iterator409.n()).done; ) {
                  var operand = _step409.value;
                  reference(instr.id, operand, ReferenceKind.Read);
                }
              } catch (err) {
                _iterator409.e(err);
              } finally {
                _iterator409.f();
              }
              var _iterator410 = _createForOfIteratorHelper(
                  eachInstructionLValue(instr)
                ),
                _step410;
              try {
                for (_iterator410.s(); !(_step410 = _iterator410.n()).done; ) {
                  var lvalue = _step410.value;
                  reference(instr.id, lvalue, ReferenceKind.Write);
                }
              } catch (err) {
                _iterator410.e(err);
              } finally {
                _iterator410.f();
              }
            }
          } catch (err) {
            _iterator407.e(err);
          } finally {
            _iterator407.f();
          }
          var _iterator408 = _createForOfIteratorHelper(
              eachTerminalOperand(block.terminal)
            ),
            _step408;
          try {
            for (_iterator408.s(); !(_step408 = _iterator408.n()).done; ) {
              var _operand29 = _step408.value;
              reference(block.terminal.id, _operand29, ReferenceKind.Read);
            }
          } catch (err) {
            _iterator408.e(err);
          } finally {
            _iterator408.f();
          }
        }
      } catch (err) {
        _iterator406.e(err);
      } finally {
        _iterator406.f();
      }
      return {
        singleUseIdentifiers: new Set(
          _toConsumableArray(singleUseIdentifiers)
            .filter(function (_ref42) {
              var _ref43 = _slicedToArray(_ref42, 2),
                count = _ref43[1];
              return count === 1;
            })
            .map(function (_ref44) {
              var _ref45 = _slicedToArray(_ref44, 1),
                id = _ref45[0];
              return id;
            })
        ),
        lastAssignments: lastAssignments
      };
    }
    function reorderBlock(env, block, shared, references) {
      var _a, _b;
      var locals = new Map();
      var named = new Map();
      var previous = null;
      var _iterator411 = _createForOfIteratorHelper(block.instructions),
        _step411;
      try {
        var _loop11 = function _loop11() {
          var instr = _step411.value;
          var lvalue = instr.lvalue,
            value = instr.value;
          var reorderability = getReorderability(instr, references);
          var node = getOrInsertWith(locals, lvalue.identifier.id, function () {
            return {
              instruction: instr,
              dependencies: new Set(),
              reorderability: reorderability,
              depth: null
            };
          });
          if (reorderability === Reorderability.Nonreorderable) {
            if (previous !== null) {
              node.dependencies.add(previous);
            }
            previous = lvalue.identifier.id;
          }
          var _iterator416 = _createForOfIteratorHelper(
              eachInstructionValueOperand(value)
            ),
            _step416;
          try {
            for (_iterator416.s(); !(_step416 = _iterator416.n()).done; ) {
              var _operand31 = _step416.value;
              var _operand31$identifier = _operand31.identifier,
                _name11 = _operand31$identifier.name,
                _id11 = _operand31$identifier.id;
              if (_name11 !== null && _name11.kind === "named") {
                var _previous2 = named.get(_name11.value);
                if (_previous2 !== undefined) {
                  node.dependencies.add(_previous2);
                }
                named.set(_name11.value, lvalue.identifier.id);
              } else if (locals.has(_id11) || shared.has(_id11)) {
                node.dependencies.add(_id11);
              }
            }
          } catch (err) {
            _iterator416.e(err);
          } finally {
            _iterator416.f();
          }
          var _iterator417 = _createForOfIteratorHelper(
              eachInstructionValueLValue(value)
            ),
            _step417;
          try {
            for (_iterator417.s(); !(_step417 = _iterator417.n()).done; ) {
              var lvalueOperand = _step417.value;
              var lvalueNode = getOrInsertWith(
                locals,
                lvalueOperand.identifier.id,
                function () {
                  return {
                    instruction: null,
                    dependencies: new Set(),
                    depth: null
                  };
                }
              );
              lvalueNode.dependencies.add(lvalue.identifier.id);
              var _name12 = lvalueOperand.identifier.name;
              if (_name12 !== null && _name12.kind === "named") {
                var _previous3 = named.get(_name12.value);
                if (_previous3 !== undefined) {
                  node.dependencies.add(_previous3);
                }
                named.set(_name12.value, lvalue.identifier.id);
              }
            }
          } catch (err) {
            _iterator417.e(err);
          } finally {
            _iterator417.f();
          }
        };
        for (_iterator411.s(); !(_step411 = _iterator411.n()).done; ) {
          _loop11();
        }
      } catch (err) {
        _iterator411.e(err);
      } finally {
        _iterator411.f();
      }
      var nextInstructions = [];
      if (isExpressionBlockKind(block.kind)) {
        if (previous !== null) {
          emit(env, locals, shared, nextInstructions, previous);
        }
        if (block.instructions.length !== 0) {
          emit(
            env,
            locals,
            shared,
            nextInstructions,
            block.instructions.at(-1).lvalue.identifier.id
          );
        }
        var _iterator412 = _createForOfIteratorHelper(
            eachTerminalOperand(block.terminal)
          ),
          _step412;
        try {
          for (_iterator412.s(); !(_step412 = _iterator412.n()).done; ) {
            var operand = _step412.value;
            emit(env, locals, shared, nextInstructions, operand.identifier.id);
          }
        } catch (err) {
          _iterator412.e(err);
        } finally {
          _iterator412.f();
        }
        var _iterator413 = _createForOfIteratorHelper(locals),
          _step413;
        try {
          for (_iterator413.s(); !(_step413 = _iterator413.n()).done; ) {
            var _step413$value = _slicedToArray(_step413.value, 2),
              id = _step413$value[0],
              _node13 = _step413$value[1];
            if (_node13.instruction == null) {
              continue;
            }
            CompilerError.invariant(
              _node13.reorderability === Reorderability.Reorderable,
              {
                reason: "Expected all remaining instructions to be reorderable",
                loc:
                  (_b =
                    (_a = _node13.instruction) === null || _a === void 0
                      ? void 0
                      : _a.loc) !== null && _b !== void 0
                    ? _b
                    : block.terminal.loc,
                description:
                  _node13.instruction != null
                    ? "Instruction [".concat(
                        _node13.instruction.id,
                        "] was not emitted yet but is not reorderable"
                      )
                    : "Lvalue $".concat(
                        id,
                        " was not emitted yet but is not reorderable"
                      )
              }
            );
            shared.set(id, _node13);
          }
        } catch (err) {
          _iterator413.e(err);
        } finally {
          _iterator413.f();
        }
      } else {
        var _iterator414 = _createForOfIteratorHelper(
            eachTerminalOperand(block.terminal)
          ),
          _step414;
        try {
          for (_iterator414.s(); !(_step414 = _iterator414.n()).done; ) {
            var _operand30 = _step414.value;
            emit(
              env,
              locals,
              shared,
              nextInstructions,
              _operand30.identifier.id
            );
          }
        } catch (err) {
          _iterator414.e(err);
        } finally {
          _iterator414.f();
        }
        var _iterator415 = _createForOfIteratorHelper(
            Array.from(locals.keys()).reverse()
          ),
          _step415;
        try {
          for (_iterator415.s(); !(_step415 = _iterator415.n()).done; ) {
            var _id10 = _step415.value;
            var _node14 = locals.get(_id10);
            if (_node14 === undefined) {
              continue;
            }
            if (_node14.reorderability === Reorderability.Reorderable) {
              shared.set(_id10, _node14);
            } else {
              emit(env, locals, shared, nextInstructions, _id10);
            }
          }
        } catch (err) {
          _iterator415.e(err);
        } finally {
          _iterator415.f();
        }
      }
      block.instructions = nextInstructions;
    }
    function getDepth(env, nodes, id) {
      var node = nodes.get(id);
      if (node == null) {
        return 0;
      }
      if (node.depth != null) {
        return node.depth;
      }
      node.depth = 0;
      var depth = node.reorderability === Reorderability.Reorderable ? 1 : 10;
      var _iterator418 = _createForOfIteratorHelper(node.dependencies),
        _step418;
      try {
        for (_iterator418.s(); !(_step418 = _iterator418.n()).done; ) {
          var dep = _step418.value;
          depth += getDepth(env, nodes, dep);
        }
      } catch (err) {
        _iterator418.e(err);
      } finally {
        _iterator418.f();
      }
      node.depth = depth;
      return depth;
    }
    function emit(env, locals, shared, instructions, id) {
      var _a;
      var node =
        (_a = locals.get(id)) !== null && _a !== void 0 ? _a : shared.get(id);
      if (node == null) {
        return;
      }
      locals["delete"](id);
      shared["delete"](id);
      var deps = _toConsumableArray(node.dependencies);
      deps.sort(function (a, b) {
        var aDepth = getDepth(env, locals, a);
        var bDepth = getDepth(env, locals, b);
        return bDepth - aDepth;
      });
      var _iterator419 = _createForOfIteratorHelper(deps),
        _step419;
      try {
        for (_iterator419.s(); !(_step419 = _iterator419.n()).done; ) {
          var dep = _step419.value;
          emit(env, locals, shared, instructions, dep);
        }
      } catch (err) {
        _iterator419.e(err);
      } finally {
        _iterator419.f();
      }
      if (node.instruction !== null) {
        instructions.push(node.instruction);
      }
    }
    var Reorderability;
    (function (Reorderability) {
      Reorderability[(Reorderability["Reorderable"] = 0)] = "Reorderable";
      Reorderability[(Reorderability["Nonreorderable"] = 1)] = "Nonreorderable";
    })(Reorderability || (Reorderability = {}));
    function getReorderability(instr, references) {
      switch (instr.value.kind) {
        case "JsxExpression":
        case "JsxFragment":
        case "JSXText":
        case "LoadGlobal":
        case "Primitive":
        case "TemplateLiteral":
        case "BinaryExpression":
        case "UnaryExpression": {
          return Reorderability.Reorderable;
        }
        case "LoadLocal": {
          var _name13 = instr.value.place.identifier.name;
          if (_name13 !== null && _name13.kind === "named") {
            var lastAssignment = references.lastAssignments.get(_name13.value);
            if (
              lastAssignment !== undefined &&
              lastAssignment < instr.id &&
              references.singleUseIdentifiers.has(instr.lvalue.identifier.id)
            ) {
              return Reorderability.Reorderable;
            }
          }
          return Reorderability.Nonreorderable;
        }
        default: {
          return Reorderability.Nonreorderable;
        }
      }
    }
    function alignMethodCallScopes(fn) {
      var scopeMapping = new Map();
      var mergedScopes = new DisjointSet();
      var _iterator420 = _createForOfIteratorHelper(fn.body.blocks),
        _step420;
      try {
        for (_iterator420.s(); !(_step420 = _iterator420.n()).done; ) {
          var _step420$value = _slicedToArray(_step420.value, 2),
            block = _step420$value[1];
          var _iterator422 = _createForOfIteratorHelper(block.instructions),
            _step422;
          try {
            for (_iterator422.s(); !(_step422 = _iterator422.n()).done; ) {
              var instr = _step422.value;
              var lvalue = instr.lvalue,
                value = instr.value;
              if (value.kind === "MethodCall") {
                var lvalueScope = lvalue.identifier.scope;
                var propertyScope = value.property.identifier.scope;
                if (lvalueScope !== null) {
                  if (propertyScope !== null) {
                    mergedScopes.union([lvalueScope, propertyScope]);
                  } else {
                    scopeMapping.set(value.property.identifier.id, lvalueScope);
                  }
                } else if (propertyScope !== null) {
                  scopeMapping.set(value.property.identifier.id, null);
                }
              } else if (
                value.kind === "FunctionExpression" ||
                value.kind === "ObjectMethod"
              ) {
                alignMethodCallScopes(value.loweredFunc.func);
              }
            }
          } catch (err) {
            _iterator422.e(err);
          } finally {
            _iterator422.f();
          }
        }
      } catch (err) {
        _iterator420.e(err);
      } finally {
        _iterator420.f();
      }
      mergedScopes.forEach(function (scope, root) {
        if (scope === root) {
          return;
        }
        root.range.start = makeInstructionId(
          Math.min(scope.range.start, root.range.start)
        );
        root.range.end = makeInstructionId(
          Math.max(scope.range.end, root.range.end)
        );
      });
      var _iterator421 = _createForOfIteratorHelper(fn.body.blocks),
        _step421;
      try {
        for (_iterator421.s(); !(_step421 = _iterator421.n()).done; ) {
          var _step421$value = _slicedToArray(_step421.value, 2),
            _block18 = _step421$value[1];
          var _iterator423 = _createForOfIteratorHelper(_block18.instructions),
            _step423;
          try {
            for (_iterator423.s(); !(_step423 = _iterator423.n()).done; ) {
              var _instr9 = _step423.value;
              var mappedScope = scopeMapping.get(_instr9.lvalue.identifier.id);
              if (mappedScope !== undefined) {
                _instr9.lvalue.identifier.scope = mappedScope;
              } else if (_instr9.lvalue.identifier.scope !== null) {
                var mergedScope = mergedScopes.find(
                  _instr9.lvalue.identifier.scope
                );
                if (mergedScope != null) {
                  _instr9.lvalue.identifier.scope = mergedScope;
                }
              }
            }
          } catch (err) {
            _iterator423.e(err);
          } finally {
            _iterator423.f();
          }
        }
      } catch (err) {
        _iterator421.e(err);
      } finally {
        _iterator421.f();
      }
    }
    function alignReactiveScopesToBlockScopesHIR(fn) {
      var _a, _b, _c, _d, _e;
      var activeBlockFallthroughRanges = [];
      var activeScopes = new Set();
      var seen = new Set();
      var valueBlockNodes = new Map();
      var placeScopes = new Map();
      function recordPlace(id, place, node) {
        if (place.identifier.scope !== null) {
          placeScopes.set(place, place.identifier.scope);
        }
        var scope = getPlaceScope(id, place);
        if (scope == null) {
          return;
        }
        activeScopes.add(scope);
        node === null || node === void 0
          ? void 0
          : node.children.push({ kind: "scope", scope: scope, id: id });
        if (seen.has(scope)) {
          return;
        }
        seen.add(scope);
        if (node != null && node.valueRange !== null) {
          scope.range.start = makeInstructionId(
            Math.min(node.valueRange.start, scope.range.start)
          );
          scope.range.end = makeInstructionId(
            Math.max(node.valueRange.end, scope.range.end)
          );
        }
      }
      var _iterator424 = _createForOfIteratorHelper(fn.body.blocks),
        _step424;
      try {
        var _loop12 = function _loop12() {
          var _step424$value = _slicedToArray(_step424.value, 2),
            block = _step424$value[1];
          var startingId =
            (_b =
              (_a = block.instructions[0]) === null || _a === void 0
                ? void 0
                : _a.id) !== null && _b !== void 0
              ? _b
              : block.terminal.id;
          retainWhere_Set(activeScopes, function (scope) {
            return scope.range.end > startingId;
          });
          var top = activeBlockFallthroughRanges.at(-1);
          if (
            (top === null || top === void 0 ? void 0 : top.fallthrough) ===
            block.id
          ) {
            activeBlockFallthroughRanges.pop();
            var _iterator425 = _createForOfIteratorHelper(activeScopes),
              _step425;
            try {
              for (_iterator425.s(); !(_step425 = _iterator425.n()).done; ) {
                var scope = _step425.value;
                scope.range.start = makeInstructionId(
                  Math.min(scope.range.start, top.range.start)
                );
              }
            } catch (err) {
              _iterator425.e(err);
            } finally {
              _iterator425.f();
            }
          }
          var instructions = block.instructions,
            terminal = block.terminal;
          var node =
            (_c = valueBlockNodes.get(block.id)) !== null && _c !== void 0
              ? _c
              : null;
          var _iterator426 = _createForOfIteratorHelper(instructions),
            _step426;
          try {
            for (_iterator426.s(); !(_step426 = _iterator426.n()).done; ) {
              var instr = _step426.value;
              var _iterator429 = _createForOfIteratorHelper(
                  eachInstructionLValue(instr)
                ),
                _step429;
              try {
                for (_iterator429.s(); !(_step429 = _iterator429.n()).done; ) {
                  var lvalue = _step429.value;
                  recordPlace(instr.id, lvalue, node);
                }
              } catch (err) {
                _iterator429.e(err);
              } finally {
                _iterator429.f();
              }
              var _iterator430 = _createForOfIteratorHelper(
                  eachInstructionValueOperand(instr.value)
                ),
                _step430;
              try {
                for (_iterator430.s(); !(_step430 = _iterator430.n()).done; ) {
                  var operand = _step430.value;
                  recordPlace(instr.id, operand, node);
                }
              } catch (err) {
                _iterator430.e(err);
              } finally {
                _iterator430.f();
              }
            }
          } catch (err) {
            _iterator426.e(err);
          } finally {
            _iterator426.f();
          }
          var _iterator427 = _createForOfIteratorHelper(
              eachTerminalOperand(terminal)
            ),
            _step427;
          try {
            for (_iterator427.s(); !(_step427 = _iterator427.n()).done; ) {
              var _operand32 = _step427.value;
              recordPlace(terminal.id, _operand32, node);
            }
          } catch (err) {
            _iterator427.e(err);
          } finally {
            _iterator427.f();
          }
          var fallthrough = terminalFallthrough(terminal);
          if (fallthrough !== null && terminal.kind !== "branch") {
            var fallthroughBlock = fn.body.blocks.get(fallthrough);
            var nextId =
              (_e =
                (_d = fallthroughBlock.instructions[0]) === null ||
                _d === void 0
                  ? void 0
                  : _d.id) !== null && _e !== void 0
                ? _e
                : fallthroughBlock.terminal.id;
            var _iterator428 = _createForOfIteratorHelper(activeScopes),
              _step428;
            try {
              for (_iterator428.s(); !(_step428 = _iterator428.n()).done; ) {
                var _scope = _step428.value;
                if (_scope.range.end > terminal.id) {
                  _scope.range.end = makeInstructionId(
                    Math.max(_scope.range.end, nextId)
                  );
                }
              }
            } catch (err) {
              _iterator428.e(err);
            } finally {
              _iterator428.f();
            }
            activeBlockFallthroughRanges.push({
              fallthrough: fallthrough,
              range: { start: terminal.id, end: nextId }
            });
            CompilerError.invariant(!valueBlockNodes.has(fallthrough), {
              reason: "Expect hir blocks to have unique fallthroughs",
              loc: terminal.loc
            });
            if (node != null) {
              valueBlockNodes.set(fallthrough, node);
            }
          }
          mapTerminalSuccessors(terminal, function (successor) {
            var _a, _b;
            if (valueBlockNodes.has(successor)) {
              return successor;
            }
            var successorBlock = fn.body.blocks.get(successor);
            if (
              successorBlock.kind === "block" ||
              successorBlock.kind === "catch"
            );
            else if (
              node == null ||
              terminal.kind === "ternary" ||
              terminal.kind === "logical" ||
              terminal.kind === "optional"
            ) {
              var valueRange;
              if (node == null) {
                CompilerError.invariant(fallthrough !== null, {
                  reason: "Expected a fallthrough for value block",
                  loc: terminal.loc
                });
                var _fallthroughBlock = fn.body.blocks.get(fallthrough);
                var _nextId2 =
                  (_b =
                    (_a = _fallthroughBlock.instructions[0]) === null ||
                    _a === void 0
                      ? void 0
                      : _a.id) !== null && _b !== void 0
                    ? _b
                    : _fallthroughBlock.terminal.id;
                valueRange = { start: terminal.id, end: _nextId2 };
              } else {
                valueRange = node.valueRange;
              }
              var childNode = {
                kind: "node",
                id: terminal.id,
                children: [],
                valueRange: valueRange
              };
              node === null || node === void 0
                ? void 0
                : node.children.push(childNode);
              valueBlockNodes.set(successor, childNode);
            } else {
              valueBlockNodes.set(successor, node);
            }
            return successor;
          });
        };
        for (_iterator424.s(); !(_step424 = _iterator424.n()).done; ) {
          _loop12();
        }
      } catch (err) {
        _iterator424.e(err);
      } finally {
        _iterator424.f();
      }
    }
    function flattenReactiveLoopsHIR(fn) {
      var activeLoops = Array();
      var _iterator431 = _createForOfIteratorHelper(fn.body.blocks),
        _step431;
      try {
        var _loop13 = function _loop13() {
          var _step431$value = _slicedToArray(_step431.value, 2),
            block = _step431$value[1];
          retainWhere(activeLoops, function (id) {
            return id !== block.id;
          });
          var terminal = block.terminal;
          switch (terminal.kind) {
            case "do-while":
            case "for":
            case "for-in":
            case "for-of":
            case "while": {
              activeLoops.push(terminal.fallthrough);
              break;
            }
            case "scope": {
              if (activeLoops.length !== 0) {
                block.terminal = {
                  kind: "pruned-scope",
                  block: terminal.block,
                  fallthrough: terminal.fallthrough,
                  id: terminal.id,
                  loc: terminal.loc,
                  scope: terminal.scope
                };
              }
              break;
            }
            case "branch":
            case "goto":
            case "if":
            case "label":
            case "logical":
            case "maybe-throw":
            case "optional":
            case "pruned-scope":
            case "return":
            case "sequence":
            case "switch":
            case "ternary":
            case "throw":
            case "try":
            case "unreachable":
            case "unsupported": {
              break;
            }
            default: {
              assertExhaustive$1(
                terminal,
                "Unexpected terminal kind `".concat(terminal.kind, "`")
              );
            }
          }
        };
        for (_iterator431.s(); !(_step431 = _iterator431.n()).done; ) {
          _loop13();
        }
      } catch (err) {
        _iterator431.e(err);
      } finally {
        _iterator431.f();
      }
    }
    function flattenScopesWithHooksOrUseHIR(fn) {
      var activeScopes = [];
      var prune = [];
      var _iterator432 = _createForOfIteratorHelper(fn.body.blocks),
        _step432;
      try {
        var _loop14 = function _loop14() {
          var _step432$value = _slicedToArray(_step432.value, 2),
            block = _step432$value[1];
          retainWhere(activeScopes, function (current) {
            return current.fallthrough !== block.id;
          });
          var _iterator433 = _createForOfIteratorHelper(block.instructions),
            _step433;
          try {
            for (_iterator433.s(); !(_step433 = _iterator433.n()).done; ) {
              var instr = _step433.value;
              var value = instr.value;
              switch (value.kind) {
                case "MethodCall":
                case "CallExpression": {
                  var callee =
                    value.kind === "MethodCall" ? value.property : value.callee;
                  if (
                    getHookKind(fn.env, callee.identifier) != null ||
                    isUseOperator(callee.identifier)
                  ) {
                    prune.push.apply(
                      prune,
                      _toConsumableArray(
                        activeScopes.map(function (entry) {
                          return entry.block;
                        })
                      )
                    );
                    activeScopes.length = 0;
                  }
                }
              }
            }
          } catch (err) {
            _iterator433.e(err);
          } finally {
            _iterator433.f();
          }
          if (block.terminal.kind === "scope") {
            activeScopes.push({
              block: block.id,
              fallthrough: block.terminal.fallthrough
            });
          }
        };
        for (_iterator432.s(); !(_step432 = _iterator432.n()).done; ) {
          _loop14();
        }
      } catch (err) {
        _iterator432.e(err);
      } finally {
        _iterator432.f();
      }
      for (var _i42 = 0, _prune = prune; _i42 < _prune.length; _i42++) {
        var id = _prune[_i42];
        var block = fn.body.blocks.get(id);
        var terminal = block.terminal;
        CompilerError.invariant(terminal.kind === "scope", {
          reason: "Expected block to have a scope terminal",
          description: "Expected block bb".concat(
            block.id,
            " to end in a scope terminal"
          ),
          loc: terminal.loc
        });
        var body = fn.body.blocks.get(terminal.block);
        if (
          body.instructions.length === 1 &&
          body.terminal.kind === "goto" &&
          body.terminal.block === terminal.fallthrough
        ) {
          block.terminal = {
            kind: "label",
            block: terminal.block,
            fallthrough: terminal.fallthrough,
            id: terminal.id,
            loc: terminal.loc
          };
          continue;
        }
        block.terminal = {
          kind: "pruned-scope",
          block: terminal.block,
          fallthrough: terminal.fallthrough,
          id: terminal.id,
          loc: terminal.loc,
          scope: terminal.scope
        };
      }
    }
    function pruneAlwaysInvalidatingScopes(fn) {
      visitReactiveFunction(fn, new Transform(), false);
    }
    var Transform = /*#__PURE__*/ (function (_ReactiveFunctionTran8) {
      function Transform() {
        var _this21;
        _classCallCheck(this, Transform);
        _this21 = _callSuper(this, Transform, arguments);
        _this21.alwaysInvalidatingValues = new Set();
        _this21.unmemoizedValues = new Set();
        return _this21;
      }
      _inherits2(Transform, _ReactiveFunctionTran8);
      return _createClass(Transform, [
        {
          key: "transformInstruction",
          value: function transformInstruction(instruction, withinScope) {
            this.visitInstruction(instruction, withinScope);
            var lvalue = instruction.lvalue,
              value = instruction.value;
            switch (value.kind) {
              case "ArrayExpression":
              case "ObjectExpression":
              case "JsxExpression":
              case "JsxFragment":
              case "NewExpression": {
                if (lvalue !== null) {
                  this.alwaysInvalidatingValues.add(lvalue.identifier);
                  if (!withinScope) {
                    this.unmemoizedValues.add(lvalue.identifier);
                  }
                }
                break;
              }
              case "StoreLocal": {
                if (this.alwaysInvalidatingValues.has(value.value.identifier)) {
                  this.alwaysInvalidatingValues.add(
                    value.lvalue.place.identifier
                  );
                }
                if (this.unmemoizedValues.has(value.value.identifier)) {
                  this.unmemoizedValues.add(value.lvalue.place.identifier);
                }
                break;
              }
              case "LoadLocal": {
                if (
                  lvalue !== null &&
                  this.alwaysInvalidatingValues.has(value.place.identifier)
                ) {
                  this.alwaysInvalidatingValues.add(lvalue.identifier);
                }
                if (
                  lvalue !== null &&
                  this.unmemoizedValues.has(value.place.identifier)
                ) {
                  this.unmemoizedValues.add(lvalue.identifier);
                }
                break;
              }
            }
            return { kind: "keep" };
          }
        },
        {
          key: "transformScope",
          value: function transformScope(scopeBlock, _withinScope) {
            this.visitScope(scopeBlock, true);
            var _iterator434 = _createForOfIteratorHelper(
                scopeBlock.scope.dependencies
              ),
              _step434;
            try {
              for (_iterator434.s(); !(_step434 = _iterator434.n()).done; ) {
                var dep = _step434.value;
                if (this.unmemoizedValues.has(dep.identifier)) {
                  var _iterator435 = _createForOfIteratorHelper(
                      scopeBlock.scope.declarations
                    ),
                    _step435;
                  try {
                    for (
                      _iterator435.s();
                      !(_step435 = _iterator435.n()).done;

                    ) {
                      var _step435$value = _slicedToArray(_step435.value, 2),
                        _ = _step435$value[0],
                        decl = _step435$value[1];
                      if (this.alwaysInvalidatingValues.has(decl.identifier)) {
                        this.unmemoizedValues.add(decl.identifier);
                      }
                    }
                  } catch (err) {
                    _iterator435.e(err);
                  } finally {
                    _iterator435.f();
                  }
                  var _iterator436 = _createForOfIteratorHelper(
                      scopeBlock.scope.reassignments
                    ),
                    _step436;
                  try {
                    for (
                      _iterator436.s();
                      !(_step436 = _iterator436.n()).done;

                    ) {
                      var _identifier16 = _step436.value;
                      if (this.alwaysInvalidatingValues.has(_identifier16)) {
                        this.unmemoizedValues.add(_identifier16);
                      }
                    }
                  } catch (err) {
                    _iterator436.e(err);
                  } finally {
                    _iterator436.f();
                  }
                  return {
                    kind: "replace",
                    value: {
                      kind: "pruned-scope",
                      scope: scopeBlock.scope,
                      instructions: scopeBlock.instructions
                    }
                  };
                }
              }
            } catch (err) {
              _iterator434.e(err);
            } finally {
              _iterator434.f();
            }
            return { kind: "keep" };
          }
        }
      ]);
    })(ReactiveFunctionTransform);
    var Visitor$2 = /*#__PURE__*/ (function (_ReactiveFunctionVisi19) {
      function Visitor(env, aliases, paths) {
        var _this22;
        _classCallCheck(this, Visitor);
        _this22 = _callSuper(this, Visitor);
        _this22.map = new Map();
        _this22.aliases = aliases;
        _this22.paths = paths;
        _this22.env = env;
        return _this22;
      }
      _inherits2(Visitor, _ReactiveFunctionVisi19);
      return _createClass(Visitor, [
        {
          key: "join",
          value: function join(values) {
            function join2(l, r) {
              if (l === "Update" || r === "Update") {
                return "Update";
              } else if (l === "Create" || r === "Create") {
                return "Create";
              } else if (l === "Unknown" || r === "Unknown") {
                return "Unknown";
              }
              assertExhaustive$1(r, "Unhandled variable kind ".concat(r));
            }
            return values.reduce(join2, "Unknown");
          }
        },
        {
          key: "isCreateOnlyHook",
          value: function isCreateOnlyHook(id) {
            return isUseStateType(id) || isUseRefType(id);
          }
        },
        {
          key: "visitPlace",
          value: function visitPlace(_, place, state) {
            var _a;
            this.map.set(
              place.identifier.id,
              this.join([
                state,
                (_a = this.map.get(place.identifier.id)) !== null &&
                _a !== void 0
                  ? _a
                  : "Unknown"
              ])
            );
          }
        },
        {
          key: "visitBlock",
          value: function visitBlock(block, state) {
            _get(_getPrototypeOf(Visitor.prototype), "visitBlock", this).call(
              this,
              _toConsumableArray(block).reverse(),
              state
            );
          }
        },
        {
          key: "visitInstruction",
          value: function visitInstruction(instruction) {
            var _this23 = this;
            var state = this.join(
              _toConsumableArray(eachInstructionLValue(instruction)).map(
                function (operand) {
                  var _a;
                  return (_a = _this23.map.get(operand.identifier.id)) !==
                    null && _a !== void 0
                    ? _a
                    : "Unknown";
                }
              )
            );
            var visitCallOrMethodNonArgs = function visitCallOrMethodNonArgs() {
              switch (instruction.value.kind) {
                case "CallExpression": {
                  _this23.visitPlace(
                    instruction.id,
                    instruction.value.callee,
                    state
                  );
                  break;
                }
                case "MethodCall": {
                  _this23.visitPlace(
                    instruction.id,
                    instruction.value.property,
                    state
                  );
                  _this23.visitPlace(
                    instruction.id,
                    instruction.value.receiver,
                    state
                  );
                  break;
                }
              }
            };
            var isHook = function isHook() {
              var callee = null;
              switch (instruction.value.kind) {
                case "CallExpression": {
                  callee = instruction.value.callee.identifier;
                  break;
                }
                case "MethodCall": {
                  callee = instruction.value.property.identifier;
                  break;
                }
              }
              return callee != null && getHookKind(_this23.env, callee) != null;
            };
            switch (instruction.value.kind) {
              case "CallExpression":
              case "MethodCall": {
                if (
                  instruction.lvalue &&
                  this.isCreateOnlyHook(instruction.lvalue.identifier)
                ) {
                  _toConsumableArray(
                    eachCallArgument(instruction.value.args)
                  ).forEach(function (operand) {
                    return _this23.visitPlace(
                      instruction.id,
                      operand,
                      "Create"
                    );
                  });
                  visitCallOrMethodNonArgs();
                } else {
                  this.traverseInstruction(
                    instruction,
                    isHook() ? "Update" : state
                  );
                }
                break;
              }
              default: {
                this.traverseInstruction(instruction, state);
              }
            }
          }
        },
        {
          key: "visitScope",
          value: function visitScope(scope) {
            var _this24 = this;
            var state = this.join(
              []
                .concat(
                  _toConsumableArray(scope.scope.declarations.keys()),
                  _toConsumableArray(
                    _toConsumableArray(scope.scope.reassignments.values()).map(
                      function (ident) {
                        return ident.id;
                      }
                    )
                  )
                )
                .map(function (id) {
                  var _a;
                  return (_a = _this24.map.get(id)) !== null && _a !== void 0
                    ? _a
                    : "Unknown";
                })
            );
            _get(_getPrototypeOf(Visitor.prototype), "visitScope", this).call(
              this,
              scope,
              state
            );
            _toConsumableArray(scope.scope.dependencies).forEach(
              function (ident) {
                var _a;
                var target =
                  (_a = _this24.aliases.find(ident.identifier.id)) !== null &&
                  _a !== void 0
                    ? _a
                    : ident.identifier.id;
                ident.path.forEach(function (token) {
                  var _a;
                  target &&
                    (target =
                      (_a = _this24.paths.get(target)) === null || _a === void 0
                        ? void 0
                        : _a.get(token.property));
                });
                if (target && _this24.map.get(target) === "Create") {
                  scope.scope.dependencies["delete"](ident);
                }
              }
            );
          }
        },
        {
          key: "visitTerminal",
          value: function visitTerminal(stmt, state) {
            CompilerError.invariant(state !== "Create", {
              reason: "Visiting a terminal statement with state 'Create'",
              loc: stmt.terminal.loc
            });
            _get(
              _getPrototypeOf(Visitor.prototype),
              "visitTerminal",
              this
            ).call(this, stmt, state);
          }
        },
        {
          key: "visitReactiveFunctionValue",
          value: function visitReactiveFunctionValue(
            _id,
            _dependencies,
            fn,
            state
          ) {
            visitReactiveFunction(fn, this, state);
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    function pruneInitializationDependencies(fn) {
      var _getAliases = getAliases(fn),
        _getAliases2 = _slicedToArray(_getAliases, 2),
        aliases = _getAliases2[0],
        paths = _getAliases2[1];
      visitReactiveFunction(
        fn,
        new Visitor$2(fn.env, aliases, paths),
        "Update"
      );
    }
    function update(map, key, path, value) {
      var _a;
      var inner =
        (_a = map.get(key)) !== null && _a !== void 0 ? _a : new Map();
      inner.set(path, value);
      map.set(key, inner);
    }
    var AliasVisitor = /*#__PURE__*/ (function (_ReactiveFunctionVisi20) {
      function AliasVisitor() {
        var _this25;
        _classCallCheck(this, AliasVisitor);
        _this25 = _callSuper(this, AliasVisitor, arguments);
        _this25.scopeIdentifiers = new DisjointSet();
        _this25.scopePaths = new Map();
        return _this25;
      }
      _inherits2(AliasVisitor, _ReactiveFunctionVisi20);
      return _createClass(AliasVisitor, [
        {
          key: "visitInstruction",
          value: function visitInstruction(instr) {
            if (
              instr.value.kind === "StoreLocal" ||
              instr.value.kind === "StoreContext"
            ) {
              this.scopeIdentifiers.union([
                instr.value.lvalue.place.identifier.id,
                instr.value.value.identifier.id
              ]);
            } else if (
              instr.value.kind === "LoadLocal" ||
              instr.value.kind === "LoadContext"
            ) {
              instr.lvalue &&
                this.scopeIdentifiers.union([
                  instr.lvalue.identifier.id,
                  instr.value.place.identifier.id
                ]);
            } else if (instr.value.kind === "PropertyLoad") {
              instr.lvalue &&
                update(
                  this.scopePaths,
                  instr.value.object.identifier.id,
                  instr.value.property,
                  instr.lvalue.identifier.id
                );
            } else if (instr.value.kind === "PropertyStore") {
              update(
                this.scopePaths,
                instr.value.object.identifier.id,
                instr.value.property,
                instr.value.value.identifier.id
              );
            }
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    function getAliases(fn) {
      var _a, _b;
      var visitor = new AliasVisitor();
      visitReactiveFunction(fn, visitor, null);
      var disjoint = visitor.scopeIdentifiers;
      var scopePaths = new Map();
      var _iterator437 = _createForOfIteratorHelper(visitor.scopePaths),
        _step437;
      try {
        for (_iterator437.s(); !(_step437 = _iterator437.n()).done; ) {
          var _step437$value = _slicedToArray(_step437.value, 2),
            _key39 = _step437$value[0],
            value = _step437$value[1];
          var _iterator438 = _createForOfIteratorHelper(value),
            _step438;
          try {
            for (_iterator438.s(); !(_step438 = _iterator438.n()).done; ) {
              var _step438$value = _slicedToArray(_step438.value, 2),
                path = _step438$value[0],
                id = _step438$value[1];
              update(
                scopePaths,
                (_a = disjoint.find(_key39)) !== null && _a !== void 0
                  ? _a
                  : _key39,
                path,
                (_b = disjoint.find(id)) !== null && _b !== void 0 ? _b : id
              );
            }
          } catch (err) {
            _iterator438.e(err);
          } finally {
            _iterator438.f();
          }
        }
      } catch (err) {
        _iterator437.e(err);
      } finally {
        _iterator437.f();
      }
      return [disjoint, scopePaths];
    }
    function isPrimitiveBinaryOp(op) {
      switch (op) {
        case "+":
        case "-":
        case "/":
        case "%":
        case "*":
        case "**":
        case "&":
        case "|":
        case ">>":
        case "<<":
        case "^":
        case ">":
        case "<":
        case ">=":
        case "<=":
        case "|>":
          return true;
        default:
          return false;
      }
    }
    function inferTypes(func) {
      var unifier = new Unifier(func.env);
      var _iterator439 = _createForOfIteratorHelper(generate(func)),
        _step439;
      try {
        for (_iterator439.s(); !(_step439 = _iterator439.n()).done; ) {
          var e = _step439.value;
          unifier.unify(e.left, e.right);
        }
      } catch (err) {
        _iterator439.e(err);
      } finally {
        _iterator439.f();
      }
      apply(func, unifier);
    }
    function apply(func, unifier) {
      var _iterator440 = _createForOfIteratorHelper(func.body.blocks),
        _step440;
      try {
        for (_iterator440.s(); !(_step440 = _iterator440.n()).done; ) {
          var _step440$value = _slicedToArray(_step440.value, 2),
            _ = _step440$value[0],
            block = _step440$value[1];
          var _iterator441 = _createForOfIteratorHelper(block.phis),
            _step441;
          try {
            for (_iterator441.s(); !(_step441 = _iterator441.n()).done; ) {
              var phi = _step441.value;
              phi.place.identifier.type = unifier.get(
                phi.place.identifier.type
              );
            }
          } catch (err) {
            _iterator441.e(err);
          } finally {
            _iterator441.f();
          }
          var _iterator442 = _createForOfIteratorHelper(block.instructions),
            _step442;
          try {
            for (_iterator442.s(); !(_step442 = _iterator442.n()).done; ) {
              var instr = _step442.value;
              var _iterator443 = _createForOfIteratorHelper(
                  eachInstructionLValue(instr)
                ),
                _step443;
              try {
                for (_iterator443.s(); !(_step443 = _iterator443.n()).done; ) {
                  var operand = _step443.value;
                  operand.identifier.type = unifier.get(
                    operand.identifier.type
                  );
                }
              } catch (err) {
                _iterator443.e(err);
              } finally {
                _iterator443.f();
              }
              var _iterator444 = _createForOfIteratorHelper(
                  eachInstructionOperand(instr)
                ),
                _step444;
              try {
                for (_iterator444.s(); !(_step444 = _iterator444.n()).done; ) {
                  var place = _step444.value;
                  place.identifier.type = unifier.get(place.identifier.type);
                }
              } catch (err) {
                _iterator444.e(err);
              } finally {
                _iterator444.f();
              }
              var lvalue = instr.lvalue,
                value = instr.value;
              lvalue.identifier.type = unifier.get(lvalue.identifier.type);
              if (
                value.kind === "FunctionExpression" ||
                value.kind === "ObjectMethod"
              ) {
                apply(value.loweredFunc.func, unifier);
              }
            }
          } catch (err) {
            _iterator442.e(err);
          } finally {
            _iterator442.f();
          }
        }
      } catch (err) {
        _iterator440.e(err);
      } finally {
        _iterator440.f();
      }
      func.returnType = unifier.get(func.returnType);
    }
    function equation(left, right) {
      return { left: left, right: right };
    }
    function generate(func) {
      var _func$params,
        props,
        ref,
        names,
        returnTypes,
        _iterator445,
        _step445,
        _step445$value,
        _,
        block,
        _iterator446,
        _step446,
        phi,
        _iterator447,
        _step447,
        instr,
        terminal;
      return _regeneratorRuntime().wrap(
        function generate$(_context10) {
          while (1)
            switch ((_context10.prev = _context10.next)) {
              case 0:
                if (!(func.fnType === "Component")) {
                  _context10.next = 8;
                  break;
                }
                (_func$params = _slicedToArray(func.params, 2)),
                  (props = _func$params[0]),
                  (ref = _func$params[1]);
                if (!(props && props.kind === "Identifier")) {
                  _context10.next = 5;
                  break;
                }
                _context10.next = 5;
                return equation(props.identifier.type, {
                  kind: "Object",
                  shapeId: BuiltInPropsId
                });
              case 5:
                if (!(ref && ref.kind === "Identifier")) {
                  _context10.next = 8;
                  break;
                }
                _context10.next = 8;
                return equation(ref.identifier.type, {
                  kind: "Object",
                  shapeId: BuiltInUseRefId
                });
              case 8:
                names = new Map();
                returnTypes = [];
                _iterator445 = _createForOfIteratorHelper(func.body.blocks);
                _context10.prev = 11;
                _iterator445.s();
              case 13:
                if ((_step445 = _iterator445.n()).done) {
                  _context10.next = 52;
                  break;
                }
                (_step445$value = _slicedToArray(_step445.value, 2)),
                  (_ = _step445$value[0]),
                  (block = _step445$value[1]);
                _iterator446 = _createForOfIteratorHelper(block.phis);
                _context10.prev = 16;
                _iterator446.s();
              case 18:
                if ((_step446 = _iterator446.n()).done) {
                  _context10.next = 24;
                  break;
                }
                phi = _step446.value;
                _context10.next = 22;
                return equation(phi.place.identifier.type, {
                  kind: "Phi",
                  operands: _toConsumableArray(phi.operands.values()).map(
                    function (id) {
                      return id.identifier.type;
                    }
                  )
                });
              case 22:
                _context10.next = 18;
                break;
              case 24:
                _context10.next = 29;
                break;
              case 26:
                _context10.prev = 26;
                _context10.t0 = _context10["catch"](16);
                _iterator446.e(_context10.t0);
              case 29:
                _context10.prev = 29;
                _iterator446.f();
                return _context10.finish(29);
              case 32:
                _iterator447 = _createForOfIteratorHelper(block.instructions);
                _context10.prev = 33;
                _iterator447.s();
              case 35:
                if ((_step447 = _iterator447.n()).done) {
                  _context10.next = 40;
                  break;
                }
                instr = _step447.value;
                return _context10.delegateYield(
                  generateInstructionTypes(func.env, names, instr),
                  "t1",
                  38
                );
              case 38:
                _context10.next = 35;
                break;
              case 40:
                _context10.next = 45;
                break;
              case 42:
                _context10.prev = 42;
                _context10.t2 = _context10["catch"](33);
                _iterator447.e(_context10.t2);
              case 45:
                _context10.prev = 45;
                _iterator447.f();
                return _context10.finish(45);
              case 48:
                terminal = block.terminal;
                if (terminal.kind === "return") {
                  returnTypes.push(terminal.value.identifier.type);
                }
              case 50:
                _context10.next = 13;
                break;
              case 52:
                _context10.next = 57;
                break;
              case 54:
                _context10.prev = 54;
                _context10.t3 = _context10["catch"](11);
                _iterator445.e(_context10.t3);
              case 57:
                _context10.prev = 57;
                _iterator445.f();
                return _context10.finish(57);
              case 60:
                if (!(returnTypes.length > 1)) {
                  _context10.next = 65;
                  break;
                }
                _context10.next = 63;
                return equation(func.returnType, {
                  kind: "Phi",
                  operands: returnTypes
                });
              case 63:
                _context10.next = 68;
                break;
              case 65:
                if (!(returnTypes.length === 1)) {
                  _context10.next = 68;
                  break;
                }
                _context10.next = 68;
                return equation(func.returnType, returnTypes[0]);
              case 68:
              case "end":
                return _context10.stop();
            }
        },
        _marked10,
        null,
        [
          [11, 54, 57, 60],
          [16, 26, 29, 32],
          [33, 42, 45, 48]
        ]
      );
    }
    function setName(names, id, name) {
      var _a;
      if (
        ((_a = name.name) === null || _a === void 0 ? void 0 : _a.kind) ===
        "named"
      ) {
        names.set(id, name.name.value);
      }
    }
    function getName(names, id) {
      var _a;
      return (_a = names.get(id)) !== null && _a !== void 0 ? _a : "";
    }
    function generateInstructionTypes(env, names, instr) {
      var lvalue,
        value,
        left,
        valueType,
        globalType,
        returnType,
        _returnType,
        _iterator448,
        _step448,
        property,
        _returnType2,
        pattern,
        i,
        item,
        propertyName,
        _iterator449,
        _step449,
        _property11;
      return _regeneratorRuntime().wrap(
        function generateInstructionTypes$(_context11) {
          while (1)
            switch ((_context11.prev = _context11.next)) {
              case 0:
                (lvalue = instr.lvalue), (value = instr.value);
                left = lvalue.identifier.type;
                _context11.t0 = value.kind;
                _context11.next =
                  _context11.t0 === "TemplateLiteral"
                    ? 5
                    : _context11.t0 === "JSXText"
                      ? 5
                      : _context11.t0 === "Primitive"
                        ? 5
                        : _context11.t0 === "UnaryExpression"
                          ? 8
                          : _context11.t0 === "LoadLocal"
                            ? 11
                            : _context11.t0 === "DeclareContext"
                              ? 15
                              : _context11.t0 === "StoreContext"
                                ? 15
                                : _context11.t0 === "LoadContext"
                                  ? 15
                                  : _context11.t0 === "StoreLocal"
                                    ? 16
                                    : _context11.t0 === "StoreGlobal"
                                      ? 31
                                      : _context11.t0 === "BinaryExpression"
                                        ? 34
                                        : _context11.t0 === "PostfixUpdate"
                                          ? 42
                                          : _context11.t0 === "PrefixUpdate"
                                            ? 42
                                            : _context11.t0 === "LoadGlobal"
                                              ? 49
                                              : _context11.t0 ===
                                                  "CallExpression"
                                                ? 54
                                                : _context11.t0 ===
                                                    "TaggedTemplateExpression"
                                                  ? 60
                                                  : _context11.t0 ===
                                                      "ObjectExpression"
                                                    ? 66
                                                    : _context11.t0 ===
                                                        "ArrayExpression"
                                                      ? 87
                                                      : _context11.t0 ===
                                                          "PropertyLoad"
                                                        ? 90
                                                        : _context11.t0 ===
                                                            "ComputedLoad"
                                                          ? 93
                                                          : _context11.t0 ===
                                                              "MethodCall"
                                                            ? 96
                                                            : _context11.t0 ===
                                                                "Destructure"
                                                              ? 102
                                                              : _context11.t0 ===
                                                                  "TypeCastExpression"
                                                                ? 139
                                                                : _context11.t0 ===
                                                                    "PropertyDelete"
                                                                  ? 149
                                                                  : _context11.t0 ===
                                                                      "ComputedDelete"
                                                                    ? 149
                                                                    : _context11.t0 ===
                                                                        "FunctionExpression"
                                                                      ? 152
                                                                      : _context11.t0 ===
                                                                          "NextPropertyOf"
                                                                        ? 156
                                                                        : _context11.t0 ===
                                                                            "ObjectMethod"
                                                                          ? 159
                                                                          : _context11.t0 ===
                                                                              "JsxExpression"
                                                                            ? 163
                                                                            : _context11.t0 ===
                                                                                "JsxFragment"
                                                                              ? 163
                                                                              : _context11.t0 ===
                                                                                  "PropertyStore"
                                                                                ? 166
                                                                                : _context11.t0 ===
                                                                                    "DeclareLocal"
                                                                                  ? 166
                                                                                  : _context11.t0 ===
                                                                                      "NewExpression"
                                                                                    ? 166
                                                                                    : _context11.t0 ===
                                                                                        "RegExpLiteral"
                                                                                      ? 166
                                                                                      : _context11.t0 ===
                                                                                          "MetaProperty"
                                                                                        ? 166
                                                                                        : _context11.t0 ===
                                                                                            "ComputedStore"
                                                                                          ? 166
                                                                                          : _context11.t0 ===
                                                                                              "Await"
                                                                                            ? 166
                                                                                            : _context11.t0 ===
                                                                                                "GetIterator"
                                                                                              ? 166
                                                                                              : _context11.t0 ===
                                                                                                  "IteratorNext"
                                                                                                ? 166
                                                                                                : _context11.t0 ===
                                                                                                    "UnsupportedNode"
                                                                                                  ? 166
                                                                                                  : _context11.t0 ===
                                                                                                      "Debugger"
                                                                                                    ? 166
                                                                                                    : _context11.t0 ===
                                                                                                        "FinishMemoize"
                                                                                                      ? 166
                                                                                                      : _context11.t0 ===
                                                                                                          "StartMemoize"
                                                                                                        ? 166
                                                                                                        : 167;
                break;
              case 5:
                _context11.next = 7;
                return equation(left, { kind: "Primitive" });
              case 7:
                return _context11.abrupt("break", 168);
              case 8:
                _context11.next = 10;
                return equation(left, { kind: "Primitive" });
              case 10:
                return _context11.abrupt("break", 168);
              case 11:
                setName(names, lvalue.identifier.id, value.place.identifier);
                _context11.next = 14;
                return equation(left, value.place.identifier.type);
              case 14:
                return _context11.abrupt("break", 168);
              case 15:
                return _context11.abrupt("break", 168);
              case 16:
                if (!env.config.enableUseTypeAnnotations) {
                  _context11.next = 26;
                  break;
                }
                _context11.next = 19;
                return equation(
                  value.lvalue.place.identifier.type,
                  value.value.identifier.type
                );
              case 19:
                valueType =
                  value.type === null ? makeType() : lowerType(value.type);
                _context11.next = 22;
                return equation(valueType, value.lvalue.place.identifier.type);
              case 22:
                _context11.next = 24;
                return equation(left, valueType);
              case 24:
                _context11.next = 30;
                break;
              case 26:
                _context11.next = 28;
                return equation(left, value.value.identifier.type);
              case 28:
                _context11.next = 30;
                return equation(
                  value.lvalue.place.identifier.type,
                  value.value.identifier.type
                );
              case 30:
                return _context11.abrupt("break", 168);
              case 31:
                _context11.next = 33;
                return equation(left, value.value.identifier.type);
              case 33:
                return _context11.abrupt("break", 168);
              case 34:
                if (!isPrimitiveBinaryOp(value.operator)) {
                  _context11.next = 39;
                  break;
                }
                _context11.next = 37;
                return equation(value.left.identifier.type, {
                  kind: "Primitive"
                });
              case 37:
                _context11.next = 39;
                return equation(value.right.identifier.type, {
                  kind: "Primitive"
                });
              case 39:
                _context11.next = 41;
                return equation(left, { kind: "Primitive" });
              case 41:
                return _context11.abrupt("break", 168);
              case 42:
                _context11.next = 44;
                return equation(value.value.identifier.type, {
                  kind: "Primitive"
                });
              case 44:
                _context11.next = 46;
                return equation(value.lvalue.identifier.type, {
                  kind: "Primitive"
                });
              case 46:
                _context11.next = 48;
                return equation(left, { kind: "Primitive" });
              case 48:
                return _context11.abrupt("break", 168);
              case 49:
                globalType = env.getGlobalDeclaration(value.binding, value.loc);
                if (!globalType) {
                  _context11.next = 53;
                  break;
                }
                _context11.next = 53;
                return equation(left, globalType);
              case 53:
                return _context11.abrupt("break", 168);
              case 54:
                returnType = makeType();
                _context11.next = 57;
                return equation(value.callee.identifier.type, {
                  kind: "Function",
                  shapeId: null,
                  return: returnType
                });
              case 57:
                _context11.next = 59;
                return equation(left, returnType);
              case 59:
                return _context11.abrupt("break", 168);
              case 60:
                _returnType = makeType();
                _context11.next = 63;
                return equation(value.tag.identifier.type, {
                  kind: "Function",
                  shapeId: null,
                  return: _returnType
                });
              case 63:
                _context11.next = 65;
                return equation(left, _returnType);
              case 65:
                return _context11.abrupt("break", 168);
              case 66:
                _iterator448 = _createForOfIteratorHelper(value.properties);
                _context11.prev = 67;
                _iterator448.s();
              case 69:
                if ((_step448 = _iterator448.n()).done) {
                  _context11.next = 76;
                  break;
                }
                property = _step448.value;
                if (
                  !(
                    property.kind === "ObjectProperty" &&
                    property.key.kind === "computed"
                  )
                ) {
                  _context11.next = 74;
                  break;
                }
                _context11.next = 74;
                return equation(property.key.name.identifier.type, {
                  kind: "Primitive"
                });
              case 74:
                _context11.next = 69;
                break;
              case 76:
                _context11.next = 81;
                break;
              case 78:
                _context11.prev = 78;
                _context11.t1 = _context11["catch"](67);
                _iterator448.e(_context11.t1);
              case 81:
                _context11.prev = 81;
                _iterator448.f();
                return _context11.finish(81);
              case 84:
                _context11.next = 86;
                return equation(left, {
                  kind: "Object",
                  shapeId: BuiltInObjectId
                });
              case 86:
                return _context11.abrupt("break", 168);
              case 87:
                _context11.next = 89;
                return equation(left, {
                  kind: "Object",
                  shapeId: BuiltInArrayId
                });
              case 89:
                return _context11.abrupt("break", 168);
              case 90:
                _context11.next = 92;
                return equation(left, {
                  kind: "Property",
                  objectType: value.object.identifier.type,
                  objectName: getName(names, value.object.identifier.id),
                  propertyName: { kind: "literal", value: value.property }
                });
              case 92:
                return _context11.abrupt("break", 168);
              case 93:
                _context11.next = 95;
                return equation(left, {
                  kind: "Property",
                  objectType: value.object.identifier.type,
                  objectName: getName(names, value.object.identifier.id),
                  propertyName: {
                    kind: "computed",
                    value: value.property.identifier.type
                  }
                });
              case 95:
                return _context11.abrupt("break", 168);
              case 96:
                _returnType2 = makeType();
                _context11.next = 99;
                return equation(value.property.identifier.type, {
                  kind: "Function",
                  return: _returnType2,
                  shapeId: null
                });
              case 99:
                _context11.next = 101;
                return equation(left, _returnType2);
              case 101:
                return _context11.abrupt("break", 168);
              case 102:
                pattern = value.lvalue.pattern;
                if (!(pattern.kind === "ArrayPattern")) {
                  _context11.next = 119;
                  break;
                }
                i = 0;
              case 105:
                if (!(i < pattern.items.length)) {
                  _context11.next = 117;
                  break;
                }
                item = pattern.items[i];
                if (!(item.kind === "Identifier")) {
                  _context11.next = 113;
                  break;
                }
                propertyName = String(i);
                _context11.next = 111;
                return equation(item.identifier.type, {
                  kind: "Property",
                  objectType: value.value.identifier.type,
                  objectName: getName(names, value.value.identifier.id),
                  propertyName: {
                    kind: "literal",
                    value: makePropertyLiteral(propertyName)
                  }
                });
              case 111:
                _context11.next = 114;
                break;
              case 113:
                return _context11.abrupt("break", 117);
              case 114:
                i++;
                _context11.next = 105;
                break;
              case 117:
                _context11.next = 138;
                break;
              case 119:
                _iterator449 = _createForOfIteratorHelper(pattern.properties);
                _context11.prev = 120;
                _iterator449.s();
              case 122:
                if ((_step449 = _iterator449.n()).done) {
                  _context11.next = 130;
                  break;
                }
                _property11 = _step449.value;
                if (!(_property11.kind === "ObjectProperty")) {
                  _context11.next = 128;
                  break;
                }
                if (
                  !(
                    _property11.key.kind === "identifier" ||
                    _property11.key.kind === "string"
                  )
                ) {
                  _context11.next = 128;
                  break;
                }
                _context11.next = 128;
                return equation(_property11.place.identifier.type, {
                  kind: "Property",
                  objectType: value.value.identifier.type,
                  objectName: getName(names, value.value.identifier.id),
                  propertyName: {
                    kind: "literal",
                    value: makePropertyLiteral(_property11.key.name)
                  }
                });
              case 128:
                _context11.next = 122;
                break;
              case 130:
                _context11.next = 135;
                break;
              case 132:
                _context11.prev = 132;
                _context11.t2 = _context11["catch"](120);
                _iterator449.e(_context11.t2);
              case 135:
                _context11.prev = 135;
                _iterator449.f();
                return _context11.finish(135);
              case 138:
                return _context11.abrupt("break", 168);
              case 139:
                if (!env.config.enableUseTypeAnnotations) {
                  _context11.next = 146;
                  break;
                }
                _context11.next = 142;
                return equation(value.type, value.value.identifier.type);
              case 142:
                _context11.next = 144;
                return equation(left, value.type);
              case 144:
                _context11.next = 148;
                break;
              case 146:
                _context11.next = 148;
                return equation(left, value.value.identifier.type);
              case 148:
                return _context11.abrupt("break", 168);
              case 149:
                _context11.next = 151;
                return equation(left, { kind: "Primitive" });
              case 151:
                return _context11.abrupt("break", 168);
              case 152:
                return _context11.delegateYield(
                  generate(value.loweredFunc.func),
                  "t3",
                  153
                );
              case 153:
                _context11.next = 155;
                return equation(left, {
                  kind: "Function",
                  shapeId: BuiltInFunctionId,
                  return: value.loweredFunc.func.returnType
                });
              case 155:
                return _context11.abrupt("break", 168);
              case 156:
                _context11.next = 158;
                return equation(left, { kind: "Primitive" });
              case 158:
                return _context11.abrupt("break", 168);
              case 159:
                return _context11.delegateYield(
                  generate(value.loweredFunc.func),
                  "t4",
                  160
                );
              case 160:
                _context11.next = 162;
                return equation(left, { kind: "ObjectMethod" });
              case 162:
                return _context11.abrupt("break", 168);
              case 163:
                _context11.next = 165;
                return equation(left, {
                  kind: "Object",
                  shapeId: BuiltInJsxId
                });
              case 165:
                return _context11.abrupt("break", 168);
              case 166:
                return _context11.abrupt("break", 168);
              case 167:
                assertExhaustive$1(
                  value,
                  "Unhandled instruction value kind: ".concat(value.kind)
                );
              case 168:
              case "end":
                return _context11.stop();
            }
        },
        _marked11,
        null,
        [
          [67, 78, 81, 84],
          [120, 132, 135, 138]
        ]
      );
    }
    var Unifier = /*#__PURE__*/ (function () {
      function Unifier(env) {
        _classCallCheck(this, Unifier);
        this.substitutions = new Map();
        this.env = env;
      }
      return _createClass(Unifier, [
        {
          key: "unify",
          value: function unify(tA, tB) {
            if (tB.kind === "Property") {
              if (
                this.env.config.enableTreatRefLikeIdentifiersAsRefs &&
                isRefLikeName(tB)
              ) {
                this.unify(tB.objectType, {
                  kind: "Object",
                  shapeId: BuiltInUseRefId
                });
                this.unify(tA, { kind: "Object", shapeId: BuiltInRefValueId });
                return;
              }
              var objectType = this.get(tB.objectType);
              var propertyType =
                tB.propertyName.kind === "literal"
                  ? this.env.getPropertyType(objectType, tB.propertyName.value)
                  : this.env.getFallthroughPropertyType(
                      objectType,
                      tB.propertyName.value
                    );
              if (propertyType !== null) {
                this.unify(tA, propertyType);
              }
              return;
            }
            if (typeEquals(tA, tB)) {
              return;
            }
            if (tA.kind === "Type") {
              this.bindVariableTo(tA, tB);
              return;
            }
            if (tB.kind === "Type") {
              this.bindVariableTo(tB, tA);
              return;
            }
            if (tB.kind === "Function" && tA.kind === "Function") {
              this.unify(tA["return"], tB["return"]);
              return;
            }
          }
        },
        {
          key: "bindVariableTo",
          value: function bindVariableTo(v, type) {
            if (type.kind === "Poly") {
              return;
            }
            if (this.substitutions.has(v.id)) {
              this.unify(this.substitutions.get(v.id), type);
              return;
            }
            if (type.kind === "Type" && this.substitutions.has(type.id)) {
              this.unify(v, this.substitutions.get(type.id));
              return;
            }
            if (type.kind === "Phi") {
              CompilerError.invariant(type.operands.length > 0, {
                reason: "there should be at least one operand",
                description: null,
                loc: null,
                suggestions: null
              });
              var candidateType = null;
              var _iterator450 = _createForOfIteratorHelper(type.operands),
                _step450;
              try {
                for (_iterator450.s(); !(_step450 = _iterator450.n()).done; ) {
                  var operand = _step450.value;
                  var resolved = this.get(operand);
                  if (candidateType === null) {
                    candidateType = resolved;
                  } else if (!typeEquals(resolved, candidateType)) {
                    var unionType = tryUnionTypes(resolved, candidateType);
                    if (unionType === null) {
                      candidateType = null;
                      break;
                    } else {
                      candidateType = unionType;
                    }
                  }
                }
              } catch (err) {
                _iterator450.e(err);
              } finally {
                _iterator450.f();
              }
              if (candidateType !== null) {
                this.unify(v, candidateType);
                return;
              }
            }
            if (this.occursCheck(v, type)) {
              var resolvedType = this.tryResolveType(v, type);
              if (resolvedType !== null) {
                this.substitutions.set(v.id, resolvedType);
                return;
              }
              throw new Error("cycle detected");
            }
            this.substitutions.set(v.id, type);
          }
        },
        {
          key: "tryResolveType",
          value: function tryResolveType(v, type) {
            switch (type.kind) {
              case "Phi": {
                var operands = [];
                var _iterator451 = _createForOfIteratorHelper(type.operands),
                  _step451;
                try {
                  for (
                    _iterator451.s();
                    !(_step451 = _iterator451.n()).done;

                  ) {
                    var operand = _step451.value;
                    if (operand.kind === "Type" && operand.id === v.id) {
                      continue;
                    }
                    var resolved = this.tryResolveType(v, operand);
                    if (resolved === null) {
                      return null;
                    }
                    operands.push(resolved);
                  }
                } catch (err) {
                  _iterator451.e(err);
                } finally {
                  _iterator451.f();
                }
                return { kind: "Phi", operands: operands };
              }
              case "Type": {
                var substitution = this.get(type);
                if (substitution !== type) {
                  var _resolved = this.tryResolveType(v, substitution);
                  if (_resolved !== null) {
                    this.substitutions.set(type.id, _resolved);
                  }
                  return _resolved;
                }
                return type;
              }
              case "Property": {
                var objectType = this.tryResolveType(
                  v,
                  this.get(type.objectType)
                );
                if (objectType === null) {
                  return null;
                }
                return {
                  kind: "Property",
                  objectName: type.objectName,
                  objectType: objectType,
                  propertyName: type.propertyName
                };
              }
              case "Function": {
                var returnType = this.tryResolveType(
                  v,
                  this.get(type["return"])
                );
                if (returnType === null) {
                  return null;
                }
                return {
                  kind: "Function",
                  return: returnType,
                  shapeId: type.shapeId
                };
              }
              case "ObjectMethod":
              case "Object":
              case "Primitive":
              case "Poly": {
                return type;
              }
              default: {
                assertExhaustive$1(
                  type,
                  "Unexpected type kind '".concat(type.kind, "'")
                );
              }
            }
          }
        },
        {
          key: "occursCheck",
          value: function occursCheck(v, type) {
            var _this26 = this;
            if (typeEquals(v, type)) return true;
            if (type.kind === "Type" && this.substitutions.has(type.id)) {
              return this.occursCheck(v, this.substitutions.get(type.id));
            }
            if (type.kind === "Phi") {
              return type.operands.some(function (o) {
                return _this26.occursCheck(v, o);
              });
            }
            if (type.kind === "Function") {
              return this.occursCheck(v, type["return"]);
            }
            return false;
          }
        },
        {
          key: "get",
          value: function get(type) {
            var _this27 = this;
            if (type.kind === "Type") {
              if (this.substitutions.has(type.id)) {
                return this.get(this.substitutions.get(type.id));
              }
            }
            if (type.kind === "Phi") {
              return {
                kind: "Phi",
                operands: type.operands.map(function (o) {
                  return _this27.get(o);
                })
              };
            }
            return type;
          }
        }
      ]);
    })();
    var RefLikeNameRE = /^(?:[a-zA-Z$_][a-zA-Z$_0-9]*)Ref$|^ref$/;
    function isRefLikeName(t) {
      return (
        t.propertyName.kind === "literal" &&
        RefLikeNameRE.test(t.objectName) &&
        t.propertyName.value === "current"
      );
    }
    function tryUnionTypes(ty1, ty2) {
      var readonlyType;
      var otherType;
      if (ty1.kind === "Object" && ty1.shapeId === BuiltInMixedReadonlyId) {
        readonlyType = ty1;
        otherType = ty2;
      } else if (
        ty2.kind === "Object" &&
        ty2.shapeId === BuiltInMixedReadonlyId
      ) {
        readonlyType = ty2;
        otherType = ty1;
      } else {
        return null;
      }
      if (otherType.kind === "Primitive") {
        return readonlyType;
      } else if (
        otherType.kind === "Object" &&
        otherType.shapeId === BuiltInArrayId
      ) {
        return otherType;
      }
      return null;
    }
    function validateContextVariableLValues(fn) {
      var identifierKinds = new Map();
      validateContextVariableLValuesImpl(fn, identifierKinds);
    }
    function validateContextVariableLValuesImpl(fn, identifierKinds) {
      var _iterator452 = _createForOfIteratorHelper(fn.body.blocks),
        _step452;
      try {
        for (_iterator452.s(); !(_step452 = _iterator452.n()).done; ) {
          var _step452$value = _slicedToArray(_step452.value, 2),
            block = _step452$value[1];
          var _iterator453 = _createForOfIteratorHelper(block.instructions),
            _step453;
          try {
            for (_iterator453.s(); !(_step453 = _iterator453.n()).done; ) {
              var instr = _step453.value;
              var value = instr.value;
              switch (value.kind) {
                case "DeclareContext":
                case "StoreContext": {
                  visit(identifierKinds, value.lvalue.place, "context");
                  break;
                }
                case "LoadContext": {
                  visit(identifierKinds, value.place, "context");
                  break;
                }
                case "StoreLocal":
                case "DeclareLocal": {
                  visit(identifierKinds, value.lvalue.place, "local");
                  break;
                }
                case "LoadLocal": {
                  visit(identifierKinds, value.place, "local");
                  break;
                }
                case "PostfixUpdate":
                case "PrefixUpdate": {
                  visit(identifierKinds, value.lvalue, "local");
                  break;
                }
                case "Destructure": {
                  var _iterator454 = _createForOfIteratorHelper(
                      eachPatternOperand(value.lvalue.pattern)
                    ),
                    _step454;
                  try {
                    for (
                      _iterator454.s();
                      !(_step454 = _iterator454.n()).done;

                    ) {
                      var lvalue = _step454.value;
                      visit(identifierKinds, lvalue, "destructure");
                    }
                  } catch (err) {
                    _iterator454.e(err);
                  } finally {
                    _iterator454.f();
                  }
                  break;
                }
                case "ObjectMethod":
                case "FunctionExpression": {
                  validateContextVariableLValuesImpl(
                    value.loweredFunc.func,
                    identifierKinds
                  );
                  break;
                }
                default: {
                  var _iterator455 = _createForOfIteratorHelper(
                      eachInstructionValueLValue(value)
                    ),
                    _step455;
                  try {
                    for (
                      _iterator455.s();
                      !(_step455 = _iterator455.n()).done;

                    ) {
                      var _ = _step455.value;
                      CompilerError.throwTodo({
                        reason:
                          "ValidateContextVariableLValues: unhandled instruction variant",
                        loc: value.loc,
                        description: "Handle '".concat(value.kind, " lvalues"),
                        suggestions: null
                      });
                    }
                  } catch (err) {
                    _iterator455.e(err);
                  } finally {
                    _iterator455.f();
                  }
                }
              }
            }
          } catch (err) {
            _iterator453.e(err);
          } finally {
            _iterator453.f();
          }
        }
      } catch (err) {
        _iterator452.e(err);
      } finally {
        _iterator452.f();
      }
    }
    function visit(identifiers, place, kind) {
      var prev = identifiers.get(place.identifier.id);
      if (prev !== undefined) {
        var wasContext = prev.kind === "context";
        var isContext = kind === "context";
        if (wasContext !== isContext) {
          if (prev.kind === "destructure" || kind === "destructure") {
            CompilerError.throwTodo({
              reason: "Support destructuring of context variables",
              loc: kind === "destructure" ? place.loc : prev.place.loc,
              description: null,
              suggestions: null
            });
          }
          CompilerError.invariant(false, {
            reason:
              "Expected all references to a variable to be consistently local or context references",
            loc: place.loc,
            description: "Identifier "
              .concat(printPlace(place), " is referenced as a ")
              .concat(kind, " variable, but was previously referenced as a ")
              .concat(prev, " variable"),
            suggestions: null
          });
        }
      }
      identifiers.set(place.identifier.id, { place: place, kind: kind });
    }
    function computeUnconditionalBlocks(fn) {
      var unconditionalBlocks = new Set();
      var dominators = computePostDominatorTree(fn, {
        includeThrowsAsExitNode: false
      });
      var exit = dominators.exit;
      var current = fn.body.entry;
      while (current !== null && current !== exit) {
        CompilerError.invariant(!unconditionalBlocks.has(current), {
          reason:
            "Internal error: non-terminating loop in ComputeUnconditionalBlocks",
          loc: null,
          suggestions: null
        });
        unconditionalBlocks.add(current);
        current = dominators.get(current);
      }
      return unconditionalBlocks;
    }
    var Kind;
    (function (Kind) {
      Kind["Error"] = "Error";
      Kind["KnownHook"] = "KnownHook";
      Kind["PotentialHook"] = "PotentialHook";
      Kind["Global"] = "Global";
      Kind["Local"] = "Local";
    })(Kind || (Kind = {}));
    function joinKinds(a, b) {
      if (a === Kind.Error || b === Kind.Error) {
        return Kind.Error;
      } else if (a === Kind.KnownHook || b === Kind.KnownHook) {
        return Kind.KnownHook;
      } else if (a === Kind.PotentialHook || b === Kind.PotentialHook) {
        return Kind.PotentialHook;
      } else if (a === Kind.Global || b === Kind.Global) {
        return Kind.Global;
      } else {
        return Kind.Local;
      }
    }
    function validateHooksUsage(fn) {
      var unconditionalBlocks = computeUnconditionalBlocks(fn);
      var errors = new CompilerError();
      var errorsByPlace = new Map();
      function recordError(loc, errorDetail) {
        if (_typeof(loc) === "symbol") {
          errors.pushErrorDetail(errorDetail);
        } else {
          errorsByPlace.set(loc, errorDetail);
        }
      }
      function recordConditionalHookError(place) {
        setKind(place, Kind.Error);
        var reason =
          "Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning)";
        var previousError =
          _typeof(place.loc) !== "symbol"
            ? errorsByPlace.get(place.loc)
            : undefined;
        if (previousError === undefined || previousError.reason !== reason) {
          recordError(
            place.loc,
            new CompilerErrorDetail({
              description: null,
              reason: reason,
              loc: place.loc,
              severity: ErrorSeverity.InvalidReact,
              suggestions: null
            })
          );
        }
      }
      function recordInvalidHookUsageError(place) {
        var previousError =
          _typeof(place.loc) !== "symbol"
            ? errorsByPlace.get(place.loc)
            : undefined;
        if (previousError === undefined) {
          recordError(
            place.loc,
            new CompilerErrorDetail({
              description: null,
              reason:
                "Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values",
              loc: place.loc,
              severity: ErrorSeverity.InvalidReact,
              suggestions: null
            })
          );
        }
      }
      function recordDynamicHookUsageError(place) {
        var previousError =
          _typeof(place.loc) !== "symbol"
            ? errorsByPlace.get(place.loc)
            : undefined;
        if (previousError === undefined) {
          recordError(
            place.loc,
            new CompilerErrorDetail({
              description: null,
              reason:
                "Hooks must be the same function on every render, but this value may change over time to a different function. See https://react.dev/reference/rules/react-calls-components-and-hooks#dont-dynamically-use-hooks",
              loc: place.loc,
              severity: ErrorSeverity.InvalidReact,
              suggestions: null
            })
          );
        }
      }
      var valueKinds = new Map();
      function getKindForPlace(place) {
        var knownKind = valueKinds.get(place.identifier.id);
        if (
          place.identifier.name !== null &&
          isHookName$2(place.identifier.name.value)
        ) {
          return joinKinds(
            knownKind !== null && knownKind !== void 0 ? knownKind : Kind.Local,
            Kind.PotentialHook
          );
        } else {
          return knownKind !== null && knownKind !== void 0
            ? knownKind
            : Kind.Local;
        }
      }
      function visitPlace(place) {
        var kind = valueKinds.get(place.identifier.id);
        if (kind === Kind.KnownHook) {
          recordInvalidHookUsageError(place);
        }
      }
      function setKind(place, kind) {
        valueKinds.set(place.identifier.id, kind);
      }
      var _iterator456 = _createForOfIteratorHelper(fn.params),
        _step456;
      try {
        for (_iterator456.s(); !(_step456 = _iterator456.n()).done; ) {
          var param = _step456.value;
          var place = param.kind === "Identifier" ? param : param.place;
          var kind = getKindForPlace(place);
          setKind(place, kind);
        }
      } catch (err) {
        _iterator456.e(err);
      } finally {
        _iterator456.f();
      }
      var _iterator457 = _createForOfIteratorHelper(fn.body.blocks),
        _step457;
      try {
        for (_iterator457.s(); !(_step457 = _iterator457.n()).done; ) {
          var _step457$value = _slicedToArray(_step457.value, 2),
            block = _step457$value[1];
          var _iterator459 = _createForOfIteratorHelper(block.phis),
            _step459;
          try {
            for (_iterator459.s(); !(_step459 = _iterator459.n()).done; ) {
              var phi = _step459.value;
              var _kind2 =
                phi.place.identifier.name !== null &&
                isHookName$2(phi.place.identifier.name.value)
                  ? Kind.PotentialHook
                  : Kind.Local;
              var _iterator462 = _createForOfIteratorHelper(phi.operands),
                _step462;
              try {
                for (_iterator462.s(); !(_step462 = _iterator462.n()).done; ) {
                  var _step462$value = _slicedToArray(_step462.value, 2),
                    operand = _step462$value[1];
                  var operandKind = valueKinds.get(operand.identifier.id);
                  if (operandKind !== undefined) {
                    _kind2 = joinKinds(_kind2, operandKind);
                  }
                }
              } catch (err) {
                _iterator462.e(err);
              } finally {
                _iterator462.f();
              }
              valueKinds.set(phi.place.identifier.id, _kind2);
            }
          } catch (err) {
            _iterator459.e(err);
          } finally {
            _iterator459.f();
          }
          var _iterator460 = _createForOfIteratorHelper(block.instructions),
            _step460;
          try {
            for (_iterator460.s(); !(_step460 = _iterator460.n()).done; ) {
              var instr = _step460.value;
              switch (instr.value.kind) {
                case "LoadGlobal": {
                  if (getHookKind(fn.env, instr.lvalue.identifier) != null) {
                    setKind(instr.lvalue, Kind.KnownHook);
                  } else {
                    setKind(instr.lvalue, Kind.Global);
                  }
                  break;
                }
                case "LoadContext":
                case "LoadLocal": {
                  visitPlace(instr.value.place);
                  var _kind3 = getKindForPlace(instr.value.place);
                  setKind(instr.lvalue, _kind3);
                  break;
                }
                case "StoreLocal":
                case "StoreContext": {
                  visitPlace(instr.value.value);
                  var _kind4 = joinKinds(
                    getKindForPlace(instr.value.value),
                    getKindForPlace(instr.value.lvalue.place)
                  );
                  setKind(instr.value.lvalue.place, _kind4);
                  setKind(instr.lvalue, _kind4);
                  break;
                }
                case "ComputedLoad": {
                  visitPlace(instr.value.object);
                  var _kind5 = getKindForPlace(instr.value.object);
                  setKind(
                    instr.lvalue,
                    joinKinds(getKindForPlace(instr.lvalue), _kind5)
                  );
                  break;
                }
                case "PropertyLoad": {
                  var objectKind = getKindForPlace(instr.value.object);
                  var isHookProperty =
                    typeof instr.value.property === "string" &&
                    isHookName$2(instr.value.property);
                  var _kind6 = void 0;
                  switch (objectKind) {
                    case Kind.Error: {
                      _kind6 = Kind.Error;
                      break;
                    }
                    case Kind.KnownHook: {
                      _kind6 = isHookProperty ? Kind.KnownHook : Kind.Local;
                      break;
                    }
                    case Kind.PotentialHook: {
                      _kind6 = Kind.PotentialHook;
                      break;
                    }
                    case Kind.Global: {
                      _kind6 = isHookProperty ? Kind.KnownHook : Kind.Global;
                      break;
                    }
                    case Kind.Local: {
                      _kind6 = isHookProperty ? Kind.PotentialHook : Kind.Local;
                      break;
                    }
                    default: {
                      assertExhaustive$1(
                        objectKind,
                        "Unexpected kind `".concat(objectKind, "`")
                      );
                    }
                  }
                  setKind(instr.lvalue, _kind6);
                  break;
                }
                case "CallExpression": {
                  var calleeKind = getKindForPlace(instr.value.callee);
                  var isHookCallee =
                    calleeKind === Kind.KnownHook ||
                    calleeKind === Kind.PotentialHook;
                  if (isHookCallee && !unconditionalBlocks.has(block.id)) {
                    recordConditionalHookError(instr.value.callee);
                  } else if (calleeKind === Kind.PotentialHook) {
                    recordDynamicHookUsageError(instr.value.callee);
                  }
                  var _iterator463 = _createForOfIteratorHelper(
                      eachInstructionOperand(instr)
                    ),
                    _step463;
                  try {
                    for (
                      _iterator463.s();
                      !(_step463 = _iterator463.n()).done;

                    ) {
                      var _operand33 = _step463.value;
                      if (_operand33 === instr.value.callee) {
                        continue;
                      }
                      visitPlace(_operand33);
                    }
                  } catch (err) {
                    _iterator463.e(err);
                  } finally {
                    _iterator463.f();
                  }
                  break;
                }
                case "MethodCall": {
                  var _calleeKind = getKindForPlace(instr.value.property);
                  var _isHookCallee =
                    _calleeKind === Kind.KnownHook ||
                    _calleeKind === Kind.PotentialHook;
                  if (_isHookCallee && !unconditionalBlocks.has(block.id)) {
                    recordConditionalHookError(instr.value.property);
                  } else if (_calleeKind === Kind.PotentialHook) {
                    recordDynamicHookUsageError(instr.value.property);
                  }
                  var _iterator464 = _createForOfIteratorHelper(
                      eachInstructionOperand(instr)
                    ),
                    _step464;
                  try {
                    for (
                      _iterator464.s();
                      !(_step464 = _iterator464.n()).done;

                    ) {
                      var _operand34 = _step464.value;
                      if (_operand34 === instr.value.property) {
                        continue;
                      }
                      visitPlace(_operand34);
                    }
                  } catch (err) {
                    _iterator464.e(err);
                  } finally {
                    _iterator464.f();
                  }
                  break;
                }
                case "Destructure": {
                  visitPlace(instr.value.value);
                  var _objectKind = getKindForPlace(instr.value.value);
                  var _iterator465 = _createForOfIteratorHelper(
                      eachInstructionLValue(instr)
                    ),
                    _step465;
                  try {
                    for (
                      _iterator465.s();
                      !(_step465 = _iterator465.n()).done;

                    ) {
                      var lvalue = _step465.value;
                      var _isHookProperty =
                        lvalue.identifier.name !== null &&
                        isHookName$2(lvalue.identifier.name.value);
                      var _kind7 = void 0;
                      switch (_objectKind) {
                        case Kind.Error: {
                          _kind7 = Kind.Error;
                          break;
                        }
                        case Kind.KnownHook: {
                          _kind7 = Kind.KnownHook;
                          break;
                        }
                        case Kind.PotentialHook: {
                          _kind7 = Kind.PotentialHook;
                          break;
                        }
                        case Kind.Global: {
                          _kind7 = _isHookProperty
                            ? Kind.KnownHook
                            : Kind.Global;
                          break;
                        }
                        case Kind.Local: {
                          _kind7 = _isHookProperty
                            ? Kind.PotentialHook
                            : Kind.Local;
                          break;
                        }
                        default: {
                          assertExhaustive$1(
                            _objectKind,
                            "Unexpected kind `".concat(_objectKind, "`")
                          );
                        }
                      }
                      setKind(lvalue, _kind7);
                    }
                  } catch (err) {
                    _iterator465.e(err);
                  } finally {
                    _iterator465.f();
                  }
                  break;
                }
                case "ObjectMethod":
                case "FunctionExpression": {
                  visitFunctionExpression(errors, instr.value.loweredFunc.func);
                  break;
                }
                default: {
                  var _iterator466 = _createForOfIteratorHelper(
                      eachInstructionOperand(instr)
                    ),
                    _step466;
                  try {
                    for (
                      _iterator466.s();
                      !(_step466 = _iterator466.n()).done;

                    ) {
                      var _operand35 = _step466.value;
                      visitPlace(_operand35);
                    }
                  } catch (err) {
                    _iterator466.e(err);
                  } finally {
                    _iterator466.f();
                  }
                  var _iterator467 = _createForOfIteratorHelper(
                      eachInstructionLValue(instr)
                    ),
                    _step467;
                  try {
                    for (
                      _iterator467.s();
                      !(_step467 = _iterator467.n()).done;

                    ) {
                      var _lvalue23 = _step467.value;
                      var _kind8 = getKindForPlace(_lvalue23);
                      setKind(_lvalue23, _kind8);
                    }
                  } catch (err) {
                    _iterator467.e(err);
                  } finally {
                    _iterator467.f();
                  }
                }
              }
            }
          } catch (err) {
            _iterator460.e(err);
          } finally {
            _iterator460.f();
          }
          var _iterator461 = _createForOfIteratorHelper(
              eachTerminalOperand(block.terminal)
            ),
            _step461;
          try {
            for (_iterator461.s(); !(_step461 = _iterator461.n()).done; ) {
              var _operand36 = _step461.value;
              visitPlace(_operand36);
            }
          } catch (err) {
            _iterator461.e(err);
          } finally {
            _iterator461.f();
          }
        }
      } catch (err) {
        _iterator457.e(err);
      } finally {
        _iterator457.f();
      }
      var _iterator458 = _createForOfIteratorHelper(errorsByPlace),
        _step458;
      try {
        for (_iterator458.s(); !(_step458 = _iterator458.n()).done; ) {
          var _step458$value = _slicedToArray(_step458.value, 2),
            error = _step458$value[1];
          errors.push(error);
        }
      } catch (err) {
        _iterator458.e(err);
      } finally {
        _iterator458.f();
      }
      if (errors.hasErrors()) {
        throw errors;
      }
    }
    function visitFunctionExpression(errors, fn) {
      var _iterator468 = _createForOfIteratorHelper(fn.body.blocks),
        _step468;
      try {
        for (_iterator468.s(); !(_step468 = _iterator468.n()).done; ) {
          var _step468$value = _slicedToArray(_step468.value, 2),
            block = _step468$value[1];
          var _iterator469 = _createForOfIteratorHelper(block.instructions),
            _step469;
          try {
            for (_iterator469.s(); !(_step469 = _iterator469.n()).done; ) {
              var instr = _step469.value;
              switch (instr.value.kind) {
                case "ObjectMethod":
                case "FunctionExpression": {
                  visitFunctionExpression(errors, instr.value.loweredFunc.func);
                  break;
                }
                case "MethodCall":
                case "CallExpression": {
                  var callee =
                    instr.value.kind === "CallExpression"
                      ? instr.value.callee
                      : instr.value.property;
                  var hookKind = getHookKind(fn.env, callee.identifier);
                  if (hookKind != null) {
                    errors.pushErrorDetail(
                      new CompilerErrorDetail({
                        severity: ErrorSeverity.InvalidReact,
                        reason:
                          "Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning)",
                        loc: callee.loc,
                        description: "Cannot call ".concat(
                          hookKind,
                          " within a function component"
                        ),
                        suggestions: null
                      })
                    );
                  }
                  break;
                }
              }
            }
          } catch (err) {
            _iterator469.e(err);
          } finally {
            _iterator469.f();
          }
        }
      } catch (err) {
        _iterator468.e(err);
      } finally {
        _iterator468.f();
      }
    }
    function validateMemoizedEffectDependencies(fn) {
      var errors = new CompilerError();
      visitReactiveFunction(fn, new Visitor$1(), errors);
      if (errors.hasErrors()) {
        throw errors;
      }
    }
    var Visitor$1 = /*#__PURE__*/ (function (_ReactiveFunctionVisi21) {
      function Visitor() {
        var _this28;
        _classCallCheck(this, Visitor);
        _this28 = _callSuper(this, Visitor, arguments);
        _this28.scopes = new Set();
        return _this28;
      }
      _inherits2(Visitor, _ReactiveFunctionVisi21);
      return _createClass(Visitor, [
        {
          key: "visitScope",
          value: function visitScope(scopeBlock, state) {
            this.traverseScope(scopeBlock, state);
            var areDependenciesMemoized = true;
            var _iterator470 = _createForOfIteratorHelper(
                scopeBlock.scope.dependencies
              ),
              _step470;
            try {
              for (_iterator470.s(); !(_step470 = _iterator470.n()).done; ) {
                var dep = _step470.value;
                if (isUnmemoized$1(dep.identifier, this.scopes)) {
                  areDependenciesMemoized = false;
                  break;
                }
              }
            } catch (err) {
              _iterator470.e(err);
            } finally {
              _iterator470.f();
            }
            if (areDependenciesMemoized) {
              this.scopes.add(scopeBlock.scope.id);
              var _iterator471 = _createForOfIteratorHelper(
                  scopeBlock.scope.merged
                ),
                _step471;
              try {
                for (_iterator471.s(); !(_step471 = _iterator471.n()).done; ) {
                  var id = _step471.value;
                  this.scopes.add(id);
                }
              } catch (err) {
                _iterator471.e(err);
              } finally {
                _iterator471.f();
              }
            }
          }
        },
        {
          key: "visitInstruction",
          value: function visitInstruction(instruction, state) {
            this.traverseInstruction(instruction, state);
            if (
              instruction.value.kind === "CallExpression" &&
              isEffectHook(instruction.value.callee.identifier) &&
              instruction.value.args.length >= 2
            ) {
              var deps = instruction.value.args[1];
              if (
                deps.kind === "Identifier" &&
                (isMutable(instruction, deps) ||
                  isUnmemoized$1(deps.identifier, this.scopes))
              ) {
                state.push({
                  reason:
                    "React Compiler has skipped optimizing this component because the effect dependencies could not be memoized. Unmemoized effect dependencies can trigger an infinite loop or other unexpected behavior",
                  description: null,
                  severity: ErrorSeverity.CannotPreserveMemoization,
                  loc:
                    _typeof(instruction.loc) !== "symbol"
                      ? instruction.loc
                      : null,
                  suggestions: null
                });
              }
            }
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    function isUnmemoized$1(operand, scopes) {
      return operand.scope != null && !scopes.has(operand.scope.id);
    }
    function isEffectHook(identifier) {
      return (
        isUseEffectHookType(identifier) ||
        isUseLayoutEffectHookType(identifier) ||
        isUseInsertionEffectHookType(identifier)
      );
    }
    function validateNoCapitalizedCalls(fn) {
      var _a;
      var envConfig = fn.env.config;
      var ALLOW_LIST = new Set(
        [].concat(
          _toConsumableArray(DEFAULT_GLOBALS.keys()),
          _toConsumableArray(
            (_a = envConfig.validateNoCapitalizedCalls) !== null &&
              _a !== void 0
              ? _a
              : []
          )
        )
      );
      var hookPattern =
        envConfig.hookPattern != null
          ? new RegExp(envConfig.hookPattern)
          : null;
      var isAllowed = function isAllowed(name) {
        return (
          ALLOW_LIST.has(name) ||
          (hookPattern != null && hookPattern.test(name))
        );
      };
      var capitalLoadGlobals = new Map();
      var capitalizedProperties = new Map();
      var reason =
        "Capitalized functions are reserved for components, which must be invoked with JSX. If this is a component, render it with JSX. Otherwise, ensure that it has no hook calls and rename it to begin with a lowercase letter. Alternatively, if you know for a fact that this function is not a component, you can allowlist it via the compiler config";
      var _iterator472 = _createForOfIteratorHelper(fn.body.blocks),
        _step472;
      try {
        for (_iterator472.s(); !(_step472 = _iterator472.n()).done; ) {
          var _step472$value = _slicedToArray(_step472.value, 2),
            block = _step472$value[1];
          var _iterator473 = _createForOfIteratorHelper(block.instructions),
            _step473;
          try {
            for (_iterator473.s(); !(_step473 = _iterator473.n()).done; ) {
              var _step473$value = _step473.value,
                lvalue = _step473$value.lvalue,
                value = _step473$value.value;
              switch (value.kind) {
                case "LoadGlobal": {
                  if (
                    value.binding.name != "" &&
                    /^[A-Z]/.test(value.binding.name) &&
                    !(
                      value.binding.name.toUpperCase() === value.binding.name
                    ) &&
                    !isAllowed(value.binding.name)
                  ) {
                    capitalLoadGlobals.set(
                      lvalue.identifier.id,
                      value.binding.name
                    );
                  }
                  break;
                }
                case "CallExpression": {
                  var calleeIdentifier = value.callee.identifier.id;
                  var calleeName = capitalLoadGlobals.get(calleeIdentifier);
                  if (calleeName != null) {
                    CompilerError.throwInvalidReact({
                      reason: reason,
                      description: "".concat(
                        calleeName,
                        " may be a component."
                      ),
                      loc: value.loc,
                      suggestions: null
                    });
                  }
                  break;
                }
                case "PropertyLoad": {
                  if (
                    typeof value.property === "string" &&
                    /^[A-Z]/.test(value.property)
                  ) {
                    capitalizedProperties.set(
                      lvalue.identifier.id,
                      value.property
                    );
                  }
                  break;
                }
                case "MethodCall": {
                  var propertyIdentifier = value.property.identifier.id;
                  var propertyName =
                    capitalizedProperties.get(propertyIdentifier);
                  if (propertyName != null) {
                    CompilerError.throwInvalidReact({
                      reason: reason,
                      description: "".concat(
                        propertyName,
                        " may be a component."
                      ),
                      loc: value.loc,
                      suggestions: null
                    });
                  }
                  break;
                }
              }
            }
          } catch (err) {
            _iterator473.e(err);
          } finally {
            _iterator473.f();
          }
        }
      } catch (err) {
        _iterator472.e(err);
      } finally {
        _iterator472.f();
      }
    }
    var _Env_changed;
    function makeRefId(id) {
      CompilerError.invariant(id >= 0 && Number.isInteger(id), {
        reason: "Expected identifier id to be a non-negative integer",
        description: null,
        loc: null,
        suggestions: null
      });
      return id;
    }
    var _refId = 0;
    function nextRefId() {
      return makeRefId(_refId++);
    }
    var Env = /*#__PURE__*/ (function (_Map) {
      function Env() {
        var _this29;
        _classCallCheck(this, Env);
        _this29 = _callSuper(this, Env, arguments);
        _Env_changed.set(_this29, false);
        return _this29;
      }
      _inherits2(Env, _Map);
      return _createClass(Env, [
        {
          key: "resetChanged",
          value: function resetChanged() {
            __classPrivateFieldSet(this, _Env_changed, false, "f");
          }
        },
        {
          key: "hasChanged",
          value: function hasChanged() {
            return __classPrivateFieldGet(this, _Env_changed, "f");
          }
        },
        {
          key: "set",
          value: function set(key, value) {
            var cur = this.get(key);
            var widenedValue = joinRefAccessTypes(
              value,
              cur !== null && cur !== void 0 ? cur : { kind: "None" }
            );
            if (
              !(cur == null && widenedValue.kind === "None") &&
              (cur == null || !tyEqual(cur, widenedValue))
            ) {
              __classPrivateFieldSet(this, _Env_changed, true, "f");
            }
            return _get(_getPrototypeOf(Env.prototype), "set", this).call(
              this,
              key,
              widenedValue
            );
          }
        }
      ]);
    })(/*#__PURE__*/ _wrapNativeSuper(Map));
    _Env_changed = new WeakMap();
    function validateNoRefAccessInRender(fn) {
      var env = new Env();
      validateNoRefAccessInRenderImpl(fn, env).unwrap();
    }
    function refTypeOfType(place) {
      if (isRefValueType(place.identifier)) {
        return { kind: "RefValue" };
      } else if (isUseRefType(place.identifier)) {
        return { kind: "Ref", refId: nextRefId() };
      } else {
        return { kind: "None" };
      }
    }
    function tyEqual(a, b) {
      if (a.kind !== b.kind) {
        return false;
      }
      switch (a.kind) {
        case "None":
          return true;
        case "Ref":
          return true;
        case "Nullable":
          return true;
        case "Guard":
          CompilerError.invariant(b.kind === "Guard", {
            reason: "Expected ref value",
            loc: null
          });
          return a.refId === b.refId;
        case "RefValue":
          CompilerError.invariant(b.kind === "RefValue", {
            reason: "Expected ref value",
            loc: null
          });
          return a.loc == b.loc;
        case "Structure": {
          CompilerError.invariant(b.kind === "Structure", {
            reason: "Expected structure",
            loc: null
          });
          var fnTypesEqual =
            (a.fn === null && b.fn === null) ||
            (a.fn !== null &&
              b.fn !== null &&
              a.fn.readRefEffect === b.fn.readRefEffect &&
              tyEqual(a.fn.returnType, b.fn.returnType));
          return (
            fnTypesEqual &&
            (a.value === b.value ||
              (a.value !== null &&
                b.value !== null &&
                tyEqual(a.value, b.value)))
          );
        }
      }
    }
    function joinRefAccessTypes() {
      function joinRefAccessRefTypes(a, b) {
        if (a.kind === "RefValue") {
          if (b.kind === "RefValue" && a.refId === b.refId) {
            return a;
          }
          return { kind: "RefValue" };
        } else if (b.kind === "RefValue") {
          return b;
        } else if (a.kind === "Ref" || b.kind === "Ref") {
          if (a.kind === "Ref" && b.kind === "Ref" && a.refId === b.refId) {
            return a;
          }
          return { kind: "Ref", refId: nextRefId() };
        } else {
          CompilerError.invariant(
            a.kind === "Structure" && b.kind === "Structure",
            { reason: "Expected structure", loc: null }
          );
          var fn =
            a.fn === null
              ? b.fn
              : b.fn === null
                ? a.fn
                : {
                    readRefEffect: a.fn.readRefEffect || b.fn.readRefEffect,
                    returnType: joinRefAccessTypes(
                      a.fn.returnType,
                      b.fn.returnType
                    )
                  };
          var value =
            a.value === null
              ? b.value
              : b.value === null
                ? a.value
                : joinRefAccessRefTypes(a.value, b.value);
          return { kind: "Structure", fn: fn, value: value };
        }
      }
      for (
        var _len8 = arguments.length, types = new Array(_len8), _key40 = 0;
        _key40 < _len8;
        _key40++
      ) {
        types[_key40] = arguments[_key40];
      }
      return types.reduce(
        function (a, b) {
          if (a.kind === "None") {
            return b;
          } else if (b.kind === "None") {
            return a;
          } else if (a.kind === "Guard") {
            if (b.kind === "Guard" && a.refId === b.refId) {
              return a;
            } else if (b.kind === "Nullable" || b.kind === "Guard") {
              return { kind: "None" };
            } else {
              return b;
            }
          } else if (b.kind === "Guard") {
            if (a.kind === "Nullable") {
              return { kind: "None" };
            } else {
              return b;
            }
          } else if (a.kind === "Nullable") {
            return b;
          } else if (b.kind === "Nullable") {
            return a;
          } else {
            return joinRefAccessRefTypes(a, b);
          }
        },
        { kind: "None" }
      );
    }
    function validateNoRefAccessInRenderImpl(fn, env) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      var returnValues = [];
      var place;
      var _iterator474 = _createForOfIteratorHelper(fn.params),
        _step474;
      try {
        for (_iterator474.s(); !(_step474 = _iterator474.n()).done; ) {
          var param = _step474.value;
          if (param.kind === "Identifier") {
            place = param;
          } else {
            place = param.place;
          }
          var type = refTypeOfType(place);
          env.set(place.identifier.id, type);
        }
      } catch (err) {
        _iterator474.e(err);
      } finally {
        _iterator474.f();
      }
      for (var i = 0; (i == 0 || env.hasChanged()) && i < 10; i++) {
        env.resetChanged();
        returnValues = [];
        var safeBlocks = new Map();
        var errors = new CompilerError();
        var _iterator475 = _createForOfIteratorHelper(fn.body.blocks),
          _step475;
        try {
          for (_iterator475.s(); !(_step475 = _iterator475.n()).done; ) {
            var _step475$value = _slicedToArray(_step475.value, 2),
              block = _step475$value[1];
            var _iterator476 = _createForOfIteratorHelper(block.phis),
              _step476;
            try {
              for (_iterator476.s(); !(_step476 = _iterator476.n()).done; ) {
                var phi = _step476.value;
                env.set(
                  phi.place.identifier.id,
                  joinRefAccessTypes.apply(
                    void 0,
                    _toConsumableArray(
                      Array.apply(
                        void 0,
                        _toConsumableArray(phi.operands.values())
                      ).map(function (operand) {
                        var _a;
                        return (_a = env.get(operand.identifier.id)) !== null &&
                          _a !== void 0
                          ? _a
                          : { kind: "None" };
                      })
                    )
                  )
                );
              }
            } catch (err) {
              _iterator476.e(err);
            } finally {
              _iterator476.f();
            }
            var _iterator477 = _createForOfIteratorHelper(block.instructions),
              _step477;
            try {
              for (_iterator477.s(); !(_step477 = _iterator477.n()).done; ) {
                var instr = _step477.value;
                switch (instr.value.kind) {
                  case "JsxExpression":
                  case "JsxFragment": {
                    var _iterator479 = _createForOfIteratorHelper(
                        eachInstructionValueOperand(instr.value)
                      ),
                      _step479;
                    try {
                      for (
                        _iterator479.s();
                        !(_step479 = _iterator479.n()).done;

                      ) {
                        var operand = _step479.value;
                        validateNoDirectRefValueAccess(errors, operand, env);
                      }
                    } catch (err) {
                      _iterator479.e(err);
                    } finally {
                      _iterator479.f();
                    }
                    break;
                  }
                  case "ComputedLoad":
                  case "PropertyLoad": {
                    if (instr.value.kind === "ComputedLoad") {
                      validateNoDirectRefValueAccess(
                        errors,
                        instr.value.property,
                        env
                      );
                    }
                    var objType = env.get(instr.value.object.identifier.id);
                    var lookupType = null;
                    if (
                      (objType === null || objType === void 0
                        ? void 0
                        : objType.kind) === "Structure"
                    ) {
                      lookupType = objType.value;
                    } else if (
                      (objType === null || objType === void 0
                        ? void 0
                        : objType.kind) === "Ref"
                    ) {
                      lookupType = {
                        kind: "RefValue",
                        loc: instr.loc,
                        refId: objType.refId
                      };
                    }
                    env.set(
                      instr.lvalue.identifier.id,
                      lookupType !== null && lookupType !== void 0
                        ? lookupType
                        : refTypeOfType(instr.lvalue)
                    );
                    break;
                  }
                  case "TypeCastExpression": {
                    env.set(
                      instr.lvalue.identifier.id,
                      (_a = env.get(instr.value.value.identifier.id)) !==
                        null && _a !== void 0
                        ? _a
                        : refTypeOfType(instr.lvalue)
                    );
                    break;
                  }
                  case "LoadContext":
                  case "LoadLocal": {
                    env.set(
                      instr.lvalue.identifier.id,
                      (_b = env.get(instr.value.place.identifier.id)) !==
                        null && _b !== void 0
                        ? _b
                        : refTypeOfType(instr.lvalue)
                    );
                    break;
                  }
                  case "StoreContext":
                  case "StoreLocal": {
                    env.set(
                      instr.value.lvalue.place.identifier.id,
                      (_c = env.get(instr.value.value.identifier.id)) !==
                        null && _c !== void 0
                        ? _c
                        : refTypeOfType(instr.value.lvalue.place)
                    );
                    env.set(
                      instr.lvalue.identifier.id,
                      (_d = env.get(instr.value.value.identifier.id)) !==
                        null && _d !== void 0
                        ? _d
                        : refTypeOfType(instr.lvalue)
                    );
                    break;
                  }
                  case "Destructure": {
                    var _objType = env.get(instr.value.value.identifier.id);
                    var _lookupType = null;
                    if (
                      (_objType === null || _objType === void 0
                        ? void 0
                        : _objType.kind) === "Structure"
                    ) {
                      _lookupType = _objType.value;
                    }
                    env.set(
                      instr.lvalue.identifier.id,
                      _lookupType !== null && _lookupType !== void 0
                        ? _lookupType
                        : refTypeOfType(instr.lvalue)
                    );
                    var _iterator480 = _createForOfIteratorHelper(
                        eachPatternOperand(instr.value.lvalue.pattern)
                      ),
                      _step480;
                    try {
                      for (
                        _iterator480.s();
                        !(_step480 = _iterator480.n()).done;

                      ) {
                        var lval = _step480.value;
                        env.set(
                          lval.identifier.id,
                          _lookupType !== null && _lookupType !== void 0
                            ? _lookupType
                            : refTypeOfType(lval)
                        );
                      }
                    } catch (err) {
                      _iterator480.e(err);
                    } finally {
                      _iterator480.f();
                    }
                    break;
                  }
                  case "ObjectMethod":
                  case "FunctionExpression": {
                    var returnType = { kind: "None" };
                    var readRefEffect = false;
                    var result = validateNoRefAccessInRenderImpl(
                      instr.value.loweredFunc.func,
                      env
                    );
                    if (result.isOk()) {
                      returnType = result.unwrap();
                    } else if (result.isErr()) {
                      readRefEffect = true;
                    }
                    env.set(instr.lvalue.identifier.id, {
                      kind: "Structure",
                      fn: {
                        readRefEffect: readRefEffect,
                        returnType: returnType
                      },
                      value: null
                    });
                    break;
                  }
                  case "MethodCall":
                  case "CallExpression": {
                    var callee =
                      instr.value.kind === "CallExpression"
                        ? instr.value.callee
                        : instr.value.property;
                    var hookKind = getHookKindForType(
                      fn.env,
                      callee.identifier.type
                    );
                    var _returnType3 = { kind: "None" };
                    var fnType = env.get(callee.identifier.id);
                    if (
                      (fnType === null || fnType === void 0
                        ? void 0
                        : fnType.kind) === "Structure" &&
                      fnType.fn !== null
                    ) {
                      _returnType3 = fnType.fn.returnType;
                      if (fnType.fn.readRefEffect) {
                        errors.push({
                          severity: ErrorSeverity.InvalidReact,
                          reason:
                            "This function accesses a ref value (the `current` property), which may not be accessed during render. (https://react.dev/reference/react/useRef)",
                          loc: callee.loc,
                          description:
                            callee.identifier.name !== null &&
                            callee.identifier.name.kind === "named"
                              ? "Function `".concat(
                                  callee.identifier.name.value,
                                  "` accesses a ref"
                                )
                              : null,
                          suggestions: null
                        });
                      }
                    }
                    var _iterator481 = _createForOfIteratorHelper(
                        eachInstructionValueOperand(instr.value)
                      ),
                      _step481;
                    try {
                      for (
                        _iterator481.s();
                        !(_step481 = _iterator481.n()).done;

                      ) {
                        var _operand37 = _step481.value;
                        if (hookKind != null) {
                          validateNoDirectRefValueAccess(
                            errors,
                            _operand37,
                            env
                          );
                        } else {
                          validateNoRefAccess(
                            errors,
                            env,
                            _operand37,
                            _operand37.loc
                          );
                        }
                      }
                    } catch (err) {
                      _iterator481.e(err);
                    } finally {
                      _iterator481.f();
                    }
                    env.set(instr.lvalue.identifier.id, _returnType3);
                    break;
                  }
                  case "ObjectExpression":
                  case "ArrayExpression": {
                    var _types3 = [];
                    var _iterator482 = _createForOfIteratorHelper(
                        eachInstructionValueOperand(instr.value)
                      ),
                      _step482;
                    try {
                      for (
                        _iterator482.s();
                        !(_step482 = _iterator482.n()).done;

                      ) {
                        var _operand38 = _step482.value;
                        validateNoDirectRefValueAccess(errors, _operand38, env);
                        _types3.push(
                          (_e = env.get(_operand38.identifier.id)) !== null &&
                            _e !== void 0
                            ? _e
                            : { kind: "None" }
                        );
                      }
                    } catch (err) {
                      _iterator482.e(err);
                    } finally {
                      _iterator482.f();
                    }
                    var value = joinRefAccessTypes.apply(void 0, _types3);
                    if (
                      value.kind === "None" ||
                      value.kind === "Guard" ||
                      value.kind === "Nullable"
                    ) {
                      env.set(instr.lvalue.identifier.id, { kind: "None" });
                    } else {
                      env.set(instr.lvalue.identifier.id, {
                        kind: "Structure",
                        value: value,
                        fn: null
                      });
                    }
                    break;
                  }
                  case "PropertyDelete":
                  case "PropertyStore":
                  case "ComputedDelete":
                  case "ComputedStore": {
                    var safe = safeBlocks.get(block.id);
                    var target = env.get(instr.value.object.identifier.id);
                    if (
                      instr.value.kind === "PropertyStore" &&
                      safe != null &&
                      (target === null || target === void 0
                        ? void 0
                        : target.kind) === "Ref" &&
                      target.refId === safe
                    ) {
                      safeBlocks["delete"](block.id);
                    } else {
                      validateNoRefAccess(
                        errors,
                        env,
                        instr.value.object,
                        instr.loc
                      );
                    }
                    var _iterator483 = _createForOfIteratorHelper(
                        eachInstructionValueOperand(instr.value)
                      ),
                      _step483;
                    try {
                      for (
                        _iterator483.s();
                        !(_step483 = _iterator483.n()).done;

                      ) {
                        var _operand39 = _step483.value;
                        if (_operand39 === instr.value.object) {
                          continue;
                        }
                        validateNoRefValueAccess(errors, env, _operand39);
                      }
                    } catch (err) {
                      _iterator483.e(err);
                    } finally {
                      _iterator483.f();
                    }
                    break;
                  }
                  case "StartMemoize":
                  case "FinishMemoize":
                    break;
                  case "Primitive": {
                    if (instr.value.value == null) {
                      env.set(instr.lvalue.identifier.id, { kind: "Nullable" });
                    }
                    break;
                  }
                  case "BinaryExpression": {
                    var left = env.get(instr.value.left.identifier.id);
                    var right = env.get(instr.value.right.identifier.id);
                    var nullish = false;
                    var refId = null;
                    if (
                      (left === null || left === void 0
                        ? void 0
                        : left.kind) === "RefValue" &&
                      left.refId != null
                    ) {
                      refId = left.refId;
                    } else if (
                      (right === null || right === void 0
                        ? void 0
                        : right.kind) === "RefValue" &&
                      right.refId != null
                    ) {
                      refId = right.refId;
                    }
                    if (
                      (left === null || left === void 0
                        ? void 0
                        : left.kind) === "Nullable"
                    ) {
                      nullish = true;
                    } else if (
                      (right === null || right === void 0
                        ? void 0
                        : right.kind) === "Nullable"
                    ) {
                      nullish = true;
                    }
                    if (refId !== null && nullish) {
                      env.set(instr.lvalue.identifier.id, {
                        kind: "Guard",
                        refId: refId
                      });
                    } else {
                      var _iterator484 = _createForOfIteratorHelper(
                          eachInstructionValueOperand(instr.value)
                        ),
                        _step484;
                      try {
                        for (
                          _iterator484.s();
                          !(_step484 = _iterator484.n()).done;

                        ) {
                          var _operand40 = _step484.value;
                          validateNoRefValueAccess(errors, env, _operand40);
                        }
                      } catch (err) {
                        _iterator484.e(err);
                      } finally {
                        _iterator484.f();
                      }
                    }
                    break;
                  }
                  default: {
                    var _iterator485 = _createForOfIteratorHelper(
                        eachInstructionValueOperand(instr.value)
                      ),
                      _step485;
                    try {
                      for (
                        _iterator485.s();
                        !(_step485 = _iterator485.n()).done;

                      ) {
                        var _operand41 = _step485.value;
                        validateNoRefValueAccess(errors, env, _operand41);
                      }
                    } catch (err) {
                      _iterator485.e(err);
                    } finally {
                      _iterator485.f();
                    }
                    break;
                  }
                }
                var _iterator486 = _createForOfIteratorHelper(
                    eachInstructionOperand(instr)
                  ),
                  _step486;
                try {
                  for (
                    _iterator486.s();
                    !(_step486 = _iterator486.n()).done;

                  ) {
                    var _operand42 = _step486.value;
                    guardCheck(errors, _operand42, env);
                  }
                } catch (err) {
                  _iterator486.e(err);
                } finally {
                  _iterator486.f();
                }
                if (
                  isUseRefType(instr.lvalue.identifier) &&
                  ((_f = env.get(instr.lvalue.identifier.id)) === null ||
                  _f === void 0
                    ? void 0
                    : _f.kind) !== "Ref"
                ) {
                  env.set(
                    instr.lvalue.identifier.id,
                    joinRefAccessTypes(
                      (_g = env.get(instr.lvalue.identifier.id)) !== null &&
                        _g !== void 0
                        ? _g
                        : { kind: "None" },
                      { kind: "Ref", refId: nextRefId() }
                    )
                  );
                }
                if (
                  isRefValueType(instr.lvalue.identifier) &&
                  ((_h = env.get(instr.lvalue.identifier.id)) === null ||
                  _h === void 0
                    ? void 0
                    : _h.kind) !== "RefValue"
                ) {
                  env.set(
                    instr.lvalue.identifier.id,
                    joinRefAccessTypes(
                      (_j = env.get(instr.lvalue.identifier.id)) !== null &&
                        _j !== void 0
                        ? _j
                        : { kind: "None" },
                      { kind: "RefValue", loc: instr.loc }
                    )
                  );
                }
              }
            } catch (err) {
              _iterator477.e(err);
            } finally {
              _iterator477.f();
            }
            if (block.terminal.kind === "if") {
              var _test30 = env.get(block.terminal.test.identifier.id);
              if (
                (_test30 === null || _test30 === void 0
                  ? void 0
                  : _test30.kind) === "Guard"
              ) {
                safeBlocks.set(block.terminal.consequent, _test30.refId);
              }
            }
            var _iterator478 = _createForOfIteratorHelper(
                eachTerminalOperand(block.terminal)
              ),
              _step478;
            try {
              for (_iterator478.s(); !(_step478 = _iterator478.n()).done; ) {
                var _operand43 = _step478.value;
                if (block.terminal.kind !== "return") {
                  validateNoRefValueAccess(errors, env, _operand43);
                  if (block.terminal.kind !== "if") {
                    guardCheck(errors, _operand43, env);
                  }
                } else {
                  validateNoDirectRefValueAccess(errors, _operand43, env);
                  guardCheck(errors, _operand43, env);
                  returnValues.push(env.get(_operand43.identifier.id));
                }
              }
            } catch (err) {
              _iterator478.e(err);
            } finally {
              _iterator478.f();
            }
          }
        } catch (err) {
          _iterator475.e(err);
        } finally {
          _iterator475.f();
        }
        if (errors.hasErrors()) {
          return Err(errors);
        }
      }
      CompilerError.invariant(!env.hasChanged(), {
        reason: "Ref type environment did not converge",
        loc: null
      });
      return Ok(
        joinRefAccessTypes.apply(
          void 0,
          _toConsumableArray(
            returnValues.filter(function (env) {
              return env !== undefined;
            })
          )
        )
      );
    }
    function destructure(type) {
      if (
        (type === null || type === void 0 ? void 0 : type.kind) ===
          "Structure" &&
        type.value !== null
      ) {
        return destructure(type.value);
      }
      return type;
    }
    function guardCheck(errors, operand, env) {
      var _a;
      if (
        ((_a = env.get(operand.identifier.id)) === null || _a === void 0
          ? void 0
          : _a.kind) === "Guard"
      ) {
        errors.push({
          severity: ErrorSeverity.InvalidReact,
          reason:
            "Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef)",
          loc: operand.loc,
          description:
            operand.identifier.name !== null &&
            operand.identifier.name.kind === "named"
              ? "Cannot access ref value `".concat(
                  operand.identifier.name.value,
                  "`"
                )
              : null,
          suggestions: null
        });
      }
    }
    function validateNoRefValueAccess(errors, env, operand) {
      var _a;
      var type = destructure(env.get(operand.identifier.id));
      if (
        (type === null || type === void 0 ? void 0 : type.kind) ===
          "RefValue" ||
        ((type === null || type === void 0 ? void 0 : type.kind) ===
          "Structure" &&
          ((_a = type.fn) === null || _a === void 0
            ? void 0
            : _a.readRefEffect))
      ) {
        errors.push({
          severity: ErrorSeverity.InvalidReact,
          reason:
            "Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef)",
          loc: (type.kind === "RefValue" && type.loc) || operand.loc,
          description:
            operand.identifier.name !== null &&
            operand.identifier.name.kind === "named"
              ? "Cannot access ref value `".concat(
                  operand.identifier.name.value,
                  "`"
                )
              : null,
          suggestions: null
        });
      }
    }
    function validateNoRefAccess(errors, env, operand, loc) {
      var _a;
      var type = destructure(env.get(operand.identifier.id));
      if (
        (type === null || type === void 0 ? void 0 : type.kind) === "Ref" ||
        (type === null || type === void 0 ? void 0 : type.kind) ===
          "RefValue" ||
        ((type === null || type === void 0 ? void 0 : type.kind) ===
          "Structure" &&
          ((_a = type.fn) === null || _a === void 0
            ? void 0
            : _a.readRefEffect))
      ) {
        errors.push({
          severity: ErrorSeverity.InvalidReact,
          reason:
            "Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef)",
          loc: (type.kind === "RefValue" && type.loc) || loc,
          description:
            operand.identifier.name !== null &&
            operand.identifier.name.kind === "named"
              ? "Cannot access ref value `".concat(
                  operand.identifier.name.value,
                  "`"
                )
              : null,
          suggestions: null
        });
      }
    }
    function validateNoDirectRefValueAccess(errors, operand, env) {
      var _a;
      var type = destructure(env.get(operand.identifier.id));
      if (
        (type === null || type === void 0 ? void 0 : type.kind) === "RefValue"
      ) {
        errors.push({
          severity: ErrorSeverity.InvalidReact,
          reason:
            "Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef)",
          loc: (_a = type.loc) !== null && _a !== void 0 ? _a : operand.loc,
          description:
            operand.identifier.name !== null &&
            operand.identifier.name.kind === "named"
              ? "Cannot access ref value `".concat(
                  operand.identifier.name.value,
                  "`"
                )
              : null,
          suggestions: null
        });
      }
    }
    function validateNoSetStateInRender(fn) {
      var unconditionalSetStateFunctions = new Set();
      validateNoSetStateInRenderImpl(
        fn,
        unconditionalSetStateFunctions
      ).unwrap();
    }
    function validateNoSetStateInRenderImpl(
      fn,
      unconditionalSetStateFunctions
    ) {
      var unconditionalBlocks = computeUnconditionalBlocks(fn);
      var activeManualMemoId = null;
      var errors = new CompilerError();
      var _iterator487 = _createForOfIteratorHelper(fn.body.blocks),
        _step487;
      try {
        for (_iterator487.s(); !(_step487 = _iterator487.n()).done; ) {
          var _step487$value = _slicedToArray(_step487.value, 2),
            block = _step487$value[1];
          var _iterator488 = _createForOfIteratorHelper(block.instructions),
            _step488;
          try {
            for (_iterator488.s(); !(_step488 = _iterator488.n()).done; ) {
              var instr = _step488.value;
              switch (instr.value.kind) {
                case "LoadLocal": {
                  if (
                    unconditionalSetStateFunctions.has(
                      instr.value.place.identifier.id
                    )
                  ) {
                    unconditionalSetStateFunctions.add(
                      instr.lvalue.identifier.id
                    );
                  }
                  break;
                }
                case "StoreLocal": {
                  if (
                    unconditionalSetStateFunctions.has(
                      instr.value.value.identifier.id
                    )
                  ) {
                    unconditionalSetStateFunctions.add(
                      instr.value.lvalue.place.identifier.id
                    );
                    unconditionalSetStateFunctions.add(
                      instr.lvalue.identifier.id
                    );
                  }
                  break;
                }
                case "ObjectMethod":
                case "FunctionExpression": {
                  if (
                    _toConsumableArray(
                      eachInstructionValueOperand(instr.value)
                    ).some(function (operand) {
                      return (
                        isSetStateType(operand.identifier) ||
                        unconditionalSetStateFunctions.has(
                          operand.identifier.id
                        )
                      );
                    }) &&
                    validateNoSetStateInRenderImpl(
                      instr.value.loweredFunc.func,
                      unconditionalSetStateFunctions
                    ).isErr()
                  ) {
                    unconditionalSetStateFunctions.add(
                      instr.lvalue.identifier.id
                    );
                  }
                  break;
                }
                case "StartMemoize": {
                  CompilerError.invariant(activeManualMemoId === null, {
                    reason: "Unexpected nested StartMemoize instructions",
                    loc: instr.value.loc
                  });
                  activeManualMemoId = instr.value.manualMemoId;
                  break;
                }
                case "FinishMemoize": {
                  CompilerError.invariant(
                    activeManualMemoId === instr.value.manualMemoId,
                    {
                      reason:
                        "Expected FinishMemoize to align with previous StartMemoize instruction",
                      loc: instr.value.loc
                    }
                  );
                  activeManualMemoId = null;
                  break;
                }
                case "CallExpression": {
                  var callee = instr.value.callee;
                  if (
                    isSetStateType(callee.identifier) ||
                    unconditionalSetStateFunctions.has(callee.identifier.id)
                  ) {
                    if (activeManualMemoId !== null) {
                      errors.push({
                        reason:
                          "Calling setState from useMemo may trigger an infinite loop. (https://react.dev/reference/react/useState)",
                        description: null,
                        severity: ErrorSeverity.InvalidReact,
                        loc: callee.loc,
                        suggestions: null
                      });
                    } else if (unconditionalBlocks.has(block.id)) {
                      errors.push({
                        reason:
                          "This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState)",
                        description: null,
                        severity: ErrorSeverity.InvalidReact,
                        loc: callee.loc,
                        suggestions: null
                      });
                    }
                  }
                  break;
                }
              }
            }
          } catch (err) {
            _iterator488.e(err);
          } finally {
            _iterator488.f();
          }
        }
      } catch (err) {
        _iterator487.e(err);
      } finally {
        _iterator487.f();
      }
      if (errors.hasErrors()) {
        return Err(errors);
      } else {
        return Ok(undefined);
      }
    }
    function validatePreservedManualMemoization(fn) {
      var state = { errors: new CompilerError(), manualMemoState: null };
      visitReactiveFunction(fn, new Visitor(), state);
      if (state.errors.hasErrors()) {
        throw state.errors;
      }
    }
    var CompareDependencyResult;
    (function (CompareDependencyResult) {
      CompareDependencyResult[(CompareDependencyResult["Ok"] = 0)] = "Ok";
      CompareDependencyResult[(CompareDependencyResult["RootDifference"] = 1)] =
        "RootDifference";
      CompareDependencyResult[(CompareDependencyResult["PathDifference"] = 2)] =
        "PathDifference";
      CompareDependencyResult[(CompareDependencyResult["Subpath"] = 3)] =
        "Subpath";
      CompareDependencyResult[
        (CompareDependencyResult["RefAccessDifference"] = 4)
      ] = "RefAccessDifference";
    })(CompareDependencyResult || (CompareDependencyResult = {}));
    function compareDeps(inferred, source) {
      var rootsEqual =
        (inferred.root.kind === "Global" &&
          source.root.kind === "Global" &&
          inferred.root.identifierName === source.root.identifierName) ||
        (inferred.root.kind === "NamedLocal" &&
          source.root.kind === "NamedLocal" &&
          inferred.root.value.identifier.id ===
            source.root.value.identifier.id);
      if (!rootsEqual) {
        return CompareDependencyResult.RootDifference;
      }
      var isSubpath = true;
      for (
        var i = 0;
        i < Math.min(inferred.path.length, source.path.length);
        i++
      ) {
        if (inferred.path[i].property !== source.path[i].property) {
          isSubpath = false;
          break;
        } else if (inferred.path[i].optional !== source.path[i].optional) {
          return CompareDependencyResult.PathDifference;
        }
      }
      if (
        isSubpath &&
        (source.path.length === inferred.path.length ||
          (inferred.path.length >= source.path.length &&
            !inferred.path.some(function (token) {
              return token.property === "current";
            })))
      ) {
        return CompareDependencyResult.Ok;
      } else {
        if (isSubpath) {
          if (
            source.path.some(function (token) {
              return token.property === "current";
            }) ||
            inferred.path.some(function (token) {
              return token.property === "current";
            })
          ) {
            return CompareDependencyResult.RefAccessDifference;
          } else {
            return CompareDependencyResult.Subpath;
          }
        } else {
          return CompareDependencyResult.PathDifference;
        }
      }
    }
    function validateInferredDep(
      dep,
      temporaries,
      declsWithinMemoBlock,
      validDepsInMemoBlock,
      errorState,
      memoLocation
    ) {
      var _a;
      var normalizedDep;
      var maybeNormalizedRoot = temporaries.get(dep.identifier.id);
      if (maybeNormalizedRoot != null) {
        normalizedDep = {
          root: maybeNormalizedRoot.root,
          path: [].concat(
            _toConsumableArray(maybeNormalizedRoot.path),
            _toConsumableArray(dep.path)
          )
        };
      } else {
        CompilerError.invariant(
          ((_a = dep.identifier.name) === null || _a === void 0
            ? void 0
            : _a.kind) === "named",
          {
            reason:
              "ValidatePreservedManualMemoization: expected scope dependency to be named",
            loc: GeneratedSource,
            suggestions: null
          }
        );
        normalizedDep = {
          root: {
            kind: "NamedLocal",
            value: {
              kind: "Identifier",
              identifier: dep.identifier,
              loc: GeneratedSource,
              effect: Effect.Read,
              reactive: false
            }
          },
          path: _toConsumableArray(dep.path)
        };
      }
      var _iterator489 = _createForOfIteratorHelper(declsWithinMemoBlock),
        _step489;
      try {
        for (_iterator489.s(); !(_step489 = _iterator489.n()).done; ) {
          var decl = _step489.value;
          if (
            normalizedDep.root.kind === "NamedLocal" &&
            decl === normalizedDep.root.value.identifier.declarationId
          ) {
            return;
          }
        }
      } catch (err) {
        _iterator489.e(err);
      } finally {
        _iterator489.f();
      }
      var _iterator490 = _createForOfIteratorHelper(validDepsInMemoBlock),
        _step490;
      try {
        for (_iterator490.s(); !(_step490 = _iterator490.n()).done; ) {
          var originalDep = _step490.value;
          var compareResult = compareDeps(normalizedDep, originalDep);
          if (compareResult === CompareDependencyResult.Ok) {
            return;
          }
        }
      } catch (err) {
        _iterator490.e(err);
      } finally {
        _iterator490.f();
      }
      errorState.push({
        severity: ErrorSeverity.CannotPreserveMemoization,
        reason:
          "React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected",
        description: null,
        loc: memoLocation,
        suggestions: null
      });
    }
    var Visitor = /*#__PURE__*/ (function (_ReactiveFunctionVisi22) {
      function Visitor() {
        var _this30;
        _classCallCheck(this, Visitor);
        _this30 = _callSuper(this, Visitor, arguments);
        _this30.scopes = new Set();
        _this30.prunedScopes = new Set();
        _this30.temporaries = new Map();
        return _this30;
      }
      _inherits2(Visitor, _ReactiveFunctionVisi22);
      return _createClass(Visitor, [
        {
          key: "recordDepsInValue",
          value: function recordDepsInValue(value, state) {
            var _a, _b;
            switch (value.kind) {
              case "SequenceExpression": {
                var _iterator491 = _createForOfIteratorHelper(
                    value.instructions
                  ),
                  _step491;
                try {
                  for (
                    _iterator491.s();
                    !(_step491 = _iterator491.n()).done;

                  ) {
                    var instr = _step491.value;
                    this.visitInstruction(instr, state);
                  }
                } catch (err) {
                  _iterator491.e(err);
                } finally {
                  _iterator491.f();
                }
                var result = this.recordDepsInValue(value.value, state);
                return result;
              }
              case "OptionalExpression": {
                return this.recordDepsInValue(value.value, state);
              }
              case "ConditionalExpression": {
                this.recordDepsInValue(value.test, state);
                this.recordDepsInValue(value.consequent, state);
                this.recordDepsInValue(value.alternate, state);
                return null;
              }
              case "LogicalExpression": {
                this.recordDepsInValue(value.left, state);
                this.recordDepsInValue(value.right, state);
                return null;
              }
              default: {
                var dep = collectMaybeMemoDependencies(
                  value,
                  this.temporaries,
                  false
                );
                if (
                  value.kind === "StoreLocal" ||
                  value.kind === "StoreContext"
                ) {
                  var storeTarget = value.lvalue.place;
                  (_a = state.manualMemoState) === null || _a === void 0
                    ? void 0
                    : _a.decls.add(storeTarget.identifier.declarationId);
                  if (
                    ((_b = storeTarget.identifier.name) === null ||
                    _b === void 0
                      ? void 0
                      : _b.kind) === "named" &&
                    dep == null
                  ) {
                    var _dep = {
                      root: { kind: "NamedLocal", value: storeTarget },
                      path: []
                    };
                    this.temporaries.set(storeTarget.identifier.id, _dep);
                    return _dep;
                  }
                }
                return dep;
              }
            }
          }
        },
        {
          key: "recordTemporaries",
          value: function recordTemporaries(instr, state) {
            var _a;
            var temporaries = this.temporaries;
            var lvalue = instr.lvalue,
              value = instr.value;
            var lvalId =
              lvalue === null || lvalue === void 0
                ? void 0
                : lvalue.identifier.id;
            if (lvalId != null && temporaries.has(lvalId)) {
              return;
            }
            var isNamedLocal =
              ((_a =
                lvalue === null || lvalue === void 0
                  ? void 0
                  : lvalue.identifier.name) === null || _a === void 0
                ? void 0
                : _a.kind) === "named";
            if (
              lvalue !== null &&
              isNamedLocal &&
              state.manualMemoState != null
            ) {
              state.manualMemoState.decls.add(lvalue.identifier.declarationId);
            }
            var maybeDep = this.recordDepsInValue(value, state);
            if (lvalId != null) {
              if (maybeDep != null) {
                temporaries.set(lvalId, maybeDep);
              } else if (isNamedLocal) {
                temporaries.set(lvalId, {
                  root: {
                    kind: "NamedLocal",
                    value: Object.assign({}, instr.lvalue)
                  },
                  path: []
                });
              }
            }
          }
        },
        {
          key: "visitScope",
          value: function visitScope(scopeBlock, state) {
            this.traverseScope(scopeBlock, state);
            if (
              state.manualMemoState != null &&
              state.manualMemoState.depsFromSource != null
            ) {
              var _iterator492 = _createForOfIteratorHelper(
                  scopeBlock.scope.dependencies
                ),
                _step492;
              try {
                for (_iterator492.s(); !(_step492 = _iterator492.n()).done; ) {
                  var dep = _step492.value;
                  validateInferredDep(
                    dep,
                    this.temporaries,
                    state.manualMemoState.decls,
                    state.manualMemoState.depsFromSource,
                    state.errors,
                    state.manualMemoState.loc
                  );
                }
              } catch (err) {
                _iterator492.e(err);
              } finally {
                _iterator492.f();
              }
            }
            this.scopes.add(scopeBlock.scope.id);
            var _iterator493 = _createForOfIteratorHelper(
                scopeBlock.scope.merged
              ),
              _step493;
            try {
              for (_iterator493.s(); !(_step493 = _iterator493.n()).done; ) {
                var id = _step493.value;
                this.scopes.add(id);
              }
            } catch (err) {
              _iterator493.e(err);
            } finally {
              _iterator493.f();
            }
          }
        },
        {
          key: "visitPrunedScope",
          value: function visitPrunedScope(scopeBlock, state) {
            this.traversePrunedScope(scopeBlock, state);
            this.prunedScopes.add(scopeBlock.scope.id);
          }
        },
        {
          key: "visitInstruction",
          value: function visitInstruction(instruction, state) {
            var _a, _b, _c;
            this.recordTemporaries(instruction, state);
            var value = instruction.value;
            if (
              value.kind === "StoreLocal" &&
              value.lvalue.kind === "Reassign" &&
              state.manualMemoState != null
            ) {
              var ids = getOrInsertDefault(
                state.manualMemoState.reassignments,
                value.lvalue.place.identifier.declarationId,
                new Set()
              );
              ids.add(value.value.identifier);
            }
            if (value.kind === "StartMemoize") {
              var depsFromSource = null;
              if (value.deps != null) {
                depsFromSource = value.deps;
              }
              CompilerError.invariant(state.manualMemoState == null, {
                reason: "Unexpected nested StartMemoize instructions",
                description: "Bad manual memoization ids: "
                  .concat(
                    (_a = state.manualMemoState) === null || _a === void 0
                      ? void 0
                      : _a.manualMemoId,
                    ", "
                  )
                  .concat(value.manualMemoId),
                loc: value.loc,
                suggestions: null
              });
              state.manualMemoState = {
                loc: instruction.loc,
                decls: new Set(),
                depsFromSource: depsFromSource,
                manualMemoId: value.manualMemoId,
                reassignments: new Map()
              };
              var _iterator494 = _createForOfIteratorHelper(
                  eachInstructionValueOperand(value)
                ),
                _step494;
              try {
                for (_iterator494.s(); !(_step494 = _iterator494.n()).done; ) {
                  var _step494$value = _step494.value,
                    _identifier17 = _step494$value.identifier,
                    loc = _step494$value.loc;
                  if (
                    _identifier17.scope != null &&
                    !this.scopes.has(_identifier17.scope.id) &&
                    !this.prunedScopes.has(_identifier17.scope.id)
                  ) {
                    state.errors.push({
                      reason:
                        "React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This dependency may be mutated later, which could cause the value to change unexpectedly",
                      description: null,
                      severity: ErrorSeverity.CannotPreserveMemoization,
                      loc: loc,
                      suggestions: null
                    });
                  }
                }
              } catch (err) {
                _iterator494.e(err);
              } finally {
                _iterator494.f();
              }
            }
            if (value.kind === "FinishMemoize") {
              CompilerError.invariant(
                state.manualMemoState != null &&
                  state.manualMemoState.manualMemoId === value.manualMemoId,
                {
                  reason:
                    "Unexpected mismatch between StartMemoize and FinishMemoize",
                  description: "Encountered StartMemoize id="
                    .concat(
                      (_b = state.manualMemoState) === null || _b === void 0
                        ? void 0
                        : _b.manualMemoId,
                      " followed by FinishMemoize id="
                    )
                    .concat(value.manualMemoId),
                  loc: value.loc,
                  suggestions: null
                }
              );
              var reassignments = state.manualMemoState.reassignments;
              state.manualMemoState = null;
              if (!value.pruned) {
                var _iterator495 = _createForOfIteratorHelper(
                    eachInstructionValueOperand(value)
                  ),
                  _step495;
                try {
                  for (
                    _iterator495.s();
                    !(_step495 = _iterator495.n()).done;

                  ) {
                    var _step495$value = _step495.value,
                      _identifier18 = _step495$value.identifier,
                      _loc6 = _step495$value.loc;
                    var decls = void 0;
                    if (_identifier18.scope == null) {
                      decls =
                        (_c = reassignments.get(
                          _identifier18.declarationId
                        )) !== null && _c !== void 0
                          ? _c
                          : [_identifier18];
                    } else {
                      decls = [_identifier18];
                    }
                    var _iterator496 = _createForOfIteratorHelper(decls),
                      _step496;
                    try {
                      for (
                        _iterator496.s();
                        !(_step496 = _iterator496.n()).done;

                      ) {
                        var _identifier19 = _step496.value;
                        if (isUnmemoized(_identifier19, this.scopes)) {
                          state.errors.push({
                            reason:
                              "React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output.",
                            description: null,
                            severity: ErrorSeverity.CannotPreserveMemoization,
                            loc: _loc6,
                            suggestions: null
                          });
                        }
                      }
                    } catch (err) {
                      _iterator496.e(err);
                    } finally {
                      _iterator496.f();
                    }
                  }
                } catch (err) {
                  _iterator495.e(err);
                } finally {
                  _iterator495.f();
                }
              }
            }
          }
        }
      ]);
    })(ReactiveFunctionVisitor);
    function isUnmemoized(operand, scopes) {
      return operand.scope != null && !scopes.has(operand.scope.id);
    }
    function validateUseMemo(fn) {
      var useMemos = new Set();
      var react = new Set();
      var functions = new Map();
      var _iterator497 = _createForOfIteratorHelper(fn.body.blocks),
        _step497;
      try {
        for (_iterator497.s(); !(_step497 = _iterator497.n()).done; ) {
          var _step497$value = _slicedToArray(_step497.value, 2),
            block = _step497$value[1];
          var _iterator498 = _createForOfIteratorHelper(block.instructions),
            _step498;
          try {
            for (_iterator498.s(); !(_step498 = _iterator498.n()).done; ) {
              var _step498$value = _step498.value,
                lvalue = _step498$value.lvalue,
                value = _step498$value.value;
              switch (value.kind) {
                case "LoadGlobal": {
                  if (value.binding.name === "useMemo") {
                    useMemos.add(lvalue.identifier.id);
                  } else if (value.binding.name === "React") {
                    react.add(lvalue.identifier.id);
                  }
                  break;
                }
                case "PropertyLoad": {
                  if (react.has(value.object.identifier.id)) {
                    if (value.property === "useMemo") {
                      useMemos.add(lvalue.identifier.id);
                    }
                  }
                  break;
                }
                case "FunctionExpression": {
                  functions.set(lvalue.identifier.id, value);
                  break;
                }
                case "MethodCall":
                case "CallExpression": {
                  var callee =
                    value.kind === "CallExpression"
                      ? value.callee.identifier.id
                      : value.property.identifier.id;
                  var isUseMemo = useMemos.has(callee);
                  if (!isUseMemo || value.args.length === 0) {
                    continue;
                  }
                  var _value$args = _slicedToArray(value.args, 1),
                    arg = _value$args[0];
                  if (arg.kind !== "Identifier") {
                    continue;
                  }
                  var body = functions.get(arg.identifier.id);
                  if (body === undefined) {
                    continue;
                  }
                  if (body.loweredFunc.func.params.length > 0) {
                    CompilerError.throwInvalidReact({
                      reason: "useMemo callbacks may not accept any arguments",
                      description: null,
                      loc: body.loc,
                      suggestions: null
                    });
                  }
                  if (
                    body.loweredFunc.func.async ||
                    body.loweredFunc.func.generator
                  ) {
                    CompilerError.throwInvalidReact({
                      reason:
                        "useMemo callbacks may not be async or generator functions",
                      description: null,
                      loc: body.loc,
                      suggestions: null
                    });
                  }
                  break;
                }
              }
            }
          } catch (err) {
            _iterator498.e(err);
          } finally {
            _iterator498.f();
          }
        }
      } catch (err) {
        _iterator497.e(err);
      } finally {
        _iterator497.f();
      }
    }
    function validateLocalsNotReassignedAfterRender(fn) {
      var contextVariables = new Set();
      var reassignment = getContextReassignment(
        fn,
        contextVariables,
        false,
        false
      );
      if (reassignment !== null) {
        CompilerError.throwInvalidReact({
          reason:
            "Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead",
          description:
            reassignment.identifier.name !== null &&
            reassignment.identifier.name.kind === "named"
              ? "Variable `".concat(
                  reassignment.identifier.name.value,
                  "` cannot be reassigned after render"
                )
              : "",
          loc: reassignment.loc
        });
      }
    }
    function getContextReassignment(
      fn,
      contextVariables,
      isFunctionExpression,
      isAsync
    ) {
      var reassigningFunctions = new Map();
      var _iterator499 = _createForOfIteratorHelper(fn.body.blocks),
        _step499;
      try {
        for (_iterator499.s(); !(_step499 = _iterator499.n()).done; ) {
          var _step499$value = _slicedToArray(_step499.value, 2),
            block = _step499$value[1];
          var _iterator500 = _createForOfIteratorHelper(block.instructions),
            _step500;
          try {
            for (_iterator500.s(); !(_step500 = _iterator500.n()).done; ) {
              var instr = _step500.value;
              var lvalue = instr.lvalue,
                value = instr.value;
              switch (value.kind) {
                case "FunctionExpression":
                case "ObjectMethod": {
                  var reassignment = getContextReassignment(
                    value.loweredFunc.func,
                    contextVariables,
                    true,
                    isAsync || value.loweredFunc.func.async
                  );
                  if (reassignment === null) {
                    var _iterator502 = _createForOfIteratorHelper(
                        eachInstructionValueOperand(value)
                      ),
                      _step502;
                    try {
                      for (
                        _iterator502.s();
                        !(_step502 = _iterator502.n()).done;

                      ) {
                        var operand = _step502.value;
                        var reassignmentFromOperand = reassigningFunctions.get(
                          operand.identifier.id
                        );
                        if (reassignmentFromOperand !== undefined) {
                          reassignment = reassignmentFromOperand;
                          break;
                        }
                      }
                    } catch (err) {
                      _iterator502.e(err);
                    } finally {
                      _iterator502.f();
                    }
                  }
                  if (reassignment !== null) {
                    if (isAsync || value.loweredFunc.func.async) {
                      CompilerError.throwInvalidReact({
                        reason:
                          "Reassigning a variable in an async function can cause inconsistent behavior on subsequent renders. Consider using state instead",
                        description:
                          reassignment.identifier.name !== null &&
                          reassignment.identifier.name.kind === "named"
                            ? "Variable `".concat(
                                reassignment.identifier.name.value,
                                "` cannot be reassigned after render"
                              )
                            : "",
                        loc: reassignment.loc
                      });
                    }
                    reassigningFunctions.set(
                      lvalue.identifier.id,
                      reassignment
                    );
                  }
                  break;
                }
                case "StoreLocal": {
                  var _reassignment = reassigningFunctions.get(
                    value.value.identifier.id
                  );
                  if (_reassignment !== undefined) {
                    reassigningFunctions.set(
                      value.lvalue.place.identifier.id,
                      _reassignment
                    );
                    reassigningFunctions.set(
                      lvalue.identifier.id,
                      _reassignment
                    );
                  }
                  break;
                }
                case "LoadLocal": {
                  var _reassignment2 = reassigningFunctions.get(
                    value.place.identifier.id
                  );
                  if (_reassignment2 !== undefined) {
                    reassigningFunctions.set(
                      lvalue.identifier.id,
                      _reassignment2
                    );
                  }
                  break;
                }
                case "DeclareContext": {
                  if (!isFunctionExpression) {
                    contextVariables.add(value.lvalue.place.identifier.id);
                  }
                  break;
                }
                case "StoreContext": {
                  if (isFunctionExpression) {
                    if (
                      contextVariables.has(value.lvalue.place.identifier.id)
                    ) {
                      return value.lvalue.place;
                    }
                  } else {
                    contextVariables.add(value.lvalue.place.identifier.id);
                  }
                  var _reassignment3 = reassigningFunctions.get(
                    value.value.identifier.id
                  );
                  if (_reassignment3 !== undefined) {
                    reassigningFunctions.set(
                      value.lvalue.place.identifier.id,
                      _reassignment3
                    );
                    reassigningFunctions.set(
                      lvalue.identifier.id,
                      _reassignment3
                    );
                  }
                  break;
                }
                default: {
                  var operands = eachInstructionValueOperand(value);
                  if (value.kind === "CallExpression") {
                    var signature = getFunctionCallSignature(
                      fn.env,
                      value.callee.identifier.type
                    );
                    if (
                      signature === null || signature === void 0
                        ? void 0
                        : signature.noAlias
                    ) {
                      operands = [value.callee];
                    }
                  } else if (value.kind === "MethodCall") {
                    var _signature5 = getFunctionCallSignature(
                      fn.env,
                      value.property.identifier.type
                    );
                    if (
                      _signature5 === null || _signature5 === void 0
                        ? void 0
                        : _signature5.noAlias
                    ) {
                      operands = [value.receiver, value.property];
                    }
                  } else if (value.kind === "TaggedTemplateExpression") {
                    var _signature6 = getFunctionCallSignature(
                      fn.env,
                      value.tag.identifier.type
                    );
                    if (
                      _signature6 === null || _signature6 === void 0
                        ? void 0
                        : _signature6.noAlias
                    ) {
                      operands = [value.tag];
                    }
                  }
                  var _iterator503 = _createForOfIteratorHelper(operands),
                    _step503;
                  try {
                    for (
                      _iterator503.s();
                      !(_step503 = _iterator503.n()).done;

                    ) {
                      var _operand44 = _step503.value;
                      CompilerError.invariant(
                        _operand44.effect !== Effect.Unknown,
                        {
                          reason:
                            "Expected effects to be inferred prior to ValidateLocalsNotReassignedAfterRender",
                          loc: _operand44.loc
                        }
                      );
                      var _reassignment4 = reassigningFunctions.get(
                        _operand44.identifier.id
                      );
                      if (_reassignment4 !== undefined) {
                        if (_operand44.effect === Effect.Freeze) {
                          return _reassignment4;
                        } else {
                          var _iterator504 = _createForOfIteratorHelper(
                              eachInstructionLValue(instr)
                            ),
                            _step504;
                          try {
                            for (
                              _iterator504.s();
                              !(_step504 = _iterator504.n()).done;

                            ) {
                              var lval = _step504.value;
                              reassigningFunctions.set(
                                lval.identifier.id,
                                _reassignment4
                              );
                            }
                          } catch (err) {
                            _iterator504.e(err);
                          } finally {
                            _iterator504.f();
                          }
                        }
                      }
                    }
                  } catch (err) {
                    _iterator503.e(err);
                  } finally {
                    _iterator503.f();
                  }
                  break;
                }
              }
            }
          } catch (err) {
            _iterator500.e(err);
          } finally {
            _iterator500.f();
          }
          var _iterator501 = _createForOfIteratorHelper(
              eachTerminalOperand(block.terminal)
            ),
            _step501;
          try {
            for (_iterator501.s(); !(_step501 = _iterator501.n()).done; ) {
              var _operand45 = _step501.value;
              var _reassignment5 = reassigningFunctions.get(
                _operand45.identifier.id
              );
              if (_reassignment5 !== undefined) {
                return _reassignment5;
              }
            }
          } catch (err) {
            _iterator501.e(err);
          } finally {
            _iterator501.f();
          }
        }
      } catch (err) {
        _iterator499.e(err);
      } finally {
        _iterator499.f();
      }
      return null;
    }
    function outlineFunctions(fn, fbtOperands) {
      var _iterator505 = _createForOfIteratorHelper(fn.body.blocks),
        _step505;
      try {
        for (_iterator505.s(); !(_step505 = _iterator505.n()).done; ) {
          var _step505$value = _slicedToArray(_step505.value, 2),
            block = _step505$value[1];
          var _iterator506 = _createForOfIteratorHelper(block.instructions),
            _step506;
          try {
            for (_iterator506.s(); !(_step506 = _iterator506.n()).done; ) {
              var instr = _step506.value;
              var value = instr.value,
                lvalue = instr.lvalue;
              if (
                value.kind === "FunctionExpression" ||
                value.kind === "ObjectMethod"
              ) {
                outlineFunctions(value.loweredFunc.func, fbtOperands);
              }
              if (
                value.kind === "FunctionExpression" &&
                value.loweredFunc.func.context.length === 0 &&
                value.loweredFunc.func.id === null &&
                !fbtOperands.has(lvalue.identifier.id)
              ) {
                var loweredFunc = value.loweredFunc.func;
                var id = fn.env.generateGloballyUniqueIdentifierName(
                  loweredFunc.id
                );
                loweredFunc.id = id.value;
                fn.env.outlineFunction(loweredFunc, null);
                instr.value = {
                  kind: "LoadGlobal",
                  binding: { kind: "Global", name: id.value },
                  loc: value.loc
                };
              }
            }
          } catch (err) {
            _iterator506.e(err);
          } finally {
            _iterator506.f();
          }
        }
      } catch (err) {
        _iterator505.e(err);
      } finally {
        _iterator505.f();
      }
    }
    function propagatePhiTypes(fn) {
      var propagated = new Set();
      var _iterator507 = _createForOfIteratorHelper(fn.body.blocks),
        _step507;
      try {
        for (_iterator507.s(); !(_step507 = _iterator507.n()).done; ) {
          var _step507$value = _slicedToArray(_step507.value, 2),
            block = _step507$value[1];
          var _iterator508 = _createForOfIteratorHelper(block.phis),
            _step508;
          try {
            for (_iterator508.s(); !(_step508 = _iterator508.n()).done; ) {
              var phi = _step508.value;
              if (
                phi.place.identifier.type.kind !== "Type" ||
                phi.place.identifier.name !== null
              ) {
                continue;
              }
              var type = null;
              var _iterator510 = _createForOfIteratorHelper(phi.operands),
                _step510;
              try {
                for (_iterator510.s(); !(_step510 = _iterator510.n()).done; ) {
                  var _step510$value = _slicedToArray(_step510.value, 2),
                    operand = _step510$value[1];
                  if (type === null) {
                    type = operand.identifier.type;
                  } else if (!typeEquals(type, operand.identifier.type)) {
                    type = null;
                    break;
                  }
                }
              } catch (err) {
                _iterator510.e(err);
              } finally {
                _iterator510.f();
              }
              if (type !== null) {
                phi.place.identifier.type = type;
                propagated.add(phi.place.identifier.id);
              }
            }
          } catch (err) {
            _iterator508.e(err);
          } finally {
            _iterator508.f();
          }
          var _iterator509 = _createForOfIteratorHelper(block.instructions),
            _step509;
          try {
            for (_iterator509.s(); !(_step509 = _iterator509.n()).done; ) {
              var instr = _step509.value;
              var value = instr.value;
              switch (value.kind) {
                case "StoreLocal": {
                  var lvalue = value.lvalue.place;
                  if (
                    propagated.has(value.value.identifier.id) &&
                    lvalue.identifier.type.kind === "Type" &&
                    lvalue.identifier.name === null
                  ) {
                    lvalue.identifier.type = value.value.identifier.type;
                    propagated.add(lvalue.identifier.id);
                  }
                }
              }
            }
          } catch (err) {
            _iterator509.e(err);
          } finally {
            _iterator509.f();
          }
        }
      } catch (err) {
        _iterator507.e(err);
      } finally {
        _iterator507.f();
      }
    }
    function lowerContextAccess(fn, loweredContextCallee) {
      var contextAccess = new Map();
      var contextKeys = new Map();
      var _iterator511 = _createForOfIteratorHelper(fn.body.blocks),
        _step511;
      try {
        for (_iterator511.s(); !(_step511 = _iterator511.n()).done; ) {
          var _step511$value = _slicedToArray(_step511.value, 2),
            _block19 = _step511$value[1];
          var _iterator513 = _createForOfIteratorHelper(_block19.instructions),
            _step513;
          try {
            for (_iterator513.s(); !(_step513 = _iterator513.n()).done; ) {
              var _instr10 = _step513.value;
              var _value25 = _instr10.value,
                _lvalue24 = _instr10.lvalue;
              if (
                _value25.kind === "CallExpression" &&
                isUseContextHookType(_value25.callee.identifier)
              ) {
                contextAccess.set(_lvalue24.identifier.id, _value25);
                continue;
              }
              if (_value25.kind !== "Destructure") {
                continue;
              }
              var destructureId = _value25.value.identifier.id;
              if (!contextAccess.has(destructureId)) {
                continue;
              }
              var _keys5 = getContextKeys(_value25);
              if (_keys5 === null) {
                return;
              }
              if (contextKeys.has(destructureId)) {
                return;
              } else {
                contextKeys.set(destructureId, _keys5);
              }
            }
          } catch (err) {
            _iterator513.e(err);
          } finally {
            _iterator513.f();
          }
        }
      } catch (err) {
        _iterator511.e(err);
      } finally {
        _iterator511.f();
      }
      if (contextAccess.size > 0 && contextKeys.size > 0) {
        var _iterator512 = _createForOfIteratorHelper(fn.body.blocks),
          _step512;
        try {
          for (_iterator512.s(); !(_step512 = _iterator512.n()).done; ) {
            var _step512$value = _slicedToArray(_step512.value, 2),
              block = _step512$value[1];
            var nextInstructions = null;
            for (var i = 0; i < block.instructions.length; i++) {
              var instr = block.instructions[i];
              var lvalue = instr.lvalue,
                value = instr.value;
              if (
                value.kind === "CallExpression" &&
                isUseContextHookType(value.callee.identifier) &&
                contextKeys.has(lvalue.identifier.id)
              ) {
                var loweredContextCalleeInstr = emitLoadLoweredContextCallee(
                  fn.env,
                  loweredContextCallee
                );
                if (nextInstructions === null) {
                  nextInstructions = block.instructions.slice(0, i);
                }
                nextInstructions.push(loweredContextCalleeInstr);
                var _keys4 = contextKeys.get(lvalue.identifier.id);
                var selectorFnInstr = emitSelectorFn(fn.env, _keys4);
                nextInstructions.push(selectorFnInstr);
                var lowerContextCallId = loweredContextCalleeInstr.lvalue;
                value.callee = lowerContextCallId;
                var selectorFn = selectorFnInstr.lvalue;
                value.args.push(selectorFn);
              }
              if (nextInstructions) {
                nextInstructions.push(instr);
              }
            }
            if (nextInstructions) {
              block.instructions = nextInstructions;
            }
          }
        } catch (err) {
          _iterator512.e(err);
        } finally {
          _iterator512.f();
        }
        markInstructionIds(fn.body);
        inferTypes(fn);
        fn.env.hasLoweredContextAccess = true;
      }
    }
    function emitLoadLoweredContextCallee(env, loweredContextCallee) {
      var loadGlobal = {
        kind: "LoadGlobal",
        binding: {
          kind: "ImportNamespace",
          module: loweredContextCallee.source,
          name: loweredContextCallee.importSpecifierName
        },
        loc: GeneratedSource
      };
      return {
        id: makeInstructionId(0),
        loc: GeneratedSource,
        lvalue: createTemporaryPlace(env, GeneratedSource),
        value: loadGlobal
      };
    }
    function getContextKeys(value) {
      var keys = [];
      var pattern = value.lvalue.pattern;
      switch (pattern.kind) {
        case "ArrayPattern": {
          return null;
        }
        case "ObjectPattern": {
          var _iterator514 = _createForOfIteratorHelper(pattern.properties),
            _step514;
          try {
            for (_iterator514.s(); !(_step514 = _iterator514.n()).done; ) {
              var place = _step514.value;
              if (
                place.kind !== "ObjectProperty" ||
                place.type !== "property" ||
                place.key.kind !== "identifier" ||
                place.place.identifier.name === null ||
                place.place.identifier.name.kind !== "named"
              ) {
                return null;
              }
              keys.push(place.key.name);
            }
          } catch (err) {
            _iterator514.e(err);
          } finally {
            _iterator514.f();
          }
          return keys;
        }
      }
    }
    function emitPropertyLoad(env, obj, property) {
      var loadObj = { kind: "LoadLocal", place: obj, loc: GeneratedSource };
      var object = createTemporaryPlace(env, GeneratedSource);
      var loadLocalInstr = {
        lvalue: object,
        value: loadObj,
        id: makeInstructionId(0),
        loc: GeneratedSource
      };
      var loadProp = {
        kind: "PropertyLoad",
        object: object,
        property: makePropertyLiteral(property),
        loc: GeneratedSource
      };
      var element = createTemporaryPlace(env, GeneratedSource);
      var loadPropInstr = {
        lvalue: element,
        value: loadProp,
        id: makeInstructionId(0),
        loc: GeneratedSource
      };
      return {
        instructions: [loadLocalInstr, loadPropInstr],
        element: element
      };
    }
    function emitSelectorFn(env, keys) {
      var obj = createTemporaryPlace(env, GeneratedSource);
      promoteTemporary(obj.identifier);
      var instr = [];
      var elements = [];
      var _iterator515 = _createForOfIteratorHelper(keys),
        _step515;
      try {
        for (_iterator515.s(); !(_step515 = _iterator515.n()).done; ) {
          var _key41 = _step515.value;
          var _emitPropertyLoad = emitPropertyLoad(env, obj, _key41),
            instructions = _emitPropertyLoad.instructions,
            prop = _emitPropertyLoad.element;
          instr.push.apply(instr, _toConsumableArray(instructions));
          elements.push(prop);
        }
      } catch (err) {
        _iterator515.e(err);
      } finally {
        _iterator515.f();
      }
      var arrayInstr = emitArrayInstr(elements, env);
      instr.push(arrayInstr);
      var block = {
        kind: "block",
        id: makeBlockId(0),
        instructions: instr,
        terminal: {
          id: makeInstructionId(0),
          kind: "return",
          loc: GeneratedSource,
          value: arrayInstr.lvalue
        },
        preds: new Set(),
        phis: new Set()
      };
      var fn = {
        loc: GeneratedSource,
        id: null,
        fnType: "Other",
        env: env,
        params: [obj],
        returnTypeAnnotation: null,
        returnType: makeType(),
        context: [],
        effects: null,
        body: { entry: block.id, blocks: new Map([[block.id, block]]) },
        generator: false,
        async: false,
        directives: []
      };
      reversePostorderBlocks(fn.body);
      markInstructionIds(fn.body);
      enterSSA(fn);
      inferTypes(fn);
      var fnInstr = {
        id: makeInstructionId(0),
        value: {
          kind: "FunctionExpression",
          name: null,
          loweredFunc: { func: fn },
          type: "ArrowFunctionExpression",
          loc: GeneratedSource
        },
        lvalue: createTemporaryPlace(env, GeneratedSource),
        loc: GeneratedSource
      };
      return fnInstr;
    }
    function emitArrayInstr(elements, env) {
      var array = {
        kind: "ArrayExpression",
        elements: elements,
        loc: GeneratedSource
      };
      var arrayLvalue = createTemporaryPlace(env, GeneratedSource);
      var arrayInstr = {
        id: makeInstructionId(0),
        value: array,
        lvalue: arrayLvalue,
        loc: GeneratedSource
      };
      return arrayInstr;
    }
    function validateNoSetStateInPassiveEffects(fn) {
      var setStateFunctions = new Map();
      var errors = new CompilerError();
      var _iterator516 = _createForOfIteratorHelper(fn.body.blocks),
        _step516;
      try {
        for (_iterator516.s(); !(_step516 = _iterator516.n()).done; ) {
          var _step516$value = _slicedToArray(_step516.value, 2),
            block = _step516$value[1];
          var _iterator517 = _createForOfIteratorHelper(block.instructions),
            _step517;
          try {
            for (_iterator517.s(); !(_step517 = _iterator517.n()).done; ) {
              var instr = _step517.value;
              switch (instr.value.kind) {
                case "LoadLocal": {
                  if (setStateFunctions.has(instr.value.place.identifier.id)) {
                    setStateFunctions.set(
                      instr.lvalue.identifier.id,
                      instr.value.place
                    );
                  }
                  break;
                }
                case "StoreLocal": {
                  if (setStateFunctions.has(instr.value.value.identifier.id)) {
                    setStateFunctions.set(
                      instr.value.lvalue.place.identifier.id,
                      instr.value.value
                    );
                    setStateFunctions.set(
                      instr.lvalue.identifier.id,
                      instr.value.value
                    );
                  }
                  break;
                }
                case "FunctionExpression": {
                  if (
                    _toConsumableArray(
                      eachInstructionValueOperand(instr.value)
                    ).some(function (operand) {
                      return (
                        isSetStateType(operand.identifier) ||
                        setStateFunctions.has(operand.identifier.id)
                      );
                    })
                  ) {
                    var callee = getSetStateCall(
                      instr.value.loweredFunc.func,
                      setStateFunctions
                    );
                    if (callee !== null) {
                      setStateFunctions.set(instr.lvalue.identifier.id, callee);
                    }
                  }
                  break;
                }
                case "MethodCall":
                case "CallExpression": {
                  var _callee5 =
                    instr.value.kind === "MethodCall"
                      ? instr.value.receiver
                      : instr.value.callee;
                  if (isUseEffectHookType(_callee5.identifier)) {
                    var arg = instr.value.args[0];
                    if (arg !== undefined && arg.kind === "Identifier") {
                      var setState = setStateFunctions.get(arg.identifier.id);
                      if (setState !== undefined) {
                        errors.push({
                          reason:
                            "Calling setState directly within a useEffect causes cascading renders and is not recommended. Consider alternatives to useEffect. (https://react.dev/learn/you-might-not-need-an-effect)",
                          description: null,
                          severity: ErrorSeverity.InvalidReact,
                          loc: setState.loc,
                          suggestions: null
                        });
                      }
                    }
                  }
                  break;
                }
              }
            }
          } catch (err) {
            _iterator517.e(err);
          } finally {
            _iterator517.f();
          }
        }
      } catch (err) {
        _iterator516.e(err);
      } finally {
        _iterator516.f();
      }
      if (errors.hasErrors()) {
        throw errors;
      }
    }
    function getSetStateCall(fn, setStateFunctions) {
      var _iterator518 = _createForOfIteratorHelper(fn.body.blocks),
        _step518;
      try {
        for (_iterator518.s(); !(_step518 = _iterator518.n()).done; ) {
          var _step518$value = _slicedToArray(_step518.value, 2),
            block = _step518$value[1];
          var _iterator519 = _createForOfIteratorHelper(block.instructions),
            _step519;
          try {
            for (_iterator519.s(); !(_step519 = _iterator519.n()).done; ) {
              var instr = _step519.value;
              switch (instr.value.kind) {
                case "LoadLocal": {
                  if (setStateFunctions.has(instr.value.place.identifier.id)) {
                    setStateFunctions.set(
                      instr.lvalue.identifier.id,
                      instr.value.place
                    );
                  }
                  break;
                }
                case "StoreLocal": {
                  if (setStateFunctions.has(instr.value.value.identifier.id)) {
                    setStateFunctions.set(
                      instr.value.lvalue.place.identifier.id,
                      instr.value.value
                    );
                    setStateFunctions.set(
                      instr.lvalue.identifier.id,
                      instr.value.value
                    );
                  }
                  break;
                }
                case "CallExpression": {
                  var callee = instr.value.callee;
                  if (
                    isSetStateType(callee.identifier) ||
                    setStateFunctions.has(callee.identifier.id)
                  ) {
                    return callee;
                  }
                }
              }
            }
          } catch (err) {
            _iterator519.e(err);
          } finally {
            _iterator519.f();
          }
        }
      } catch (err) {
        _iterator518.e(err);
      } finally {
        _iterator518.f();
      }
      return null;
    }
    function validateNoJSXInTryStatement(fn) {
      var activeTryBlocks = [];
      var errors = new CompilerError();
      var _iterator520 = _createForOfIteratorHelper(fn.body.blocks),
        _step520;
      try {
        var _loop15 = function _loop15() {
          var _step520$value = _slicedToArray(_step520.value, 2),
            block = _step520$value[1];
          retainWhere(activeTryBlocks, function (id) {
            return id !== block.id;
          });
          if (activeTryBlocks.length !== 0) {
            var _iterator521 = _createForOfIteratorHelper(block.instructions),
              _step521;
            try {
              for (_iterator521.s(); !(_step521 = _iterator521.n()).done; ) {
                var instr = _step521.value;
                var value = instr.value;
                switch (value.kind) {
                  case "JsxExpression":
                  case "JsxFragment": {
                    errors.push({
                      severity: ErrorSeverity.InvalidReact,
                      reason:
                        "Unexpected JSX element within a try statement. To catch errors in rendering a given component, wrap that component in an error boundary. (https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)",
                      loc: value.loc
                    });
                    break;
                  }
                }
              }
            } catch (err) {
              _iterator521.e(err);
            } finally {
              _iterator521.f();
            }
          }
          if (block.terminal.kind === "try") {
            activeTryBlocks.push(block.terminal.handler);
          }
        };
        for (_iterator520.s(); !(_step520 = _iterator520.n()).done; ) {
          _loop15();
        }
      } catch (err) {
        _iterator520.e(err);
      } finally {
        _iterator520.f();
      }
      if (errors.hasErrors()) {
        throw errors;
      }
    }
    function collectHoistablePropertyLoads(
      fn,
      temporaries,
      hoistableFromOptionals
    ) {
      var registry = new PropertyPathRegistry();
      var knownImmutableIdentifiers = new Set();
      if (fn.fnType === "Component" || fn.fnType === "Hook") {
        var _iterator522 = _createForOfIteratorHelper(fn.params),
          _step522;
        try {
          for (_iterator522.s(); !(_step522 = _iterator522.n()).done; ) {
            var p = _step522.value;
            if (p.kind === "Identifier") {
              knownImmutableIdentifiers.add(p.identifier.id);
            }
          }
        } catch (err) {
          _iterator522.e(err);
        } finally {
          _iterator522.f();
        }
      }
      return collectHoistablePropertyLoadsImpl(fn, {
        temporaries: temporaries,
        knownImmutableIdentifiers: knownImmutableIdentifiers,
        hoistableFromOptionals: hoistableFromOptionals,
        registry: registry,
        nestedFnImmutableContext: null
      });
    }
    function collectHoistablePropertyLoadsImpl(fn, context) {
      var nodes = collectNonNullsInBlocks(fn, context);
      propagateNonNull(fn, nodes, context.registry);
      return nodes;
    }
    function keyByScopeId(fn, source) {
      var keyedByScopeId = new Map();
      var _iterator523 = _createForOfIteratorHelper(fn.body.blocks),
        _step523;
      try {
        for (_iterator523.s(); !(_step523 = _iterator523.n()).done; ) {
          var _step523$value = _slicedToArray(_step523.value, 2),
            _ = _step523$value[0],
            block = _step523$value[1];
          if (block.terminal.kind === "scope") {
            keyedByScopeId.set(
              block.terminal.scope.id,
              source.get(block.terminal.block)
            );
          }
        }
      } catch (err) {
        _iterator523.e(err);
      } finally {
        _iterator523.f();
      }
      return keyedByScopeId;
    }
    var PropertyPathRegistry = /*#__PURE__*/ (function () {
      function PropertyPathRegistry() {
        _classCallCheck(this, PropertyPathRegistry);
        this.roots = new Map();
      }
      return _createClass(
        PropertyPathRegistry,
        [
          {
            key: "getOrCreateIdentifier",
            value: function getOrCreateIdentifier(identifier) {
              var rootNode = this.roots.get(identifier.id);
              if (rootNode === undefined) {
                rootNode = {
                  root: identifier.id,
                  properties: new Map(),
                  optionalProperties: new Map(),
                  fullPath: { identifier: identifier, path: [] },
                  hasOptional: false,
                  parent: null
                };
                this.roots.set(identifier.id, rootNode);
              }
              return rootNode;
            }
          },
          {
            key: "getOrCreateProperty",
            value: function getOrCreateProperty(n) {
              var currNode = this.getOrCreateIdentifier(n.identifier);
              if (n.path.length === 0) {
                return currNode;
              }
              for (var i = 0; i < n.path.length - 1; i++) {
                currNode = PropertyPathRegistry.getOrCreatePropertyEntry(
                  currNode,
                  n.path[i]
                );
              }
              return PropertyPathRegistry.getOrCreatePropertyEntry(
                currNode,
                n.path.at(-1)
              );
            }
          }
        ],
        [
          {
            key: "getOrCreatePropertyEntry",
            value: function getOrCreatePropertyEntry(parent, entry) {
              var map = entry.optional
                ? parent.optionalProperties
                : parent.properties;
              var child = map.get(entry.property);
              if (child == null) {
                child = {
                  properties: new Map(),
                  optionalProperties: new Map(),
                  parent: parent,
                  fullPath: {
                    identifier: parent.fullPath.identifier,
                    path: parent.fullPath.path.concat(entry)
                  },
                  hasOptional: parent.hasOptional || entry.optional
                };
                map.set(entry.property, child);
              }
              return child;
            }
          }
        ]
      );
    })();
    function getMaybeNonNullInInstruction(instr, context) {
      var _a, _b, _c;
      var path = null;
      if (instr.kind === "PropertyLoad") {
        path =
          (_a = context.temporaries.get(instr.object.identifier.id)) !== null &&
          _a !== void 0
            ? _a
            : { identifier: instr.object.identifier, path: [] };
      } else if (instr.kind === "Destructure") {
        path =
          (_b = context.temporaries.get(instr.value.identifier.id)) !== null &&
          _b !== void 0
            ? _b
            : null;
      } else if (instr.kind === "ComputedLoad") {
        path =
          (_c = context.temporaries.get(instr.object.identifier.id)) !== null &&
          _c !== void 0
            ? _c
            : null;
      }
      return path != null ? context.registry.getOrCreateProperty(path) : null;
    }
    function isImmutableAtInstr(identifier, instr, context) {
      if (context.nestedFnImmutableContext != null) {
        return context.nestedFnImmutableContext.has(identifier.id);
      } else {
        var mutableAtInstr =
          identifier.mutableRange.end > identifier.mutableRange.start + 1 &&
          identifier.scope != null &&
          inRange({ id: instr }, identifier.scope.range);
        return (
          !mutableAtInstr ||
          context.knownImmutableIdentifiers.has(identifier.id)
        );
      }
    }
    function collectNonNullsInBlocks(fn, context) {
      var _a;
      var knownNonNullIdentifiers = new Set();
      if (
        fn.fnType === "Component" &&
        fn.params.length > 0 &&
        fn.params[0].kind === "Identifier"
      ) {
        var _identifier20 = fn.params[0].identifier;
        knownNonNullIdentifiers.add(
          context.registry.getOrCreateIdentifier(_identifier20)
        );
      }
      var nodes = new Map();
      var _iterator524 = _createForOfIteratorHelper(fn.body.blocks),
        _step524;
      try {
        for (_iterator524.s(); !(_step524 = _iterator524.n()).done; ) {
          var _step524$value = _slicedToArray(_step524.value, 2),
            _ = _step524$value[0],
            block = _step524$value[1];
          var assumedNonNullObjects = new Set(knownNonNullIdentifiers);
          var maybeOptionalChain = context.hoistableFromOptionals.get(block.id);
          if (maybeOptionalChain != null) {
            assumedNonNullObjects.add(
              context.registry.getOrCreateProperty(maybeOptionalChain)
            );
          }
          var _iterator525 = _createForOfIteratorHelper(block.instructions),
            _step525;
          try {
            var _loop16 = function _loop16() {
              var instr = _step525.value;
              var maybeNonNull = getMaybeNonNullInInstruction(
                instr.value,
                context
              );
              if (
                maybeNonNull != null &&
                isImmutableAtInstr(
                  maybeNonNull.fullPath.identifier,
                  instr.id,
                  context
                )
              ) {
                assumedNonNullObjects.add(maybeNonNull);
              }
              if (
                (instr.value.kind === "FunctionExpression" ||
                  instr.value.kind === "ObjectMethod") &&
                !fn.env.config.enableTreatFunctionDepsAsConditional
              ) {
                var innerFn = instr.value.loweredFunc;
                var innerHoistableMap = collectHoistablePropertyLoadsImpl(
                  innerFn.func,
                  Object.assign(Object.assign({}, context), {
                    nestedFnImmutableContext:
                      (_a = context.nestedFnImmutableContext) !== null &&
                      _a !== void 0
                        ? _a
                        : new Set(
                            innerFn.func.context
                              .filter(function (place) {
                                return isImmutableAtInstr(
                                  place.identifier,
                                  instr.id,
                                  context
                                );
                              })
                              .map(function (place) {
                                return place.identifier.id;
                              })
                          )
                  })
                );
                var innerHoistables = assertNonNull(
                  innerHoistableMap.get(innerFn.func.body.entry)
                );
                var _iterator526 = _createForOfIteratorHelper(
                    innerHoistables.assumedNonNullObjects
                  ),
                  _step526;
                try {
                  for (
                    _iterator526.s();
                    !(_step526 = _iterator526.n()).done;

                  ) {
                    var entry = _step526.value;
                    assumedNonNullObjects.add(entry);
                  }
                } catch (err) {
                  _iterator526.e(err);
                } finally {
                  _iterator526.f();
                }
              }
            };
            for (_iterator525.s(); !(_step525 = _iterator525.n()).done; ) {
              _loop16();
            }
          } catch (err) {
            _iterator525.e(err);
          } finally {
            _iterator525.f();
          }
          nodes.set(block.id, {
            block: block,
            assumedNonNullObjects: assumedNonNullObjects
          });
        }
      } catch (err) {
        _iterator524.e(err);
      } finally {
        _iterator524.f();
      }
      return nodes;
    }
    function propagateNonNull(fn, nodes, registry) {
      var blockSuccessors = new Map();
      var terminalPreds = new Set();
      var _iterator527 = _createForOfIteratorHelper(fn.body.blocks),
        _step527;
      try {
        for (_iterator527.s(); !(_step527 = _iterator527.n()).done; ) {
          var _step527$value = _slicedToArray(_step527.value, 2),
            _blockId3 = _step527$value[0],
            block = _step527$value[1];
          var _iterator530 = _createForOfIteratorHelper(block.preds),
            _step530;
          try {
            for (_iterator530.s(); !(_step530 = _iterator530.n()).done; ) {
              var pred = _step530.value;
              getOrInsertDefault(blockSuccessors, pred, new Set()).add(
                _blockId3
              );
            }
          } catch (err) {
            _iterator530.e(err);
          } finally {
            _iterator530.f();
          }
          if (
            block.terminal.kind === "throw" ||
            block.terminal.kind === "return"
          ) {
            terminalPreds.add(_blockId3);
          }
        }
      } catch (err) {
        _iterator527.e(err);
      } finally {
        _iterator527.f();
      }
      function recursivelyPropagateNonNull(nodeId, direction, traversalState) {
        var _a;
        if (traversalState.has(nodeId)) {
          return false;
        }
        traversalState.set(nodeId, "active");
        var node = nodes.get(nodeId);
        if (node == null) {
          CompilerError.invariant(false, {
            reason: "Bad node ".concat(nodeId, ", kind: ").concat(direction),
            loc: GeneratedSource
          });
        }
        var neighbors = Array.from(
          direction === "backward"
            ? (_a = blockSuccessors.get(nodeId)) !== null && _a !== void 0
              ? _a
              : []
            : node.block.preds
        );
        var changed = false;
        for (
          var _i43 = 0, _neighbors = neighbors;
          _i43 < _neighbors.length;
          _i43++
        ) {
          var pred = _neighbors[_i43];
          if (!traversalState.has(pred)) {
            var neighborChanged = recursivelyPropagateNonNull(
              pred,
              direction,
              traversalState
            );
            changed || (changed = neighborChanged);
          }
        }
        var neighborAccesses = Set_intersect(
          Array.from(neighbors)
            .filter(function (n) {
              return traversalState.get(n) === "done";
            })
            .map(function (n) {
              return assertNonNull(nodes.get(n)).assumedNonNullObjects;
            })
        );
        var prevObjects = assertNonNull(
          nodes.get(nodeId)
        ).assumedNonNullObjects;
        var mergedObjects = Set_union(prevObjects, neighborAccesses);
        reduceMaybeOptionalChains(mergedObjects, registry);
        assertNonNull(nodes.get(nodeId)).assumedNonNullObjects = mergedObjects;
        traversalState.set(nodeId, "done");
        changed || (changed = !Set_equal(prevObjects, mergedObjects));
        return changed;
      }
      var traversalState = new Map();
      var reversedBlocks = _toConsumableArray(fn.body.blocks);
      reversedBlocks.reverse();
      var changed;
      var i = 0;
      do {
        CompilerError.invariant(i++ < 100, {
          reason:
            "[CollectHoistablePropertyLoads] fixed point iteration did not terminate after 100 loops",
          loc: GeneratedSource
        });
        changed = false;
        var _iterator528 = _createForOfIteratorHelper(fn.body.blocks),
          _step528;
        try {
          for (_iterator528.s(); !(_step528 = _iterator528.n()).done; ) {
            var _step528$value = _slicedToArray(_step528.value, 1),
              blockId = _step528$value[0];
            var forwardChanged = recursivelyPropagateNonNull(
              blockId,
              "forward",
              traversalState
            );
            changed || (changed = forwardChanged);
          }
        } catch (err) {
          _iterator528.e(err);
        } finally {
          _iterator528.f();
        }
        traversalState.clear();
        var _iterator529 = _createForOfIteratorHelper(reversedBlocks),
          _step529;
        try {
          for (_iterator529.s(); !(_step529 = _iterator529.n()).done; ) {
            var _step529$value = _slicedToArray(_step529.value, 1),
              _blockId2 = _step529$value[0];
            var backwardChanged = recursivelyPropagateNonNull(
              _blockId2,
              "backward",
              traversalState
            );
            changed || (changed = backwardChanged);
          }
        } catch (err) {
          _iterator529.e(err);
        } finally {
          _iterator529.f();
        }
        traversalState.clear();
      } while (changed);
    }
    function assertNonNull(value, source) {
      CompilerError.invariant(value != null, {
        reason: "Unexpected null",
        description: source != null ? "(from ".concat(source, ")") : null,
        loc: GeneratedSource
      });
      return value;
    }
    function reduceMaybeOptionalChains(nodes, registry) {
      var optionalChainNodes = Set_filter(nodes, function (n) {
        return n.hasOptional;
      });
      if (optionalChainNodes.size === 0) {
        return;
      }
      var changed;
      do {
        changed = false;
        var _iterator531 = _createForOfIteratorHelper(optionalChainNodes),
          _step531;
        try {
          for (_iterator531.s(); !(_step531 = _iterator531.n()).done; ) {
            var original = _step531.value;
            var _original$fullPath = original.fullPath,
              _identifier21 = _original$fullPath.identifier,
              origPath = _original$fullPath.path;
            var currNode = registry.getOrCreateIdentifier(_identifier21);
            for (var i = 0; i < origPath.length; i++) {
              var entry = origPath[i];
              var nextEntry =
                entry.optional && nodes.has(currNode)
                  ? { property: entry.property, optional: false }
                  : entry;
              currNode = PropertyPathRegistry.getOrCreatePropertyEntry(
                currNode,
                nextEntry
              );
            }
            if (currNode !== original) {
              changed = true;
              optionalChainNodes["delete"](original);
              optionalChainNodes.add(currNode);
              nodes["delete"](original);
              nodes.add(currNode);
            }
          }
        } catch (err) {
          _iterator531.e(err);
        } finally {
          _iterator531.f();
        }
      } while (changed);
    }
    var _Node_value, _Node_next;
    function empty() {
      return EMPTY;
    }
    var Node = /*#__PURE__*/ (function () {
      function Node(value) {
        var next =
          arguments.length > 1 && arguments[1] !== undefined
            ? arguments[1]
            : EMPTY;
        _classCallCheck(this, Node);
        _Node_value.set(this, void 0);
        _Node_next.set(this, void 0);
        __classPrivateFieldSet(this, _Node_value, value, "f");
        __classPrivateFieldSet(this, _Node_next, next, "f");
      }
      return _createClass(Node, [
        {
          key: "push",
          value: function push(value) {
            return new Node(value, this);
          }
        },
        {
          key: "pop",
          value: function pop() {
            return __classPrivateFieldGet(this, _Node_next, "f");
          }
        },
        {
          key: "find",
          value: function find(fn) {
            return fn(__classPrivateFieldGet(this, _Node_value, "f"))
              ? true
              : __classPrivateFieldGet(this, _Node_next, "f").find(fn);
          }
        },
        {
          key: "contains",
          value: function contains(value) {
            return (
              value === __classPrivateFieldGet(this, _Node_value, "f") ||
              (__classPrivateFieldGet(this, _Node_next, "f") !== null &&
                __classPrivateFieldGet(this, _Node_next, "f").contains(value))
            );
          }
        },
        {
          key: "each",
          value: function each(fn) {
            fn(__classPrivateFieldGet(this, _Node_value, "f"));
            __classPrivateFieldGet(this, _Node_next, "f").each(fn);
          }
        },
        {
          key: "value",
          get: function get() {
            return __classPrivateFieldGet(this, _Node_value, "f");
          }
        },
        {
          key: "print",
          value: function print(fn) {
            return (
              fn(__classPrivateFieldGet(this, _Node_value, "f")) +
              __classPrivateFieldGet(this, _Node_next, "f").print(fn)
            );
          }
        }
      ]);
    })();
    (_Node_value = new WeakMap()), (_Node_next = new WeakMap());
    var Empty = /*#__PURE__*/ (function () {
      function Empty() {
        _classCallCheck(this, Empty);
      }
      return _createClass(Empty, [
        {
          key: "push",
          value: function push(value) {
            return new Node(value, this);
          }
        },
        {
          key: "pop",
          value: function pop() {
            return this;
          }
        },
        {
          key: "find",
          value: function find(_fn) {
            return false;
          }
        },
        {
          key: "contains",
          value: function contains(_value) {
            return false;
          }
        },
        {
          key: "each",
          value: function each(_fn) {
            return;
          }
        },
        {
          key: "value",
          get: function get() {
            return null;
          }
        },
        {
          key: "print",
          value: function print(_) {
            return "";
          }
        }
      ]);
    })();
    var EMPTY = new Empty();
    var _a,
      _ReactiveScopeDependencyTreeHIR_hoistableObjects,
      _ReactiveScopeDependencyTreeHIR_deps,
      _ReactiveScopeDependencyTreeHIR_getOrCreateRoot,
      _ReactiveScopeDependencyTreeHIR_debugImpl;
    var ReactiveScopeDependencyTreeHIR = /*#__PURE__*/ (function () {
      function ReactiveScopeDependencyTreeHIR(hoistableObjects) {
        _classCallCheck(this, ReactiveScopeDependencyTreeHIR);
        var _b;
        _ReactiveScopeDependencyTreeHIR_hoistableObjects.set(this, new Map());
        _ReactiveScopeDependencyTreeHIR_deps.set(this, new Map());
        var _iterator532 = _createForOfIteratorHelper(hoistableObjects),
          _step532;
        try {
          for (_iterator532.s(); !(_step532 = _iterator532.n()).done; ) {
            var _step532$value = _step532.value,
              path = _step532$value.path,
              _identifier22 = _step532$value.identifier;
            var currNode = __classPrivateFieldGet(
              _a,
              _a,
              "m",
              _ReactiveScopeDependencyTreeHIR_getOrCreateRoot
            ).call(
              _a,
              _identifier22,
              __classPrivateFieldGet(
                this,
                _ReactiveScopeDependencyTreeHIR_hoistableObjects,
                "f"
              ),
              path.length > 0 && path[0].optional ? "Optional" : "NonNull"
            );
            for (var i = 0; i < path.length; i++) {
              var prevAccessType =
                (_b = currNode.properties.get(path[i].property)) === null ||
                _b === void 0
                  ? void 0
                  : _b.accessType;
              var accessType =
                i + 1 < path.length && path[i + 1].optional
                  ? "Optional"
                  : "NonNull";
              CompilerError.invariant(
                prevAccessType == null || prevAccessType === accessType,
                { reason: "Conflicting access types", loc: GeneratedSource }
              );
              var nextNode = currNode.properties.get(path[i].property);
              if (nextNode == null) {
                nextNode = { properties: new Map(), accessType: accessType };
                currNode.properties.set(path[i].property, nextNode);
              }
              currNode = nextNode;
            }
          }
        } catch (err) {
          _iterator532.e(err);
        } finally {
          _iterator532.f();
        }
      }
      return _createClass(
        ReactiveScopeDependencyTreeHIR,
        [
          {
            key: "addDependency",
            value: function addDependency(dep) {
              var identifier = dep.identifier,
                path = dep.path;
              var depCursor = __classPrivateFieldGet(
                _a,
                _a,
                "m",
                _ReactiveScopeDependencyTreeHIR_getOrCreateRoot
              ).call(
                _a,
                identifier,
                __classPrivateFieldGet(
                  this,
                  _ReactiveScopeDependencyTreeHIR_deps,
                  "f"
                ),
                PropertyAccessType.UnconditionalAccess
              );
              var hoistableCursor = __classPrivateFieldGet(
                this,
                _ReactiveScopeDependencyTreeHIR_hoistableObjects,
                "f"
              ).get(identifier);
              var _iterator533 = _createForOfIteratorHelper(path),
                _step533;
              try {
                for (_iterator533.s(); !(_step533 = _iterator533.n()).done; ) {
                  var entry = _step533.value;
                  var nextHoistableCursor = void 0;
                  var nextDepCursor = void 0;
                  if (entry.optional) {
                    if (hoistableCursor != null) {
                      nextHoistableCursor =
                        hoistableCursor === null || hoistableCursor === void 0
                          ? void 0
                          : hoistableCursor.properties.get(entry.property);
                    }
                    var accessType = void 0;
                    if (
                      hoistableCursor != null &&
                      hoistableCursor.accessType === "NonNull"
                    ) {
                      accessType = PropertyAccessType.UnconditionalAccess;
                    } else {
                      accessType = PropertyAccessType.OptionalAccess;
                    }
                    nextDepCursor = makeOrMergeProperty(
                      depCursor,
                      entry.property,
                      accessType
                    );
                  } else if (
                    hoistableCursor != null &&
                    hoistableCursor.accessType === "NonNull"
                  ) {
                    nextHoistableCursor = hoistableCursor.properties.get(
                      entry.property
                    );
                    nextDepCursor = makeOrMergeProperty(
                      depCursor,
                      entry.property,
                      PropertyAccessType.UnconditionalAccess
                    );
                  } else {
                    break;
                  }
                  depCursor = nextDepCursor;
                  hoistableCursor = nextHoistableCursor;
                }
              } catch (err) {
                _iterator533.e(err);
              } finally {
                _iterator533.f();
              }
              depCursor.accessType = merge(
                depCursor.accessType,
                PropertyAccessType.OptionalDependency
              );
            }
          },
          {
            key: "deriveMinimalDependencies",
            value: function deriveMinimalDependencies() {
              var results = new Set();
              var _iterator534 = _createForOfIteratorHelper(
                  __classPrivateFieldGet(
                    this,
                    _ReactiveScopeDependencyTreeHIR_deps,
                    "f"
                  ).entries()
                ),
                _step534;
              try {
                for (_iterator534.s(); !(_step534 = _iterator534.n()).done; ) {
                  var _step534$value = _slicedToArray(_step534.value, 2),
                    rootId = _step534$value[0],
                    rootNode = _step534$value[1];
                  collectMinimalDependenciesInSubtree(
                    rootNode,
                    rootId,
                    [],
                    results
                  );
                }
              } catch (err) {
                _iterator534.e(err);
              } finally {
                _iterator534.f();
              }
              return results;
            }
          },
          {
            key: "printDeps",
            value: function printDeps(includeAccesses) {
              var res = [];
              var _iterator535 = _createForOfIteratorHelper(
                  __classPrivateFieldGet(
                    this,
                    _ReactiveScopeDependencyTreeHIR_deps,
                    "f"
                  ).entries()
                ),
                _step535;
              try {
                var _loop17 = function _loop17() {
                  var _step535$value = _slicedToArray(_step535.value, 2),
                    rootId = _step535$value[0],
                    rootNode = _step535$value[1];
                  var rootResults = printSubtree(rootNode, includeAccesses).map(
                    function (result) {
                      return ""
                        .concat(printIdentifier(rootId), ".")
                        .concat(result);
                    }
                  );
                  res.push(rootResults);
                };
                for (_iterator535.s(); !(_step535 = _iterator535.n()).done; ) {
                  _loop17();
                }
              } catch (err) {
                _iterator535.e(err);
              } finally {
                _iterator535.f();
              }
              return res.flat().join("\n");
            }
          }
        ],
        [
          {
            key: "debug",
            value: function debug(roots) {
              var buf = ["tree() ["];
              var _iterator536 = _createForOfIteratorHelper(roots),
                _step536;
              try {
                for (_iterator536.s(); !(_step536 = _iterator536.n()).done; ) {
                  var _step536$value = _slicedToArray(_step536.value, 2),
                    rootId = _step536$value[0],
                    rootNode = _step536$value[1];
                  buf.push(
                    ""
                      .concat(printIdentifier(rootId), " (")
                      .concat(rootNode.accessType, "):")
                  );
                  __classPrivateFieldGet(
                    this,
                    _a,
                    "m",
                    _ReactiveScopeDependencyTreeHIR_debugImpl
                  ).call(this, buf, rootNode, 1);
                }
              } catch (err) {
                _iterator536.e(err);
              } finally {
                _iterator536.f();
              }
              buf.push("]");
              return buf.length > 2 ? buf.join("\n") : buf.join("");
            }
          }
        ]
      );
    })();
    (_a = ReactiveScopeDependencyTreeHIR),
      (_ReactiveScopeDependencyTreeHIR_hoistableObjects = new WeakMap()),
      (_ReactiveScopeDependencyTreeHIR_deps = new WeakMap()),
      (_ReactiveScopeDependencyTreeHIR_getOrCreateRoot =
        function _ReactiveScopeDependencyTreeHIR_getOrCreateRoot(
          identifier,
          roots,
          defaultAccessType
        ) {
          var rootNode = roots.get(identifier);
          if (rootNode === undefined) {
            rootNode = { properties: new Map(), accessType: defaultAccessType };
            roots.set(identifier, rootNode);
          }
          return rootNode;
        }),
      (_ReactiveScopeDependencyTreeHIR_debugImpl =
        function _ReactiveScopeDependencyTreeHIR_debugImpl(buf, node) {
          var depth =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : 0;
          var _iterator537 = _createForOfIteratorHelper(node.properties),
            _step537;
          try {
            for (_iterator537.s(); !(_step537 = _iterator537.n()).done; ) {
              var _step537$value = _slicedToArray(_step537.value, 2),
                property = _step537$value[0],
                childNode = _step537$value[1];
              buf.push(
                ""
                  .concat("  ".repeat(depth), ".")
                  .concat(property, " (")
                  .concat(childNode.accessType, "):")
              );
              __classPrivateFieldGet(
                this,
                _a,
                "m",
                _ReactiveScopeDependencyTreeHIR_debugImpl
              ).call(this, buf, childNode, depth + 1);
            }
          } catch (err) {
            _iterator537.e(err);
          } finally {
            _iterator537.f();
          }
        });
    var PropertyAccessType;
    (function (PropertyAccessType) {
      PropertyAccessType["OptionalAccess"] = "OptionalAccess";
      PropertyAccessType["UnconditionalAccess"] = "UnconditionalAccess";
      PropertyAccessType["OptionalDependency"] = "OptionalDependency";
      PropertyAccessType["UnconditionalDependency"] = "UnconditionalDependency";
    })(PropertyAccessType || (PropertyAccessType = {}));
    function isOptional(access) {
      return (
        access === PropertyAccessType.OptionalAccess ||
        access === PropertyAccessType.OptionalDependency
      );
    }
    function isDependency(access) {
      return (
        access === PropertyAccessType.OptionalDependency ||
        access === PropertyAccessType.UnconditionalDependency
      );
    }
    function merge(access1, access2) {
      var resultIsUnconditional = !(isOptional(access1) && isOptional(access2));
      var resultIsDependency = isDependency(access1) || isDependency(access2);
      if (resultIsUnconditional) {
        if (resultIsDependency) {
          return PropertyAccessType.UnconditionalDependency;
        } else {
          return PropertyAccessType.UnconditionalAccess;
        }
      } else {
        if (resultIsDependency) {
          return PropertyAccessType.OptionalDependency;
        } else {
          return PropertyAccessType.OptionalAccess;
        }
      }
    }
    function collectMinimalDependenciesInSubtree(
      node,
      rootIdentifier,
      path,
      results
    ) {
      if (isDependency(node.accessType)) {
        results.add({ identifier: rootIdentifier, path: path });
      } else {
        var _iterator538 = _createForOfIteratorHelper(node.properties),
          _step538;
        try {
          for (_iterator538.s(); !(_step538 = _iterator538.n()).done; ) {
            var _step538$value = _slicedToArray(_step538.value, 2),
              childName = _step538$value[0],
              childNode = _step538$value[1];
            collectMinimalDependenciesInSubtree(
              childNode,
              rootIdentifier,
              [].concat(_toConsumableArray(path), [
                {
                  property: childName,
                  optional: isOptional(childNode.accessType)
                }
              ]),
              results
            );
          }
        } catch (err) {
          _iterator538.e(err);
        } finally {
          _iterator538.f();
        }
      }
    }
    function printSubtree(node, includeAccesses) {
      var results = [];
      var _iterator539 = _createForOfIteratorHelper(node.properties),
        _step539;
      try {
        var _loop18 = function _loop18() {
          var _step539$value = _slicedToArray(_step539.value, 2),
            propertyName = _step539$value[0],
            propertyNode = _step539$value[1];
          if (includeAccesses || isDependency(propertyNode.accessType)) {
            results.push(
              "".concat(propertyName, " (").concat(propertyNode.accessType, ")")
            );
          }
          var propertyResults = printSubtree(propertyNode, includeAccesses);
          results.push.apply(
            results,
            _toConsumableArray(
              propertyResults.map(function (result) {
                return "".concat(propertyName, ".").concat(result);
              })
            )
          );
        };
        for (_iterator539.s(); !(_step539 = _iterator539.n()).done; ) {
          _loop18();
        }
      } catch (err) {
        _iterator539.e(err);
      } finally {
        _iterator539.f();
      }
      return results;
    }
    function makeOrMergeProperty(node, property, accessType) {
      var child = node.properties.get(property);
      if (child == null) {
        child = { properties: new Map(), accessType: accessType };
        node.properties.set(property, child);
      } else {
        child.accessType = merge(child.accessType, accessType);
      }
      return child;
    }
    function collectOptionalChainSidemap(fn) {
      var context = {
        currFn: fn,
        blocks: fn.body.blocks,
        seenOptionals: new Set(),
        processedInstrsInOptional: new Set(),
        temporariesReadInOptional: new Map(),
        hoistableObjects: new Map()
      };
      traverseFunction(fn, context);
      return {
        temporariesReadInOptional: context.temporariesReadInOptional,
        processedInstrsInOptional: context.processedInstrsInOptional,
        hoistableObjects: context.hoistableObjects
      };
    }
    function traverseFunction(fn, context) {
      var _iterator540 = _createForOfIteratorHelper(fn.body.blocks),
        _step540;
      try {
        for (_iterator540.s(); !(_step540 = _iterator540.n()).done; ) {
          var _step540$value = _slicedToArray(_step540.value, 2),
            _ = _step540$value[0],
            block = _step540$value[1];
          var _iterator541 = _createForOfIteratorHelper(block.instructions),
            _step541;
          try {
            for (_iterator541.s(); !(_step541 = _iterator541.n()).done; ) {
              var instr = _step541.value;
              if (
                instr.value.kind === "FunctionExpression" ||
                instr.value.kind === "ObjectMethod"
              ) {
                traverseFunction(
                  instr.value.loweredFunc.func,
                  Object.assign(Object.assign({}, context), {
                    currFn: instr.value.loweredFunc.func,
                    blocks: instr.value.loweredFunc.func.body.blocks
                  })
                );
              }
            }
          } catch (err) {
            _iterator541.e(err);
          } finally {
            _iterator541.f();
          }
          if (
            block.terminal.kind === "optional" &&
            !context.seenOptionals.has(block.id)
          ) {
            traverseOptionalBlock(block, context, null);
          }
        }
      } catch (err) {
        _iterator540.e(err);
      } finally {
        _iterator540.f();
      }
    }
    function matchOptionalTestBlock(terminal, blocks) {
      var consequentBlock = assertNonNull(blocks.get(terminal.consequent));
      if (
        consequentBlock.instructions.length === 2 &&
        consequentBlock.instructions[0].value.kind === "PropertyLoad" &&
        consequentBlock.instructions[1].value.kind === "StoreLocal"
      ) {
        var propertyLoad = consequentBlock.instructions[0];
        var storeLocal = consequentBlock.instructions[1].value;
        var storeLocalInstr = consequentBlock.instructions[1];
        CompilerError.invariant(
          propertyLoad.value.object.identifier.id ===
            terminal.test.identifier.id,
          {
            reason:
              "[OptionalChainDeps] Inconsistent optional chaining property load",
            description: "Test="
              .concat(
                printIdentifier(terminal.test.identifier),
                " PropertyLoad base="
              )
              .concat(printIdentifier(propertyLoad.value.object.identifier)),
            loc: propertyLoad.loc
          }
        );
        CompilerError.invariant(
          storeLocal.value.identifier.id === propertyLoad.lvalue.identifier.id,
          {
            reason: "[OptionalChainDeps] Unexpected storeLocal",
            loc: propertyLoad.loc
          }
        );
        if (
          consequentBlock.terminal.kind !== "goto" ||
          consequentBlock.terminal.variant !== GotoVariant.Break
        ) {
          return null;
        }
        var alternate = assertNonNull(blocks.get(terminal.alternate));
        CompilerError.invariant(
          alternate.instructions.length === 2 &&
            alternate.instructions[0].value.kind === "Primitive" &&
            alternate.instructions[1].value.kind === "StoreLocal",
          { reason: "Unexpected alternate structure", loc: terminal.loc }
        );
        return {
          consequentId: storeLocal.lvalue.place.identifier.id,
          property: propertyLoad.value.property,
          propertyId: propertyLoad.lvalue.identifier.id,
          storeLocalInstr: storeLocalInstr,
          consequentGoto: consequentBlock.terminal.block
        };
      }
      return null;
    }
    function traverseOptionalBlock(optional, context, outerAlternate) {
      context.seenOptionals.add(optional.id);
      var maybeTest = context.blocks.get(optional.terminal.test);
      var test;
      var baseObject;
      if (maybeTest.terminal.kind === "branch") {
        CompilerError.invariant(optional.terminal.optional, {
          reason: "[OptionalChainDeps] Expect base case to be always optional",
          loc: optional.terminal.loc
        });
        if (
          maybeTest.instructions.length === 0 ||
          maybeTest.instructions[0].value.kind !== "LoadLocal"
        ) {
          return null;
        }
        var path = [];
        for (var i = 1; i < maybeTest.instructions.length; i++) {
          var instrVal = maybeTest.instructions[i].value;
          var prevInstr = maybeTest.instructions[i - 1];
          if (
            instrVal.kind === "PropertyLoad" &&
            instrVal.object.identifier.id === prevInstr.lvalue.identifier.id
          ) {
            path.push({ property: instrVal.property, optional: false });
          } else {
            return null;
          }
        }
        CompilerError.invariant(
          maybeTest.terminal.test.identifier.id ===
            maybeTest.instructions.at(-1).lvalue.identifier.id,
          {
            reason: "[OptionalChainDeps] Unexpected test expression",
            loc: maybeTest.terminal.loc
          }
        );
        baseObject = {
          identifier: maybeTest.instructions[0].value.place.identifier,
          path: path
        };
        test = maybeTest.terminal;
      } else if (maybeTest.terminal.kind === "optional") {
        var testBlock = context.blocks.get(maybeTest.terminal.fallthrough);
        if (testBlock.terminal.kind !== "branch") {
          CompilerError.throwTodo({
            reason: "Unexpected terminal kind `".concat(
              testBlock.terminal.kind,
              "` for optional fallthrough block"
            ),
            loc: maybeTest.terminal.loc
          });
        }
        var innerOptional = traverseOptionalBlock(
          maybeTest,
          context,
          testBlock.terminal.alternate
        );
        if (innerOptional == null) {
          return null;
        }
        if (testBlock.terminal.test.identifier.id !== innerOptional) {
          return null;
        }
        if (!optional.terminal.optional) {
          context.hoistableObjects.set(
            optional.id,
            assertNonNull(context.temporariesReadInOptional.get(innerOptional))
          );
        }
        baseObject = assertNonNull(
          context.temporariesReadInOptional.get(innerOptional)
        );
        test = testBlock.terminal;
      } else {
        return null;
      }
      if (test.alternate === outerAlternate) {
        CompilerError.invariant(optional.instructions.length === 0, {
          reason:
            "[OptionalChainDeps] Unexpected instructions an inner optional block. " +
            "This indicates that the compiler may be incorrectly concatenating two unrelated optional chains",
          loc: optional.terminal.loc
        });
      }
      var matchConsequentResult = matchOptionalTestBlock(test, context.blocks);
      if (!matchConsequentResult) {
        return null;
      }
      CompilerError.invariant(
        matchConsequentResult.consequentGoto === optional.terminal.fallthrough,
        {
          reason: "[OptionalChainDeps] Unexpected optional goto-fallthrough",
          description: ""
            .concat(matchConsequentResult.consequentGoto, " != ")
            .concat(optional.terminal.fallthrough),
          loc: optional.terminal.loc
        }
      );
      var load = {
        identifier: baseObject.identifier,
        path: [].concat(_toConsumableArray(baseObject.path), [
          {
            property: matchConsequentResult.property,
            optional: optional.terminal.optional
          }
        ])
      };
      context.processedInstrsInOptional.add(
        matchConsequentResult.storeLocalInstr
      );
      context.processedInstrsInOptional.add(test);
      context.temporariesReadInOptional.set(
        matchConsequentResult.consequentId,
        load
      );
      context.temporariesReadInOptional.set(
        matchConsequentResult.propertyId,
        load
      );
      return matchConsequentResult.consequentId;
    }
    var _Context_instances,
      _Context_declarations,
      _Context_reassignments,
      _Context_scopes,
      _Context_dependencies,
      _Context_temporaries,
      _Context_temporariesUsedOutsideScope,
      _Context_processedInstrsInOptional,
      _Context_innerFnContext,
      _Context_checkValidDependency,
      _Context_isScopeActive;
    function propagateScopeDependenciesHIR(fn) {
      var usedOutsideDeclaringScope =
        findTemporariesUsedOutsideDeclaringScope(fn);
      var temporaries = collectTemporariesSidemap(
        fn,
        usedOutsideDeclaringScope
      );
      var _collectOptionalChain = collectOptionalChainSidemap(fn),
        temporariesReadInOptional =
          _collectOptionalChain.temporariesReadInOptional,
        processedInstrsInOptional =
          _collectOptionalChain.processedInstrsInOptional,
        hoistableObjects = _collectOptionalChain.hoistableObjects;
      var hoistablePropertyLoads = keyByScopeId(
        fn,
        collectHoistablePropertyLoads(fn, temporaries, hoistableObjects)
      );
      var scopeDeps = collectDependencies(
        fn,
        usedOutsideDeclaringScope,
        new Map(
          [].concat(
            _toConsumableArray(temporaries),
            _toConsumableArray(temporariesReadInOptional)
          )
        ),
        processedInstrsInOptional
      );
      var _iterator542 = _createForOfIteratorHelper(scopeDeps),
        _step542;
      try {
        for (_iterator542.s(); !(_step542 = _iterator542.n()).done; ) {
          var _step542$value = _slicedToArray(_step542.value, 2),
            scope = _step542$value[0],
            deps = _step542$value[1];
          if (deps.length === 0) {
            continue;
          }
          var hoistables = hoistablePropertyLoads.get(scope.id);
          CompilerError.invariant(hoistables != null, {
            reason:
              "[PropagateScopeDependencies] Scope not found in tracked blocks",
            loc: GeneratedSource
          });
          var tree = new ReactiveScopeDependencyTreeHIR(
            _toConsumableArray(hoistables.assumedNonNullObjects).map(
              function (o) {
                return o.fullPath;
              }
            )
          );
          var _iterator543 = _createForOfIteratorHelper(deps),
            _step543;
          try {
            for (_iterator543.s(); !(_step543 = _iterator543.n()).done; ) {
              var dep = _step543.value;
              tree.addDependency(Object.assign({}, dep));
            }
          } catch (err) {
            _iterator543.e(err);
          } finally {
            _iterator543.f();
          }
          var candidates = tree.deriveMinimalDependencies();
          var _iterator544 = _createForOfIteratorHelper(candidates),
            _step544;
          try {
            var _loop19 = function _loop19() {
              var candidateDep = _step544.value;
              if (
                !Iterable_some(scope.dependencies, function (existingDep) {
                  return (
                    existingDep.identifier.declarationId ===
                      candidateDep.identifier.declarationId &&
                    areEqualPaths(existingDep.path, candidateDep.path)
                  );
                })
              )
                scope.dependencies.add(candidateDep);
            };
            for (_iterator544.s(); !(_step544 = _iterator544.n()).done; ) {
              _loop19();
            }
          } catch (err) {
            _iterator544.e(err);
          } finally {
            _iterator544.f();
          }
        }
      } catch (err) {
        _iterator542.e(err);
      } finally {
        _iterator542.f();
      }
    }
    function findTemporariesUsedOutsideDeclaringScope(fn) {
      var declarations = new Map();
      var prunedScopes = new Set();
      var scopeTraversal = new ScopeBlockTraversal();
      var usedOutsideDeclaringScope = new Set();
      function handlePlace(place) {
        var declaringScope = declarations.get(place.identifier.declarationId);
        if (
          declaringScope != null &&
          !scopeTraversal.isScopeActive(declaringScope) &&
          !prunedScopes.has(declaringScope)
        ) {
          usedOutsideDeclaringScope.add(place.identifier.declarationId);
        }
      }
      function handleInstruction(instr) {
        var scope = scopeTraversal.currentScope;
        if (scope == null || prunedScopes.has(scope)) {
          return;
        }
        switch (instr.value.kind) {
          case "LoadLocal":
          case "LoadContext":
          case "PropertyLoad": {
            declarations.set(instr.lvalue.identifier.declarationId, scope);
            break;
          }
        }
      }
      var _iterator545 = _createForOfIteratorHelper(fn.body.blocks),
        _step545;
      try {
        for (_iterator545.s(); !(_step545 = _iterator545.n()).done; ) {
          var _step545$value = _slicedToArray(_step545.value, 2),
            blockId = _step545$value[0],
            block = _step545$value[1];
          scopeTraversal.recordScopes(block);
          var scopeStartInfo = scopeTraversal.blockInfos.get(blockId);
          if (
            (scopeStartInfo === null || scopeStartInfo === void 0
              ? void 0
              : scopeStartInfo.kind) === "begin" &&
            scopeStartInfo.pruned
          ) {
            prunedScopes.add(scopeStartInfo.scope.id);
          }
          var _iterator546 = _createForOfIteratorHelper(block.instructions),
            _step546;
          try {
            for (_iterator546.s(); !(_step546 = _iterator546.n()).done; ) {
              var instr = _step546.value;
              var _iterator548 = _createForOfIteratorHelper(
                  eachInstructionOperand(instr)
                ),
                _step548;
              try {
                for (_iterator548.s(); !(_step548 = _iterator548.n()).done; ) {
                  var place = _step548.value;
                  handlePlace(place);
                }
              } catch (err) {
                _iterator548.e(err);
              } finally {
                _iterator548.f();
              }
              handleInstruction(instr);
            }
          } catch (err) {
            _iterator546.e(err);
          } finally {
            _iterator546.f();
          }
          var _iterator547 = _createForOfIteratorHelper(
              eachTerminalOperand(block.terminal)
            ),
            _step547;
          try {
            for (_iterator547.s(); !(_step547 = _iterator547.n()).done; ) {
              var _place29 = _step547.value;
              handlePlace(_place29);
            }
          } catch (err) {
            _iterator547.e(err);
          } finally {
            _iterator547.f();
          }
        }
      } catch (err) {
        _iterator545.e(err);
      } finally {
        _iterator545.f();
      }
      return usedOutsideDeclaringScope;
    }
    function collectTemporariesSidemap(fn, usedOutsideDeclaringScope) {
      var temporaries = new Map();
      collectTemporariesSidemapImpl(
        fn,
        usedOutsideDeclaringScope,
        temporaries,
        null
      );
      return temporaries;
    }
    function isLoadContextMutable(instrValue, id) {
      if (instrValue.kind === "LoadContext") {
        CompilerError.invariant(instrValue.place.identifier.scope != null, {
          reason:
            "[PropagateScopeDependencies] Expected all context variables to be assigned a scope",
          loc: instrValue.loc
        });
        return id >= instrValue.place.identifier.scope.range.end;
      }
      return false;
    }
    function collectTemporariesSidemapImpl(
      fn,
      usedOutsideDeclaringScope,
      temporaries,
      innerFnContext
    ) {
      var _iterator549 = _createForOfIteratorHelper(fn.body.blocks),
        _step549;
      try {
        for (_iterator549.s(); !(_step549 = _iterator549.n()).done; ) {
          var _step549$value = _slicedToArray(_step549.value, 2),
            _ = _step549$value[0],
            block = _step549$value[1];
          var _iterator550 = _createForOfIteratorHelper(block.instructions),
            _step550;
          try {
            var _loop20 = function _loop20() {
              var _step550$value = _step550.value,
                value = _step550$value.value,
                lvalue = _step550$value.lvalue,
                origInstrId = _step550$value.id;
              var instrId =
                innerFnContext != null ? innerFnContext.instrId : origInstrId;
              var usedOutside = usedOutsideDeclaringScope.has(
                lvalue.identifier.declarationId
              );
              if (value.kind === "PropertyLoad" && !usedOutside) {
                if (
                  innerFnContext == null ||
                  temporaries.has(value.object.identifier.id)
                ) {
                  var property = getProperty(
                    value.object,
                    value.property,
                    false,
                    temporaries
                  );
                  temporaries.set(lvalue.identifier.id, property);
                }
              } else if (
                (value.kind === "LoadLocal" ||
                  isLoadContextMutable(value, instrId)) &&
                lvalue.identifier.name == null &&
                value.place.identifier.name !== null &&
                !usedOutside
              ) {
                if (
                  innerFnContext == null ||
                  fn.context.some(function (context) {
                    return context.identifier.id === value.place.identifier.id;
                  })
                ) {
                  temporaries.set(lvalue.identifier.id, {
                    identifier: value.place.identifier,
                    path: []
                  });
                }
              } else if (
                value.kind === "FunctionExpression" ||
                value.kind === "ObjectMethod"
              ) {
                collectTemporariesSidemapImpl(
                  value.loweredFunc.func,
                  usedOutsideDeclaringScope,
                  temporaries,
                  innerFnContext !== null && innerFnContext !== void 0
                    ? innerFnContext
                    : { instrId: instrId }
                );
              }
            };
            for (_iterator550.s(); !(_step550 = _iterator550.n()).done; ) {
              _loop20();
            }
          } catch (err) {
            _iterator550.e(err);
          } finally {
            _iterator550.f();
          }
        }
      } catch (err) {
        _iterator549.e(err);
      } finally {
        _iterator549.f();
      }
    }
    function getProperty(object, propertyName, optional, temporaries) {
      var resolvedDependency = temporaries.get(object.identifier.id);
      var property;
      if (resolvedDependency == null) {
        property = {
          identifier: object.identifier,
          path: [{ property: propertyName, optional: optional }]
        };
      } else {
        property = {
          identifier: resolvedDependency.identifier,
          path: [].concat(_toConsumableArray(resolvedDependency.path), [
            { property: propertyName, optional: optional }
          ])
        };
      }
      return property;
    }
    var Context$1 = /*#__PURE__*/ (function () {
      function Context(
        temporariesUsedOutsideScope,
        temporaries,
        processedInstrsInOptional
      ) {
        _classCallCheck(this, Context);
        _Context_instances.add(this);
        _Context_declarations.set(this, new Map());
        _Context_reassignments.set(this, new Map());
        _Context_scopes.set(this, empty());
        _Context_dependencies.set(this, empty());
        this.deps = new Map();
        _Context_temporaries.set(this, void 0);
        _Context_temporariesUsedOutsideScope.set(this, void 0);
        _Context_processedInstrsInOptional.set(this, void 0);
        _Context_innerFnContext.set(this, null);
        __classPrivateFieldSet(
          this,
          _Context_temporariesUsedOutsideScope,
          temporariesUsedOutsideScope,
          "f"
        );
        __classPrivateFieldSet(this, _Context_temporaries, temporaries, "f");
        __classPrivateFieldSet(
          this,
          _Context_processedInstrsInOptional,
          processedInstrsInOptional,
          "f"
        );
      }
      return _createClass(Context, [
        {
          key: "enterScope",
          value: function enterScope(scope) {
            __classPrivateFieldSet(
              this,
              _Context_dependencies,
              __classPrivateFieldGet(this, _Context_dependencies, "f").push([]),
              "f"
            );
            __classPrivateFieldSet(
              this,
              _Context_scopes,
              __classPrivateFieldGet(this, _Context_scopes, "f").push(scope),
              "f"
            );
          }
        },
        {
          key: "exitScope",
          value: function exitScope(scope, pruned) {
            var _a;
            var scopedDependencies = __classPrivateFieldGet(
              this,
              _Context_dependencies,
              "f"
            ).value;
            CompilerError.invariant(scopedDependencies != null, {
              reason: "[PropagateScopeDeps]: Unexpected scope mismatch",
              loc: scope.loc
            });
            __classPrivateFieldSet(
              this,
              _Context_scopes,
              __classPrivateFieldGet(this, _Context_scopes, "f").pop(),
              "f"
            );
            __classPrivateFieldSet(
              this,
              _Context_dependencies,
              __classPrivateFieldGet(this, _Context_dependencies, "f").pop(),
              "f"
            );
            var _iterator551 = _createForOfIteratorHelper(scopedDependencies),
              _step551;
            try {
              for (_iterator551.s(); !(_step551 = _iterator551.n()).done; ) {
                var dep = _step551.value;
                if (
                  __classPrivateFieldGet(
                    this,
                    _Context_instances,
                    "m",
                    _Context_checkValidDependency
                  ).call(this, dep)
                ) {
                  (_a = __classPrivateFieldGet(
                    this,
                    _Context_dependencies,
                    "f"
                  ).value) === null || _a === void 0
                    ? void 0
                    : _a.push(dep);
                }
              }
            } catch (err) {
              _iterator551.e(err);
            } finally {
              _iterator551.f();
            }
            if (!pruned) {
              this.deps.set(scope, scopedDependencies);
            }
          }
        },
        {
          key: "isUsedOutsideDeclaringScope",
          value: function isUsedOutsideDeclaringScope(place) {
            return __classPrivateFieldGet(
              this,
              _Context_temporariesUsedOutsideScope,
              "f"
            ).has(place.identifier.declarationId);
          }
        },
        {
          key: "declare",
          value: function declare(identifier, decl) {
            if (
              __classPrivateFieldGet(this, _Context_innerFnContext, "f") != null
            )
              return;
            if (
              !__classPrivateFieldGet(this, _Context_declarations, "f").has(
                identifier.declarationId
              )
            ) {
              __classPrivateFieldGet(this, _Context_declarations, "f").set(
                identifier.declarationId,
                decl
              );
            }
            __classPrivateFieldGet(this, _Context_reassignments, "f").set(
              identifier,
              decl
            );
          }
        },
        {
          key: "currentScope",
          get: function get() {
            return __classPrivateFieldGet(this, _Context_scopes, "f");
          }
        },
        {
          key: "visitOperand",
          value: function visitOperand(place) {
            var _a;
            this.visitDependency(
              (_a = __classPrivateFieldGet(this, _Context_temporaries, "f").get(
                place.identifier.id
              )) !== null && _a !== void 0
                ? _a
                : { identifier: place.identifier, path: [] }
            );
          }
        },
        {
          key: "visitProperty",
          value: function visitProperty(object, property, optional) {
            var nextDependency = getProperty(
              object,
              property,
              optional,
              __classPrivateFieldGet(this, _Context_temporaries, "f")
            );
            this.visitDependency(nextDependency);
          }
        },
        {
          key: "visitDependency",
          value: function visitDependency(maybeDependency) {
            var _this31 = this;
            var _a;
            var originalDeclaration = __classPrivateFieldGet(
              this,
              _Context_declarations,
              "f"
            ).get(maybeDependency.identifier.declarationId);
            if (
              originalDeclaration !== undefined &&
              originalDeclaration.scope.value !== null
            ) {
              originalDeclaration.scope.each(function (scope) {
                if (
                  !__classPrivateFieldGet(
                    _this31,
                    _Context_instances,
                    "m",
                    _Context_isScopeActive
                  ).call(_this31, scope) &&
                  !Iterable_some(scope.declarations.values(), function (decl) {
                    return (
                      decl.identifier.declarationId ===
                      maybeDependency.identifier.declarationId
                    );
                  })
                ) {
                  scope.declarations.set(maybeDependency.identifier.id, {
                    identifier: maybeDependency.identifier,
                    scope: originalDeclaration.scope.value
                  });
                }
              });
            }
            if (
              isUseRefType(maybeDependency.identifier) &&
              ((_a = maybeDependency.path.at(0)) === null || _a === void 0
                ? void 0
                : _a.property) === "current"
            ) {
              maybeDependency = {
                identifier: maybeDependency.identifier,
                path: []
              };
            }
            if (
              __classPrivateFieldGet(
                this,
                _Context_instances,
                "m",
                _Context_checkValidDependency
              ).call(this, maybeDependency)
            ) {
              __classPrivateFieldGet(
                this,
                _Context_dependencies,
                "f"
              ).value.push(maybeDependency);
            }
          }
        },
        {
          key: "visitReassignment",
          value: function visitReassignment(place) {
            var currentScope = this.currentScope.value;
            if (
              currentScope != null &&
              !Iterable_some(currentScope.reassignments, function (identifier) {
                return (
                  identifier.declarationId === place.identifier.declarationId
                );
              }) &&
              __classPrivateFieldGet(
                this,
                _Context_instances,
                "m",
                _Context_checkValidDependency
              ).call(this, { identifier: place.identifier, path: [] })
            ) {
              currentScope.reassignments.add(place.identifier);
            }
          }
        },
        {
          key: "enterInnerFn",
          value: function enterInnerFn(innerFn, cb) {
            var _a;
            var prevContext = __classPrivateFieldGet(
              this,
              _Context_innerFnContext,
              "f"
            );
            __classPrivateFieldSet(
              this,
              _Context_innerFnContext,
              (_a = __classPrivateFieldGet(
                this,
                _Context_innerFnContext,
                "f"
              )) !== null && _a !== void 0
                ? _a
                : { outerInstrId: innerFn.id },
              "f"
            );
            var result = cb();
            __classPrivateFieldSet(
              this,
              _Context_innerFnContext,
              prevContext,
              "f"
            );
            return result;
          }
        },
        {
          key: "isDeferredDependency",
          value: function isDeferredDependency(instr) {
            return (
              __classPrivateFieldGet(
                this,
                _Context_processedInstrsInOptional,
                "f"
              ).has(instr.value) ||
              (instr.kind === HIRValue.Instruction &&
                __classPrivateFieldGet(this, _Context_temporaries, "f").has(
                  instr.value.lvalue.identifier.id
                ))
            );
          }
        }
      ]);
    })();
    (_Context_declarations = new WeakMap()),
      (_Context_reassignments = new WeakMap()),
      (_Context_scopes = new WeakMap()),
      (_Context_dependencies = new WeakMap()),
      (_Context_temporaries = new WeakMap()),
      (_Context_temporariesUsedOutsideScope = new WeakMap()),
      (_Context_processedInstrsInOptional = new WeakMap()),
      (_Context_innerFnContext = new WeakMap()),
      (_Context_instances = new WeakSet()),
      (_Context_checkValidDependency = function _Context_checkValidDependency(
        maybeDependency
      ) {
        var _a;
        if (isRefValueType(maybeDependency.identifier)) {
          return false;
        }
        if (isObjectMethodType(maybeDependency.identifier)) {
          return false;
        }
        var identifier = maybeDependency.identifier;
        var currentDeclaration =
          (_a = __classPrivateFieldGet(this, _Context_reassignments, "f").get(
            identifier
          )) !== null && _a !== void 0
            ? _a
            : __classPrivateFieldGet(this, _Context_declarations, "f").get(
                identifier.declarationId
              );
        var currentScope = this.currentScope.value;
        return (
          currentScope != null &&
          currentDeclaration !== undefined &&
          currentDeclaration.id < currentScope.range.start
        );
      }),
      (_Context_isScopeActive = function _Context_isScopeActive(scope) {
        if (__classPrivateFieldGet(this, _Context_scopes, "f") === null) {
          return false;
        }
        return __classPrivateFieldGet(this, _Context_scopes, "f").find(
          function (state) {
            return state === scope;
          }
        );
      });
    var HIRValue;
    (function (HIRValue) {
      HIRValue[(HIRValue["Instruction"] = 1)] = "Instruction";
      HIRValue[(HIRValue["Terminal"] = 2)] = "Terminal";
    })(HIRValue || (HIRValue = {}));
    function handleInstruction(instr, context) {
      var id = instr.id,
        value = instr.value,
        lvalue = instr.lvalue;
      context.declare(lvalue.identifier, {
        id: id,
        scope: context.currentScope
      });
      if (
        context.isDeferredDependency({
          kind: HIRValue.Instruction,
          value: instr
        })
      ) {
        return;
      }
      if (value.kind === "PropertyLoad") {
        context.visitProperty(value.object, value.property, false);
      } else if (value.kind === "StoreLocal") {
        context.visitOperand(value.value);
        if (value.lvalue.kind === InstructionKind.Reassign) {
          context.visitReassignment(value.lvalue.place);
        }
        context.declare(value.lvalue.place.identifier, {
          id: id,
          scope: context.currentScope
        });
      } else if (
        value.kind === "DeclareLocal" ||
        value.kind === "DeclareContext"
      ) {
        context.declare(value.lvalue.place.identifier, {
          id: id,
          scope: context.currentScope
        });
      } else if (value.kind === "Destructure") {
        context.visitOperand(value.value);
        var _iterator552 = _createForOfIteratorHelper(
            eachPatternOperand(value.lvalue.pattern)
          ),
          _step552;
        try {
          for (_iterator552.s(); !(_step552 = _iterator552.n()).done; ) {
            var place = _step552.value;
            if (value.lvalue.kind === InstructionKind.Reassign) {
              context.visitReassignment(place);
            }
            context.declare(place.identifier, {
              id: id,
              scope: context.currentScope
            });
          }
        } catch (err) {
          _iterator552.e(err);
        } finally {
          _iterator552.f();
        }
      } else {
        var _iterator553 = _createForOfIteratorHelper(
            eachInstructionValueOperand(value)
          ),
          _step553;
        try {
          for (_iterator553.s(); !(_step553 = _iterator553.n()).done; ) {
            var operand = _step553.value;
            context.visitOperand(operand);
          }
        } catch (err) {
          _iterator553.e(err);
        } finally {
          _iterator553.f();
        }
      }
    }
    function collectDependencies(
      fn,
      usedOutsideDeclaringScope,
      temporaries,
      processedInstrsInOptional
    ) {
      var context = new Context$1(
        usedOutsideDeclaringScope,
        temporaries,
        processedInstrsInOptional
      );
      var _iterator554 = _createForOfIteratorHelper(fn.params),
        _step554;
      try {
        for (_iterator554.s(); !(_step554 = _iterator554.n()).done; ) {
          var param = _step554.value;
          if (param.kind === "Identifier") {
            context.declare(param.identifier, {
              id: makeInstructionId(0),
              scope: empty()
            });
          } else {
            context.declare(param.place.identifier, {
              id: makeInstructionId(0),
              scope: empty()
            });
          }
        }
      } catch (err) {
        _iterator554.e(err);
      } finally {
        _iterator554.f();
      }
      var scopeTraversal = new ScopeBlockTraversal();
      var _handleFunction = function handleFunction(fn) {
        var _iterator555 = _createForOfIteratorHelper(fn.body.blocks),
          _step555;
        try {
          for (_iterator555.s(); !(_step555 = _iterator555.n()).done; ) {
            var _step555$value = _slicedToArray(_step555.value, 2),
              blockId = _step555$value[0],
              block = _step555$value[1];
            scopeTraversal.recordScopes(block);
            var scopeBlockInfo = scopeTraversal.blockInfos.get(blockId);
            if (
              (scopeBlockInfo === null || scopeBlockInfo === void 0
                ? void 0
                : scopeBlockInfo.kind) === "begin"
            ) {
              context.enterScope(scopeBlockInfo.scope);
            } else if (
              (scopeBlockInfo === null || scopeBlockInfo === void 0
                ? void 0
                : scopeBlockInfo.kind) === "end"
            ) {
              context.exitScope(scopeBlockInfo.scope, scopeBlockInfo.pruned);
            }
            var _iterator556 = _createForOfIteratorHelper(block.phis),
              _step556;
            try {
              for (_iterator556.s(); !(_step556 = _iterator556.n()).done; ) {
                var phi = _step556.value;
                var _iterator559 = _createForOfIteratorHelper(phi.operands),
                  _step559;
                try {
                  for (
                    _iterator559.s();
                    !(_step559 = _iterator559.n()).done;

                  ) {
                    var operand = _step559.value;
                    var maybeOptionalChain = temporaries.get(
                      operand[1].identifier.id
                    );
                    if (maybeOptionalChain) {
                      context.visitDependency(maybeOptionalChain);
                    }
                  }
                } catch (err) {
                  _iterator559.e(err);
                } finally {
                  _iterator559.f();
                }
              }
            } catch (err) {
              _iterator556.e(err);
            } finally {
              _iterator556.f();
            }
            var _iterator557 = _createForOfIteratorHelper(block.instructions),
              _step557;
            try {
              var _loop21 = function _loop21() {
                var instr = _step557.value;
                if (
                  instr.value.kind === "FunctionExpression" ||
                  instr.value.kind === "ObjectMethod"
                ) {
                  context.declare(instr.lvalue.identifier, {
                    id: instr.id,
                    scope: context.currentScope
                  });
                  var innerFn = instr.value.loweredFunc.func;
                  context.enterInnerFn(instr, function () {
                    _handleFunction(innerFn);
                  });
                } else {
                  handleInstruction(instr, context);
                }
              };
              for (_iterator557.s(); !(_step557 = _iterator557.n()).done; ) {
                _loop21();
              }
            } catch (err) {
              _iterator557.e(err);
            } finally {
              _iterator557.f();
            }
            if (
              !context.isDeferredDependency({
                kind: HIRValue.Terminal,
                value: block.terminal
              })
            ) {
              var _iterator558 = _createForOfIteratorHelper(
                  eachTerminalOperand(block.terminal)
                ),
                _step558;
              try {
                for (_iterator558.s(); !(_step558 = _iterator558.n()).done; ) {
                  var place = _step558.value;
                  context.visitOperand(place);
                }
              } catch (err) {
                _iterator558.e(err);
              } finally {
                _iterator558.f();
              }
            }
          }
        } catch (err) {
          _iterator555.e(err);
        } finally {
          _iterator555.f();
        }
      };
      _handleFunction(fn);
      return context.deps;
    }
    function outlineJSX(fn) {
      var outlinedFns = [];
      outlineJsxImpl(fn, outlinedFns);
      for (
        var _i44 = 0, _outlinedFns = outlinedFns;
        _i44 < _outlinedFns.length;
        _i44++
      ) {
        var outlinedFn = _outlinedFns[_i44];
        fn.env.outlineFunction(outlinedFn, "Component");
      }
    }
    function outlineJsxImpl(fn, outlinedFns) {
      var globals = new Map();
      function processAndOutlineJSX(state, rewriteInstr) {
        if (state.jsx.length <= 1) {
          return;
        }
        var result = process$1(
          fn,
          _toConsumableArray(state.jsx).sort(function (a, b) {
            return a.id - b.id;
          }),
          globals
        );
        if (result) {
          outlinedFns.push(result.fn);
          rewriteInstr.set(state.jsx.at(0).id, result.instrs);
        }
      }
      var _iterator560 = _createForOfIteratorHelper(fn.body.blocks),
        _step560;
      try {
        for (_iterator560.s(); !(_step560 = _iterator560.n()).done; ) {
          var _step560$value = _slicedToArray(_step560.value, 2),
            block = _step560$value[1];
          var rewriteInstr = new Map();
          var state = { jsx: [], children: new Set() };
          for (var i = block.instructions.length - 1; i >= 0; i--) {
            var instr = block.instructions[i];
            var value = instr.value,
              lvalue = instr.lvalue;
            switch (value.kind) {
              case "LoadGlobal": {
                globals.set(lvalue.identifier.id, instr);
                break;
              }
              case "FunctionExpression": {
                outlineJsxImpl(value.loweredFunc.func, outlinedFns);
                break;
              }
              case "JsxExpression": {
                if (!state.children.has(lvalue.identifier.id)) {
                  processAndOutlineJSX(state, rewriteInstr);
                  state = { jsx: [], children: new Set() };
                }
                state.jsx.push(instr);
                if (value.children) {
                  var _iterator561 = _createForOfIteratorHelper(value.children),
                    _step561;
                  try {
                    for (
                      _iterator561.s();
                      !(_step561 = _iterator561.n()).done;

                    ) {
                      var child = _step561.value;
                      state.children.add(child.identifier.id);
                    }
                  } catch (err) {
                    _iterator561.e(err);
                  } finally {
                    _iterator561.f();
                  }
                }
                break;
              }
              case "ArrayExpression":
              case "Await":
              case "BinaryExpression":
              case "CallExpression":
              case "ComputedDelete":
              case "ComputedLoad":
              case "ComputedStore":
              case "Debugger":
              case "DeclareContext":
              case "DeclareLocal":
              case "Destructure":
              case "FinishMemoize":
              case "GetIterator":
              case "IteratorNext":
              case "JSXText":
              case "JsxFragment":
              case "LoadContext":
              case "LoadLocal":
              case "MetaProperty":
              case "MethodCall":
              case "NewExpression":
              case "NextPropertyOf":
              case "ObjectExpression":
              case "ObjectMethod":
              case "PostfixUpdate":
              case "PrefixUpdate":
              case "Primitive":
              case "PropertyDelete":
              case "PropertyLoad":
              case "PropertyStore":
              case "RegExpLiteral":
              case "StartMemoize":
              case "StoreContext":
              case "StoreGlobal":
              case "StoreLocal":
              case "TaggedTemplateExpression":
              case "TemplateLiteral":
              case "TypeCastExpression":
              case "UnsupportedNode":
              case "UnaryExpression": {
                break;
              }
              default: {
                assertExhaustive$1(
                  value,
                  "Unexpected instruction: ".concat(value)
                );
              }
            }
          }
          processAndOutlineJSX(state, rewriteInstr);
          if (rewriteInstr.size > 0) {
            var newInstrs = [];
            for (var _i45 = 0; _i45 < block.instructions.length; _i45++) {
              var id = _i45 + 1;
              if (rewriteInstr.has(id)) {
                var instrs = rewriteInstr.get(id);
                newInstrs.push.apply(newInstrs, _toConsumableArray(instrs));
              } else {
                newInstrs.push(block.instructions[_i45]);
              }
            }
            block.instructions = newInstrs;
          }
          deadCodeElimination(fn);
        }
      } catch (err) {
        _iterator560.e(err);
      } finally {
        _iterator560.f();
      }
    }
    function process$1(fn, jsx, globals) {
      if (fn.fnType === "Component") {
        return null;
      }
      var props = collectProps(jsx);
      if (!props) return null;
      var outlinedTag = fn.env.generateGloballyUniqueIdentifierName(null).value;
      var newInstrs = emitOutlinedJsx(fn.env, jsx, props, outlinedTag);
      if (!newInstrs) return null;
      var outlinedFn = emitOutlinedFn(fn.env, jsx, props, globals);
      if (!outlinedFn) return null;
      outlinedFn.id = outlinedTag;
      return { instrs: newInstrs, fn: outlinedFn };
    }
    function collectProps(instructions) {
      var id = 1;
      function generateName(oldName) {
        var newName = oldName;
        while (seen.has(newName)) {
          newName = "".concat(oldName).concat(id++);
        }
        seen.add(newName);
        return newName;
      }
      var attributes = [];
      var jsxIds = new Set(
        instructions.map(function (i) {
          return i.lvalue.identifier.id;
        })
      );
      var seen = new Set();
      var _iterator562 = _createForOfIteratorHelper(instructions),
        _step562;
      try {
        for (_iterator562.s(); !(_step562 = _iterator562.n()).done; ) {
          var instr = _step562.value;
          var value = instr.value;
          var _iterator563 = _createForOfIteratorHelper(value.props),
            _step563;
          try {
            for (_iterator563.s(); !(_step563 = _iterator563.n()).done; ) {
              var at = _step563.value;
              if (at.kind === "JsxSpreadAttribute") {
                return null;
              }
              if (at.kind === "JsxAttribute") {
                var _newName = generateName(at.name);
                attributes.push({
                  originalName: at.name,
                  newName: _newName,
                  place: at.place
                });
              }
            }
          } catch (err) {
            _iterator563.e(err);
          } finally {
            _iterator563.f();
          }
          if (value.children) {
            var _iterator564 = _createForOfIteratorHelper(value.children),
              _step564;
            try {
              for (_iterator564.s(); !(_step564 = _iterator564.n()).done; ) {
                var child = _step564.value;
                if (jsxIds.has(child.identifier.id)) {
                  continue;
                }
                promoteTemporary(child.identifier);
                var newName = generateName("t");
                attributes.push({
                  originalName: child.identifier.name.value,
                  newName: newName,
                  place: child
                });
              }
            } catch (err) {
              _iterator564.e(err);
            } finally {
              _iterator564.f();
            }
          }
        }
      } catch (err) {
        _iterator562.e(err);
      } finally {
        _iterator562.f();
      }
      return attributes;
    }
    function emitOutlinedJsx(env, instructions, outlinedProps, outlinedTag) {
      var props = outlinedProps.map(function (p) {
        return { kind: "JsxAttribute", name: p.newName, place: p.place };
      });
      var loadJsx = {
        id: makeInstructionId(0),
        loc: GeneratedSource,
        lvalue: createTemporaryPlace(env, GeneratedSource),
        value: {
          kind: "LoadGlobal",
          binding: { kind: "ModuleLocal", name: outlinedTag },
          loc: GeneratedSource
        }
      };
      promoteTemporaryJsxTag(loadJsx.lvalue.identifier);
      var jsxExpr = {
        id: makeInstructionId(0),
        loc: GeneratedSource,
        lvalue: instructions.at(-1).lvalue,
        value: {
          kind: "JsxExpression",
          tag: Object.assign({}, loadJsx.lvalue),
          props: props,
          children: null,
          loc: GeneratedSource,
          openingLoc: GeneratedSource,
          closingLoc: GeneratedSource
        }
      };
      return [loadJsx, jsxExpr];
    }
    function emitOutlinedFn(env, jsx, oldProps, globals) {
      var instructions = [];
      var oldToNewProps = createOldToNewPropsMapping(env, oldProps);
      var propsObj = createTemporaryPlace(env, GeneratedSource);
      promoteTemporary(propsObj.identifier);
      var destructurePropsInstr = emitDestructureProps(
        env,
        propsObj,
        oldToNewProps
      );
      instructions.push(destructurePropsInstr);
      var updatedJsxInstructions = emitUpdatedJsx(jsx, oldToNewProps);
      var loadGlobalInstrs = emitLoadGlobals(jsx, globals);
      if (!loadGlobalInstrs) {
        return null;
      }
      instructions.push.apply(
        instructions,
        _toConsumableArray(loadGlobalInstrs)
      );
      instructions.push.apply(
        instructions,
        _toConsumableArray(updatedJsxInstructions)
      );
      var block = {
        kind: "block",
        id: makeBlockId(0),
        instructions: instructions,
        terminal: {
          id: makeInstructionId(0),
          kind: "return",
          loc: GeneratedSource,
          value: instructions.at(-1).lvalue
        },
        preds: new Set(),
        phis: new Set()
      };
      var fn = {
        loc: GeneratedSource,
        id: null,
        fnType: "Other",
        env: env,
        params: [propsObj],
        returnTypeAnnotation: null,
        returnType: makeType(),
        context: [],
        effects: null,
        body: { entry: block.id, blocks: new Map([[block.id, block]]) },
        generator: false,
        async: false,
        directives: []
      };
      return fn;
    }
    function emitLoadGlobals(jsx, globals) {
      var instructions = [];
      var _iterator565 = _createForOfIteratorHelper(jsx),
        _step565;
      try {
        for (_iterator565.s(); !(_step565 = _iterator565.n()).done; ) {
          var value = _step565.value.value;
          if (value.tag.kind === "Identifier") {
            var loadGlobalInstr = globals.get(value.tag.identifier.id);
            if (!loadGlobalInstr) {
              return null;
            }
            instructions.push(loadGlobalInstr);
          }
        }
      } catch (err) {
        _iterator565.e(err);
      } finally {
        _iterator565.f();
      }
      return instructions;
    }
    function emitUpdatedJsx(jsx, oldToNewProps) {
      var newInstrs = [];
      var jsxIds = new Set(
        jsx.map(function (i) {
          return i.lvalue.identifier.id;
        })
      );
      var _iterator566 = _createForOfIteratorHelper(jsx),
        _step566;
      try {
        for (_iterator566.s(); !(_step566 = _iterator566.n()).done; ) {
          var instr = _step566.value;
          var value = instr.value;
          var newProps = [];
          var _iterator567 = _createForOfIteratorHelper(value.props),
            _step567;
          try {
            for (_iterator567.s(); !(_step567 = _iterator567.n()).done; ) {
              var prop = _step567.value;
              invariant_1(
                prop.kind === "JsxAttribute",
                "Expected only attributes but found ".concat(prop.kind)
              );
              if (prop.name === "key") {
                continue;
              }
              var newProp = oldToNewProps.get(prop.place.identifier.id);
              invariant_1(
                newProp !== undefined,
                "Expected a new property for ".concat(
                  printIdentifier(prop.place.identifier)
                )
              );
              newProps.push({
                kind: "JsxAttribute",
                name: newProp.originalName,
                place: newProp.place
              });
            }
          } catch (err) {
            _iterator567.e(err);
          } finally {
            _iterator567.f();
          }
          var newChildren = null;
          if (value.children) {
            newChildren = [];
            var _iterator568 = _createForOfIteratorHelper(value.children),
              _step568;
            try {
              for (_iterator568.s(); !(_step568 = _iterator568.n()).done; ) {
                var child = _step568.value;
                if (jsxIds.has(child.identifier.id)) {
                  newChildren.push(Object.assign({}, child));
                  continue;
                }
                var newChild = oldToNewProps.get(child.identifier.id);
                invariant_1(
                  newChild !== undefined,
                  "Expected a new prop for ".concat(
                    printIdentifier(child.identifier)
                  )
                );
                newChildren.push(Object.assign({}, newChild.place));
              }
            } catch (err) {
              _iterator568.e(err);
            } finally {
              _iterator568.f();
            }
          }
          newInstrs.push(
            Object.assign(Object.assign({}, instr), {
              value: Object.assign(Object.assign({}, value), {
                props: newProps,
                children: newChildren
              })
            })
          );
        }
      } catch (err) {
        _iterator566.e(err);
      } finally {
        _iterator566.f();
      }
      return newInstrs;
    }
    function createOldToNewPropsMapping(env, oldProps) {
      var oldToNewProps = new Map();
      var _iterator569 = _createForOfIteratorHelper(oldProps),
        _step569;
      try {
        for (_iterator569.s(); !(_step569 = _iterator569.n()).done; ) {
          var oldProp = _step569.value;
          if (oldProp.originalName === "key") {
            continue;
          }
          var newProp = Object.assign(Object.assign({}, oldProp), {
            place: createTemporaryPlace(env, GeneratedSource)
          });
          newProp.place.identifier.name = makeIdentifierName(oldProp.newName);
          oldToNewProps.set(oldProp.place.identifier.id, newProp);
        }
      } catch (err) {
        _iterator569.e(err);
      } finally {
        _iterator569.f();
      }
      return oldToNewProps;
    }
    function emitDestructureProps(env, propsObj, oldToNewProps) {
      var properties = [];
      var _iterator570 = _createForOfIteratorHelper(oldToNewProps),
        _step570;
      try {
        for (_iterator570.s(); !(_step570 = _iterator570.n()).done; ) {
          var _step570$value = _slicedToArray(_step570.value, 2),
            _ = _step570$value[0],
            prop = _step570$value[1];
          properties.push({
            kind: "ObjectProperty",
            key: { kind: "string", name: prop.newName },
            type: "property",
            place: prop.place
          });
        }
      } catch (err) {
        _iterator570.e(err);
      } finally {
        _iterator570.f();
      }
      var destructurePropsInstr = {
        id: makeInstructionId(0),
        lvalue: createTemporaryPlace(env, GeneratedSource),
        loc: GeneratedSource,
        value: {
          kind: "Destructure",
          lvalue: {
            pattern: { kind: "ObjectPattern", properties: properties },
            kind: InstructionKind.Let
          },
          loc: GeneratedSource,
          value: propsObj
        }
      };
      return destructurePropsInstr;
    }
    function optimizePropsMethodCalls(fn) {
      var _iterator571 = _createForOfIteratorHelper(fn.body.blocks),
        _step571;
      try {
        for (_iterator571.s(); !(_step571 = _iterator571.n()).done; ) {
          var _step571$value = _slicedToArray(_step571.value, 2),
            block = _step571$value[1];
          for (var i = 0; i < block.instructions.length; i++) {
            var instr = block.instructions[i];
            if (
              instr.value.kind === "MethodCall" &&
              isPropsType(instr.value.receiver.identifier)
            ) {
              instr.value = {
                kind: "CallExpression",
                callee: instr.value.property,
                args: instr.value.args,
                loc: instr.value.loc
              };
            }
          }
        }
      } catch (err) {
        _iterator571.e(err);
      } finally {
        _iterator571.f();
      }
    }
    var _Context_env,
      _Context_errors,
      _Context_callExpressions,
      _Context_functionExpressions,
      _Context_loadLocals,
      _Context_fireCalleesToFireFunctions,
      _Context_calleesWithInsertedFire,
      _Context_capturedCalleeIdentifierIds,
      _Context_inUseEffectLambda,
      _Context_loadGlobalInstructionIds,
      _Context_arrayExpressions;
    var CANNOT_COMPILE_FIRE = "Cannot compile `fire`";
    function transformFire(fn) {
      var context = new Context(fn.env);
      replaceFireFunctions(fn, context);
      if (!context.hasErrors()) {
        ensureNoMoreFireUses(fn, context);
      }
      context.throwIfErrorsFound();
    }
    function replaceFireFunctions(fn, context) {
      var hasRewrite = false;
      var _iterator572 = _createForOfIteratorHelper(fn.body.blocks),
        _step572;
      try {
        for (_iterator572.s(); !(_step572 = _iterator572.n()).done; ) {
          var _step572$value = _slicedToArray(_step572.value, 2),
            block = _step572$value[1];
          var rewriteInstrs = new Map();
          var deleteInstrs = new Set();
          var _iterator573 = _createForOfIteratorHelper(block.instructions),
            _step573;
          try {
            for (_iterator573.s(); !(_step573 = _iterator573.n()).done; ) {
              var instr = _step573.value;
              var value = instr.value,
                lvalue = instr.lvalue;
              if (
                value.kind === "CallExpression" &&
                isUseEffectHookType(value.callee.identifier) &&
                value.args.length > 0 &&
                value.args[0].kind === "Identifier"
              ) {
                var lambda = context.getFunctionExpression(
                  value.args[0].identifier.id
                );
                if (lambda != null) {
                  var capturedCallees =
                    visitFunctionExpressionAndPropagateFireDependencies(
                      lambda,
                      context,
                      true
                    );
                  var newInstrs = [];
                  var _iterator574 = _createForOfIteratorHelper(
                      capturedCallees.entries()
                    ),
                    _step574;
                  try {
                    for (
                      _iterator574.s();
                      !(_step574 = _iterator574.n()).done;

                    ) {
                      var _step574$value = _slicedToArray(_step574.value, 2),
                        fireCalleePlace = _step574$value[0],
                        fireCalleeInfo = _step574$value[1];
                      if (!context.hasCalleeWithInsertedFire(fireCalleePlace)) {
                        context.addCalleeWithInsertedFire(fireCalleePlace);
                        var loadUseFireInstr = makeLoadUseFireInstruction(
                          fn.env
                        );
                        var loadFireCalleeInstr = makeLoadFireCalleeInstruction(
                          fn.env,
                          fireCalleeInfo.capturedCalleeIdentifier
                        );
                        var callUseFireInstr = makeCallUseFireInstruction(
                          fn.env,
                          loadUseFireInstr.lvalue,
                          loadFireCalleeInstr.lvalue
                        );
                        var storeUseFireInstr = makeStoreUseFireInstruction(
                          fn.env,
                          callUseFireInstr.lvalue,
                          fireCalleeInfo.fireFunctionBinding
                        );
                        newInstrs.push(
                          loadUseFireInstr,
                          loadFireCalleeInstr,
                          callUseFireInstr,
                          storeUseFireInstr
                        );
                        var loadUseEffectInstrId = context.getLoadGlobalInstrId(
                          value.callee.identifier.id
                        );
                        if (loadUseEffectInstrId == null) {
                          context.pushError({
                            loc: value.loc,
                            description: null,
                            severity: ErrorSeverity.Invariant,
                            reason:
                              "[InsertFire] No LoadGlobal found for useEffect call",
                            suggestions: null
                          });
                          continue;
                        }
                        rewriteInstrs.set(loadUseEffectInstrId, newInstrs);
                      }
                    }
                  } catch (err) {
                    _iterator574.e(err);
                  } finally {
                    _iterator574.f();
                  }
                  ensureNoRemainingCalleeCaptures(
                    lambda.loweredFunc.func,
                    context,
                    capturedCallees
                  );
                  if (
                    value.args.length > 1 &&
                    value.args[1] != null &&
                    value.args[1].kind === "Identifier"
                  ) {
                    var depArray = value.args[1];
                    var depArrayExpression = context.getArrayExpression(
                      depArray.identifier.id
                    );
                    if (depArrayExpression != null) {
                      var _iterator575 = _createForOfIteratorHelper(
                          depArrayExpression.elements
                        ),
                        _step575;
                      try {
                        for (
                          _iterator575.s();
                          !(_step575 = _iterator575.n()).done;

                        ) {
                          var dependency = _step575.value;
                          if (dependency.kind === "Identifier") {
                            var loadOfDependency = context.getLoadLocalInstr(
                              dependency.identifier.id
                            );
                            if (loadOfDependency != null) {
                              var replacedDepArrayItem = capturedCallees.get(
                                loadOfDependency.place.identifier.id
                              );
                              if (replacedDepArrayItem != null) {
                                loadOfDependency.place =
                                  replacedDepArrayItem.fireFunctionBinding;
                              }
                            }
                          }
                        }
                      } catch (err) {
                        _iterator575.e(err);
                      } finally {
                        _iterator575.f();
                      }
                    } else {
                      context.pushError({
                        loc: value.args[1].loc,
                        description:
                          "You must use an array literal for an effect dependency array when that effect uses `fire()`",
                        severity: ErrorSeverity.Invariant,
                        reason: CANNOT_COMPILE_FIRE,
                        suggestions: null
                      });
                    }
                  } else if (
                    value.args.length > 1 &&
                    value.args[1].kind === "Spread"
                  ) {
                    context.pushError({
                      loc: value.args[1].place.loc,
                      description:
                        "You must use an array literal for an effect dependency array when that effect uses `fire()`",
                      severity: ErrorSeverity.Invariant,
                      reason: CANNOT_COMPILE_FIRE,
                      suggestions: null
                    });
                  }
                }
              } else if (
                value.kind === "CallExpression" &&
                value.callee.identifier.type.kind === "Function" &&
                value.callee.identifier.type.shapeId === BuiltInFireId &&
                context.inUseEffectLambda()
              ) {
                if (
                  value.args.length === 1 &&
                  value.args[0].kind === "Identifier"
                ) {
                  var callExpr = context.getCallExpression(
                    value.args[0].identifier.id
                  );
                  if (callExpr != null) {
                    var calleeId = callExpr.callee.identifier.id;
                    var loadLocal = context.getLoadLocalInstr(calleeId);
                    if (loadLocal == null) {
                      context.pushError({
                        loc: value.loc,
                        description: null,
                        severity: ErrorSeverity.Invariant,
                        reason:
                          "[InsertFire] No loadLocal found for fire call argument",
                        suggestions: null
                      });
                      continue;
                    }
                    var fireFunctionBinding =
                      context.getOrGenerateFireFunctionBinding(
                        loadLocal.place,
                        value.loc
                      );
                    loadLocal.place = Object.assign({}, fireFunctionBinding);
                    deleteInstrs.add(instr.id);
                  } else {
                    context.pushError({
                      loc: value.loc,
                      description:
                        "`fire()` can only receive a function call such as `fire(fn(a,b)). Method calls and other expressions are not allowed",
                      severity: ErrorSeverity.InvalidReact,
                      reason: CANNOT_COMPILE_FIRE,
                      suggestions: null
                    });
                  }
                } else {
                  var description =
                    "fire() can only take in a single call expression as an argument";
                  if (value.args.length === 0) {
                    description += " but received none";
                  } else if (value.args.length > 1) {
                    description += " but received multiple arguments";
                  } else if (value.args[0].kind === "Spread") {
                    description += " but received a spread argument";
                  }
                  context.pushError({
                    loc: value.loc,
                    description: description,
                    severity: ErrorSeverity.InvalidReact,
                    reason: CANNOT_COMPILE_FIRE,
                    suggestions: null
                  });
                }
              } else if (value.kind === "CallExpression") {
                context.addCallExpression(lvalue.identifier.id, value);
              } else if (
                value.kind === "FunctionExpression" &&
                context.inUseEffectLambda()
              ) {
                visitFunctionExpressionAndPropagateFireDependencies(
                  value,
                  context,
                  false
                );
              } else if (value.kind === "FunctionExpression") {
                context.addFunctionExpression(lvalue.identifier.id, value);
              } else if (value.kind === "LoadLocal") {
                context.addLoadLocalInstr(lvalue.identifier.id, value);
              } else if (
                value.kind === "LoadGlobal" &&
                value.binding.kind === "ImportSpecifier" &&
                value.binding.module === "react" &&
                value.binding.imported === "fire" &&
                context.inUseEffectLambda()
              ) {
                deleteInstrs.add(instr.id);
              } else if (value.kind === "LoadGlobal") {
                context.addLoadGlobalInstrId(lvalue.identifier.id, instr.id);
              } else if (value.kind === "ArrayExpression") {
                context.addArrayExpression(lvalue.identifier.id, value);
              }
            }
          } catch (err) {
            _iterator573.e(err);
          } finally {
            _iterator573.f();
          }
          block.instructions = rewriteInstructions(
            rewriteInstrs,
            block.instructions
          );
          block.instructions = deleteInstructions(
            deleteInstrs,
            block.instructions
          );
          if (rewriteInstrs.size > 0 || deleteInstrs.size > 0) {
            hasRewrite = true;
            fn.env.hasFireRewrite = true;
          }
        }
      } catch (err) {
        _iterator572.e(err);
      } finally {
        _iterator572.f();
      }
      if (hasRewrite) {
        markInstructionIds(fn.body);
      }
    }
    function visitFunctionExpressionAndPropagateFireDependencies(
      fnExpr,
      context,
      enteringUseEffect
    ) {
      var withScope = enteringUseEffect
        ? context.withUseEffectLambdaScope.bind(context)
        : context.withFunctionScope.bind(context);
      var calleesCapturedByFnExpression = withScope(function () {
        return replaceFireFunctions(fnExpr.loweredFunc.func, context);
      });
      for (
        var contextIdx = 0;
        contextIdx < fnExpr.loweredFunc.func.context.length;
        contextIdx++
      ) {
        var contextItem = fnExpr.loweredFunc.func.context[contextIdx];
        var replacedCallee = calleesCapturedByFnExpression.get(
          contextItem.identifier.id
        );
        if (replacedCallee != null) {
          fnExpr.loweredFunc.func.context[contextIdx] = Object.assign(
            {},
            replacedCallee.fireFunctionBinding
          );
        }
      }
      context.mergeCalleesFromInnerScope(calleesCapturedByFnExpression);
      return calleesCapturedByFnExpression;
    }
    function eachReachablePlace(fn) {
      var _iterator576,
        _step576,
        _step576$value,
        block,
        _iterator577,
        _step577,
        instr;
      return _regeneratorRuntime().wrap(
        function eachReachablePlace$(_context12) {
          while (1)
            switch ((_context12.prev = _context12.next)) {
              case 0:
                _iterator576 = _createForOfIteratorHelper(fn.body.blocks);
                _context12.prev = 1;
                _iterator576.s();
              case 3:
                if ((_step576 = _iterator576.n()).done) {
                  _context12.next = 27;
                  break;
                }
                (_step576$value = _slicedToArray(_step576.value, 2)),
                  (block = _step576$value[1]);
                _iterator577 = _createForOfIteratorHelper(block.instructions);
                _context12.prev = 6;
                _iterator577.s();
              case 8:
                if ((_step577 = _iterator577.n()).done) {
                  _context12.next = 17;
                  break;
                }
                instr = _step577.value;
                if (
                  !(
                    instr.value.kind === "FunctionExpression" ||
                    instr.value.kind === "ObjectMethod"
                  )
                ) {
                  _context12.next = 14;
                  break;
                }
                return _context12.delegateYield(
                  eachReachablePlace(instr.value.loweredFunc.func),
                  "t0",
                  12
                );
              case 12:
                _context12.next = 15;
                break;
              case 14:
                return _context12.delegateYield(
                  eachInstructionOperand(instr),
                  "t1",
                  15
                );
              case 15:
                _context12.next = 8;
                break;
              case 17:
                _context12.next = 22;
                break;
              case 19:
                _context12.prev = 19;
                _context12.t2 = _context12["catch"](6);
                _iterator577.e(_context12.t2);
              case 22:
                _context12.prev = 22;
                _iterator577.f();
                return _context12.finish(22);
              case 25:
                _context12.next = 3;
                break;
              case 27:
                _context12.next = 32;
                break;
              case 29:
                _context12.prev = 29;
                _context12.t3 = _context12["catch"](1);
                _iterator576.e(_context12.t3);
              case 32:
                _context12.prev = 32;
                _iterator576.f();
                return _context12.finish(32);
              case 35:
              case "end":
                return _context12.stop();
            }
        },
        _marked12,
        null,
        [
          [1, 29, 32, 35],
          [6, 19, 22, 25]
        ]
      );
    }
    function ensureNoRemainingCalleeCaptures(fn, context, capturedCallees) {
      var _a;
      var _iterator578 = _createForOfIteratorHelper(eachReachablePlace(fn)),
        _step578;
      try {
        for (_iterator578.s(); !(_step578 = _iterator578.n()).done; ) {
          var place = _step578.value;
          var calleeInfo = capturedCallees.get(place.identifier.id);
          if (calleeInfo != null) {
            var calleeName =
              ((_a = calleeInfo.capturedCalleeIdentifier.name) === null ||
              _a === void 0
                ? void 0
                : _a.kind) === "named"
                ? calleeInfo.capturedCalleeIdentifier.name.value
                : "<unknown>";
            context.pushError({
              loc: place.loc,
              description: "All uses of "
                .concat(
                  calleeName,
                  " must be either used with a fire() call in this effect or not used with a fire() call at all. "
                )
                .concat(calleeName, " was used with fire() on line ")
                .concat(
                  printSourceLocationLine(calleeInfo.fireLoc),
                  " in this effect"
                ),
              severity: ErrorSeverity.InvalidReact,
              reason: CANNOT_COMPILE_FIRE,
              suggestions: null
            });
          }
        }
      } catch (err) {
        _iterator578.e(err);
      } finally {
        _iterator578.f();
      }
    }
    function ensureNoMoreFireUses(fn, context) {
      var _iterator579 = _createForOfIteratorHelper(eachReachablePlace(fn)),
        _step579;
      try {
        for (_iterator579.s(); !(_step579 = _iterator579.n()).done; ) {
          var place = _step579.value;
          if (
            place.identifier.type.kind === "Function" &&
            place.identifier.type.shapeId === BuiltInFireId
          ) {
            context.pushError({
              loc: place.identifier.loc,
              description: "Cannot use `fire` outside of a useEffect function",
              severity: ErrorSeverity.Invariant,
              reason: CANNOT_COMPILE_FIRE,
              suggestions: null
            });
          }
        }
      } catch (err) {
        _iterator579.e(err);
      } finally {
        _iterator579.f();
      }
    }
    function makeLoadUseFireInstruction(env) {
      var useFirePlace = createTemporaryPlace(env, GeneratedSource);
      useFirePlace.effect = Effect.Read;
      useFirePlace.identifier.type = DefaultNonmutatingHook;
      var instrValue = {
        kind: "LoadGlobal",
        binding: {
          kind: "ImportSpecifier",
          name: "useFire",
          module: "react",
          imported: "useFire"
        },
        loc: GeneratedSource
      };
      return {
        id: makeInstructionId(0),
        value: instrValue,
        lvalue: Object.assign({}, useFirePlace),
        loc: GeneratedSource
      };
    }
    function makeLoadFireCalleeInstruction(env, fireCalleeIdentifier) {
      var loadedFireCallee = createTemporaryPlace(env, GeneratedSource);
      var fireCallee = {
        kind: "Identifier",
        identifier: fireCalleeIdentifier,
        reactive: false,
        effect: Effect.Unknown,
        loc: fireCalleeIdentifier.loc
      };
      return {
        id: makeInstructionId(0),
        value: {
          kind: "LoadLocal",
          loc: GeneratedSource,
          place: Object.assign({}, fireCallee)
        },
        lvalue: Object.assign({}, loadedFireCallee),
        loc: GeneratedSource
      };
    }
    function makeCallUseFireInstruction(env, useFirePlace, argPlace) {
      var useFireCallResultPlace = createTemporaryPlace(env, GeneratedSource);
      useFireCallResultPlace.effect = Effect.Read;
      var useFireCall = {
        kind: "CallExpression",
        callee: Object.assign({}, useFirePlace),
        args: [argPlace],
        loc: GeneratedSource
      };
      return {
        id: makeInstructionId(0),
        value: useFireCall,
        lvalue: Object.assign({}, useFireCallResultPlace),
        loc: GeneratedSource
      };
    }
    function makeStoreUseFireInstruction(
      env,
      useFireCallResultPlace,
      fireFunctionBindingPlace
    ) {
      promoteTemporary(fireFunctionBindingPlace.identifier);
      var fireFunctionBindingLValuePlace = createTemporaryPlace(
        env,
        GeneratedSource
      );
      return {
        id: makeInstructionId(0),
        value: {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, fireFunctionBindingPlace)
          },
          value: Object.assign({}, useFireCallResultPlace),
          type: null,
          loc: GeneratedSource
        },
        lvalue: fireFunctionBindingLValuePlace,
        loc: GeneratedSource
      };
    }
    var Context = /*#__PURE__*/ (function () {
      function Context(env) {
        _classCallCheck(this, Context);
        _Context_env.set(this, void 0);
        _Context_errors.set(this, new CompilerError());
        _Context_callExpressions.set(this, new Map());
        _Context_functionExpressions.set(this, new Map());
        _Context_loadLocals.set(this, new Map());
        _Context_fireCalleesToFireFunctions.set(this, new Map());
        _Context_calleesWithInsertedFire.set(this, new Set());
        _Context_capturedCalleeIdentifierIds.set(this, new Map());
        _Context_inUseEffectLambda.set(this, false);
        _Context_loadGlobalInstructionIds.set(this, new Map());
        _Context_arrayExpressions.set(this, new Map());
        __classPrivateFieldSet(this, _Context_env, env, "f");
      }
      return _createClass(Context, [
        {
          key: "pushError",
          value: function pushError(error) {
            __classPrivateFieldGet(this, _Context_errors, "f").push(error);
          }
        },
        {
          key: "withFunctionScope",
          value: function withFunctionScope(fn) {
            fn();
            return __classPrivateFieldGet(
              this,
              _Context_capturedCalleeIdentifierIds,
              "f"
            );
          }
        },
        {
          key: "withUseEffectLambdaScope",
          value: function withUseEffectLambdaScope(fn) {
            var capturedCalleeIdentifierIds = __classPrivateFieldGet(
              this,
              _Context_capturedCalleeIdentifierIds,
              "f"
            );
            var inUseEffectLambda = __classPrivateFieldGet(
              this,
              _Context_inUseEffectLambda,
              "f"
            );
            __classPrivateFieldSet(
              this,
              _Context_capturedCalleeIdentifierIds,
              new Map(),
              "f"
            );
            __classPrivateFieldSet(this, _Context_inUseEffectLambda, true, "f");
            var resultCapturedCalleeIdentifierIds = this.withFunctionScope(fn);
            __classPrivateFieldSet(
              this,
              _Context_capturedCalleeIdentifierIds,
              capturedCalleeIdentifierIds,
              "f"
            );
            __classPrivateFieldSet(
              this,
              _Context_inUseEffectLambda,
              inUseEffectLambda,
              "f"
            );
            return resultCapturedCalleeIdentifierIds;
          }
        },
        {
          key: "addCallExpression",
          value: function addCallExpression(id, callExpr) {
            __classPrivateFieldGet(this, _Context_callExpressions, "f").set(
              id,
              callExpr
            );
          }
        },
        {
          key: "getCallExpression",
          value: function getCallExpression(id) {
            return __classPrivateFieldGet(
              this,
              _Context_callExpressions,
              "f"
            ).get(id);
          }
        },
        {
          key: "addLoadLocalInstr",
          value: function addLoadLocalInstr(id, loadLocal) {
            __classPrivateFieldGet(this, _Context_loadLocals, "f").set(
              id,
              loadLocal
            );
          }
        },
        {
          key: "getLoadLocalInstr",
          value: function getLoadLocalInstr(id) {
            return __classPrivateFieldGet(this, _Context_loadLocals, "f").get(
              id
            );
          }
        },
        {
          key: "getOrGenerateFireFunctionBinding",
          value: function getOrGenerateFireFunctionBinding(callee, fireLoc) {
            var _this32 = this;
            var fireFunctionBinding = getOrInsertWith(
              __classPrivateFieldGet(
                this,
                _Context_fireCalleesToFireFunctions,
                "f"
              ),
              callee.identifier.id,
              function () {
                return createTemporaryPlace(
                  __classPrivateFieldGet(_this32, _Context_env, "f"),
                  GeneratedSource
                );
              }
            );
            __classPrivateFieldGet(
              this,
              _Context_capturedCalleeIdentifierIds,
              "f"
            ).set(callee.identifier.id, {
              fireFunctionBinding: fireFunctionBinding,
              capturedCalleeIdentifier: callee.identifier,
              fireLoc: fireLoc
            });
            return fireFunctionBinding;
          }
        },
        {
          key: "mergeCalleesFromInnerScope",
          value: function mergeCalleesFromInnerScope(innerCallees) {
            var _iterator580 = _createForOfIteratorHelper(
                innerCallees.entries()
              ),
              _step580;
            try {
              for (_iterator580.s(); !(_step580 = _iterator580.n()).done; ) {
                var _step580$value = _slicedToArray(_step580.value, 2),
                  id = _step580$value[0],
                  calleeInfo = _step580$value[1];
                __classPrivateFieldGet(
                  this,
                  _Context_capturedCalleeIdentifierIds,
                  "f"
                ).set(id, calleeInfo);
              }
            } catch (err) {
              _iterator580.e(err);
            } finally {
              _iterator580.f();
            }
          }
        },
        {
          key: "addCalleeWithInsertedFire",
          value: function addCalleeWithInsertedFire(id) {
            __classPrivateFieldGet(
              this,
              _Context_calleesWithInsertedFire,
              "f"
            ).add(id);
          }
        },
        {
          key: "hasCalleeWithInsertedFire",
          value: function hasCalleeWithInsertedFire(id) {
            return __classPrivateFieldGet(
              this,
              _Context_calleesWithInsertedFire,
              "f"
            ).has(id);
          }
        },
        {
          key: "inUseEffectLambda",
          value: function inUseEffectLambda() {
            return __classPrivateFieldGet(
              this,
              _Context_inUseEffectLambda,
              "f"
            );
          }
        },
        {
          key: "addFunctionExpression",
          value: function addFunctionExpression(id, fn) {
            __classPrivateFieldGet(this, _Context_functionExpressions, "f").set(
              id,
              fn
            );
          }
        },
        {
          key: "getFunctionExpression",
          value: function getFunctionExpression(id) {
            return __classPrivateFieldGet(
              this,
              _Context_functionExpressions,
              "f"
            ).get(id);
          }
        },
        {
          key: "addLoadGlobalInstrId",
          value: function addLoadGlobalInstrId(id, instrId) {
            __classPrivateFieldGet(
              this,
              _Context_loadGlobalInstructionIds,
              "f"
            ).set(id, instrId);
          }
        },
        {
          key: "getLoadGlobalInstrId",
          value: function getLoadGlobalInstrId(id) {
            return __classPrivateFieldGet(
              this,
              _Context_loadGlobalInstructionIds,
              "f"
            ).get(id);
          }
        },
        {
          key: "addArrayExpression",
          value: function addArrayExpression(id, array) {
            __classPrivateFieldGet(this, _Context_arrayExpressions, "f").set(
              id,
              array
            );
          }
        },
        {
          key: "getArrayExpression",
          value: function getArrayExpression(id) {
            return __classPrivateFieldGet(
              this,
              _Context_arrayExpressions,
              "f"
            ).get(id);
          }
        },
        {
          key: "hasErrors",
          value: function hasErrors() {
            return __classPrivateFieldGet(
              this,
              _Context_errors,
              "f"
            ).hasErrors();
          }
        },
        {
          key: "throwIfErrorsFound",
          value: function throwIfErrorsFound() {
            if (this.hasErrors())
              throw __classPrivateFieldGet(this, _Context_errors, "f");
          }
        }
      ]);
    })();
    (_Context_env = new WeakMap()),
      (_Context_errors = new WeakMap()),
      (_Context_callExpressions = new WeakMap()),
      (_Context_functionExpressions = new WeakMap()),
      (_Context_loadLocals = new WeakMap()),
      (_Context_fireCalleesToFireFunctions = new WeakMap()),
      (_Context_calleesWithInsertedFire = new WeakMap()),
      (_Context_capturedCalleeIdentifierIds = new WeakMap()),
      (_Context_inUseEffectLambda = new WeakMap()),
      (_Context_loadGlobalInstructionIds = new WeakMap()),
      (_Context_arrayExpressions = new WeakMap());
    function deleteInstructions(deleteInstrs, instructions) {
      if (deleteInstrs.size > 0) {
        var newInstrs = instructions.filter(function (instr) {
          return !deleteInstrs.has(instr.id);
        });
        return newInstrs;
      }
      return instructions;
    }
    function rewriteInstructions(rewriteInstrs, instructions) {
      if (rewriteInstrs.size > 0) {
        var newInstrs = [];
        var _iterator581 = _createForOfIteratorHelper(instructions),
          _step581;
        try {
          for (_iterator581.s(); !(_step581 = _iterator581.n()).done; ) {
            var instr = _step581.value;
            var newInstrsAtId = rewriteInstrs.get(instr.id);
            if (newInstrsAtId != null) {
              newInstrs.push.apply(
                newInstrs,
                _toConsumableArray(newInstrsAtId).concat([instr])
              );
            } else {
              newInstrs.push(instr);
            }
          }
        } catch (err) {
          _iterator581.e(err);
        } finally {
          _iterator581.f();
        }
        return newInstrs;
      }
      return instructions;
    }
    function validateNoImpureFunctionsInRender(fn) {
      var errors = new CompilerError();
      var _iterator582 = _createForOfIteratorHelper(fn.body.blocks),
        _step582;
      try {
        for (_iterator582.s(); !(_step582 = _iterator582.n()).done; ) {
          var _step582$value = _slicedToArray(_step582.value, 2),
            block = _step582$value[1];
          var _iterator583 = _createForOfIteratorHelper(block.instructions),
            _step583;
          try {
            for (_iterator583.s(); !(_step583 = _iterator583.n()).done; ) {
              var instr = _step583.value;
              var value = instr.value;
              if (
                value.kind === "MethodCall" ||
                value.kind == "CallExpression"
              ) {
                var callee =
                  value.kind === "MethodCall" ? value.property : value.callee;
                var signature = getFunctionCallSignature(
                  fn.env,
                  callee.identifier.type
                );
                if (signature != null && signature.impure === true) {
                  errors.push({
                    reason:
                      "Calling an impure function can produce unstable results. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent)",
                    description:
                      signature.canonicalName != null
                        ? "`".concat(
                            signature.canonicalName,
                            "` is an impure function whose results may change on every call"
                          )
                        : null,
                    severity: ErrorSeverity.InvalidReact,
                    loc: callee.loc,
                    suggestions: null
                  });
                }
              }
            }
          } catch (err) {
            _iterator583.e(err);
          } finally {
            _iterator583.f();
          }
        }
      } catch (err) {
        _iterator582.e(err);
      } finally {
        _iterator582.f();
      }
      if (errors.hasErrors()) {
        throw errors;
      }
    }
    function run(
      func,
      config,
      fnType,
      mode,
      useMemoCacheIdentifier,
      logger,
      filename,
      code
    ) {
      var _a, _b;
      var contextIdentifiers = findContextIdentifiers(func);
      var env = new Environment(
        func.scope,
        fnType,
        mode,
        config,
        contextIdentifiers,
        logger,
        filename,
        code,
        useMemoCacheIdentifier
      );
      (_b =
        (_a = env.logger) === null || _a === void 0
          ? void 0
          : _a.debugLogIRs) === null || _b === void 0
        ? void 0
        : _b.call(_a, {
            kind: "debug",
            name: "EnvironmentConfig",
            value: build(env.config)
          });
      return runWithEnvironment(func, env);
    }
    function runWithEnvironment(func, env) {
      var log = function log(value) {
        var _a, _b;
        (_b =
          (_a = env.logger) === null || _a === void 0
            ? void 0
            : _a.debugLogIRs) === null || _b === void 0
          ? void 0
          : _b.call(_a, value);
      };
      var hir = lower$1(func, env).unwrap();
      log({ kind: "hir", name: "HIR", value: hir });
      pruneMaybeThrows(hir);
      log({ kind: "hir", name: "PruneMaybeThrows", value: hir });
      validateContextVariableLValues(hir);
      validateUseMemo(hir);
      if (
        env.isInferredMemoEnabled &&
        !env.config.enablePreserveExistingManualUseMemo &&
        !env.config.disableMemoizationForDebugging &&
        !env.config.enableChangeDetectionForDebugging
      ) {
        dropManualMemoization(hir);
        log({ kind: "hir", name: "DropManualMemoization", value: hir });
      }
      inlineImmediatelyInvokedFunctionExpressions(hir);
      log({
        kind: "hir",
        name: "InlineImmediatelyInvokedFunctionExpressions",
        value: hir
      });
      mergeConsecutiveBlocks(hir);
      log({ kind: "hir", name: "MergeConsecutiveBlocks", value: hir });
      assertConsistentIdentifiers(hir);
      assertTerminalSuccessorsExist(hir);
      enterSSA(hir);
      log({ kind: "hir", name: "SSA", value: hir });
      eliminateRedundantPhi(hir);
      log({ kind: "hir", name: "EliminateRedundantPhi", value: hir });
      assertConsistentIdentifiers(hir);
      constantPropagation(hir);
      log({ kind: "hir", name: "ConstantPropagation", value: hir });
      inferTypes(hir);
      log({ kind: "hir", name: "InferTypes", value: hir });
      if (env.isInferredMemoEnabled) {
        if (env.config.validateHooksUsage) {
          validateHooksUsage(hir);
        }
        if (env.config.validateNoCapitalizedCalls) {
          validateNoCapitalizedCalls(hir);
        }
      }
      if (env.config.enableFire) {
        transformFire(hir);
        log({ kind: "hir", name: "TransformFire", value: hir });
      }
      if (env.config.lowerContextAccess) {
        lowerContextAccess(hir, env.config.lowerContextAccess);
      }
      optimizePropsMethodCalls(hir);
      log({ kind: "hir", name: "OptimizePropsMethodCalls", value: hir });
      analyseFunctions(hir);
      log({ kind: "hir", name: "AnalyseFunctions", value: hir });
      var fnEffectErrors = inferReferenceEffects(hir);
      if (env.isInferredMemoEnabled) {
        if (fnEffectErrors.length > 0) {
          CompilerError["throw"](fnEffectErrors[0]);
        }
      }
      log({ kind: "hir", name: "InferReferenceEffects", value: hir });
      validateLocalsNotReassignedAfterRender(hir);
      deadCodeElimination(hir);
      log({ kind: "hir", name: "DeadCodeElimination", value: hir });
      if (env.config.enableInstructionReordering) {
        instructionReordering(hir);
        log({ kind: "hir", name: "InstructionReordering", value: hir });
      }
      pruneMaybeThrows(hir);
      log({ kind: "hir", name: "PruneMaybeThrows", value: hir });
      inferMutableRanges(hir);
      log({ kind: "hir", name: "InferMutableRanges", value: hir });
      if (env.isInferredMemoEnabled) {
        if (env.config.assertValidMutableRanges) {
          assertValidMutableRanges(hir);
        }
        if (env.config.validateRefAccessDuringRender) {
          validateNoRefAccessInRender(hir);
        }
        if (env.config.validateNoSetStateInRender) {
          validateNoSetStateInRender(hir);
        }
        if (env.config.validateNoSetStateInPassiveEffects) {
          validateNoSetStateInPassiveEffects(hir);
        }
        if (env.config.validateNoJSXInTryStatements) {
          validateNoJSXInTryStatement(hir);
        }
        if (env.config.validateNoImpureFunctionsInRender) {
          validateNoImpureFunctionsInRender(hir);
        }
      }
      inferReactivePlaces(hir);
      log({ kind: "hir", name: "InferReactivePlaces", value: hir });
      rewriteInstructionKindsBasedOnReassignment(hir);
      log({
        kind: "hir",
        name: "RewriteInstructionKindsBasedOnReassignment",
        value: hir
      });
      propagatePhiTypes(hir);
      log({ kind: "hir", name: "PropagatePhiTypes", value: hir });
      if (env.isInferredMemoEnabled) {
        inferReactiveScopeVariables(hir);
        log({ kind: "hir", name: "InferReactiveScopeVariables", value: hir });
      }
      var fbtOperands = memoizeFbtAndMacroOperandsInSameScope(hir);
      log({
        kind: "hir",
        name: "MemoizeFbtAndMacroOperandsInSameScope",
        value: hir
      });
      if (env.config.enableJsxOutlining) {
        outlineJSX(hir);
      }
      if (env.config.enableFunctionOutlining) {
        outlineFunctions(hir, fbtOperands);
        log({ kind: "hir", name: "OutlineFunctions", value: hir });
      }
      alignMethodCallScopes(hir);
      log({ kind: "hir", name: "AlignMethodCallScopes", value: hir });
      alignObjectMethodScopes(hir);
      log({ kind: "hir", name: "AlignObjectMethodScopes", value: hir });
      pruneUnusedLabelsHIR(hir);
      log({ kind: "hir", name: "PruneUnusedLabelsHIR", value: hir });
      alignReactiveScopesToBlockScopesHIR(hir);
      log({
        kind: "hir",
        name: "AlignReactiveScopesToBlockScopesHIR",
        value: hir
      });
      mergeOverlappingReactiveScopesHIR(hir);
      log({
        kind: "hir",
        name: "MergeOverlappingReactiveScopesHIR",
        value: hir
      });
      assertValidBlockNesting(hir);
      buildReactiveScopeTerminalsHIR(hir);
      log({ kind: "hir", name: "BuildReactiveScopeTerminalsHIR", value: hir });
      assertValidBlockNesting(hir);
      flattenReactiveLoopsHIR(hir);
      log({ kind: "hir", name: "FlattenReactiveLoopsHIR", value: hir });
      flattenScopesWithHooksOrUseHIR(hir);
      log({ kind: "hir", name: "FlattenScopesWithHooksOrUseHIR", value: hir });
      assertTerminalSuccessorsExist(hir);
      assertTerminalPredsExist(hir);
      propagateScopeDependenciesHIR(hir);
      log({ kind: "hir", name: "PropagateScopeDependenciesHIR", value: hir });
      if (env.config.inferEffectDependencies) {
        inferEffectDependencies(hir);
      }
      if (env.config.inlineJsxTransform) {
        inlineJsxTransform(hir, env.config.inlineJsxTransform);
        log({ kind: "hir", name: "inlineJsxTransform", value: hir });
      }
      var reactiveFunction = buildReactiveFunction(hir);
      log({
        kind: "reactive",
        name: "BuildReactiveFunction",
        value: reactiveFunction
      });
      assertWellFormedBreakTargets(reactiveFunction);
      pruneUnusedLabels(reactiveFunction);
      log({
        kind: "reactive",
        name: "PruneUnusedLabels",
        value: reactiveFunction
      });
      assertScopeInstructionsWithinScopes(reactiveFunction);
      pruneNonEscapingScopes(reactiveFunction);
      log({
        kind: "reactive",
        name: "PruneNonEscapingScopes",
        value: reactiveFunction
      });
      pruneNonReactiveDependencies(reactiveFunction);
      log({
        kind: "reactive",
        name: "PruneNonReactiveDependencies",
        value: reactiveFunction
      });
      pruneUnusedScopes(reactiveFunction);
      log({
        kind: "reactive",
        name: "PruneUnusedScopes",
        value: reactiveFunction
      });
      mergeReactiveScopesThatInvalidateTogether(reactiveFunction);
      log({
        kind: "reactive",
        name: "MergeReactiveScopesThatInvalidateTogether",
        value: reactiveFunction
      });
      pruneAlwaysInvalidatingScopes(reactiveFunction);
      log({
        kind: "reactive",
        name: "PruneAlwaysInvalidatingScopes",
        value: reactiveFunction
      });
      if (env.config.enableChangeDetectionForDebugging != null) {
        pruneInitializationDependencies(reactiveFunction);
        log({
          kind: "reactive",
          name: "PruneInitializationDependencies",
          value: reactiveFunction
        });
      }
      propagateEarlyReturns(reactiveFunction);
      log({
        kind: "reactive",
        name: "PropagateEarlyReturns",
        value: reactiveFunction
      });
      pruneUnusedLValues(reactiveFunction);
      log({
        kind: "reactive",
        name: "PruneUnusedLValues",
        value: reactiveFunction
      });
      promoteUsedTemporaries(reactiveFunction);
      log({
        kind: "reactive",
        name: "PromoteUsedTemporaries",
        value: reactiveFunction
      });
      extractScopeDeclarationsFromDestructuring(reactiveFunction);
      log({
        kind: "reactive",
        name: "ExtractScopeDeclarationsFromDestructuring",
        value: reactiveFunction
      });
      stabilizeBlockIds(reactiveFunction);
      log({
        kind: "reactive",
        name: "StabilizeBlockIds",
        value: reactiveFunction
      });
      var uniqueIdentifiers = renameVariables(reactiveFunction);
      log({
        kind: "reactive",
        name: "RenameVariables",
        value: reactiveFunction
      });
      pruneHoistedContexts(reactiveFunction);
      log({
        kind: "reactive",
        name: "PruneHoistedContexts",
        value: reactiveFunction
      });
      if (env.config.validateMemoizedEffectDependencies) {
        validateMemoizedEffectDependencies(reactiveFunction);
      }
      if (
        env.config.enablePreserveExistingMemoizationGuarantees ||
        env.config.validatePreserveExistingMemoizationGuarantees
      ) {
        validatePreservedManualMemoization(reactiveFunction);
      }
      var ast = codegenFunction(reactiveFunction, {
        uniqueIdentifiers: uniqueIdentifiers,
        fbtOperands: fbtOperands
      }).unwrap();
      log({ kind: "ast", name: "Codegen", value: ast });
      var _iterator584 = _createForOfIteratorHelper(ast.outlined),
        _step584;
      try {
        for (_iterator584.s(); !(_step584 = _iterator584.n()).done; ) {
          var outlined = _step584.value;
          log({ kind: "ast", name: "Codegen (outlined)", value: outlined.fn });
        }
      } catch (err) {
        _iterator584.e(err);
      } finally {
        _iterator584.f();
      }
      if (env.config.throwUnknownException__testonly) {
        throw new Error("unexpected error");
      }
      return ast;
    }
    function compileFn(
      func,
      config,
      fnType,
      mode,
      useMemoCacheIdentifier,
      logger,
      filename,
      code
    ) {
      return run(
        func,
        config,
        fnType,
        mode,
        useMemoCacheIdentifier,
        logger,
        filename,
        code
      );
    }
    function isComponentDeclaration(node) {
      return Object.prototype.hasOwnProperty.call(
        node,
        "__componentDeclaration"
      );
    }
    function isHookDeclaration(node) {
      return Object.prototype.hasOwnProperty.call(node, "__hookDeclaration");
    }
    function filterSuppressionsThatAffectFunction(suppressionRanges, fn) {
      var suppressionsInScope = [];
      var fnNode = fn.node;
      var _iterator585 = _createForOfIteratorHelper(suppressionRanges),
        _step585;
      try {
        for (_iterator585.s(); !(_step585 = _iterator585.n()).done; ) {
          var suppressionRange = _step585.value;
          if (
            suppressionRange.disableComment.start == null ||
            fnNode.start == null ||
            fnNode.end == null
          ) {
            continue;
          }
          if (
            suppressionRange.disableComment.start > fnNode.start &&
            (suppressionRange.enableComment === null ||
              (suppressionRange.enableComment.end != null &&
                suppressionRange.enableComment.end < fnNode.end))
          ) {
            suppressionsInScope.push(suppressionRange);
          }
          if (
            suppressionRange.disableComment.start < fnNode.start &&
            (suppressionRange.enableComment === null ||
              (suppressionRange.enableComment.end != null &&
                suppressionRange.enableComment.end > fnNode.end))
          ) {
            suppressionsInScope.push(suppressionRange);
          }
        }
      } catch (err) {
        _iterator585.e(err);
      } finally {
        _iterator585.f();
      }
      return suppressionsInScope;
    }
    function findProgramSuppressions(
      programComments,
      ruleNames,
      flowSuppressions
    ) {
      var suppressionRanges = [];
      var disableComment = null;
      var enableComment = null;
      var source = null;
      var rulePattern = "(".concat(ruleNames.join("|"), ")");
      var disableNextLinePattern = new RegExp(
        "eslint-disable-next-line ".concat(rulePattern)
      );
      var disablePattern = new RegExp("eslint-disable ".concat(rulePattern));
      var enablePattern = new RegExp("eslint-enable ".concat(rulePattern));
      var flowSuppressionPattern = new RegExp(
        "\\$(FlowFixMe\\w*|FlowExpectedError|FlowIssue)\\[react\\-rule"
      );
      var _iterator586 = _createForOfIteratorHelper(programComments),
        _step586;
      try {
        for (_iterator586.s(); !(_step586 = _iterator586.n()).done; ) {
          var comment = _step586.value;
          if (comment.start == null || comment.end == null) {
            continue;
          }
          if (
            disableComment == null &&
            disableNextLinePattern.test(comment.value)
          ) {
            disableComment = comment;
            enableComment = comment;
            source = "Eslint";
          }
          if (
            flowSuppressions &&
            disableComment == null &&
            flowSuppressionPattern.test(comment.value)
          ) {
            disableComment = comment;
            enableComment = comment;
            source = "Flow";
          }
          if (disablePattern.test(comment.value)) {
            disableComment = comment;
            source = "Eslint";
          }
          if (enablePattern.test(comment.value) && source === "Eslint") {
            enableComment = comment;
          }
          if (disableComment != null && source != null) {
            suppressionRanges.push({
              disableComment: disableComment,
              enableComment: enableComment,
              source: source
            });
            disableComment = null;
            enableComment = null;
            source = null;
          }
        }
      } catch (err) {
        _iterator586.e(err);
      } finally {
        _iterator586.f();
      }
      return suppressionRanges;
    }
    function suppressionsToCompilerError(suppressionRanges) {
      var _a;
      CompilerError.invariant(suppressionRanges.length !== 0, {
        reason: "Expected at least suppression comment source range",
        loc: GeneratedSource
      });
      var error = new CompilerError();
      var _iterator587 = _createForOfIteratorHelper(suppressionRanges),
        _step587;
      try {
        for (_iterator587.s(); !(_step587 = _iterator587.n()).done; ) {
          var suppressionRange = _step587.value;
          if (
            suppressionRange.disableComment.start == null ||
            suppressionRange.disableComment.end == null
          ) {
            continue;
          }
          var reason = void 0,
            suggestion = void 0;
          switch (suppressionRange.source) {
            case "Eslint":
              reason =
                "React Compiler has skipped optimizing this component because one or more React ESLint rules were disabled";
              suggestion =
                "Remove the ESLint suppression and address the React error";
              break;
            case "Flow":
              reason =
                "React Compiler has skipped optimizing this component because one or more React rule violations were reported by Flow";
              suggestion =
                "Remove the Flow suppression and address the React error";
              break;
            default:
              assertExhaustive$1(
                suppressionRange.source,
                "Unhandled suppression source"
              );
          }
          error.pushErrorDetail(
            new CompilerErrorDetail({
              reason: "".concat(
                reason,
                ". React Compiler only works when your components follow all the rules of React, disabling them may result in unexpected or incorrect behavior"
              ),
              description: suppressionRange.disableComment.value.trim(),
              severity: ErrorSeverity.InvalidReact,
              loc:
                (_a = suppressionRange.disableComment.loc) !== null &&
                _a !== void 0
                  ? _a
                  : null,
              suggestions: [
                {
                  description: suggestion,
                  range: [
                    suppressionRange.disableComment.start,
                    suppressionRange.disableComment.end
                  ],
                  op: CompilerSuggestionOperation.Remove
                }
              ]
            })
          );
        }
      } catch (err) {
        _iterator587.e(err);
      } finally {
        _iterator587.f();
      }
      return error;
    }
    var OPT_IN_DIRECTIVES = new Set(["use forget", "use memo"]);
    var OPT_OUT_DIRECTIVES = new Set(["use no forget", "use no memo"]);
    function findDirectiveEnablingMemoization(directives) {
      return directives.filter(function (directive) {
        return OPT_IN_DIRECTIVES.has(directive.value.value);
      });
    }
    function findDirectiveDisablingMemoization(directives) {
      return directives.filter(function (directive) {
        return OPT_OUT_DIRECTIVES.has(directive.value.value);
      });
    }
    function isCriticalError(err) {
      return !(err instanceof CompilerError) || err.isCritical();
    }
    function isConfigError(err) {
      if (err instanceof CompilerError) {
        return err.details.some(function (detail) {
          return detail.severity === ErrorSeverity.InvalidConfig;
        });
      }
      return false;
    }
    function logError(err, pass, fnLoc) {
      var _a, _b;
      if (pass.opts.logger) {
        if (err instanceof CompilerError) {
          var _iterator588 = _createForOfIteratorHelper(err.details),
            _step588;
          try {
            for (_iterator588.s(); !(_step588 = _iterator588.n()).done; ) {
              var detail = _step588.value;
              pass.opts.logger.logEvent(pass.filename, {
                kind: "CompileError",
                fnLoc: fnLoc,
                detail: detail.options
              });
            }
          } catch (err) {
            _iterator588.e(err);
          } finally {
            _iterator588.f();
          }
        } else {
          var stringifiedError;
          if (err instanceof Error) {
            stringifiedError =
              (_a = err.stack) !== null && _a !== void 0 ? _a : err.message;
          } else {
            stringifiedError =
              (_b =
                err === null || err === void 0 ? void 0 : err.toString()) !==
                null && _b !== void 0
                ? _b
                : "[ null ]";
          }
          pass.opts.logger.logEvent(pass.filename, {
            kind: "PipelineError",
            fnLoc: fnLoc,
            data: stringifiedError
          });
        }
      }
    }
    function handleError(err, pass, fnLoc) {
      logError(err, pass, fnLoc);
      if (
        pass.opts.panicThreshold === "all_errors" ||
        (pass.opts.panicThreshold === "critical_errors" &&
          isCriticalError(err)) ||
        isConfigError(err)
      ) {
        throw err;
      }
    }
    function createNewFunctionNode(originalFn, compiledFn) {
      var _a, _b, _c;
      var transformedFn;
      switch (originalFn.node.type) {
        case "FunctionDeclaration": {
          var fn = {
            type: "FunctionDeclaration",
            id: compiledFn.id,
            loc:
              (_a = originalFn.node.loc) !== null && _a !== void 0 ? _a : null,
            async: compiledFn.async,
            generator: compiledFn.generator,
            params: compiledFn.params,
            body: compiledFn.body
          };
          transformedFn = fn;
          break;
        }
        case "ArrowFunctionExpression": {
          var _fn3 = {
            type: "ArrowFunctionExpression",
            loc:
              (_b = originalFn.node.loc) !== null && _b !== void 0 ? _b : null,
            async: compiledFn.async,
            generator: compiledFn.generator,
            params: compiledFn.params,
            expression: originalFn.node.expression,
            body: compiledFn.body
          };
          transformedFn = _fn3;
          break;
        }
        case "FunctionExpression": {
          var _fn4 = {
            type: "FunctionExpression",
            id: compiledFn.id,
            loc:
              (_c = originalFn.node.loc) !== null && _c !== void 0 ? _c : null,
            async: compiledFn.async,
            generator: compiledFn.generator,
            params: compiledFn.params,
            body: compiledFn.body
          };
          transformedFn = _fn4;
          break;
        }
        default: {
          assertExhaustive$1(
            originalFn.node,
            "Creating unhandled function: ".concat(originalFn.node)
          );
        }
      }
      ALREADY_COMPILED.add(transformedFn);
      return transformedFn;
    }
    function insertNewOutlinedFunctionNode(program, originalFn, compiledFn) {
      var _a, _b, _c;
      switch (originalFn.type) {
        case "FunctionDeclaration": {
          return originalFn.insertAfter(
            createNewFunctionNode(originalFn, compiledFn)
          )[0];
        }
        case "ArrowFunctionExpression":
        case "FunctionExpression": {
          var fn = {
            type: "FunctionDeclaration",
            id: compiledFn.id,
            loc:
              (_a = originalFn.node.loc) !== null && _a !== void 0 ? _a : null,
            async: compiledFn.async,
            generator: compiledFn.generator,
            params: compiledFn.params,
            body: compiledFn.body
          };
          var insertedFuncDecl = program.pushContainer("body", [fn])[0];
          CompilerError.invariant(insertedFuncDecl.isFunctionDeclaration(), {
            reason: "Expected inserted function declaration",
            description: "Got: ".concat(insertedFuncDecl),
            loc:
              (_c =
                (_b = insertedFuncDecl.node) === null || _b === void 0
                  ? void 0
                  : _b.loc) !== null && _c !== void 0
                ? _c
                : null
          });
          return insertedFuncDecl;
        }
        default: {
          assertExhaustive$1(
            originalFn,
            "Inserting unhandled function: ".concat(originalFn)
          );
        }
      }
    }
    var ALREADY_COMPILED = new (
      WeakSet !== null && WeakSet !== void 0 ? WeakSet : Set
    )();
    var DEFAULT_ESLINT_SUPPRESSIONS = [
      "react-hooks/exhaustive-deps",
      "react-hooks/rules-of-hooks"
    ];
    function isFilePartOfSources(sources, filename) {
      if (typeof sources === "function") {
        return sources(filename);
      }
      var _iterator589 = _createForOfIteratorHelper(sources),
        _step589;
      try {
        for (_iterator589.s(); !(_step589 = _iterator589.n()).done; ) {
          var prefix = _step589.value;
          if (filename.indexOf(prefix) !== -1) {
            return true;
          }
        }
      } catch (err) {
        _iterator589.e(err);
      } finally {
        _iterator589.f();
      }
      return false;
    }
    function compileProgram(program, pass) {
      var _a, _b;
      if (shouldSkipCompilation(program, pass)) {
        return null;
      }
      var environment = pass.opts.environment;
      var restrictedImportsErr = validateRestrictedImports(
        program,
        environment
      );
      if (restrictedImportsErr) {
        handleError(restrictedImportsErr, pass, null);
        return null;
      }
      var useMemoCacheIdentifier = program.scope.generateUidIdentifier("c");
      var suppressions = findProgramSuppressions(
        pass.comments,
        (_a = pass.opts.eslintSuppressionRules) !== null && _a !== void 0
          ? _a
          : DEFAULT_ESLINT_SUPPRESSIONS,
        pass.opts.flowSuppressions
      );
      var queue = [];
      var compiledFns = [];
      var traverseFunction = function traverseFunction(fn, pass) {
        var fnType = getReactFunctionType(fn, pass, environment);
        if (fnType === null || ALREADY_COMPILED.has(fn.node)) {
          return;
        }
        ALREADY_COMPILED.add(fn.node);
        fn.skip();
        queue.push({ kind: "original", fn: fn, fnType: fnType });
      };
      program.traverse(
        {
          ClassDeclaration: function ClassDeclaration(node) {
            node.skip();
            return;
          },
          ClassExpression: function ClassExpression(node) {
            node.skip();
            return;
          },
          FunctionDeclaration: traverseFunction,
          FunctionExpression: traverseFunction,
          ArrowFunctionExpression: traverseFunction
        },
        Object.assign(Object.assign({}, pass), {
          opts: Object.assign(Object.assign({}, pass.opts), pass.opts),
          filename: (_b = pass.filename) !== null && _b !== void 0 ? _b : null
        })
      );
      var retryErrors = [];
      var processFn = function processFn(fn, fnType) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var optInDirectives = [];
        var optOutDirectives = [];
        if (fn.node.body.type === "BlockStatement") {
          optInDirectives = findDirectiveEnablingMemoization(
            fn.node.body.directives
          );
          optOutDirectives = findDirectiveDisablingMemoization(
            fn.node.body.directives
          );
        }
        var suppressionsInFunction = filterSuppressionsThatAffectFunction(
          suppressions,
          fn
        );
        var compileResult;
        if (suppressionsInFunction.length > 0) {
          compileResult = {
            kind: "error",
            error: suppressionsToCompilerError(suppressionsInFunction)
          };
        } else {
          try {
            compileResult = {
              kind: "compile",
              compiledFn: compileFn(
                fn,
                environment,
                fnType,
                "all_features",
                useMemoCacheIdentifier.name,
                pass.opts.logger,
                pass.filename,
                pass.code
              )
            };
          } catch (err) {
            compileResult = { kind: "error", error: err };
          }
        }
        if (compileResult.kind === "error") {
          if (optOutDirectives.length > 0) {
            logError(
              compileResult.error,
              pass,
              (_a = fn.node.loc) !== null && _a !== void 0 ? _a : null
            );
          } else {
            handleError(
              compileResult.error,
              pass,
              (_b = fn.node.loc) !== null && _b !== void 0 ? _b : null
            );
          }
          if (
            !(
              environment.enableFire ||
              environment.inferEffectDependencies != null
            )
          ) {
            return null;
          }
          try {
            compileResult = {
              kind: "compile",
              compiledFn: compileFn(
                fn,
                environment,
                fnType,
                "no_inferred_memo",
                useMemoCacheIdentifier.name,
                pass.opts.logger,
                pass.filename,
                pass.code
              )
            };
          } catch (err) {
            if (err instanceof CompilerError) {
              retryErrors.push({ fn: fn, error: err });
            }
            return null;
          }
        }
        (_c = pass.opts.logger) === null || _c === void 0
          ? void 0
          : _c.logEvent(pass.filename, {
              kind: "CompileSuccess",
              fnLoc: (_d = fn.node.loc) !== null && _d !== void 0 ? _d : null,
              fnName:
                (_f =
                  (_e = compileResult.compiledFn.id) === null || _e === void 0
                    ? void 0
                    : _e.name) !== null && _f !== void 0
                  ? _f
                  : null,
              memoSlots: compileResult.compiledFn.memoSlotsUsed,
              memoBlocks: compileResult.compiledFn.memoBlocks,
              memoValues: compileResult.compiledFn.memoValues,
              prunedMemoBlocks: compileResult.compiledFn.prunedMemoBlocks,
              prunedMemoValues: compileResult.compiledFn.prunedMemoValues
            });
        if (optInDirectives.length > 0) {
          return compileResult.compiledFn;
        } else if (pass.opts.compilationMode === "annotation") {
          return null;
        }
        if (
          pass.opts.ignoreUseNoForget === false &&
          optOutDirectives.length > 0
        ) {
          var _iterator590 = _createForOfIteratorHelper(optOutDirectives),
            _step590;
          try {
            for (_iterator590.s(); !(_step590 = _iterator590.n()).done; ) {
              var _directive = _step590.value;
              (_g = pass.opts.logger) === null || _g === void 0
                ? void 0
                : _g.logEvent(pass.filename, {
                    kind: "CompileSkip",
                    fnLoc:
                      (_h = fn.node.body.loc) !== null && _h !== void 0
                        ? _h
                        : null,
                    reason: "Skipped due to '".concat(
                      _directive.value.value,
                      "' directive."
                    ),
                    loc:
                      (_j = _directive.loc) !== null && _j !== void 0
                        ? _j
                        : null
                  });
            }
          } catch (err) {
            _iterator590.e(err);
          } finally {
            _iterator590.f();
          }
          return null;
        }
        if (!pass.opts.noEmit) {
          return compileResult.compiledFn;
        }
        return null;
      };
      while (queue.length !== 0) {
        var current = queue.shift();
        var compiled = processFn(current.fn, current.fnType);
        if (compiled === null) {
          continue;
        }
        var _iterator591 = _createForOfIteratorHelper(compiled.outlined),
          _step591;
        try {
          for (_iterator591.s(); !(_step591 = _iterator591.n()).done; ) {
            var outlined = _step591.value;
            CompilerError.invariant(outlined.fn.outlined.length === 0, {
              reason: "Unexpected nested outlined functions",
              loc: outlined.fn.loc
            });
            var fn = insertNewOutlinedFunctionNode(
              program,
              current.fn,
              outlined.fn
            );
            fn.skip();
            ALREADY_COMPILED.add(fn.node);
            if (outlined.type !== null) {
              queue.push({ kind: "outlined", fn: fn, fnType: outlined.type });
            }
          }
        } catch (err) {
          _iterator591.e(err);
        } finally {
          _iterator591.f();
        }
        compiledFns.push({
          kind: current.kind,
          compiledFn: compiled,
          originalFn: current.fn
        });
      }
      var moduleScopeOptOutDirectives = findDirectiveDisablingMemoization(
        program.node.directives
      );
      if (moduleScopeOptOutDirectives.length > 0) {
        return null;
      }
      var gating = null;
      if (pass.opts.gating != null) {
        gating = {
          gatingFn: pass.opts.gating,
          referencedBeforeDeclared:
            getFunctionReferencedBeforeDeclarationAtTopLevel(
              program,
              compiledFns
            )
        };
      }
      var hasLoweredContextAccess = compiledFns.some(function (c) {
        return c.compiledFn.hasLoweredContextAccess;
      });
      var externalFunctions = [];
      try {
        if (gating != null) {
          externalFunctions.push(gating.gatingFn);
        }
        var _lowerContextAccess = environment.lowerContextAccess;
        if (_lowerContextAccess && hasLoweredContextAccess) {
          externalFunctions.push(_lowerContextAccess);
        }
        var enableEmitInstrumentForget = environment.enableEmitInstrumentForget;
        if (enableEmitInstrumentForget != null) {
          externalFunctions.push(enableEmitInstrumentForget.fn);
          if (enableEmitInstrumentForget.gating != null) {
            externalFunctions.push(enableEmitInstrumentForget.gating);
          }
        }
        if (environment.enableEmitFreeze != null) {
          externalFunctions.push(environment.enableEmitFreeze);
        }
        if (environment.enableEmitHookGuards != null) {
          externalFunctions.push(environment.enableEmitHookGuards);
        }
        if (environment.enableChangeDetectionForDebugging != null) {
          externalFunctions.push(environment.enableChangeDetectionForDebugging);
        }
        var hasFireRewrite = compiledFns.some(function (c) {
          return c.compiledFn.hasFireRewrite;
        });
        if (environment.enableFire && hasFireRewrite) {
          externalFunctions.push({
            source: getReactCompilerRuntimeModule(pass.opts),
            importSpecifierName: "useFire"
          });
        }
      } catch (err) {
        handleError(err, pass, null);
        return null;
      }
      for (
        var _i46 = 0, _compiledFns = compiledFns;
        _i46 < _compiledFns.length;
        _i46++
      ) {
        var result = _compiledFns[_i46];
        var kind = result.kind,
          originalFn = result.originalFn,
          compiledFn = result.compiledFn;
        var transformedFn = createNewFunctionNode(originalFn, compiledFn);
        if (gating != null && kind === "original") {
          insertGatedFunctionDeclaration(
            originalFn,
            transformedFn,
            gating.gatingFn,
            gating.referencedBeforeDeclared.has(result)
          );
        } else {
          originalFn.replaceWith(transformedFn);
        }
      }
      if (compiledFns.length > 0) {
        var needsMemoCacheFunctionImport = false;
        var _iterator592 = _createForOfIteratorHelper(compiledFns),
          _step592;
        try {
          for (_iterator592.s(); !(_step592 = _iterator592.n()).done; ) {
            var _fn5 = _step592.value;
            if (_fn5.compiledFn.memoSlotsUsed > 0) {
              needsMemoCacheFunctionImport = true;
              break;
            }
          }
        } catch (err) {
          _iterator592.e(err);
        } finally {
          _iterator592.f();
        }
        if (needsMemoCacheFunctionImport) {
          updateMemoCacheFunctionImport(
            program,
            getReactCompilerRuntimeModule(pass.opts),
            useMemoCacheIdentifier.name
          );
        }
        addImportsToProgram(program, externalFunctions);
      }
      return { retryErrors: retryErrors };
    }
    function shouldSkipCompilation(program, pass) {
      if (pass.opts.sources) {
        if (pass.filename === null) {
          var error = new CompilerError();
          error.pushErrorDetail(
            new CompilerErrorDetail({
              reason: "Expected a filename but found none.",
              description:
                "When the 'sources' config options is specified, the React compiler will only compile files with a name",
              severity: ErrorSeverity.InvalidConfig,
              loc: null
            })
          );
          handleError(error, pass, null);
          return true;
        }
        if (!isFilePartOfSources(pass.opts.sources, pass.filename)) {
          return true;
        }
      }
      if (
        hasMemoCacheFunctionImport(
          program,
          getReactCompilerRuntimeModule(pass.opts)
        )
      ) {
        return true;
      }
      return false;
    }
    function getReactFunctionType(fn, pass, environment) {
      var _a, _b;
      var hookPattern = environment.hookPattern;
      if (fn.node.body.type === "BlockStatement") {
        if (
          findDirectiveEnablingMemoization(fn.node.body.directives).length > 0
        )
          return (_a = getComponentOrHookLike(fn, hookPattern)) !== null &&
            _a !== void 0
            ? _a
            : "Other";
      }
      var componentSyntaxType = null;
      if (fn.isFunctionDeclaration()) {
        if (isComponentDeclaration(fn.node)) {
          componentSyntaxType = "Component";
        } else if (isHookDeclaration(fn.node)) {
          componentSyntaxType = "Hook";
        }
      }
      switch (pass.opts.compilationMode) {
        case "annotation": {
          return null;
        }
        case "infer": {
          return componentSyntaxType !== null && componentSyntaxType !== void 0
            ? componentSyntaxType
            : getComponentOrHookLike(fn, hookPattern);
        }
        case "syntax": {
          return componentSyntaxType;
        }
        case "all": {
          if (fn.scope.getProgramParent() !== fn.scope.parent) {
            return null;
          }
          return (_b = getComponentOrHookLike(fn, hookPattern)) !== null &&
            _b !== void 0
            ? _b
            : "Other";
        }
        default: {
          assertExhaustive$1(
            pass.opts.compilationMode,
            "Unexpected compilationMode `".concat(
              pass.opts.compilationMode,
              "`"
            )
          );
        }
      }
    }
    function hasMemoCacheFunctionImport(program, moduleName) {
      var hasUseMemoCache = false;
      program.traverse({
        ImportSpecifier: function ImportSpecifier(path) {
          var imported = path.get("imported");
          var importedName = null;
          if (imported.isIdentifier()) {
            importedName = imported.node.name;
          } else if (imported.isStringLiteral()) {
            importedName = imported.node.value;
          }
          if (
            importedName === "c" &&
            path.parentPath.isImportDeclaration() &&
            path.parentPath.get("source").node.value === moduleName
          ) {
            hasUseMemoCache = true;
          }
        }
      });
      return hasUseMemoCache;
    }
    function isHookName$1(s, hookPattern) {
      if (hookPattern !== null) {
        return new RegExp(hookPattern).test(s);
      }
      return /^use[A-Z0-9]/.test(s);
    }
    function isHook$1(path, hookPattern) {
      if (path.isIdentifier()) {
        return isHookName$1(path.node.name, hookPattern);
      } else if (
        path.isMemberExpression() &&
        !path.node.computed &&
        isHook$1(path.get("property"), hookPattern)
      ) {
        var obj = path.get("object").node;
        var isPascalCaseNameSpace = /^[A-Z].*/;
        return (
          obj.type === "Identifier" && isPascalCaseNameSpace.test(obj.name)
        );
      } else {
        return false;
      }
    }
    function isComponentName$1(path) {
      return path.isIdentifier() && /^[A-Z]/.test(path.node.name);
    }
    function isReactAPI(path, functionName) {
      var node = path.node;
      return (
        (node.type === "Identifier" && node.name === functionName) ||
        (node.type === "MemberExpression" &&
          node.object.type === "Identifier" &&
          node.object.name === "React" &&
          node.property.type === "Identifier" &&
          node.property.name === functionName)
      );
    }
    function isForwardRefCallback$1(path) {
      return !!(
        path.parentPath.isCallExpression() &&
        path.parentPath.get("callee").isExpression() &&
        isReactAPI(path.parentPath.get("callee"), "forwardRef")
      );
    }
    function isMemoCallback$1(path) {
      return (
        path.parentPath.isCallExpression() &&
        path.parentPath.get("callee").isExpression() &&
        isReactAPI(path.parentPath.get("callee"), "memo")
      );
    }
    function isValidPropsAnnotation(annot) {
      if (annot == null) {
        return true;
      } else if (annot.type === "TSTypeAnnotation") {
        switch (annot.typeAnnotation.type) {
          case "TSArrayType":
          case "TSBigIntKeyword":
          case "TSBooleanKeyword":
          case "TSConstructorType":
          case "TSFunctionType":
          case "TSLiteralType":
          case "TSNeverKeyword":
          case "TSNumberKeyword":
          case "TSStringKeyword":
          case "TSSymbolKeyword":
          case "TSTupleType":
            return false;
        }
        return true;
      } else if (annot.type === "TypeAnnotation") {
        switch (annot.typeAnnotation.type) {
          case "ArrayTypeAnnotation":
          case "BooleanLiteralTypeAnnotation":
          case "BooleanTypeAnnotation":
          case "EmptyTypeAnnotation":
          case "FunctionTypeAnnotation":
          case "NumberLiteralTypeAnnotation":
          case "NumberTypeAnnotation":
          case "StringLiteralTypeAnnotation":
          case "StringTypeAnnotation":
          case "SymbolTypeAnnotation":
          case "ThisTypeAnnotation":
          case "TupleTypeAnnotation":
            return false;
        }
        return true;
      } else if (annot.type === "Noop") {
        return true;
      } else {
        assertExhaustive$1(
          annot,
          "Unexpected annotation node `".concat(annot, "`")
        );
      }
    }
    function isValidComponentParams(params) {
      if (params.length === 0) {
        return true;
      } else if (params.length > 0 && params.length <= 2) {
        if (!isValidPropsAnnotation(params[0].node.typeAnnotation)) {
          return false;
        }
        if (params.length === 1) {
          return !params[0].isRestElement();
        } else if (params[1].isIdentifier()) {
          var _name14 = params[1].node.name;
          return _name14.includes("ref") || _name14.includes("Ref");
        } else {
          return false;
        }
      }
      return false;
    }
    function getComponentOrHookLike(node, hookPattern) {
      var functionName = getFunctionName$1(node);
      if (functionName !== null && isComponentName$1(functionName)) {
        var isComponent =
          callsHooksOrCreatesJsx(node, hookPattern) &&
          isValidComponentParams(node.get("params")) &&
          !returnsNonNode(node);
        return isComponent ? "Component" : null;
      } else if (functionName !== null && isHook$1(functionName, hookPattern)) {
        return callsHooksOrCreatesJsx(node, hookPattern) ? "Hook" : null;
      }
      if (node.isFunctionExpression() || node.isArrowFunctionExpression()) {
        if (isForwardRefCallback$1(node) || isMemoCallback$1(node)) {
          return callsHooksOrCreatesJsx(node, hookPattern) ? "Component" : null;
        }
      }
      return null;
    }
    function skipNestedFunctions(node) {
      return function (fn) {
        if (fn.node !== node.node) {
          fn.skip();
        }
      };
    }
    function callsHooksOrCreatesJsx(node, hookPattern) {
      var invokesHooks = false;
      var createsJsx = false;
      node.traverse({
        JSX: function JSX() {
          createsJsx = true;
        },
        CallExpression: function CallExpression(call) {
          var callee = call.get("callee");
          if (callee.isExpression() && isHook$1(callee, hookPattern)) {
            invokesHooks = true;
          }
        },
        ArrowFunctionExpression: skipNestedFunctions(node),
        FunctionExpression: skipNestedFunctions(node),
        FunctionDeclaration: skipNestedFunctions(node)
      });
      return invokesHooks || createsJsx;
    }
    function returnsNonNode(node) {
      var hasReturn = false;
      var returnsNonNode = false;
      node.traverse({
        ReturnStatement: function ReturnStatement(ret) {
          hasReturn = true;
          var argument = ret.node.argument;
          if (argument == null) {
            returnsNonNode = true;
          } else {
            switch (argument.type) {
              case "ObjectExpression":
              case "ArrowFunctionExpression":
              case "FunctionExpression":
              case "BigIntLiteral":
              case "ClassExpression":
              case "NewExpression":
                returnsNonNode = true;
            }
          }
        },
        ArrowFunctionExpression: skipNestedFunctions(node),
        FunctionExpression: skipNestedFunctions(node),
        FunctionDeclaration: skipNestedFunctions(node),
        ObjectMethod: function ObjectMethod(node) {
          return node.skip();
        }
      });
      return !hasReturn || returnsNonNode;
    }
    function getFunctionName$1(path) {
      if (path.isFunctionDeclaration()) {
        var _id12 = path.get("id");
        if (_id12.isIdentifier()) {
          return _id12;
        }
        return null;
      }
      var id = null;
      var parent = path.parentPath;
      if (
        parent.isVariableDeclarator() &&
        parent.get("init").node === path.node
      ) {
        id = parent.get("id");
      } else if (
        parent.isAssignmentExpression() &&
        parent.get("right").node === path.node &&
        parent.get("operator") === "="
      ) {
        id = parent.get("left");
      } else if (
        parent.isProperty() &&
        parent.get("value").node === path.node &&
        !parent.get("computed") &&
        parent.get("key").isLVal()
      ) {
        id = parent.get("key");
      } else if (
        parent.isAssignmentPattern() &&
        parent.get("right").node === path.node &&
        !parent.get("computed")
      ) {
        id = parent.get("left");
      }
      if (id !== null && (id.isIdentifier() || id.isMemberExpression())) {
        return id;
      } else {
        return null;
      }
    }
    function getFunctionReferencedBeforeDeclarationAtTopLevel(program, fns) {
      var fnNames = new Map(
        fns
          .map(function (fn) {
            return [getFunctionName$1(fn.originalFn), fn];
          })
          .filter(function (entry) {
            return !!entry[0] && entry[0].isIdentifier();
          })
          .map(function (entry) {
            return [entry[0].node.name, { id: entry[0].node, fn: entry[1] }];
          })
      );
      var referencedBeforeDeclaration = new Set();
      program.traverse({
        TypeAnnotation: function TypeAnnotation(path) {
          path.skip();
        },
        TSTypeAnnotation: function TSTypeAnnotation(path) {
          path.skip();
        },
        TypeAlias: function TypeAlias(path) {
          path.skip();
        },
        TSTypeAliasDeclaration: function TSTypeAliasDeclaration(path) {
          path.skip();
        },
        Identifier: function Identifier(id) {
          var fn = fnNames.get(id.node.name);
          if (!fn) {
            return;
          }
          if (id.node === fn.id) {
            fnNames["delete"](id.node.name);
            return;
          }
          var scope = id.scope.getFunctionParent();
          if (scope === null && id.isReferencedIdentifier()) {
            referencedBeforeDeclaration.add(fn.fn);
          }
        }
      });
      return referencedBeforeDeclaration;
    }
    function getReactCompilerRuntimeModule(opts) {
      if (opts.target === "19") {
        return "react/compiler-runtime";
      } else if (opts.target === "17" || opts.target === "18") {
        return "react-compiler-runtime";
      } else {
        CompilerError.invariant(
          opts.target != null &&
            opts.target.kind === "donotuse_meta_internal" &&
            typeof opts.target.runtimeModule === "string",
          {
            reason: "Expected target to already be validated",
            description: null,
            loc: null,
            suggestions: null
          }
        );
        return opts.target.runtimeModule;
      }
    }
    function hasModule(name) {
      if (typeof require === "undefined") {
        return false;
      }
      try {
        return !!require.resolve(name);
      } catch (error) {
        if (
          error.code === "MODULE_NOT_FOUND" &&
          error.message.indexOf(name) !== -1
        ) {
          return false;
        }
        throw error;
      }
    }
    function pipelineUsesReanimatedPlugin(plugins) {
      if (Array.isArray(plugins)) {
        var _iterator593 = _createForOfIteratorHelper(plugins),
          _step593;
        try {
          for (_iterator593.s(); !(_step593 = _iterator593.n()).done; ) {
            var _plugin2 = _step593.value;
            if (hasOwnProperty$1(_plugin2, "key")) {
              var _key42 = _plugin2.key;
              if (
                typeof _key42 === "string" &&
                _key42.indexOf("react-native-reanimated") !== -1
              ) {
                return true;
              }
            }
          }
        } catch (err) {
          _iterator593.e(err);
        } finally {
          _iterator593.f();
        }
      }
      return hasModule("react-native-reanimated");
    }
    function injectReanimatedFlag(options) {
      return Object.assign(Object.assign({}, options), {
        environment: Object.assign(Object.assign({}, options.environment), {
          enableCustomTypeDefinitionForReanimated: true
        })
      });
    }
    function throwInvalidReact(options, _ref46) {
      var logger = _ref46.logger,
        filename = _ref46.filename;
      var detail = Object.assign(Object.assign({}, options), {
        severity: ErrorSeverity.InvalidReact
      });
      logger === null || logger === void 0
        ? void 0
        : logger.logEvent(filename, {
            kind: "CompileError",
            fnLoc: null,
            detail: detail
          });
      CompilerError["throw"](detail);
    }
    function assertValidEffectImportReference(numArgs, paths, context) {
      var _a;
      var _iterator594 = _createForOfIteratorHelper(paths),
        _step594;
      try {
        for (_iterator594.s(); !(_step594 = _iterator594.n()).done; ) {
          var path = _step594.value;
          var parent = path.parentPath;
          if (parent != null && parent.isCallExpression()) {
            var args = parent.get("arguments");
            if (args.length === numArgs) {
              var maybeErrorDiagnostic = matchCompilerDiagnostic(
                path,
                context.transformErrors
              );
              throwInvalidReact(
                {
                  reason:
                    "[InferEffectDependencies] React Compiler is unable to infer dependencies of this effect. " +
                    "This will break your build! " +
                    "To resolve, either pass your own dependency array or fix reported compiler bailout diagnostics.",
                  description: maybeErrorDiagnostic
                    ? "(Bailout reason: ".concat(maybeErrorDiagnostic, ")")
                    : null,
                  loc:
                    (_a = parent.node.loc) !== null && _a !== void 0 ? _a : null
                },
                context
              );
            }
          }
        }
      } catch (err) {
        _iterator594.e(err);
      } finally {
        _iterator594.f();
      }
    }
    function assertValidFireImportReference(paths, context) {
      var _a;
      if (paths.length > 0) {
        var maybeErrorDiagnostic = matchCompilerDiagnostic(
          paths[0],
          context.transformErrors
        );
        throwInvalidReact(
          {
            reason:
              "[Fire] Untransformed reference to compiler-required feature. " +
              "Either remove this `fire` call or ensure it is successfully transformed by the compiler",
            description: maybeErrorDiagnostic
              ? "(Bailout reason: ".concat(maybeErrorDiagnostic, ")")
              : null,
            loc: (_a = paths[0].node.loc) !== null && _a !== void 0 ? _a : null
          },
          context
        );
      }
    }
    function validateNoUntransformedReferences(
      path,
      filename,
      logger,
      env,
      transformErrors
    ) {
      var moduleLoadChecks = new Map();
      if (env.enableFire) {
        var _iterator595 = _createForOfIteratorHelper(
            Environment.knownReactModules
          ),
          _step595;
        try {
          for (_iterator595.s(); !(_step595 = _iterator595.n()).done; ) {
            var module = _step595.value;
            var react = getOrInsertWith(moduleLoadChecks, module, function () {
              return new Map();
            });
            react.set("fire", assertValidFireImportReference);
          }
        } catch (err) {
          _iterator595.e(err);
        } finally {
          _iterator595.f();
        }
      }
      if (env.inferEffectDependencies) {
        var _iterator596 = _createForOfIteratorHelper(
            env.inferEffectDependencies
          ),
          _step596;
        try {
          for (_iterator596.s(); !(_step596 = _iterator596.n()).done; ) {
            var _step596$value = _step596.value,
              _step596$value$functi = _step596$value["function"],
              source = _step596$value$functi.source,
              importSpecifierName = _step596$value$functi.importSpecifierName,
              numRequiredArgs = _step596$value.numRequiredArgs;
            var _module = getOrInsertWith(
              moduleLoadChecks,
              source,
              function () {
                return new Map();
              }
            );
            _module.set(
              importSpecifierName,
              assertValidEffectImportReference.bind(null, numRequiredArgs)
            );
          }
        } catch (err) {
          _iterator596.e(err);
        } finally {
          _iterator596.f();
        }
      }
      if (moduleLoadChecks.size > 0) {
        transformProgram(
          path,
          moduleLoadChecks,
          filename,
          logger,
          transformErrors
        );
      }
    }
    function validateImportSpecifier(specifier, importSpecifierChecks, state) {
      var _a;
      var imported = specifier.get("imported");
      var specifierName =
        imported.node.type === "Identifier"
          ? imported.node.name
          : imported.node.value;
      var checkFn = importSpecifierChecks.get(specifierName);
      if (checkFn == null) {
        return;
      }
      if (state.shouldInvalidateScopes) {
        state.shouldInvalidateScopes = false;
        state.program.scope.crawl();
      }
      var local = specifier.get("local");
      var binding = local.scope.getBinding(local.node.name);
      CompilerError.invariant(binding != null, {
        reason: "Expected binding to be found for import specifier",
        loc: (_a = local.node.loc) !== null && _a !== void 0 ? _a : null
      });
      checkFn(binding.referencePaths, state);
    }
    function validateNamespacedImport(specifier, importSpecifierChecks, state) {
      var _a;
      if (state.shouldInvalidateScopes) {
        state.shouldInvalidateScopes = false;
        state.program.scope.crawl();
      }
      var local = specifier.get("local");
      var binding = local.scope.getBinding(local.node.name);
      var defaultCheckFn = importSpecifierChecks.get(DEFAULT_EXPORT);
      CompilerError.invariant(binding != null, {
        reason: "Expected binding to be found for import specifier",
        loc: (_a = local.node.loc) !== null && _a !== void 0 ? _a : null
      });
      var filteredReferences = new Map();
      var _iterator597 = _createForOfIteratorHelper(binding.referencePaths),
        _step597;
      try {
        for (_iterator597.s(); !(_step597 = _iterator597.n()).done; ) {
          var reference = _step597.value;
          if (defaultCheckFn != null) {
            getOrInsertWith(filteredReferences, defaultCheckFn, function () {
              return [];
            }).push(reference);
          }
          var parent = reference.parentPath;
          if (
            parent != null &&
            parent.isMemberExpression() &&
            parent.get("object") === reference
          ) {
            if (
              parent.node.computed ||
              parent.node.property.type !== "Identifier"
            ) {
              continue;
            }
            var checkFn = importSpecifierChecks.get(parent.node.property.name);
            if (checkFn != null) {
              getOrInsertWith(filteredReferences, checkFn, function () {
                return [];
              }).push(parent);
            }
          }
        }
      } catch (err) {
        _iterator597.e(err);
      } finally {
        _iterator597.f();
      }
      var _iterator598 = _createForOfIteratorHelper(filteredReferences),
        _step598;
      try {
        for (_iterator598.s(); !(_step598 = _iterator598.n()).done; ) {
          var _step598$value = _slicedToArray(_step598.value, 2),
            _checkFn = _step598$value[0],
            references = _step598$value[1];
          _checkFn(references, state);
        }
      } catch (err) {
        _iterator598.e(err);
      } finally {
        _iterator598.f();
      }
    }
    function transformProgram(
      path,
      moduleLoadChecks,
      filename,
      logger,
      transformErrors
    ) {
      var traversalState = {
        shouldInvalidateScopes: true,
        program: path,
        filename: filename,
        logger: logger,
        transformErrors: transformErrors
      };
      path.traverse({
        ImportDeclaration: function ImportDeclaration(path) {
          var importSpecifierChecks = moduleLoadChecks.get(
            path.node.source.value
          );
          if (importSpecifierChecks == null) {
            return;
          }
          var specifiers = path.get("specifiers");
          var _iterator599 = _createForOfIteratorHelper(specifiers),
            _step599;
          try {
            for (_iterator599.s(); !(_step599 = _iterator599.n()).done; ) {
              var specifier = _step599.value;
              if (specifier.isImportSpecifier()) {
                validateImportSpecifier(
                  specifier,
                  importSpecifierChecks,
                  traversalState
                );
              } else {
                validateNamespacedImport(
                  specifier,
                  importSpecifierChecks,
                  traversalState
                );
              }
            }
          } catch (err) {
            _iterator599.e(err);
          } finally {
            _iterator599.f();
          }
        }
      });
    }
    function matchCompilerDiagnostic(badReference, transformErrors) {
      var _iterator600 = _createForOfIteratorHelper(transformErrors),
        _step600;
      try {
        for (_iterator600.s(); !(_step600 = _iterator600.n()).done; ) {
          var _step600$value = _step600.value,
            fn = _step600$value.fn,
            error = _step600$value.error;
          if (fn.isAncestor(badReference)) {
            return error.toString();
          }
        }
      } catch (err) {
        _iterator600.e(err);
      } finally {
        _iterator600.f();
      }
      return null;
    }
    var ENABLE_REACT_COMPILER_TIMINGS =
      process.env["ENABLE_REACT_COMPILER_TIMINGS"] === "1";
    function BabelPluginReactCompiler(_babel) {
      return {
        name: "react-forget",
        visitor: {
          Program: {
            enter: function enter(prog, pass) {
              var _a, _b, _c, _d, _e;
              var filename =
                (_a = pass.filename) !== null && _a !== void 0 ? _a : "unknown";
              if (ENABLE_REACT_COMPILER_TIMINGS === true) {
                performance.mark("".concat(filename, ":start"), {
                  detail: "BabelPlugin:Program:start"
                });
              }
              var opts = parsePluginOptions(pass.opts);
              var isDev = true === true;
              if (
                opts.enableReanimatedCheck === true &&
                pipelineUsesReanimatedPlugin(pass.file.opts.plugins)
              ) {
                opts = injectReanimatedFlag(opts);
              }
              if (
                opts.environment.enableResetCacheOnSourceFileChanges !==
                  false &&
                isDev
              ) {
                opts = Object.assign(Object.assign({}, opts), {
                  environment: Object.assign(
                    Object.assign({}, opts.environment),
                    { enableResetCacheOnSourceFileChanges: true }
                  )
                });
              }
              var result = compileProgram(prog, {
                opts: opts,
                filename:
                  (_b = pass.filename) !== null && _b !== void 0 ? _b : null,
                comments:
                  (_c = pass.file.ast.comments) !== null && _c !== void 0
                    ? _c
                    : [],
                code: pass.file.code
              });
              validateNoUntransformedReferences(
                prog,
                (_d = pass.filename) !== null && _d !== void 0 ? _d : null,
                opts.logger,
                opts.environment,
                (_e =
                  result === null || result === void 0
                    ? void 0
                    : result.retryErrors) !== null && _e !== void 0
                  ? _e
                  : []
              );
              if (ENABLE_REACT_COMPILER_TIMINGS === true) {
                performance.mark("".concat(filename, ":end"), {
                  detail: "BabelPlugin:Program:end"
                });
              }
            },
            exit: function exit(_, pass) {
              var _a;
              if (ENABLE_REACT_COMPILER_TIMINGS === true) {
                var filename =
                  (_a = pass.filename) !== null && _a !== void 0
                    ? _a
                    : "unknown";
                var measurement = performance.measure(filename, {
                  start: "".concat(filename, ":start"),
                  end: "".concat(filename, ":end"),
                  detail: "BabelPlugin:Program"
                });
                if ("logger" in pass.opts && pass.opts.logger != null) {
                  var logger = pass.opts.logger;
                  logger.logEvent(filename, {
                    kind: "Timing",
                    measurement: measurement
                  });
                }
              }
            }
          }
        }
      };
    }
    function assertExhaustive(_, errorMsg) {
      throw new Error(errorMsg);
    }
    var DEFAULT_REPORTABLE_LEVELS = new Set([
      ErrorSeverity.InvalidReact,
      ErrorSeverity.InvalidJS
    ]);
    var reportableLevels = DEFAULT_REPORTABLE_LEVELS;
    function isReportableDiagnostic(detail) {
      return (
        reportableLevels.has(detail.severity) &&
        detail.loc != null &&
        _typeof(detail.loc) !== "symbol"
      );
    }
    function makeSuggestions(detail) {
      var suggest = [];
      if (Array.isArray(detail.suggestions)) {
        var _iterator601 = _createForOfIteratorHelper(detail.suggestions),
          _step601;
        try {
          var _loop22 = function _loop22() {
            var suggestion = _step601.value;
            switch (suggestion.op) {
              case CompilerSuggestionOperation.InsertBefore:
                suggest.push({
                  desc: suggestion.description,
                  fix: function fix(fixer) {
                    return fixer.insertTextBeforeRange(
                      suggestion.range,
                      suggestion.text
                    );
                  }
                });
                break;
              case CompilerSuggestionOperation.InsertAfter:
                suggest.push({
                  desc: suggestion.description,
                  fix: function fix(fixer) {
                    return fixer.insertTextAfterRange(
                      suggestion.range,
                      suggestion.text
                    );
                  }
                });
                break;
              case CompilerSuggestionOperation.Replace:
                suggest.push({
                  desc: suggestion.description,
                  fix: function fix(fixer) {
                    return fixer.replaceTextRange(
                      suggestion.range,
                      suggestion.text
                    );
                  }
                });
                break;
              case CompilerSuggestionOperation.Remove:
                suggest.push({
                  desc: suggestion.description,
                  fix: function fix(fixer) {
                    return fixer.removeRange(suggestion.range);
                  }
                });
                break;
              default:
                assertExhaustive(suggestion, "Unhandled suggestion operation");
            }
          };
          for (_iterator601.s(); !(_step601 = _iterator601.n()).done; ) {
            _loop22();
          }
        } catch (err) {
          _iterator601.e(err);
        } finally {
          _iterator601.f();
        }
      }
      return suggest;
    }
    var COMPILER_OPTIONS = {
      noEmit: true,
      panicThreshold: "none",
      flowSuppressions: false
    };
    var rule$1 = {
      meta: {
        type: "problem",
        docs: {
          description: "Surfaces diagnostics from React Forget",
          recommended: true
        },
        fixable: "code",
        hasSuggestions: true,
        schema: [{ type: "object", additionalProperties: true }]
      },
      create: function create(context) {
        var _a, _b, _c, _d, _e;
        var sourceCode =
          (_a = context.sourceCode) !== null && _a !== void 0
            ? _a
            : context.getSourceCode();
        var filename =
          (_b = context.filename) !== null && _b !== void 0
            ? _b
            : context.getFilename();
        var userOpts =
          (_c = context.options[0]) !== null && _c !== void 0 ? _c : {};
        if (
          userOpts.reportableLevels != null &&
          userOpts.reportableLevels instanceof Set
        ) {
          reportableLevels = userOpts.reportableLevels;
        } else {
          reportableLevels = DEFAULT_REPORTABLE_LEVELS;
        }
        var __unstable_donotuse_reportAllBailouts = false;
        if (
          userOpts.__unstable_donotuse_reportAllBailouts != null &&
          typeof userOpts.__unstable_donotuse_reportAllBailouts === "boolean"
        ) {
          __unstable_donotuse_reportAllBailouts =
            userOpts.__unstable_donotuse_reportAllBailouts;
        }
        var shouldReportUnusedOptOutDirective = true;
        var options = Object.assign(
          Object.assign({}, parsePluginOptions(userOpts)),
          COMPILER_OPTIONS
        );
        var userLogger = options.logger;
        options.logger = {
          logEvent: function logEvent(eventFilename, event) {
            var _a, _b;
            userLogger === null || userLogger === void 0
              ? void 0
              : userLogger.logEvent(eventFilename, event);
            if (event.kind === "CompileError") {
              shouldReportUnusedOptOutDirective = false;
              var detail = event.detail;
              var suggest = makeSuggestions(detail);
              if (
                __unstable_donotuse_reportAllBailouts &&
                event.fnLoc != null
              ) {
                var locStr =
                  detail.loc != null && _typeof(detail.loc) !== "symbol"
                    ? " (@:"
                        .concat(detail.loc.start.line, ":")
                        .concat(detail.loc.start.column, ")")
                    : "";
                var endLoc;
                if (event.fnLoc.end.line === event.fnLoc.start.line) {
                  endLoc = event.fnLoc.end;
                } else {
                  endLoc = {
                    line: event.fnLoc.start.line,
                    column:
                      (_b =
                        (_a =
                          sourceCode.text.split(/\r?\n|\r|\n/g)[
                            event.fnLoc.start.line - 1
                          ]) === null || _a === void 0
                          ? void 0
                          : _a.length) !== null && _b !== void 0
                        ? _b
                        : 0
                  };
                }
                var firstLineLoc = { start: event.fnLoc.start, end: endLoc };
                context.report({
                  message: "[ReactCompilerBailout] "
                    .concat(detail.reason)
                    .concat(locStr),
                  loc: firstLineLoc,
                  suggest: suggest
                });
              }
              if (!isReportableDiagnostic(detail)) {
                return;
              }
              if (
                hasFlowSuppression(detail.loc, "react-rule-hook") ||
                hasFlowSuppression(detail.loc, "react-rule-unsafe-ref")
              ) {
                return;
              }
              var loc =
                detail.loc == null || _typeof(detail.loc) === "symbol"
                  ? event.fnLoc
                  : detail.loc;
              if (loc != null) {
                context.report({
                  message: detail.reason,
                  loc: loc,
                  suggest: suggest
                });
              }
            }
          }
        };
        try {
          options.environment = validateEnvironmentConfig(
            (_d = options.environment) !== null && _d !== void 0 ? _d : {}
          );
        } catch (err) {
          (_e = options.logger) === null || _e === void 0
            ? void 0
            : _e.logEvent("", err);
        }
        function hasFlowSuppression(nodeLoc, suppression) {
          var comments = sourceCode.getAllComments();
          var flowSuppressionRegex = new RegExp(
            "\\$FlowFixMe\\[" + suppression + "\\]"
          );
          var _iterator602 = _createForOfIteratorHelper(comments),
            _step602;
          try {
            for (_iterator602.s(); !(_step602 = _iterator602.n()).done; ) {
              var commentNode = _step602.value;
              if (
                flowSuppressionRegex.test(commentNode.value) &&
                commentNode.loc.end.line === nodeLoc.start.line - 1
              ) {
                return true;
              }
            }
          } catch (err) {
            _iterator602.e(err);
          } finally {
            _iterator602.f();
          }
          return false;
        }
        var babelAST;
        if (filename.endsWith(".tsx") || filename.endsWith(".ts")) {
          try {
            var _require = require("@babel/parser"),
              babelParse = _require.parse;
            babelAST = babelParse(sourceCode.text, {
              filename: filename,
              sourceType: "unambiguous",
              plugins: ["typescript", "jsx"]
            });
          } catch (_f) {}
        } else {
          try {
            babelAST = HermesParser.parse(sourceCode.text, {
              babel: true,
              enableExperimentalComponentSyntax: true,
              sourceFilename: filename,
              sourceType: "module"
            });
          } catch (_g) {}
        }
        if (babelAST != null) {
          try {
            core$1.transformFromAstSync(babelAST, sourceCode.text, {
              filename: filename,
              highlightCode: false,
              retainLines: true,
              plugins: [
                [PluginProposalPrivateMethods["default"], { loose: true }],
                [BabelPluginReactCompiler, options]
              ],
              sourceType: "module",
              configFile: false,
              babelrc: false
            });
          } catch (err) {}
        }
        function reportUnusedOptOutDirective(stmt) {
          if (
            stmt.type === "ExpressionStatement" &&
            stmt.expression.type === "Literal" &&
            typeof stmt.expression.value === "string" &&
            OPT_OUT_DIRECTIVES.has(stmt.expression.value) &&
            stmt.loc != null
          ) {
            context.report({
              message: "Unused '".concat(stmt.expression.value, "' directive"),
              loc: stmt.loc,
              suggest: [
                {
                  desc: "Remove the directive",
                  fix: function fix(fixer) {
                    return fixer.remove(stmt);
                  }
                }
              ]
            });
          }
        }
        if (shouldReportUnusedOptOutDirective) {
          return {
            FunctionDeclaration: function FunctionDeclaration(fnDecl) {
              var _iterator603 = _createForOfIteratorHelper(fnDecl.body.body),
                _step603;
              try {
                for (_iterator603.s(); !(_step603 = _iterator603.n()).done; ) {
                  var stmt = _step603.value;
                  reportUnusedOptOutDirective(stmt);
                }
              } catch (err) {
                _iterator603.e(err);
              } finally {
                _iterator603.f();
              }
            },
            ArrowFunctionExpression: function ArrowFunctionExpression(fnExpr) {
              if (fnExpr.body.type === "BlockStatement") {
                var _iterator604 = _createForOfIteratorHelper(fnExpr.body.body),
                  _step604;
                try {
                  for (
                    _iterator604.s();
                    !(_step604 = _iterator604.n()).done;

                  ) {
                    var stmt = _step604.value;
                    reportUnusedOptOutDirective(stmt);
                  }
                } catch (err) {
                  _iterator604.e(err);
                } finally {
                  _iterator604.f();
                }
              }
            },
            FunctionExpression: function FunctionExpression(fnExpr) {
              var _iterator605 = _createForOfIteratorHelper(fnExpr.body.body),
                _step605;
              try {
                for (_iterator605.s(); !(_step605 = _iterator605.n()).done; ) {
                  var stmt = _step605.value;
                  reportUnusedOptOutDirective(stmt);
                }
              } catch (err) {
                _iterator605.e(err);
              } finally {
                _iterator605.f();
              }
            }
          };
        } else {
          return {};
        }
      }
    };
    function isHookName(s) {
      return s === "use" || /^use[A-Z0-9]/.test(s);
    }
    function isHook(node) {
      if (node.type === "Identifier") {
        return isHookName(node.name);
      } else if (
        node.type === "MemberExpression" &&
        !node.computed &&
        isHook(node.property)
      ) {
        var obj = node.object;
        var isPascalCaseNameSpace = /^[A-Z].*/;
        return (
          obj.type === "Identifier" && isPascalCaseNameSpace.test(obj.name)
        );
      } else {
        return false;
      }
    }
    function isComponentName(node) {
      return node.type === "Identifier" && /^[A-Z]/.test(node.name);
    }
    function isReactFunction(node, functionName) {
      return (
        ("name" in node && node.name === functionName) ||
        (node.type === "MemberExpression" &&
          "name" in node.object &&
          node.object.name === "React" &&
          "name" in node.property &&
          node.property.name === functionName)
      );
    }
    function isForwardRefCallback(node) {
      return !!(
        node.parent &&
        "callee" in node.parent &&
        node.parent.callee &&
        isReactFunction(node.parent.callee, "forwardRef")
      );
    }
    function isMemoCallback(node) {
      return !!(
        node.parent &&
        "callee" in node.parent &&
        node.parent.callee &&
        isReactFunction(node.parent.callee, "memo")
      );
    }
    function isInsideComponentOrHook(node) {
      while (node) {
        var functionName = getFunctionName(node);
        if (functionName) {
          if (isComponentName(functionName) || isHook(functionName)) {
            return true;
          }
        }
        if (isForwardRefCallback(node) || isMemoCallback(node)) {
          return true;
        }
        node = node.parent;
      }
      return false;
    }
    function isInsideDoWhileLoop(node) {
      while (node) {
        if (node.type === "DoWhileStatement") {
          return true;
        }
        node = node.parent;
      }
      return false;
    }
    function isUseEffectEventIdentifier(node) {
      {
        return node.type === "Identifier" && node.name === "useEffectEvent";
      }
    }
    function isUseIdentifier(node) {
      return isReactFunction(node, "use");
    }
    var rule = {
      meta: {
        type: "problem",
        docs: {
          description: "enforces the Rules of Hooks",
          recommended: true,
          url: "https://reactjs.org/docs/hooks-rules.html"
        }
      },
      create: function create(context) {
        var lastEffect = null;
        var codePathReactHooksMapStack = [];
        var codePathSegmentStack = [];
        var useEffectEventFunctions = new WeakSet();
        function recordAllUseEffectEventFunctions(scope) {
          var _iterator606 = _createForOfIteratorHelper(scope.references),
            _step606;
          try {
            for (_iterator606.s(); !(_step606 = _iterator606.n()).done; ) {
              var reference = _step606.value;
              var parent = reference.identifier.parent;
              if (
                (parent === null || parent === void 0
                  ? void 0
                  : parent.type) === "VariableDeclarator" &&
                parent.init &&
                parent.init.type === "CallExpression" &&
                parent.init.callee &&
                isUseEffectEventIdentifier(parent.init.callee)
              ) {
                if (reference.resolved === null) {
                  throw new Error("Unexpected null reference.resolved");
                }
                var _iterator607 = _createForOfIteratorHelper(
                    reference.resolved.references
                  ),
                  _step607;
                try {
                  for (
                    _iterator607.s();
                    !(_step607 = _iterator607.n()).done;

                  ) {
                    var ref = _step607.value;
                    if (ref !== reference) {
                      useEffectEventFunctions.add(ref.identifier);
                    }
                  }
                } catch (err) {
                  _iterator607.e(err);
                } finally {
                  _iterator607.f();
                }
              }
            }
          } catch (err) {
            _iterator606.e(err);
          } finally {
            _iterator606.f();
          }
        }
        var getSourceCode =
          typeof context.getSourceCode === "function"
            ? function () {
                return context.getSourceCode();
              }
            : function () {
                return context.sourceCode;
              };
        var getScope =
          typeof context.getScope === "function"
            ? function () {
                return context.getScope();
              }
            : function (node) {
                return getSourceCode().getScope(node);
              };
        return {
          onCodePathSegmentStart: function onCodePathSegmentStart(segment) {
            return codePathSegmentStack.push(segment);
          },
          onCodePathSegmentEnd: function onCodePathSegmentEnd() {
            return codePathSegmentStack.pop();
          },
          onCodePathStart: function onCodePathStart() {
            return codePathReactHooksMapStack.push(new Map());
          },
          onCodePathEnd: function onCodePathEnd(codePath, codePathNode) {
            var reactHooksMap = codePathReactHooksMapStack.pop();
            if (
              (reactHooksMap === null || reactHooksMap === void 0
                ? void 0
                : reactHooksMap.size) === 0
            ) {
              return;
            } else if (typeof reactHooksMap === "undefined") {
              throw new Error("Unexpected undefined reactHooksMap");
            }
            var cyclic = new Set();
            function countPathsFromStart(segment, pathHistory) {
              var cache = countPathsFromStart.cache;
              var paths = cache.get(segment.id);
              var pathList = new Set(pathHistory);
              if (pathList.has(segment.id)) {
                var pathArray = _toConsumableArray(pathList);
                var cyclicSegments = pathArray.slice(
                  pathArray.indexOf(segment.id) + 1
                );
                var _iterator608 = _createForOfIteratorHelper(cyclicSegments),
                  _step608;
                try {
                  for (
                    _iterator608.s();
                    !(_step608 = _iterator608.n()).done;

                  ) {
                    var cyclicSegment = _step608.value;
                    cyclic.add(cyclicSegment);
                  }
                } catch (err) {
                  _iterator608.e(err);
                } finally {
                  _iterator608.f();
                }
                return BigInt("0");
              }
              pathList.add(segment.id);
              if (paths !== undefined) {
                return paths;
              }
              if (codePath.thrownSegments.includes(segment)) {
                paths = BigInt("0");
              } else if (segment.prevSegments.length === 0) {
                paths = BigInt("1");
              } else {
                paths = BigInt("0");
                var _iterator609 = _createForOfIteratorHelper(
                    segment.prevSegments
                  ),
                  _step609;
                try {
                  for (
                    _iterator609.s();
                    !(_step609 = _iterator609.n()).done;

                  ) {
                    var prevSegment = _step609.value;
                    paths += countPathsFromStart(prevSegment, pathList);
                  }
                } catch (err) {
                  _iterator609.e(err);
                } finally {
                  _iterator609.f();
                }
              }
              if (segment.reachable && paths === BigInt("0")) {
                cache["delete"](segment.id);
              } else {
                cache.set(segment.id, paths);
              }
              return paths;
            }
            function countPathsToEnd(segment, pathHistory) {
              var cache = countPathsToEnd.cache;
              var paths = cache.get(segment.id);
              var pathList = new Set(pathHistory);
              if (pathList.has(segment.id)) {
                var pathArray = Array.from(pathList);
                var cyclicSegments = pathArray.slice(
                  pathArray.indexOf(segment.id) + 1
                );
                var _iterator610 = _createForOfIteratorHelper(cyclicSegments),
                  _step610;
                try {
                  for (
                    _iterator610.s();
                    !(_step610 = _iterator610.n()).done;

                  ) {
                    var cyclicSegment = _step610.value;
                    cyclic.add(cyclicSegment);
                  }
                } catch (err) {
                  _iterator610.e(err);
                } finally {
                  _iterator610.f();
                }
                return BigInt("0");
              }
              pathList.add(segment.id);
              if (paths !== undefined) {
                return paths;
              }
              if (codePath.thrownSegments.includes(segment)) {
                paths = BigInt("0");
              } else if (segment.nextSegments.length === 0) {
                paths = BigInt("1");
              } else {
                paths = BigInt("0");
                var _iterator611 = _createForOfIteratorHelper(
                    segment.nextSegments
                  ),
                  _step611;
                try {
                  for (
                    _iterator611.s();
                    !(_step611 = _iterator611.n()).done;

                  ) {
                    var nextSegment = _step611.value;
                    paths += countPathsToEnd(nextSegment, pathList);
                  }
                } catch (err) {
                  _iterator611.e(err);
                } finally {
                  _iterator611.f();
                }
              }
              cache.set(segment.id, paths);
              return paths;
            }
            function shortestPathLengthToStart(segment) {
              var cache = shortestPathLengthToStart.cache;
              var length = cache.get(segment.id);
              if (length === null) {
                return Infinity;
              }
              if (length !== undefined) {
                return length;
              }
              cache.set(segment.id, null);
              if (segment.prevSegments.length === 0) {
                length = 1;
              } else {
                length = Infinity;
                var _iterator612 = _createForOfIteratorHelper(
                    segment.prevSegments
                  ),
                  _step612;
                try {
                  for (
                    _iterator612.s();
                    !(_step612 = _iterator612.n()).done;

                  ) {
                    var prevSegment = _step612.value;
                    var prevLength = shortestPathLengthToStart(prevSegment);
                    if (prevLength < length) {
                      length = prevLength;
                    }
                  }
                } catch (err) {
                  _iterator612.e(err);
                } finally {
                  _iterator612.f();
                }
                length += 1;
              }
              cache.set(segment.id, length);
              return length;
            }
            countPathsFromStart.cache = new Map();
            countPathsToEnd.cache = new Map();
            shortestPathLengthToStart.cache = new Map();
            var allPathsFromStartToEnd = countPathsToEnd(
              codePath.initialSegment
            );
            var codePathFunctionName = getFunctionName(codePathNode);
            var isSomewhereInsideComponentOrHook =
              isInsideComponentOrHook(codePathNode);
            var isDirectlyInsideComponentOrHook = codePathFunctionName
              ? isComponentName(codePathFunctionName) ||
                isHook(codePathFunctionName)
              : isForwardRefCallback(codePathNode) ||
                isMemoCallback(codePathNode);
            var shortestFinalPathLength = Infinity;
            var _iterator613 = _createForOfIteratorHelper(
                codePath.finalSegments
              ),
              _step613;
            try {
              for (_iterator613.s(); !(_step613 = _iterator613.n()).done; ) {
                var finalSegment = _step613.value;
                if (!finalSegment.reachable) {
                  continue;
                }
                var length = shortestPathLengthToStart(finalSegment);
                if (length < shortestFinalPathLength) {
                  shortestFinalPathLength = length;
                }
              }
            } catch (err) {
              _iterator613.e(err);
            } finally {
              _iterator613.f();
            }
            var _iterator614 = _createForOfIteratorHelper(reactHooksMap),
              _step614;
            try {
              for (_iterator614.s(); !(_step614 = _iterator614.n()).done; ) {
                var _step614$value = _slicedToArray(_step614.value, 2),
                  segment = _step614$value[0],
                  reactHooks = _step614$value[1];
                if (!segment.reachable) {
                  continue;
                }
                var possiblyHasEarlyReturn =
                  segment.nextSegments.length === 0
                    ? shortestFinalPathLength <=
                      shortestPathLengthToStart(segment)
                    : shortestFinalPathLength <
                      shortestPathLengthToStart(segment);
                var pathsFromStartToEnd =
                  countPathsFromStart(segment) * countPathsToEnd(segment);
                var cycled = cyclic.has(segment.id);
                var _iterator615 = _createForOfIteratorHelper(reactHooks),
                  _step615;
                try {
                  for (
                    _iterator615.s();
                    !(_step615 = _iterator615.n()).done;

                  ) {
                    var hook = _step615.value;
                    if (
                      (cycled || isInsideDoWhileLoop(hook)) &&
                      !isUseIdentifier(hook)
                    ) {
                      context.report({
                        node: hook,
                        message:
                          'React Hook "'.concat(
                            getSourceCode().getText(hook),
                            '" may be executed '
                          ) +
                          "more than once. Possibly because it is called in a loop. " +
                          "React Hooks must be called in the exact same order in " +
                          "every component render."
                      });
                    }
                    if (isDirectlyInsideComponentOrHook) {
                      var isAsyncFunction = codePathNode.async;
                      if (isAsyncFunction) {
                        context.report({
                          node: hook,
                          message:
                            'React Hook "'.concat(
                              getSourceCode().getText(hook),
                              '" cannot be '
                            ) + "called in an async function."
                        });
                      }
                      if (
                        !cycled &&
                        pathsFromStartToEnd !== allPathsFromStartToEnd &&
                        !isUseIdentifier(hook) &&
                        !isInsideDoWhileLoop(hook)
                      ) {
                        var message =
                          'React Hook "'.concat(
                            getSourceCode().getText(hook),
                            '" is called '
                          ) +
                          "conditionally. React Hooks must be called in the exact " +
                          "same order in every component render." +
                          (possiblyHasEarlyReturn
                            ? " Did you accidentally call a React Hook after an" +
                              " early return?"
                            : "");
                        context.report({ node: hook, message: message });
                      }
                    } else if (
                      codePathNode.parent != null &&
                      (codePathNode.parent.type === "MethodDefinition" ||
                        codePathNode.parent.type === "ClassProperty" ||
                        codePathNode.parent.type === "PropertyDefinition") &&
                      codePathNode.parent.value === codePathNode
                    ) {
                      var _message2 =
                        'React Hook "'.concat(
                          getSourceCode().getText(hook),
                          '" cannot be called '
                        ) +
                        "in a class component. React Hooks must be called in a " +
                        "React function component or a custom React Hook function.";
                      context.report({ node: hook, message: _message2 });
                    } else if (codePathFunctionName) {
                      var _message3 =
                        'React Hook "'.concat(
                          getSourceCode().getText(hook),
                          '" is called in '
                        ) +
                        'function "'.concat(
                          getSourceCode().getText(codePathFunctionName),
                          '" '
                        ) +
                        "that is neither a React function component nor a custom " +
                        "React Hook function." +
                        " React component names must start with an uppercase letter." +
                        ' React Hook names must start with the word "use".';
                      context.report({ node: hook, message: _message3 });
                    } else if (codePathNode.type === "Program") {
                      var _message4 =
                        'React Hook "'.concat(
                          getSourceCode().getText(hook),
                          '" cannot be called '
                        ) +
                        "at the top level. React Hooks must be called in a " +
                        "React function component or a custom React Hook function.";
                      context.report({ node: hook, message: _message4 });
                    } else {
                      if (
                        isSomewhereInsideComponentOrHook &&
                        !isUseIdentifier(hook)
                      ) {
                        var _message5 =
                          'React Hook "'.concat(
                            getSourceCode().getText(hook),
                            '" cannot be called '
                          ) +
                          "inside a callback. React Hooks must be called in a " +
                          "React function component or a custom React Hook function.";
                        context.report({ node: hook, message: _message5 });
                      }
                    }
                  }
                } catch (err) {
                  _iterator615.e(err);
                } finally {
                  _iterator615.f();
                }
              }
            } catch (err) {
              _iterator614.e(err);
            } finally {
              _iterator614.f();
            }
          },
          CallExpression: function CallExpression(node) {
            if (isHook(node.callee)) {
              var reactHooksMap = last(codePathReactHooksMapStack);
              var codePathSegment = last(codePathSegmentStack);
              var reactHooks = reactHooksMap.get(codePathSegment);
              if (!reactHooks) {
                reactHooks = [];
                reactHooksMap.set(codePathSegment, reactHooks);
              }
              reactHooks.push(node.callee);
            }
            if (
              node.callee.type === "Identifier" &&
              (node.callee.name === "useEffect" ||
                isUseEffectEventIdentifier(node.callee)) &&
              node.arguments.length > 0
            ) {
              lastEffect = node;
            }
          },
          Identifier: function Identifier(node) {
            if (
              lastEffect == null &&
              useEffectEventFunctions.has(node) &&
              node.parent.type !== "CallExpression"
            ) {
              context.report({
                node: node,
                message:
                  "`".concat(
                    getSourceCode().getText(node),
                    '` is a function created with React Hook "useEffectEvent", and can only be called from '
                  ) +
                  "the same component. They cannot be assigned to variables or passed down."
              });
            }
          },
          "CallExpression:exit": function CallExpressionExit(node) {
            if (node === lastEffect) {
              lastEffect = null;
            }
          },
          FunctionDeclaration: function FunctionDeclaration(node) {
            if (isInsideComponentOrHook(node)) {
              recordAllUseEffectEventFunctions(getScope(node));
            }
          },
          ArrowFunctionExpression: function ArrowFunctionExpression(node) {
            if (isInsideComponentOrHook(node)) {
              recordAllUseEffectEventFunctions(getScope(node));
            }
          }
        };
      }
    };
    function getFunctionName(node) {
      var _a, _b, _c, _d;
      if (
        node.type === "FunctionDeclaration" ||
        (node.type === "FunctionExpression" && node.id)
      ) {
        return node.id;
      } else if (
        node.type === "FunctionExpression" ||
        node.type === "ArrowFunctionExpression"
      ) {
        if (
          ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) ===
            "VariableDeclarator" &&
          node.parent.init === node
        ) {
          return node.parent.id;
        } else if (
          ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type) ===
            "AssignmentExpression" &&
          node.parent.right === node &&
          node.parent.operator === "="
        ) {
          return node.parent.left;
        } else if (
          ((_c = node.parent) === null || _c === void 0 ? void 0 : _c.type) ===
            "Property" &&
          node.parent.value === node &&
          !node.parent.computed
        ) {
          return node.parent.key;
        } else if (
          ((_d = node.parent) === null || _d === void 0 ? void 0 : _d.type) ===
            "AssignmentPattern" &&
          node.parent.right === node &&
          !node.parent.computed
        ) {
          return node.parent.left;
        } else {
          return undefined;
        }
      } else {
        return undefined;
      }
    }
    function last(array) {
      return array[array.length - 1];
    }
    var rules = {
      "exhaustive-deps": rule$2,
      "react-compiler": rule$1,
      "rules-of-hooks": rule
    };
    var configRules = {
      "react-hooks/rules-of-hooks": "error",
      "react-hooks/exhaustive-deps": "warn"
    };
    var recommendedConfig = {
      name: "react-hooks/recommended",
      plugins: {
        get "react-hooks"() {
          return plugin;
        }
      },
      rules: configRules
    };
    var plugin = {
      meta: { name: "eslint-plugin-react-hooks" },
      rules: rules,
      configs: {
        "recommended-legacy": { plugins: ["react-hooks"], rules: configRules },
        recommended: recommendedConfig,
        "recommended-latest": recommendedConfig
      }
    };
    var configs = plugin.configs;
    var meta = plugin.meta;
    exports.configs = configs;
    exports.meta = meta;
    exports.rules = rules;
  })();
}
