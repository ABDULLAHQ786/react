{"version":3,"sources":["graphql/LocalStorage.js","graphql/getInternURL.js","graphql/Config.js","graphql/genCSRFToken.js","graphql/GraphQL.js","graphql/xhr.js","App.js","graphql/PersistentDocumentIds.js","serviceWorker.js","index.js"],"names":["genv","keys","Promise","resolve","chrome","storage","local","get","gen","key","items","genSetObject","obj","set","genSet","value","getInternURL","path","CSRF_KEY","PROJECT_NAME","i","CSRF","item","now","Date","expire","token","fetch","response","status","console","warn","text","JSON","parse","slice","_memo","_memoTime","_genCSRFToken","genGraphQL","fbid","variables","genCSRFToken","then","csrf","url","encodeURIComponent","stringify","formData","reject","xhr","XMLHttpRequest","open","responseType","onerror","Error","onload","res","send","json","error","data","App","React","useState","yourProfilePhotoUri","setProfilePhotoUri","me","profile_picture","uri","className","src","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.bad550ae.chunk.js","sourcesContent":["/* global chrome */\n\nexport function genv(keys) {\n  return new Promise(resolve => chrome.storage.local.get(keys, resolve));\n}\n\nexport async function gen(key) {\n  const items = await genv([key]);\n  return items[key];\n}\n\nexport function genSetObject(obj) {\n  return new Promise(resolve => chrome.storage.local.set(obj, resolve));\n}\n\nexport async function genSet(key, value) {\n  return await genSetObject({[key]: value});\n}\n\nexport function genClear(keys) {\n  return new Promise(resolve => chrome.storage.local.remove(keys, resolve));\n}\n\n\nexport function load(key, callback) {\n  const onloadTime = Math.floor(Date.now() / 1000);\n  gen(key).then(stored => {\n    const data = (stored == null || stored.expiration < onloadTime) ? null : stored.data;\n    if(data != null) {\n      callback(data);\n    }\n  });\n}\n\nexport function persist(key, data, timeout) {\n  const now = Math.floor(Date.now() / 1000);\n  genSet(key, {data, expiration: now + timeout});\n}\n","export default function getInternURL(path) {\n  return 'https://internalfb.com/intern' + path;\n}\n","const PROJECT_NAME = 'superlinks';\n\nexport const GRAPHQL_KEY_ROOT = PROJECT_NAME + '/cached_graphql/v2/';\nexport const CSRF_KEY = PROJECT_NAME + '/settings/csrftoken/v1';\nexport const GRAPHQL_CLEAR_SETTINGS = PROJECT_NAME + '/settings/';\n","import {gen, genSet} from './LocalStorage.js';\nimport getInternURL from './getInternURL.js';\nimport {CSRF_KEY} from './Config.js';\n\nconst CSRF = getInternURL('/api/dtsg/internal');\n\nasync function _genCSRFToken() {\n  const item = await gen(CSRF_KEY);\n  const now = Date.now() / 1000 + 60;\n  if (item != null && item.expire >= now) {\n    return item.token;\n  }\n  const response = await fetch(CSRF);\n  if (response.status !== 200) {\n    console.warn('Failed GraphQL fetch. Status Code: ' + response.status);\n    return null;\n  }\n  const text = await response.text();\n  if (text == null) {\n    console.warn('Failed to get CSRF token');\n    return null;\n  }\n  const token = JSON.parse(text.slice(9));\n  await genSet(CSRF_KEY, token);\n  return token.token;\n}\n\n// memoize up to 2hrs so we only send one csrf request at a time\nlet _memo = null;\nlet _memoTime = null;\nexport default function() {\n  const now = Date.now() / 1000;\n  if (_memo === null || _memoTime <= now) {\n    _memo = _genCSRFToken(CSRF_KEY);\n    _memoTime = now + 7200;\n  }\n  return _memo;\n}\n","/**\n * (c) Meta Platforms, Inc. and affiliates. Confidential and proprietary.\n *\n * @emails oncall+manager_products\n * @flow strict\n * @format\n */\n\n/* global chrome */\n\nimport genCSRFToken from './genCSRFToken.js';\nimport {gen, genv, genClear} from './LocalStorage.js';\nimport xhr from './xhr.js';\nimport getInternURL from './getInternURL.js';\n\nimport {GRAPHQL_KEY_ROOT, GRAPHQL_CLEAR_SETTINGS} from './Config.js';\n\nexport function genGraphQL(fbid, variables) {\n  return genCSRFToken()\n    .then(csrf => {\n      let url = getInternURL('/api/graphql?doc_id=' + fbid);\n      if (variables) {\n        url += '&variables=' + encodeURIComponent(JSON.stringify(variables));\n      }\n      url += '&fb_dtsg=' + csrf + '&__a=1';\n      return xhr(url);\n    })\n    .then(response => {\n      const json = JSON.parse(response);\n      if (json.error) {\n        console.warn('Failed GraphQL fetch. Status Code: ' + json.error);\n        return null;\n      }\n      return json != null ? json.data : null;\n    });\n}\n\nexport async function cleanup(forceClear) {\n  if (forceClear) {\n    console.log('Forcing clear of local cache');\n  }\n  const items = await genv(null);\n  const now = Math.floor(Date.now() / 1000);\n  const weekAgo = now - 86400 * 7;\n  const keysToRemove = [];\n  for (let key in items) {\n    if (key.startsWith(GRAPHQL_KEY_ROOT)) {\n      // Remove keys expired a week ago to keep storage clean\n      const item = items[key];\n      if (forceClear || item.expiration < weekAgo) {\n        keysToRemove.push(key);\n      }\n    } else if (!key.startsWith()) {\n      keysToRemove.push(key);\n    }\n  }\n  if (keysToRemove.length > 0) {\n    await genClear(keysToRemove);\n  }\n}\n\nexport function genCachedGraphQL(fbid, variables, timeout, cb) {\n  let key = GRAPHQL_KEY_ROOT + fbid;\n  if (variables) {\n    key += JSON.stringify(variables);\n  }\n  const now = Math.floor(Date.now() / 1000);\n  gen(key).then(data => {\n    function _gen() {\n      return genGraphQL(fbid, variables).then(payload => {\n        if (payload == null) {\n          // just keep the old data for now\n          return;\n        }\n        const data = {\n          payload,\n          expiration: now + (timeout || 86400),\n        };\n        chrome.storage.local.set({[key]: data});\n        cb(payload, false);\n      });\n    }\n    if (data != null) {\n      cb(data.payload, true);\n    }\n    if (data == null || data.expiration < now) {\n      _gen();\n    }\n  });\n}\n","// Can't use fetch() API since it sets the Origin header wrong :(\nexport default function xhr(url, formData) {\n  return new Promise(function(resolve, reject) {\n    let xhr = new XMLHttpRequest();\n\n    xhr.open('POST', url);\n\n    xhr.responseType = '';\n\n    xhr.onerror = function() {\n      reject(new Error('error'));\n    };\n\n    xhr.onload = function() {\n      // do something with response\n      let res = xhr.response;\n      resolve(res);\n    };\n\n    // send request\n    xhr.send(formData);\n  });\n}\n","import React from 'react';\nimport {genGraphQL} from './graphql/GraphQL';\nimport {EXAMPLE_QUERY} from './graphql/PersistentDocumentIds';\n\nfunction App() {\n  const [yourProfilePhotoUri, setProfilePhotoUri] = React.useState(null);\n  genGraphQL(EXAMPLE_QUERY).then(data=> {\n    setProfilePhotoUri(data?.me?.profile_picture?.uri);\n  });\n  return (\n    <div className=\"App\">\n      {yourProfilePhotoUri != null ? <img src={yourProfilePhotoUri}/> : null}\n    </div>\n  );\n}\n\nexport default App;\n","export const EXAMPLE_QUERY = '3827580680585240';\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}